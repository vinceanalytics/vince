(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a3, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp.call(b2, prop))
        __defNormalProp(a3, prop, b2[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b2)) {
        if (__propIsEnum.call(b2, prop))
          __defNormalProp(a3, prop, b2[prop]);
      }
    return a3;
  };
  var __spreadProps = (a3, b2) => __defProps(a3, __getOwnPropDescs(b2));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to2, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
  var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
  var __privateWrapper = (obj, member, setter, getter) => ({
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  });

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.3.1";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            // Used to reproduce behavior of `batchedUpdates` in legacy mode.
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn(format2) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format2, args);
              }
            }
          }
          function error(format2) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            /**
             * Checks whether or not this composite component is mounted.
             * @param {ReactClass} publicInstance The instance we want to test.
             * @return {boolean} True if mounted, false otherwise.
             * @protected
             * @final
             */
            isMounted: function(publicInstance) {
              return false;
            },
            /**
             * Forces an update. This should only be invoked when it is known with
             * certainty that we are **not** in a DOM transaction.
             *
             * You may want to call this when you know that some deeper aspect of the
             * component's state has changed but `setState` was not called.
             *
             * This will not invoke `shouldComponentUpdate`, but it will invoke
             * `componentWillUpdate` and `componentDidUpdate`.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueForceUpdate: function(publicInstance, callback2, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            /**
             * Replaces all of the state. Always use this or `setState` to mutate state.
             * You should treat `this.state` as immutable.
             *
             * There is no guarantee that `this.state` will be immediately updated, so
             * accessing `this.state` after calling this method may return the old value.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} completeState Next state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueReplaceState: function(publicInstance, completeState, callback2, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            /**
             * Sets a subset of the state. This only exists because _pendingState is
             * internal. This provides a merging strategy that is not available to deep
             * properties which is confusing. TODO: Expose pendingState or don't use it
             * during the merge.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} partialState Next partial state to be merged with state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} Name of the calling function in the public API.
             * @internal
             */
            enqueueSetState: function(publicInstance, partialState, callback2, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component4(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component4.prototype.isReactComponent = {};
          Component4.prototype.setState = function(partialState, callback2) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback2, "setState");
          };
          Component4.prototype.forceUpdate = function(callback2) {
            this.updater.enqueueForceUpdate(this, callback2, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component4.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component4.prototype;
          function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent;
          assign(pureComponentPrototype, Component4.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray3(a3) {
            return isArrayImpl(a3);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e3) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x3) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config) {
            {
              if (hasOwnProperty.call(config, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.ref !== void 0;
          }
          function hasValidKey(config) {
            {
              if (hasOwnProperty.call(config, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config) {
            {
              if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              // This tag allows us to uniquely identify this as a React Element
              $$typeof: REACT_ELEMENT_TYPE,
              // Built-in properties that belong on the element
              type,
              key,
              ref,
              props,
              // Record the component responsible for creating this element.
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement15(type, config, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config);
                }
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              self2 = config.__self === void 0 ? null : config.__self;
              source = config.__source === void 0 ? null : config.__source;
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i5 = 0; i5 < childrenLength; i5++) {
                childArray[i5] = arguments[i5 + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement2(element, config, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              var defaultProps;
              if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
              }
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config[propName] === void 0 && defaultProps !== void 0) {
                    props[propName] = defaultProps[propName];
                  } else {
                    props[propName] = config[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i5 = 0; i5 < childrenLength; i5++) {
                childArray[i5] = arguments[i5 + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self2, source, owner, props);
          }
          function isValidElement(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index2) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape("" + element.key);
            }
            return index2.toString(36);
          }
          function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback2) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback2(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray3(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array, escapedChildKey, "", function(c3) {
                  return c3;
                });
              } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    // Keep both the (mapped) and old keys if they differ, just as
                    // traverseAllChildren used to do for objects as children
                    escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                    (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                      // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                      // eslint-disable-next-line react-internal/safe-string-coercion
                      escapeUserProvidedKey("" + mappedChild.key) + "/"
                    ) : "") + childKey
                  );
                }
                array.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray3(children)) {
              for (var i5 = 0; i5 < children.length; i5++) {
                child = children[i5];
                nextName = nextNamePrefix + getElementKey(child, i5);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback2);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback2);
                }
              } else if (type === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n2 = 0;
            mapChildren(children, function() {
              n2++;
            });
            return n2;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext10(defaultValue) {
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              // As a workaround to support multiple concurrent renderers, we categorize
              // some renderers as primary and others as secondary. We only expect
              // there to be two concurrent renderers at most: React Native (primary) and
              // Fabric (secondary); React DOM (primary) and React ART (secondary).
              // Secondary renderers store their context values on separate fields.
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              // Used to track how many concurrent renderers this context currently
              // supports within in a single renderer. Such as parallel server rendering.
              _threadCount: 0,
              // These are circular
              Provider: null,
              Consumer: null,
              // Add these to use same hidden class in VM as ServerContext
              _defaultValue: null,
              _globalName: null
            };
            context.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                  },
                  set: function(_Provider) {
                    context.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context._currentValue;
                  },
                  set: function(_currentValue) {
                    context._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context._threadCount;
                  },
                  set: function(_threadCount) {
                    context._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context.Consumer = Consumer;
            }
            {
              context._currentRenderer = null;
              context._currentRenderer2 = null;
            }
            return context;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error2;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              // We use these fields to store the result.
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps;
                  },
                  set: function(newDefaultProps) {
                    error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef11(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!render.name && !render.displayName) {
                    render.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo2(type, compare) {
            {
              if (!isValidElementType(type)) {
                error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare === void 0 ? null : compare
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!type.name && !type.displayName) {
                    type.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext11(Context) {
            var dispatcher = resolveDispatcher();
            {
              if (Context._context !== void 0) {
                var realContext = Context._context;
                if (realContext.Consumer === Context) {
                  error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context) {
                  error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context);
          }
          function useState29(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
          }
          function useRef12(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect30(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
          }
          function useInsertionEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create, deps);
          }
          function useLayoutEffect4(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
          }
          function useCallback23(callback2, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback2, deps);
          }
          function useMemo7(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
          }
          function useImperativeHandle(ref, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create, deps);
          }
          function useDebugValue(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          function useTransition2() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
          }
          function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix2;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix2 === void 0) {
                try {
                  throw Error();
                } catch (x3) {
                  var match = x3.stack.trim().match(/\n( *(at )?)/);
                  prefix2 = match && match[1] || "";
                }
              }
              return "\n" + prefix2 + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x3) {
                    control = x3;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x3) {
                    control = x3;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x3) {
                  control = x3;
                }
                fn2();
              }
            } catch (sample2) {
              if (sample2 && control && typeof sample2.stack === "string") {
                var sampleLines = sample2.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s7 = sampleLines.length - 1;
                var c3 = controlLines.length - 1;
                while (s7 >= 1 && c3 >= 0 && sampleLines[s7] !== controlLines[c3]) {
                  c3--;
                }
                for (; s7 >= 1 && c3 >= 0; s7--, c3--) {
                  if (sampleLines[s7] !== controlLines[c3]) {
                    if (s7 !== 1 || c3 !== 1) {
                      do {
                        s7--;
                        c3--;
                        if (c3 < 0 || sampleLines[s7] !== controlLines[c3]) {
                          var _frame = "\n" + sampleLines[s7].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s7 >= 1 && c3 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component5) {
            var prototype = Component5.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x3) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (isArray3(node)) {
              for (var i5 = 0; i5 < node.length; i5++) {
                var child = node[i5];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i5 = 0; i5 < keys.length; i5++) {
                var key = keys[i5];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray3(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement15.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i5 = 2; i5 < arguments.length; i5++) {
                validateChildKeys(arguments[i5], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement2.apply(this, arguments);
            for (var i5 = 2; i5 < arguments.length; i5++) {
              validateChildKeys(arguments[i5], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module && module[requireString];
                enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback2) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback2;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback2) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback2();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue = ReactCurrentActQueue.current;
                  if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                  }
                }
              } catch (error2) {
                popActScope(prevActScopeDepth);
                throw error2;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve2, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve2, reject);
                      } else {
                        resolve2(returnValue2);
                      }
                    }, function(error2) {
                      popActScope(prevActScopeDepth);
                      reject(error2);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve2, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve2, reject);
                      } else {
                        resolve2(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve2, reject) {
                      resolve2(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve2, reject) {
            {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    if (queue.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve2(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve2, reject);
                    }
                  });
                } catch (error2) {
                  reject(error2);
                }
              } else {
                resolve2(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i5 = 0;
                try {
                  for (; i5 < queue.length; i5++) {
                    var callback2 = queue[i5];
                    do {
                      callback2 = callback2(true);
                    } while (callback2 !== null);
                  }
                  queue.length = 0;
                } catch (error2) {
                  queue = queue.slice(i5 + 1);
                  throw error2;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children2 = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray,
            only: onlyChild
          };
          exports.Children = Children2;
          exports.Component = Component4;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.Profiler = REACT_PROFILER_TYPE;
          exports.PureComponent = PureComponent;
          exports.StrictMode = REACT_STRICT_MODE_TYPE;
          exports.Suspense = REACT_SUSPENSE_TYPE;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.act = act;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext10;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef;
          exports.forwardRef = forwardRef11;
          exports.isValidElement = isValidElement;
          exports.lazy = lazy;
          exports.memo = memo2;
          exports.startTransition = startTransition;
          exports.unstable_act = act;
          exports.useCallback = useCallback23;
          exports.useContext = useContext11;
          exports.useDebugValue = useDebugValue;
          exports.useDeferredValue = useDeferredValue;
          exports.useEffect = useEffect30;
          exports.useId = useId;
          exports.useImperativeHandle = useImperativeHandle;
          exports.useInsertionEffect = useInsertionEffect;
          exports.useLayoutEffect = useLayoutEffect4;
          exports.useMemo = useMemo7;
          exports.useReducer = useReducer;
          exports.useRef = useRef12;
          exports.useState = useState29;
          exports.useSyncExternalStore = useSyncExternalStore2;
          exports.useTransition = useTransition2;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var enableSchedulerDebugging = false;
          var enableProfiling = false;
          var frameYieldMs = 5;
          function push(heap, node) {
            var index2 = heap.length;
            heap.push(node);
            siftUp(heap, node, index2);
          }
          function peek(heap) {
            return heap.length === 0 ? null : heap[0];
          }
          function pop(heap) {
            if (heap.length === 0) {
              return null;
            }
            var first = heap[0];
            var last2 = heap.pop();
            if (last2 !== first) {
              heap[0] = last2;
              siftDown(heap, last2, 0);
            }
            return first;
          }
          function siftUp(heap, node, i5) {
            var index2 = i5;
            while (index2 > 0) {
              var parentIndex = index2 - 1 >>> 1;
              var parent = heap[parentIndex];
              if (compare(parent, node) > 0) {
                heap[parentIndex] = node;
                heap[index2] = parent;
                index2 = parentIndex;
              } else {
                return;
              }
            }
          }
          function siftDown(heap, node, i5) {
            var index2 = i5;
            var length = heap.length;
            var halfLength = length >>> 1;
            while (index2 < halfLength) {
              var leftIndex = (index2 + 1) * 2 - 1;
              var left2 = heap[leftIndex];
              var rightIndex = leftIndex + 1;
              var right2 = heap[rightIndex];
              if (compare(left2, node) < 0) {
                if (rightIndex < length && compare(right2, left2) < 0) {
                  heap[index2] = right2;
                  heap[rightIndex] = node;
                  index2 = rightIndex;
                } else {
                  heap[index2] = left2;
                  heap[leftIndex] = node;
                  index2 = leftIndex;
                }
              } else if (rightIndex < length && compare(right2, node) < 0) {
                heap[index2] = right2;
                heap[rightIndex] = node;
                index2 = rightIndex;
              } else {
                return;
              }
            }
          }
          function compare(a3, b2) {
            var diff = a3.sortIndex - b2.sortIndex;
            return diff !== 0 ? diff : a3.id - b2.id;
          }
          var ImmediatePriority = 1;
          var UserBlockingPriority = 2;
          var NormalPriority = 3;
          var LowPriority = 4;
          var IdlePriority = 5;
          function markTaskErrored(task, ms) {
          }
          var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
          if (hasPerformanceNow) {
            var localPerformance = performance;
            exports.unstable_now = function() {
              return localPerformance.now();
            };
          } else {
            var localDate = Date;
            var initialTime = localDate.now();
            exports.unstable_now = function() {
              return localDate.now() - initialTime;
            };
          }
          var maxSigned31BitInt = 1073741823;
          var IMMEDIATE_PRIORITY_TIMEOUT = -1;
          var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
          var NORMAL_PRIORITY_TIMEOUT = 5e3;
          var LOW_PRIORITY_TIMEOUT = 1e4;
          var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
          var taskQueue = [];
          var timerQueue = [];
          var taskIdCounter = 1;
          var currentTask = null;
          var currentPriorityLevel = NormalPriority;
          var isPerformingWork = false;
          var isHostCallbackScheduled = false;
          var isHostTimeoutScheduled = false;
          var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
          var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
          var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
          var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
          function advanceTimers(currentTime) {
            var timer = peek(timerQueue);
            while (timer !== null) {
              if (timer.callback === null) {
                pop(timerQueue);
              } else if (timer.startTime <= currentTime) {
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push(taskQueue, timer);
              } else {
                return;
              }
              timer = peek(timerQueue);
            }
          }
          function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
              if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                  requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
              }
            }
          }
          function flushWork(hasTimeRemaining, initialTime2) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
              isHostTimeoutScheduled = false;
              cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              if (enableProfiling) {
                try {
                  return workLoop(hasTimeRemaining, initialTime2);
                } catch (error) {
                  if (currentTask !== null) {
                    var currentTime = exports.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                  }
                  throw error;
                }
              } else {
                return workLoop(hasTimeRemaining, initialTime2);
              }
            } finally {
              currentTask = null;
              currentPriorityLevel = previousPriorityLevel;
              isPerformingWork = false;
            }
          }
          function workLoop(hasTimeRemaining, initialTime2) {
            var currentTime = initialTime2;
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
            while (currentTask !== null && !enableSchedulerDebugging) {
              if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
                break;
              }
              var callback2 = currentTask.callback;
              if (typeof callback2 === "function") {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                var continuationCallback = callback2(didUserCallbackTimeout);
                currentTime = exports.unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                } else {
                  if (currentTask === peek(taskQueue)) {
                    pop(taskQueue);
                  }
                }
                advanceTimers(currentTime);
              } else {
                pop(taskQueue);
              }
              currentTask = peek(taskQueue);
            }
            if (currentTask !== null) {
              return true;
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
              return false;
            }
          }
          function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
              case LowPriority:
              case IdlePriority:
                break;
              default:
                priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
                priorityLevel = NormalPriority;
                break;
              default:
                priorityLevel = currentPriorityLevel;
                break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_wrapCallback(callback2) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback2.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          }
          function unstable_scheduleCallback(priorityLevel, callback2, options) {
            var currentTime = exports.unstable_now();
            var startTime2;
            if (typeof options === "object" && options !== null) {
              var delay = options.delay;
              if (typeof delay === "number" && delay > 0) {
                startTime2 = currentTime + delay;
              } else {
                startTime2 = currentTime;
              }
            } else {
              startTime2 = currentTime;
            }
            var timeout;
            switch (priorityLevel) {
              case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
              case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
              case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
              case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
              case NormalPriority:
              default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
            }
            var expirationTime = startTime2 + timeout;
            var newTask = {
              id: taskIdCounter++,
              callback: callback2,
              priorityLevel,
              startTime: startTime2,
              expirationTime,
              sortIndex: -1
            };
            if (startTime2 > currentTime) {
              newTask.sortIndex = startTime2;
              push(timerQueue, newTask);
              if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                if (isHostTimeoutScheduled) {
                  cancelHostTimeout();
                } else {
                  isHostTimeoutScheduled = true;
                }
                requestHostTimeout(handleTimeout, startTime2 - currentTime);
              }
            } else {
              newTask.sortIndex = expirationTime;
              push(taskQueue, newTask);
              if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              }
            }
            return newTask;
          }
          function unstable_pauseExecution() {
          }
          function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
          }
          function unstable_cancelCallback(task) {
            task.callback = null;
          }
          function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var taskTimeoutID = -1;
          var frameInterval = frameYieldMs;
          var startTime = -1;
          function shouldYieldToHost() {
            var timeElapsed = exports.unstable_now() - startTime;
            if (timeElapsed < frameInterval) {
              return false;
            }
            return true;
          }
          function requestPaint() {
          }
          function forceFrameRate(fps) {
            if (fps < 0 || fps > 125) {
              console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
              return;
            }
            if (fps > 0) {
              frameInterval = Math.floor(1e3 / fps);
            } else {
              frameInterval = frameYieldMs;
            }
          }
          var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
              var currentTime = exports.unstable_now();
              startTime = currentTime;
              var hasTimeRemaining = true;
              var hasMoreWork = true;
              try {
                hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
              } finally {
                if (hasMoreWork) {
                  schedulePerformWorkUntilDeadline();
                } else {
                  isMessageLoopRunning = false;
                  scheduledHostCallback = null;
                }
              }
            } else {
              isMessageLoopRunning = false;
            }
          };
          var schedulePerformWorkUntilDeadline;
          if (typeof localSetImmediate === "function") {
            schedulePerformWorkUntilDeadline = function() {
              localSetImmediate(performWorkUntilDeadline);
            };
          } else if (typeof MessageChannel !== "undefined") {
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            schedulePerformWorkUntilDeadline = function() {
              port.postMessage(null);
            };
          } else {
            schedulePerformWorkUntilDeadline = function() {
              localSetTimeout(performWorkUntilDeadline, 0);
            };
          }
          function requestHostCallback(callback2) {
            scheduledHostCallback = callback2;
            if (!isMessageLoopRunning) {
              isMessageLoopRunning = true;
              schedulePerformWorkUntilDeadline();
            }
          }
          function requestHostTimeout(callback2, ms) {
            taskTimeoutID = localSetTimeout(function() {
              callback2(exports.unstable_now());
            }, ms);
          }
          function cancelHostTimeout() {
            localClearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          }
          var unstable_requestPaint = requestPaint;
          var unstable_Profiling = null;
          exports.unstable_IdlePriority = IdlePriority;
          exports.unstable_ImmediatePriority = ImmediatePriority;
          exports.unstable_LowPriority = LowPriority;
          exports.unstable_NormalPriority = NormalPriority;
          exports.unstable_Profiling = unstable_Profiling;
          exports.unstable_UserBlockingPriority = UserBlockingPriority;
          exports.unstable_cancelCallback = unstable_cancelCallback;
          exports.unstable_continueExecution = unstable_continueExecution;
          exports.unstable_forceFrameRate = forceFrameRate;
          exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
          exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
          exports.unstable_next = unstable_next;
          exports.unstable_pauseExecution = unstable_pauseExecution;
          exports.unstable_requestPaint = unstable_requestPaint;
          exports.unstable_runWithPriority = unstable_runWithPriority;
          exports.unstable_scheduleCallback = unstable_scheduleCallback;
          exports.unstable_shouldYield = shouldYieldToHost;
          exports.unstable_wrapCallback = unstable_wrapCallback;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React92 = require_react();
          var Scheduler = require_scheduler();
          var ReactSharedInternals = React92.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          var suppressWarning = false;
          function setSuppressWarning(newSuppressWarning) {
            {
              suppressWarning = newSuppressWarning;
            }
          }
          function warn(format2) {
            {
              if (!suppressWarning) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format2, args);
              }
            }
          }
          function error(format2) {
            {
              if (!suppressWarning) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var FunctionComponent = 0;
          var ClassComponent = 1;
          var IndeterminateComponent = 2;
          var HostRoot = 3;
          var HostPortal = 4;
          var HostComponent = 5;
          var HostText = 6;
          var Fragment11 = 7;
          var Mode = 8;
          var ContextConsumer = 9;
          var ContextProvider = 10;
          var ForwardRef10 = 11;
          var Profiler = 12;
          var SuspenseComponent = 13;
          var MemoComponent = 14;
          var SimpleMemoComponent = 15;
          var LazyComponent = 16;
          var IncompleteClassComponent = 17;
          var DehydratedFragment = 18;
          var SuspenseListComponent = 19;
          var ScopeComponent = 21;
          var OffscreenComponent = 22;
          var LegacyHiddenComponent = 23;
          var CacheComponent = 24;
          var TracingMarkerComponent = 25;
          var enableClientRenderFallbackOnTextMismatch = true;
          var enableNewReconciler = false;
          var enableLazyContextPropagation = false;
          var enableLegacyHidden = false;
          var enableSuspenseAvoidThisFallback = false;
          var disableCommentsAsDOMContainers = true;
          var enableCustomElementPropertySupport = false;
          var warnAboutStringRefs = true;
          var enableSchedulingProfiler = true;
          var enableProfilerTimer = true;
          var enableProfilerCommitHooks = true;
          var allNativeEvents = /* @__PURE__ */ new Set();
          var registrationNameDependencies = {};
          var possibleRegistrationNames = {};
          function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + "Capture", dependencies);
          }
          function registerDirectEvent(registrationName, dependencies) {
            {
              if (registrationNameDependencies[registrationName]) {
                error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
              }
            }
            registrationNameDependencies[registrationName] = dependencies;
            {
              var lowerCasedName = registrationName.toLowerCase();
              possibleRegistrationNames[lowerCasedName] = registrationName;
              if (registrationName === "onDoubleClick") {
                possibleRegistrationNames.ondblclick = registrationName;
              }
            }
            for (var i5 = 0; i5 < dependencies.length; i5++) {
              allNativeEvents.add(dependencies[i5]);
            }
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e3) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkAttributeStringCoercion(value, attributeName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkPropStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkCSSPropertyStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkHtmlStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkFormFieldValueStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null) {
              return propertyInfo.type === RESERVED;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
              return true;
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix3 = name.toLowerCase().slice(0, 5);
                  return prefix3 !== "data-" && prefix3 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
            if (value === null || typeof value === "undefined") {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
              return true;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              switch (propertyInfo.type) {
                case BOOLEAN:
                  return !value;
                case OVERLOADED_BOOLEAN:
                  return value === false;
                case NUMERIC:
                  return isNaN(value);
                case POSITIVE_NUMERIC:
                  return isNaN(value) || value < 1;
              }
            }
            return false;
          }
          function getPropertyInfo(name) {
            return properties.hasOwnProperty(name) ? properties[name] : null;
          }
          function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            // TODO: This prevents the assignment of defaultValue to regular
            // elements (not just inputs). Now that ReactDOMInput assigns to the
            // defaultValue property -- do we need this?
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              RESERVED,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name = _ref[0], attributeName = _ref[1];
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEANISH_STRING,
              false,
              // mustUseProperty
              name.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEANISH_STRING,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "allowFullScreen",
            "async",
            // Note: there is a special case that prevents it from being written to the DOM
            // on the client side because the browsers are inconsistent. Instead we call focus().
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            // Microdata
            "itemScope"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEAN,
              false,
              // mustUseProperty
              name.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "checked",
            // Note: `option.selected` is not updated if `select.multiple` is
            // disabled with `removeAttribute`. We have special logic for handling this.
            "multiple",
            "muted",
            "selected"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEAN,
              true,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "capture",
            "download"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              OVERLOADED_BOOLEAN,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "cols",
            "rows",
            "size",
            "span"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              POSITIVE_NUMERIC,
              false,
              // mustUseProperty
              name,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["rowSpan", "start"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              NUMERIC,
              false,
              // mustUseProperty
              name.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              "http://www.w3.org/1999/xlink",
              false,
              // sanitizeURL
              false
            );
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              "http://www.w3.org/XML/1998/namespace",
              false,
              // sanitizeURL
              false
            );
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              // mustUseProperty
              attributeName.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord(
            "xlinkHref",
            STRING,
            false,
            // mustUseProperty
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            true,
            // sanitizeURL
            false
          );
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              // mustUseProperty
              attributeName.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              true,
              // sanitizeURL
              true
            );
          });
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          function getValueForProperty(node, name, expected, propertyInfo) {
            {
              if (propertyInfo.mustUseProperty) {
                var propertyName = propertyInfo.propertyName;
                return node[propertyName];
              } else {
                {
                  checkAttributeStringCoercion(expected, name);
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL("" + expected);
                }
                var attributeName = propertyInfo.attributeName;
                var stringValue = null;
                if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                  if (node.hasAttribute(attributeName)) {
                    var value = node.getAttribute(attributeName);
                    if (value === "") {
                      return true;
                    }
                    if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                      return value;
                    }
                    if (value === "" + expected) {
                      return expected;
                    }
                    return value;
                  }
                } else if (node.hasAttribute(attributeName)) {
                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                    return node.getAttribute(attributeName);
                  }
                  if (propertyInfo.type === BOOLEAN) {
                    return expected;
                  }
                  stringValue = node.getAttribute(attributeName);
                }
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return stringValue === null ? expected : stringValue;
                } else if (stringValue === "" + expected) {
                  return expected;
                } else {
                  return stringValue;
                }
              }
            }
          }
          function getValueForAttribute(node, name, expected, isCustomComponentTag) {
            {
              if (!isAttributeNameSafe(name)) {
                return;
              }
              if (!node.hasAttribute(name)) {
                return expected === void 0 ? void 0 : null;
              }
              var value = node.getAttribute(name);
              {
                checkAttributeStringCoercion(expected, name);
              }
              if (value === "" + expected) {
                return expected;
              }
              return value;
            }
          }
          function setValueForProperty(node, name, value, isCustomComponentTag) {
            var propertyInfo = getPropertyInfo(name);
            if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
              return;
            }
            if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
              value = null;
            }
            if (isCustomComponentTag || propertyInfo === null) {
              if (isAttributeNameSafe(name)) {
                var _attributeName = name;
                if (value === null) {
                  node.removeAttribute(_attributeName);
                } else {
                  {
                    checkAttributeStringCoercion(value, name);
                  }
                  node.setAttribute(_attributeName, "" + value);
                }
              }
              return;
            }
            var mustUseProperty = propertyInfo.mustUseProperty;
            if (mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              if (value === null) {
                var type = propertyInfo.type;
                node[propertyName] = type === BOOLEAN ? false : "";
              } else {
                node[propertyName] = value;
              }
              return;
            }
            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
            if (value === null) {
              node.removeAttribute(attributeName);
            } else {
              var _type = propertyInfo.type;
              var attributeValue;
              if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
                attributeValue = "";
              } else {
                {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  attributeValue = "" + value;
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL(attributeValue.toString());
                }
              }
              if (attributeNamespace) {
                node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
              } else {
                node.setAttribute(attributeName, attributeValue);
              }
            }
          }
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_SCOPE_TYPE = Symbol.for("react.scope");
          var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
          var REACT_CACHE_TYPE = Symbol.for("react.cache");
          var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var assign = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix2;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix2 === void 0) {
                try {
                  throw Error();
                } catch (x3) {
                  var match = x3.stack.trim().match(/\n( *(at )?)/);
                  prefix2 = match && match[1] || "";
                }
              }
              return "\n" + prefix2 + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x3) {
                    control = x3;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x3) {
                    control = x3;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x3) {
                  control = x3;
                }
                fn2();
              }
            } catch (sample2) {
              if (sample2 && control && typeof sample2.stack === "string") {
                var sampleLines = sample2.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s7 = sampleLines.length - 1;
                var c3 = controlLines.length - 1;
                while (s7 >= 1 && c3 >= 0 && sampleLines[s7] !== controlLines[c3]) {
                  c3--;
                }
                for (; s7 >= 1 && c3 >= 0; s7--, c3--) {
                  if (sampleLines[s7] !== controlLines[c3]) {
                    if (s7 !== 1 || c3 !== 1) {
                      do {
                        s7--;
                        c3--;
                        if (c3 < 0 || sampleLines[s7] !== controlLines[c3]) {
                          var _frame = "\n" + sampleLines[s7].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s7 >= 1 && c3 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component4) {
            var prototype = Component4.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x3) {
                  }
                }
              }
            }
            return "";
          }
          function describeFiber(fiber) {
            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
            var source = fiber._debugSource;
            switch (fiber.tag) {
              case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
              case LazyComponent:
                return describeBuiltInComponentFrame("Lazy");
              case SuspenseComponent:
                return describeBuiltInComponentFrame("Suspense");
              case SuspenseListComponent:
                return describeBuiltInComponentFrame("SuspenseList");
              case FunctionComponent:
              case IndeterminateComponent:
              case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
              case ForwardRef10:
                return describeFunctionComponentFrame(fiber.type.render);
              case ClassComponent:
                return describeClassComponentFrame(fiber.type);
              default:
                return "";
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            try {
              var info = "";
              var node = workInProgress2;
              do {
                info += describeFiber(node);
                node = node.return;
              } while (node);
              return info;
            } catch (x3) {
              return "\nError generating stack: " + x3.message + "\n" + x3.stack;
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x3) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          function getWrappedName$1(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName$1(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromFiber(fiber) {
            var tag = fiber.tag, type = fiber.type;
            switch (tag) {
              case CacheComponent:
                return "Cache";
              case ContextConsumer:
                var context = type;
                return getContextName$1(context) + ".Consumer";
              case ContextProvider:
                var provider = type;
                return getContextName$1(provider._context) + ".Provider";
              case DehydratedFragment:
                return "DehydratedFragment";
              case ForwardRef10:
                return getWrappedName$1(type, type.render, "ForwardRef");
              case Fragment11:
                return "Fragment";
              case HostComponent:
                return type;
              case HostPortal:
                return "Portal";
              case HostRoot:
                return "Root";
              case HostText:
                return "Text";
              case LazyComponent:
                return getComponentNameFromType(type);
              case Mode:
                if (type === REACT_STRICT_MODE_TYPE) {
                  return "StrictMode";
                }
                return "Mode";
              case OffscreenComponent:
                return "Offscreen";
              case Profiler:
                return "Profiler";
              case ScopeComponent:
                return "Scope";
              case SuspenseComponent:
                return "Suspense";
              case SuspenseListComponent:
                return "SuspenseList";
              case TracingMarkerComponent:
                return "TracingMarker";
              case ClassComponent:
              case FunctionComponent:
              case IncompleteClassComponent:
              case IndeterminateComponent:
              case MemoComponent:
              case SimpleMemoComponent:
                if (typeof type === "function") {
                  return type.displayName || type.name || null;
                }
                if (typeof type === "string") {
                  return type;
                }
                break;
            }
            return null;
          }
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var current = null;
          var isRendering = false;
          function getCurrentFiberOwnerNameInDevOrNull() {
            {
              if (current === null) {
                return null;
              }
              var owner = current._debugOwner;
              if (owner !== null && typeof owner !== "undefined") {
                return getComponentNameFromFiber(owner);
              }
            }
            return null;
          }
          function getCurrentFiberStackInDev() {
            {
              if (current === null) {
                return "";
              }
              return getStackByFiberInDevAndProd(current);
            }
          }
          function resetCurrentFiber() {
            {
              ReactDebugCurrentFrame.getCurrentStack = null;
              current = null;
              isRendering = false;
            }
          }
          function setCurrentFiber(fiber) {
            {
              ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
              current = fiber;
              isRendering = false;
            }
          }
          function getCurrentFiber() {
            {
              return current;
            }
          }
          function setIsRendering(rendering) {
            {
              isRendering = rendering;
            }
          }
          function toString(value) {
            return "" + value;
          }
          function getToStringValue(value) {
            switch (typeof value) {
              case "boolean":
              case "number":
              case "string":
              case "undefined":
                return value;
              case "object":
                {
                  checkFormFieldValueStringCoercion(value);
                }
                return value;
              default:
                return "";
            }
          }
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCheckable(elem) {
            var type = elem.type;
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
          }
          function getTracker(node) {
            return node._valueTracker;
          }
          function detachTracker(node) {
            node._valueTracker = null;
          }
          function getValueFromNode(node) {
            var value = "";
            if (!node) {
              return value;
            }
            if (isCheckable(node)) {
              value = node.checked ? "true" : "false";
            } else {
              value = node.value;
            }
            return value;
          }
          function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? "checked" : "value";
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            {
              checkFormFieldValueStringCoercion(node[valueField]);
            }
            var currentValue = "" + node[valueField];
            if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
              return;
            }
            var get3 = descriptor.get, set3 = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get3.call(this);
              },
              set: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
                set3.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            var tracker = {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
              },
              stopTracking: function() {
                detachTracker(node);
                delete node[valueField];
              }
            };
            return tracker;
          }
          function track(node) {
            if (getTracker(node)) {
              return;
            }
            node._valueTracker = trackValueOnNode(node);
          }
          function updateValueIfChanged(node) {
            if (!node) {
              return false;
            }
            var tracker = getTracker(node);
            if (!tracker) {
              return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node);
            if (nextValue !== lastValue) {
              tracker.setValue(nextValue);
              return true;
            }
            return false;
          }
          function getActiveElement(doc) {
            doc = doc || (typeof document !== "undefined" ? document : void 0);
            if (typeof doc === "undefined") {
              return null;
            }
            try {
              return doc.activeElement || doc.body;
            } catch (e3) {
              return doc.body;
            }
          }
          var didWarnValueDefaultValue = false;
          var didWarnCheckedDefaultChecked = false;
          var didWarnControlledToUncontrolled = false;
          var didWarnUncontrolledToControlled = false;
          function isControlled(props) {
            var usesChecked = props.type === "checkbox" || props.type === "radio";
            return usesChecked ? props.checked != null : props.value != null;
          }
          function getHostProps(element, props) {
            var node = element;
            var checked = props.checked;
            var hostProps = assign({}, props, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: void 0,
              checked: checked != null ? checked : node._wrapperState.initialChecked
            });
            return hostProps;
          }
          function initWrapperState(element, props) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
                error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnCheckedDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
                error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnValueDefaultValue = true;
              }
            }
            var node = element;
            var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
            node._wrapperState = {
              initialChecked: props.checked != null ? props.checked : props.defaultChecked,
              initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
              controlled: isControlled(props)
            };
          }
          function updateChecked(element, props) {
            var node = element;
            var checked = props.checked;
            if (checked != null) {
              setValueForProperty(node, "checked", checked, false);
            }
          }
          function updateWrapper(element, props) {
            var node = element;
            {
              var controlled = isControlled(props);
              if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnUncontrolledToControlled = true;
              }
              if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnControlledToUncontrolled = true;
              }
            }
            updateChecked(element, props);
            var value = getToStringValue(props.value);
            var type = props.type;
            if (value != null) {
              if (type === "number") {
                if (value === 0 && node.value === "" || // We explicitly want to coerce to number here if possible.
                // eslint-disable-next-line
                node.value != value) {
                  node.value = toString(value);
                }
              } else if (node.value !== toString(value)) {
                node.value = toString(value);
              }
            } else if (type === "submit" || type === "reset") {
              node.removeAttribute("value");
              return;
            }
            {
              if (props.hasOwnProperty("value")) {
                setDefaultValue(node, props.type, value);
              } else if (props.hasOwnProperty("defaultValue")) {
                setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
              }
            }
            {
              if (props.checked == null && props.defaultChecked != null) {
                node.defaultChecked = !!props.defaultChecked;
              }
            }
          }
          function postMountWrapper(element, props, isHydrating2) {
            var node = element;
            if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
              var type = props.type;
              var isButton = type === "submit" || type === "reset";
              if (isButton && (props.value === void 0 || props.value === null)) {
                return;
              }
              var initialValue = toString(node._wrapperState.initialValue);
              if (!isHydrating2) {
                {
                  if (initialValue !== node.value) {
                    node.value = initialValue;
                  }
                }
              }
              {
                node.defaultValue = initialValue;
              }
            }
            var name = node.name;
            if (name !== "") {
              node.name = "";
            }
            {
              node.defaultChecked = !node.defaultChecked;
              node.defaultChecked = !!node._wrapperState.initialChecked;
            }
            if (name !== "") {
              node.name = name;
            }
          }
          function restoreControlledState(element, props) {
            var node = element;
            updateWrapper(node, props);
            updateNamedCousins(node, props);
          }
          function updateNamedCousins(rootNode, props) {
            var name = props.name;
            if (props.type === "radio" && name != null) {
              var queryRoot = rootNode;
              while (queryRoot.parentNode) {
                queryRoot = queryRoot.parentNode;
              }
              {
                checkAttributeStringCoercion(name, "name");
              }
              var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
              for (var i5 = 0; i5 < group.length; i5++) {
                var otherNode = group[i5];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                  continue;
                }
                var otherProps = getFiberCurrentPropsFromNode(otherNode);
                if (!otherProps) {
                  throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                }
                updateValueIfChanged(otherNode);
                updateWrapper(otherNode, otherProps);
              }
            }
          }
          function setDefaultValue(node, type, value) {
            if (
              // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
              type !== "number" || getActiveElement(node.ownerDocument) !== node
            ) {
              if (value == null) {
                node.defaultValue = toString(node._wrapperState.initialValue);
              } else if (node.defaultValue !== toString(value)) {
                node.defaultValue = toString(value);
              }
            }
          }
          var didWarnSelectedSetOnOption = false;
          var didWarnInvalidChild = false;
          var didWarnInvalidInnerHTML = false;
          function validateProps(element, props) {
            {
              if (props.value == null) {
                if (typeof props.children === "object" && props.children !== null) {
                  React92.Children.forEach(props.children, function(child) {
                    if (child == null) {
                      return;
                    }
                    if (typeof child === "string" || typeof child === "number") {
                      return;
                    }
                    if (!didWarnInvalidChild) {
                      didWarnInvalidChild = true;
                      error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                    }
                  });
                } else if (props.dangerouslySetInnerHTML != null) {
                  if (!didWarnInvalidInnerHTML) {
                    didWarnInvalidInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              if (props.selected != null && !didWarnSelectedSetOnOption) {
                error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                didWarnSelectedSetOnOption = true;
              }
            }
          }
          function postMountWrapper$1(element, props) {
            if (props.value != null) {
              element.setAttribute("value", toString(getToStringValue(props.value)));
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray3(a3) {
            return isArrayImpl(a3);
          }
          var didWarnValueDefaultValue$1;
          {
            didWarnValueDefaultValue$1 = false;
          }
          function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              return "\n\nCheck the render method of `" + ownerName + "`.";
            }
            return "";
          }
          var valuePropNames = ["value", "defaultValue"];
          function checkSelectPropTypes(props) {
            {
              checkControlledValueProps("select", props);
              for (var i5 = 0; i5 < valuePropNames.length; i5++) {
                var propName = valuePropNames[i5];
                if (props[propName] == null) {
                  continue;
                }
                var propNameIsArray = isArray3(props[propName]);
                if (props.multiple && !propNameIsArray) {
                  error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
                } else if (!props.multiple && propNameIsArray) {
                  error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
                }
              }
            }
          }
          function updateOptions(node, multiple, propValue, setDefaultSelected) {
            var options2 = node.options;
            if (multiple) {
              var selectedValues = propValue;
              var selectedValue = {};
              for (var i5 = 0; i5 < selectedValues.length; i5++) {
                selectedValue["$" + selectedValues[i5]] = true;
              }
              for (var _i = 0; _i < options2.length; _i++) {
                var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
                if (options2[_i].selected !== selected) {
                  options2[_i].selected = selected;
                }
                if (selected && setDefaultSelected) {
                  options2[_i].defaultSelected = true;
                }
              }
            } else {
              var _selectedValue = toString(getToStringValue(propValue));
              var defaultSelected = null;
              for (var _i2 = 0; _i2 < options2.length; _i2++) {
                if (options2[_i2].value === _selectedValue) {
                  options2[_i2].selected = true;
                  if (setDefaultSelected) {
                    options2[_i2].defaultSelected = true;
                  }
                  return;
                }
                if (defaultSelected === null && !options2[_i2].disabled) {
                  defaultSelected = options2[_i2];
                }
              }
              if (defaultSelected !== null) {
                defaultSelected.selected = true;
              }
            }
          }
          function getHostProps$1(element, props) {
            return assign({}, props, {
              value: void 0
            });
          }
          function initWrapperState$1(element, props) {
            var node = element;
            {
              checkSelectPropTypes(props);
            }
            node._wrapperState = {
              wasMultiple: !!props.multiple
            };
            {
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
                error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnValueDefaultValue$1 = true;
              }
            }
          }
          function postMountWrapper$2(element, props) {
            var node = element;
            node.multiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            }
          }
          function postUpdateWrapper(element, props) {
            var node = element;
            var wasMultiple = node._wrapperState.wasMultiple;
            node._wrapperState.wasMultiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (wasMultiple !== !!props.multiple) {
              if (props.defaultValue != null) {
                updateOptions(node, !!props.multiple, props.defaultValue, true);
              } else {
                updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
              }
            }
          }
          function restoreControlledState$1(element, props) {
            var node = element;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            }
          }
          var didWarnValDefaultVal = false;
          function getHostProps$2(element, props) {
            var node = element;
            if (props.dangerouslySetInnerHTML != null) {
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            }
            var hostProps = assign({}, props, {
              value: void 0,
              defaultValue: void 0,
              children: toString(node._wrapperState.initialValue)
            });
            return hostProps;
          }
          function initWrapperState$2(element, props) {
            var node = element;
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
                error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
                didWarnValDefaultVal = true;
              }
            }
            var initialValue = props.value;
            if (initialValue == null) {
              var children = props.children, defaultValue = props.defaultValue;
              if (children != null) {
                {
                  error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                }
                {
                  if (defaultValue != null) {
                    throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                  }
                  if (isArray3(children)) {
                    if (children.length > 1) {
                      throw new Error("<textarea> can only have at most one child.");
                    }
                    children = children[0];
                  }
                  defaultValue = children;
                }
              }
              if (defaultValue == null) {
                defaultValue = "";
              }
              initialValue = defaultValue;
            }
            node._wrapperState = {
              initialValue: getToStringValue(initialValue)
            };
          }
          function updateWrapper$1(element, props) {
            var node = element;
            var value = getToStringValue(props.value);
            var defaultValue = getToStringValue(props.defaultValue);
            if (value != null) {
              var newValue = toString(value);
              if (newValue !== node.value) {
                node.value = newValue;
              }
              if (props.defaultValue == null && node.defaultValue !== newValue) {
                node.defaultValue = newValue;
              }
            }
            if (defaultValue != null) {
              node.defaultValue = toString(defaultValue);
            }
          }
          function postMountWrapper$3(element, props) {
            var node = element;
            var textContent = node.textContent;
            if (textContent === node._wrapperState.initialValue) {
              if (textContent !== "" && textContent !== null) {
                node.value = textContent;
              }
            }
          }
          function restoreControlledState$2(element, props) {
            updateWrapper$1(element, props);
          }
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          function getIntrinsicNamespace(type) {
            switch (type) {
              case "svg":
                return SVG_NAMESPACE;
              case "math":
                return MATH_NAMESPACE;
              default:
                return HTML_NAMESPACE;
            }
          }
          function getChildNamespace(parentNamespace, type) {
            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
              return getIntrinsicNamespace(type);
            }
            if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
              return HTML_NAMESPACE;
            }
            return parentNamespace;
          }
          var createMicrosoftUnsafeLocalFunction = function(func) {
            if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
              return function(arg0, arg1, arg2, arg3) {
                MSApp.execUnsafeLocalFunction(function() {
                  return func(arg0, arg1, arg2, arg3);
                });
              };
            } else {
              return func;
            }
          };
          var reusableSVGContainer;
          var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
            if (node.namespaceURI === SVG_NAMESPACE) {
              if (!("innerHTML" in node)) {
                reusableSVGContainer = reusableSVGContainer || document.createElement("div");
                reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
                var svgNode = reusableSVGContainer.firstChild;
                while (node.firstChild) {
                  node.removeChild(node.firstChild);
                }
                while (svgNode.firstChild) {
                  node.appendChild(svgNode.firstChild);
                }
                return;
              }
            }
            node.innerHTML = html;
          });
          var ELEMENT_NODE = 1;
          var TEXT_NODE = 3;
          var COMMENT_NODE = 8;
          var DOCUMENT_NODE = 9;
          var DOCUMENT_FRAGMENT_NODE = 11;
          var setTextContent = function(node, text) {
            if (text) {
              var firstChild = node.firstChild;
              if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text;
                return;
              }
            }
            node.textContent = text;
          };
          var shorthandToLonghand = {
            animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
            background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
            borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
            borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
            borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
            borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
            borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
            borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
            borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
            borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
            fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
            gap: ["columnGap", "rowGap"],
            grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
            wordWrap: ["overflowWrap"]
          };
          var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            // SVG-related properties
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix3, key) {
            return prefix3 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix3) {
              isUnitlessNumber[prefixKey(prefix3, prop)] = isUnitlessNumber[prop];
            });
          });
          function dangerousStyleValue(name, value, isCustomProperty) {
            var isEmpty = value == null || typeof value === "boolean" || value === "";
            if (isEmpty) {
              return "";
            }
            if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
              return value + "px";
            }
            {
              checkCSSPropertyStringCoercion(value, name);
            }
            return ("" + value).trim();
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern = /^ms-/;
          function hyphenateStyleName(name) {
            return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern$1 = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string) {
              return string.replace(hyphenPattern, function(_2, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error(
                "Unsupported style property %s. Did you mean %s?",
                name,
                // As Andi Smith suggests
                // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
                // is converted to lowercase `ms`.
                camelize(name.replace(msPattern$1, "ms-"))
              );
            };
            var warnBadVendoredStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name, value) {
              if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
              }
              warnedStyleValues[value] = true;
              error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name, value) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error("`NaN` is an invalid value for the `%s` css style property.", name);
            };
            var warnStyleValueIsInfinity = function(name, value) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error("`Infinity` is an invalid value for the `%s` css style property.", name);
            };
            warnValidStyle = function(name, value) {
              if (name.indexOf("-") > -1) {
                warnHyphenatedStyleName(name);
              } else if (badVendoredStyleNamePattern.test(name)) {
                warnBadVendoredStyleName(name);
              } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name, value);
              }
              if (typeof value === "number") {
                if (isNaN(value)) {
                  warnStyleValueIsNaN(name, value);
                } else if (!isFinite(value)) {
                  warnStyleValueIsInfinity(name, value);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          function createDangerousStringForStyles(styles) {
            {
              var serialized = "";
              var delimiter = "";
              for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                  continue;
                }
                var styleValue = styles[styleName];
                if (styleValue != null) {
                  var isCustomProperty = styleName.indexOf("--") === 0;
                  serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                  serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                  delimiter = ";";
                }
              }
              return serialized || null;
            }
          }
          function setValueForStyles(node, styles) {
            var style2 = node.style;
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var isCustomProperty = styleName.indexOf("--") === 0;
              {
                if (!isCustomProperty) {
                  warnValidStyle$1(styleName, styles[styleName]);
                }
              }
              var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
              if (styleName === "float") {
                styleName = "cssFloat";
              }
              if (isCustomProperty) {
                style2.setProperty(styleName, styleValue);
              } else {
                style2[styleName] = styleValue;
              }
            }
          }
          function isValueEmpty(value) {
            return value == null || typeof value === "boolean" || value === "";
          }
          function expandShorthandMap(styles) {
            var expanded = {};
            for (var key in styles) {
              var longhands = shorthandToLonghand[key] || [key];
              for (var i5 = 0; i5 < longhands.length; i5++) {
                expanded[longhands[i5]] = key;
              }
            }
            return expanded;
          }
          function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
            {
              if (!nextStyles) {
                return;
              }
              var expandedUpdates = expandShorthandMap(styleUpdates);
              var expandedStyles = expandShorthandMap(nextStyles);
              var warnedAbout = {};
              for (var key in expandedUpdates) {
                var originalKey = expandedUpdates[key];
                var correctOriginalKey = expandedStyles[key];
                if (correctOriginalKey && originalKey !== correctOriginalKey) {
                  var warningKey = originalKey + "," + correctOriginalKey;
                  if (warnedAbout[warningKey]) {
                    continue;
                  }
                  warnedAbout[warningKey] = true;
                  error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
                }
              }
            }
          }
          var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
            // NOTE: menuitem's close tag should be omitted, but that causes problems.
          };
          var voidElementTags = assign({
            menuitem: true
          }, omittedCloseTags);
          var HTML = "__html";
          function assertValidProps(tag, props) {
            if (!props) {
              return;
            }
            if (voidElementTags[tag]) {
              if (props.children != null || props.dangerouslySetInnerHTML != null) {
                throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
            if (props.dangerouslySetInnerHTML != null) {
              if (props.children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
            {
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
            }
            if (props.style != null && typeof props.style !== "object") {
              throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var possibleStandardNames = {
            // HTML
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            // SVG
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var ariaProperties = {
            "aria-current": 0,
            // state
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            // state
            "aria-hidden": 0,
            // state
            "aria-invalid": 0,
            // state
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            // Widget Attributes
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            // Live Region Attributes
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            // Drag-and-Drop Attributes
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            // Relationship Attributes
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          function validateProperty(tagName, name) {
            {
              if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
                return true;
              }
              if (rARIACamel.test(name)) {
                var ariaName = "aria-" + name.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                  warnedProperties[name] = true;
                  return true;
                }
                if (name !== correctName) {
                  error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
              if (rARIA.test(name)) {
                var lowerCasedName = name.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name] = true;
                  return false;
                }
                if (name !== standardName) {
                  error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid = validateProperty(type, key);
                if (!isValid) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name, value, eventRegistry) {
              if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                return true;
              }
              var lowerCasedName = name.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies2.hasOwnProperty(name)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
                if (registrationName != null) {
                  error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name)) {
                  error("Unknown event handler property `%s`. It will be ignored.", name);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name)) {
                if (INVALID_EVENT_NAME_REGEX.test(name)) {
                  error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
                error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "number" && isNaN(value)) {
                error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
                warnedProperties$1[name] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name) {
                  error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (!isReserved && name !== lowerCasedName) {
                error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                if (value) {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
                } else {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                warnedProperties$1[name] = true;
                return false;
              }
              if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                warnedProperties$1[name] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid = validateProperty$1(type, key, props[key], eventRegistry);
                if (!isValid) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
          var IS_NON_DELEGATED = 1 << 1;
          var IS_CAPTURE_PHASE = 1 << 2;
          var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
          var currentReplayingEvent = null;
          function setReplayingEvent(event) {
            {
              if (currentReplayingEvent !== null) {
                error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = event;
          }
          function resetReplayingEvent() {
            {
              if (currentReplayingEvent === null) {
                error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = null;
          }
          function isReplayingEvent(event) {
            return event === currentReplayingEvent;
          }
          function getEventTarget(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            if (target.correspondingUseElement) {
              target = target.correspondingUseElement;
            }
            return target.nodeType === TEXT_NODE ? target.parentNode : target;
          }
          var restoreImpl = null;
          var restoreTarget = null;
          var restoreQueue = null;
          function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (!internalInstance) {
              return;
            }
            if (typeof restoreImpl !== "function") {
              throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
            }
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
              var _props = getFiberCurrentPropsFromNode(stateNode);
              restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
          }
          function setRestoreImplementation(impl) {
            restoreImpl = impl;
          }
          function enqueueStateRestore(target) {
            if (restoreTarget) {
              if (restoreQueue) {
                restoreQueue.push(target);
              } else {
                restoreQueue = [target];
              }
            } else {
              restoreTarget = target;
            }
          }
          function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
          }
          function restoreStateIfNeeded() {
            if (!restoreTarget) {
              return;
            }
            var target = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target);
            if (queuedTargets) {
              for (var i5 = 0; i5 < queuedTargets.length; i5++) {
                restoreStateOfTarget(queuedTargets[i5]);
              }
            }
          }
          var batchedUpdatesImpl = function(fn2, bookkeeping) {
            return fn2(bookkeeping);
          };
          var flushSyncImpl = function() {
          };
          var isInsideEventHandler = false;
          function finishEventHandler() {
            var controlledComponentsHavePendingUpdates = needsStateRestore();
            if (controlledComponentsHavePendingUpdates) {
              flushSyncImpl();
              restoreStateIfNeeded();
            }
          }
          function batchedUpdates(fn2, a3, b2) {
            if (isInsideEventHandler) {
              return fn2(a3, b2);
            }
            isInsideEventHandler = true;
            try {
              return batchedUpdatesImpl(fn2, a3, b2);
            } finally {
              isInsideEventHandler = false;
              finishEventHandler();
            }
          }
          function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
            batchedUpdatesImpl = _batchedUpdatesImpl;
            flushSyncImpl = _flushSyncImpl;
          }
          function isInteractive(tag) {
            return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
          }
          function shouldPreventMouseEvent(name, type, props) {
            switch (name) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                return !!(props.disabled && isInteractive(type));
              default:
                return false;
            }
          }
          function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (stateNode === null) {
              return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (props === null) {
              return null;
            }
            var listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
              return null;
            }
            if (listener && typeof listener !== "function") {
              throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
            }
            return listener;
          }
          var passiveBrowserEventsSupported = false;
          if (canUseDOM) {
            try {
              var options = {};
              Object.defineProperty(options, "passive", {
                get: function() {
                  passiveBrowserEventsSupported = true;
                }
              });
              window.addEventListener("test", options, options);
              window.removeEventListener("test", options, options);
            } catch (e3) {
              passiveBrowserEventsSupported = false;
            }
          }
          function invokeGuardedCallbackProd(name, func, context, a3, b2, c3, d5, e3, f5) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
              func.apply(context, funcArgs);
            } catch (error2) {
              this.onError(error2);
            }
          }
          var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
          {
            if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
              var fakeNode = document.createElement("react");
              invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a3, b2, c3, d5, e3, f5) {
                if (typeof document === "undefined" || document === null) {
                  throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                }
                var evt = document.createEvent("Event");
                var didCall = false;
                var didError = true;
                var windowEvent = window.event;
                var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                function restoreAfterDispatch() {
                  fakeNode.removeEventListener(evtType, callCallback2, false);
                  if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                    window.event = windowEvent;
                  }
                }
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                function callCallback2() {
                  didCall = true;
                  restoreAfterDispatch();
                  func.apply(context, funcArgs);
                  didError = false;
                }
                var error2;
                var didSetError = false;
                var isCrossOriginError = false;
                function handleWindowError(event) {
                  error2 = event.error;
                  didSetError = true;
                  if (error2 === null && event.colno === 0 && event.lineno === 0) {
                    isCrossOriginError = true;
                  }
                  if (event.defaultPrevented) {
                    if (error2 != null && typeof error2 === "object") {
                      try {
                        error2._suppressLogging = true;
                      } catch (inner) {
                      }
                    }
                  }
                }
                var evtType = "react-" + (name ? name : "invokeguardedcallback");
                window.addEventListener("error", handleWindowError);
                fakeNode.addEventListener(evtType, callCallback2, false);
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                if (windowEventDescriptor) {
                  Object.defineProperty(window, "event", windowEventDescriptor);
                }
                if (didCall && didError) {
                  if (!didSetError) {
                    error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                  } else if (isCrossOriginError) {
                    error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                  }
                  this.onError(error2);
                }
                window.removeEventListener("error", handleWindowError);
                if (!didCall) {
                  restoreAfterDispatch();
                  return invokeGuardedCallbackProd.apply(this, arguments);
                }
              };
            }
          }
          var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
          var hasError = false;
          var caughtError = null;
          var hasRethrowError = false;
          var rethrowError = null;
          var reporter = {
            onError: function(error2) {
              hasError = true;
              caughtError = error2;
            }
          };
          function invokeGuardedCallback(name, func, context, a3, b2, c3, d5, e3, f5) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
          }
          function invokeGuardedCallbackAndCatchFirstError(name, func, context, a3, b2, c3, d5, e3, f5) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
              var error2 = clearCaughtError();
              if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error2;
              }
            }
          }
          function rethrowCaughtError() {
            if (hasRethrowError) {
              var error2 = rethrowError;
              hasRethrowError = false;
              rethrowError = null;
              throw error2;
            }
          }
          function hasCaughtError() {
            return hasError;
          }
          function clearCaughtError() {
            if (hasError) {
              var error2 = caughtError;
              hasError = false;
              caughtError = null;
              return error2;
            } else {
              throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function get2(key) {
            return key._reactInternals;
          }
          function has(key) {
            return key._reactInternals !== void 0;
          }
          function set2(key, value) {
            key._reactInternals = value;
          }
          var NoFlags = (
            /*                      */
            0
          );
          var PerformedWork = (
            /*                */
            1
          );
          var Placement = (
            /*                    */
            2
          );
          var Update = (
            /*                       */
            4
          );
          var ChildDeletion = (
            /*                */
            16
          );
          var ContentReset = (
            /*                 */
            32
          );
          var Callback = (
            /*                     */
            64
          );
          var DidCapture = (
            /*                   */
            128
          );
          var ForceClientRender = (
            /*            */
            256
          );
          var Ref = (
            /*                          */
            512
          );
          var Snapshot = (
            /*                     */
            1024
          );
          var Passive = (
            /*                      */
            2048
          );
          var Hydrating = (
            /*                    */
            4096
          );
          var Visibility = (
            /*                   */
            8192
          );
          var StoreConsistency = (
            /*             */
            16384
          );
          var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
          var HostEffectMask = (
            /*               */
            32767
          );
          var Incomplete = (
            /*                   */
            32768
          );
          var ShouldCapture = (
            /*                */
            65536
          );
          var ForceUpdateForLegacySuspense = (
            /* */
            131072
          );
          var Forked = (
            /*                       */
            1048576
          );
          var RefStatic = (
            /*                    */
            2097152
          );
          var LayoutStatic = (
            /*                 */
            4194304
          );
          var PassiveStatic = (
            /*                */
            8388608
          );
          var MountLayoutDev = (
            /*               */
            16777216
          );
          var MountPassiveDev = (
            /*              */
            33554432
          );
          var BeforeMutationMask = (
            // TODO: Remove Update flag from before mutation phase by re-landing Visibility
            // flag logic (see #20043)
            Update | Snapshot | 0
          );
          var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
          var LayoutMask = Update | Callback | Ref | Visibility;
          var PassiveMask = Passive | ChildDeletion;
          var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node;
              do {
                node = nextNode;
                if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                  nearestMounted = node.return;
                }
                nextNode = node.return;
              } while (nextNode);
            } else {
              while (node.return) {
                node = node.return;
              }
            }
            if (node.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
              var suspenseState = fiber.memoizedState;
              if (suspenseState === null) {
                var current2 = fiber.alternate;
                if (current2 !== null) {
                  suspenseState = current2.memoizedState;
                }
              }
              if (suspenseState !== null) {
                return suspenseState.dehydrated;
              }
            }
            return null;
          }
          function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
          }
          function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
          }
          function isMounted(component) {
            {
              var owner = ReactCurrentOwner.current;
              if (owner !== null && owner.tag === ClassComponent) {
                var ownerFiber = owner;
                var instance = ownerFiber.stateNode;
                if (!instance._warnedAboutRefsInRender) {
                  error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
                }
                instance._warnedAboutRefsInRender = true;
              }
            }
            var fiber = get2(component);
            if (!fiber) {
              return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
          }
          function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
              throw new Error("Unable to find node on an unmounted component.");
            }
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (nearestMounted === null) {
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a3 = fiber;
            var b2 = alternate;
            while (true) {
              var parentA = a3.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a3 = b2 = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a3) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b2) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (a3.return !== b2.return) {
                a3 = parentA;
                b2 = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a3) {
                    didFindChild = true;
                    a3 = parentA;
                    b2 = parentB;
                    break;
                  }
                  if (_child === b2) {
                    didFindChild = true;
                    b2 = parentA;
                    a3 = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a3) {
                      didFindChild = true;
                      a3 = parentB;
                      b2 = parentA;
                      break;
                    }
                    if (_child === b2) {
                      didFindChild = true;
                      b2 = parentB;
                      a3 = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                  }
                }
              }
              if (a3.alternate !== b2) {
                throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (a3.tag !== HostRoot) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a3.stateNode.current === a3) {
              return fiber;
            }
            return alternate;
          }
          function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
          }
          function findCurrentHostFiberImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              var match = findCurrentHostFiberImpl(child);
              if (match !== null) {
                return match;
              }
              child = child.sibling;
            }
            return null;
          }
          function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
          }
          function findCurrentHostFiberWithNoPortalsImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              if (child.tag !== HostPortal) {
                var match = findCurrentHostFiberWithNoPortalsImpl(child);
                if (match !== null) {
                  return match;
                }
              }
              child = child.sibling;
            }
            return null;
          }
          var scheduleCallback = Scheduler.unstable_scheduleCallback;
          var cancelCallback = Scheduler.unstable_cancelCallback;
          var shouldYield = Scheduler.unstable_shouldYield;
          var requestPaint = Scheduler.unstable_requestPaint;
          var now = Scheduler.unstable_now;
          var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
          var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
          var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
          var NormalPriority = Scheduler.unstable_NormalPriority;
          var LowPriority = Scheduler.unstable_LowPriority;
          var IdlePriority = Scheduler.unstable_IdlePriority;
          var unstable_yieldValue = Scheduler.unstable_yieldValue;
          var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
          var rendererID = null;
          var injectedHook = null;
          var injectedProfilingHooks = null;
          var hasLoggedError = false;
          var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
          function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
              return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
              return true;
            }
            if (!hook.supportsFiber) {
              {
                error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
              }
              return true;
            }
            try {
              if (enableSchedulingProfiler) {
                internals = assign({}, internals, {
                  getLaneLabelMap,
                  injectProfilingHooks
                });
              }
              rendererID = hook.inject(internals);
              injectedHook = hook;
            } catch (err) {
              {
                error("React instrumentation encountered an error: %s.", err);
              }
            }
            if (hook.checkDCE) {
              return true;
            } else {
              return false;
            }
          }
          function onScheduleRoot(root2, children) {
            {
              if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
                try {
                  injectedHook.onScheduleFiberRoot(rendererID, root2, children);
                } catch (err) {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitRoot(root2, eventPriority) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
              try {
                var didError = (root2.current.flags & DidCapture) === DidCapture;
                if (enableProfilerTimer) {
                  var schedulerPriority;
                  switch (eventPriority) {
                    case DiscreteEventPriority:
                      schedulerPriority = ImmediatePriority;
                      break;
                    case ContinuousEventPriority:
                      schedulerPriority = UserBlockingPriority;
                      break;
                    case DefaultEventPriority:
                      schedulerPriority = NormalPriority;
                      break;
                    case IdleEventPriority:
                      schedulerPriority = IdlePriority;
                      break;
                    default:
                      schedulerPriority = NormalPriority;
                      break;
                  }
                  injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);
                } else {
                  injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
                }
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onPostCommitRoot(root2) {
            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root2);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
              try {
                injectedHook.onCommitFiberUnmount(rendererID, fiber);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function setIsStrictModeForDevtools(newIsStrictMode) {
            {
              if (typeof unstable_yieldValue === "function") {
                unstable_setDisableYieldValue(newIsStrictMode);
                setSuppressWarning(newIsStrictMode);
              }
              if (injectedHook && typeof injectedHook.setStrictMode === "function") {
                try {
                  injectedHook.setStrictMode(rendererID, newIsStrictMode);
                } catch (err) {
                  {
                    if (!hasLoggedError) {
                      hasLoggedError = true;
                      error("React instrumentation encountered an error: %s", err);
                    }
                  }
                }
              }
            }
          }
          function injectProfilingHooks(profilingHooks) {
            injectedProfilingHooks = profilingHooks;
          }
          function getLaneLabelMap() {
            {
              var map3 = /* @__PURE__ */ new Map();
              var lane = 1;
              for (var index3 = 0; index3 < TotalLanes; index3++) {
                var label = getLabelForLane(lane);
                map3.set(lane, label);
                lane *= 2;
              }
              return map3;
            }
          }
          function markCommitStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
                injectedProfilingHooks.markCommitStarted(lanes);
              }
            }
          }
          function markCommitStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
                injectedProfilingHooks.markCommitStopped();
              }
            }
          }
          function markComponentRenderStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
                injectedProfilingHooks.markComponentRenderStarted(fiber);
              }
            }
          }
          function markComponentRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
                injectedProfilingHooks.markComponentRenderStopped();
              }
            }
          }
          function markComponentPassiveEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStopped();
              }
            }
          }
          function markComponentPassiveEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
              }
            }
          }
          function markComponentLayoutEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStopped();
              }
            }
          }
          function markComponentLayoutEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
              }
            }
          }
          function markComponentErrored(fiber, thrownValue, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
                injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
              }
            }
          }
          function markComponentSuspended(fiber, wakeable, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
                injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
              }
            }
          }
          function markLayoutEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
                injectedProfilingHooks.markLayoutEffectsStarted(lanes);
              }
            }
          }
          function markLayoutEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
                injectedProfilingHooks.markLayoutEffectsStopped();
              }
            }
          }
          function markPassiveEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
                injectedProfilingHooks.markPassiveEffectsStarted(lanes);
              }
            }
          }
          function markPassiveEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
                injectedProfilingHooks.markPassiveEffectsStopped();
              }
            }
          }
          function markRenderStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
                injectedProfilingHooks.markRenderStarted(lanes);
              }
            }
          }
          function markRenderYielded() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
                injectedProfilingHooks.markRenderYielded();
              }
            }
          }
          function markRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
                injectedProfilingHooks.markRenderStopped();
              }
            }
          }
          function markRenderScheduled(lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
                injectedProfilingHooks.markRenderScheduled(lane);
              }
            }
          }
          function markForceUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
                injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
              }
            }
          }
          function markStateUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
                injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
              }
            }
          }
          var NoMode = (
            /*                         */
            0
          );
          var ConcurrentMode = (
            /*                 */
            1
          );
          var ProfileMode = (
            /*                    */
            2
          );
          var StrictLegacyMode = (
            /*               */
            8
          );
          var StrictEffectsMode = (
            /*              */
            16
          );
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(x3) {
            var asUint = x3 >>> 0;
            if (asUint === 0) {
              return 32;
            }
            return 31 - (log(asUint) / LN2 | 0) | 0;
          }
          var TotalLanes = 31;
          var NoLanes = (
            /*                        */
            0
          );
          var NoLane = (
            /*                          */
            0
          );
          var SyncLane = (
            /*                        */
            1
          );
          var InputContinuousHydrationLane = (
            /*    */
            2
          );
          var InputContinuousLane = (
            /*             */
            4
          );
          var DefaultHydrationLane = (
            /*            */
            8
          );
          var DefaultLane = (
            /*                     */
            16
          );
          var TransitionHydrationLane = (
            /*                */
            32
          );
          var TransitionLanes = (
            /*                       */
            4194240
          );
          var TransitionLane1 = (
            /*                        */
            64
          );
          var TransitionLane2 = (
            /*                        */
            128
          );
          var TransitionLane3 = (
            /*                        */
            256
          );
          var TransitionLane4 = (
            /*                        */
            512
          );
          var TransitionLane5 = (
            /*                        */
            1024
          );
          var TransitionLane6 = (
            /*                        */
            2048
          );
          var TransitionLane7 = (
            /*                        */
            4096
          );
          var TransitionLane8 = (
            /*                        */
            8192
          );
          var TransitionLane9 = (
            /*                        */
            16384
          );
          var TransitionLane10 = (
            /*                       */
            32768
          );
          var TransitionLane11 = (
            /*                       */
            65536
          );
          var TransitionLane12 = (
            /*                       */
            131072
          );
          var TransitionLane13 = (
            /*                       */
            262144
          );
          var TransitionLane14 = (
            /*                       */
            524288
          );
          var TransitionLane15 = (
            /*                       */
            1048576
          );
          var TransitionLane16 = (
            /*                       */
            2097152
          );
          var RetryLanes = (
            /*                            */
            130023424
          );
          var RetryLane1 = (
            /*                             */
            4194304
          );
          var RetryLane2 = (
            /*                             */
            8388608
          );
          var RetryLane3 = (
            /*                             */
            16777216
          );
          var RetryLane4 = (
            /*                             */
            33554432
          );
          var RetryLane5 = (
            /*                             */
            67108864
          );
          var SomeRetryLane = RetryLane1;
          var SelectiveHydrationLane = (
            /*          */
            134217728
          );
          var NonIdleLanes = (
            /*                          */
            268435455
          );
          var IdleHydrationLane = (
            /*               */
            268435456
          );
          var IdleLane = (
            /*                        */
            536870912
          );
          var OffscreenLane = (
            /*                   */
            1073741824
          );
          function getLabelForLane(lane) {
            {
              if (lane & SyncLane) {
                return "Sync";
              }
              if (lane & InputContinuousHydrationLane) {
                return "InputContinuousHydration";
              }
              if (lane & InputContinuousLane) {
                return "InputContinuous";
              }
              if (lane & DefaultHydrationLane) {
                return "DefaultHydration";
              }
              if (lane & DefaultLane) {
                return "Default";
              }
              if (lane & TransitionHydrationLane) {
                return "TransitionHydration";
              }
              if (lane & TransitionLanes) {
                return "Transition";
              }
              if (lane & RetryLanes) {
                return "Retry";
              }
              if (lane & SelectiveHydrationLane) {
                return "SelectiveHydration";
              }
              if (lane & IdleHydrationLane) {
                return "IdleHydration";
              }
              if (lane & IdleLane) {
                return "Idle";
              }
              if (lane & OffscreenLane) {
                return "Offscreen";
              }
            }
          }
          var NoTimestamp = -1;
          var nextTransitionLane = TransitionLane1;
          var nextRetryLane = RetryLane1;
          function getHighestPriorityLanes(lanes) {
            switch (getHighestPriorityLane(lanes)) {
              case SyncLane:
                return SyncLane;
              case InputContinuousHydrationLane:
                return InputContinuousHydrationLane;
              case InputContinuousLane:
                return InputContinuousLane;
              case DefaultHydrationLane:
                return DefaultHydrationLane;
              case DefaultLane:
                return DefaultLane;
              case TransitionHydrationLane:
                return TransitionHydrationLane;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return lanes & TransitionLanes;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return lanes & RetryLanes;
              case SelectiveHydrationLane:
                return SelectiveHydrationLane;
              case IdleHydrationLane:
                return IdleHydrationLane;
              case IdleLane:
                return IdleLane;
              case OffscreenLane:
                return OffscreenLane;
              default:
                {
                  error("Should have found matching lanes. This is a bug in React.");
                }
                return lanes;
            }
          }
          function getNextLanes(root2, wipLanes) {
            var pendingLanes = root2.pendingLanes;
            if (pendingLanes === NoLanes) {
              return NoLanes;
            }
            var nextLanes = NoLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
              var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
              if (nonIdleUnblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
              } else {
                var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                if (nonIdlePingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                }
              }
            } else {
              var unblockedLanes = pendingLanes & ~suspendedLanes;
              if (unblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(unblockedLanes);
              } else {
                if (pingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(pingedLanes);
                }
              }
            }
            if (nextLanes === NoLanes) {
              return NoLanes;
            }
            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
            // bother waiting until the root is complete.
            (wipLanes & suspendedLanes) === NoLanes) {
              var nextLane = getHighestPriorityLane(nextLanes);
              var wipLane = getHighestPriorityLane(wipLanes);
              if (
                // Tests whether the next lane is equal or lower priority than the wip
                // one. This works because the bits decrease in priority as you go left.
                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
                // only difference between default updates and transition updates is that
                // default updates do not support refresh transitions.
                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
              ) {
                return wipLanes;
              }
            }
            if ((nextLanes & InputContinuousLane) !== NoLanes) {
              nextLanes |= pendingLanes & DefaultLane;
            }
            var entangledLanes = root2.entangledLanes;
            if (entangledLanes !== NoLanes) {
              var entanglements = root2.entanglements;
              var lanes = nextLanes & entangledLanes;
              while (lanes > 0) {
                var index3 = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index3;
                nextLanes |= entanglements[index3];
                lanes &= ~lane;
              }
            }
            return nextLanes;
          }
          function getMostRecentEventTime(root2, lanes) {
            var eventTimes = root2.eventTimes;
            var mostRecentEventTime = NoTimestamp;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              var eventTime = eventTimes[index3];
              if (eventTime > mostRecentEventTime) {
                mostRecentEventTime = eventTime;
              }
              lanes &= ~lane;
            }
            return mostRecentEventTime;
          }
          function computeExpirationTime(lane, currentTime) {
            switch (lane) {
              case SyncLane:
              case InputContinuousHydrationLane:
              case InputContinuousLane:
                return currentTime + 250;
              case DefaultHydrationLane:
              case DefaultLane:
              case TransitionHydrationLane:
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return currentTime + 5e3;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return NoTimestamp;
              case SelectiveHydrationLane:
              case IdleHydrationLane:
              case IdleLane:
              case OffscreenLane:
                return NoTimestamp;
              default:
                {
                  error("Should have found matching lanes. This is a bug in React.");
                }
                return NoTimestamp;
            }
          }
          function markStarvedLanesAsExpired(root2, currentTime) {
            var pendingLanes = root2.pendingLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = pendingLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              var expirationTime = expirationTimes[index3];
              if (expirationTime === NoTimestamp) {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                  expirationTimes[index3] = computeExpirationTime(lane, currentTime);
                }
              } else if (expirationTime <= currentTime) {
                root2.expiredLanes |= lane;
              }
              lanes &= ~lane;
            }
          }
          function getHighestPriorityPendingLanes(root2) {
            return getHighestPriorityLanes(root2.pendingLanes);
          }
          function getLanesToRetrySynchronouslyOnError(root2) {
            var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
              return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
              return OffscreenLane;
            }
            return NoLanes;
          }
          function includesSyncLane(lanes) {
            return (lanes & SyncLane) !== NoLanes;
          }
          function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
          }
          function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
          }
          function includesOnlyNonUrgentLanes(lanes) {
            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
            return (lanes & UrgentLanes) === NoLanes;
          }
          function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
          }
          function includesBlockingLane(root2, lanes) {
            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
            return (lanes & SyncDefaultLanes) !== NoLanes;
          }
          function includesExpiredLane(root2, lanes) {
            return (lanes & root2.expiredLanes) !== NoLanes;
          }
          function isTransitionLane(lane) {
            return (lane & TransitionLanes) !== NoLanes;
          }
          function claimNextTransitionLane() {
            var lane = nextTransitionLane;
            nextTransitionLane <<= 1;
            if ((nextTransitionLane & TransitionLanes) === NoLanes) {
              nextTransitionLane = TransitionLane1;
            }
            return lane;
          }
          function claimNextRetryLane() {
            var lane = nextRetryLane;
            nextRetryLane <<= 1;
            if ((nextRetryLane & RetryLanes) === NoLanes) {
              nextRetryLane = RetryLane1;
            }
            return lane;
          }
          function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
          }
          function pickArbitraryLane(lanes) {
            return getHighestPriorityLane(lanes);
          }
          function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
          }
          function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
          }
          function includesSomeLane(a3, b2) {
            return (a3 & b2) !== NoLanes;
          }
          function isSubsetOfLanes(set3, subset) {
            return (set3 & subset) === subset;
          }
          function mergeLanes(a3, b2) {
            return a3 | b2;
          }
          function removeLanes(set3, subset) {
            return set3 & ~subset;
          }
          function intersectLanes(a3, b2) {
            return a3 & b2;
          }
          function laneToLanes(lane) {
            return lane;
          }
          function higherPriorityLane(a3, b2) {
            return a3 !== NoLane && a3 < b2 ? a3 : b2;
          }
          function createLaneMap(initial) {
            var laneMap = [];
            for (var i5 = 0; i5 < TotalLanes; i5++) {
              laneMap.push(initial);
            }
            return laneMap;
          }
          function markRootUpdated(root2, updateLane, eventTime) {
            root2.pendingLanes |= updateLane;
            if (updateLane !== IdleLane) {
              root2.suspendedLanes = NoLanes;
              root2.pingedLanes = NoLanes;
            }
            var eventTimes = root2.eventTimes;
            var index3 = laneToIndex(updateLane);
            eventTimes[index3] = eventTime;
          }
          function markRootSuspended(root2, suspendedLanes) {
            root2.suspendedLanes |= suspendedLanes;
            root2.pingedLanes &= ~suspendedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = suspendedLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              expirationTimes[index3] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootPinged(root2, pingedLanes, eventTime) {
            root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          }
          function markRootFinished(root2, remainingLanes) {
            var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
            root2.pendingLanes = remainingLanes;
            root2.suspendedLanes = NoLanes;
            root2.pingedLanes = NoLanes;
            root2.expiredLanes &= remainingLanes;
            root2.mutableReadLanes &= remainingLanes;
            root2.entangledLanes &= remainingLanes;
            var entanglements = root2.entanglements;
            var eventTimes = root2.eventTimes;
            var expirationTimes = root2.expirationTimes;
            var lanes = noLongerPendingLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              entanglements[index3] = NoLanes;
              eventTimes[index3] = NoTimestamp;
              expirationTimes[index3] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootEntangled(root2, entangledLanes) {
            var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
            var entanglements = root2.entanglements;
            var lanes = rootEntangledLanes;
            while (lanes) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              if (
                // Is this one of the newly entangled lanes?
                lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
                entanglements[index3] & entangledLanes
              ) {
                entanglements[index3] |= entangledLanes;
              }
              lanes &= ~lane;
            }
          }
          function getBumpedLaneForHydration(root2, renderLanes2) {
            var renderLane = getHighestPriorityLane(renderLanes2);
            var lane;
            switch (renderLane) {
              case InputContinuousLane:
                lane = InputContinuousHydrationLane;
                break;
              case DefaultLane:
                lane = DefaultHydrationLane;
                break;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                lane = TransitionHydrationLane;
                break;
              case IdleLane:
                lane = IdleHydrationLane;
                break;
              default:
                lane = NoLane;
                break;
            }
            if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {
              return NoLane;
            }
            return lane;
          }
          function addFiberToLanesMap(root2, fiber, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
            while (lanes > 0) {
              var index3 = laneToIndex(lanes);
              var lane = 1 << index3;
              var updaters = pendingUpdatersLaneMap[index3];
              updaters.add(fiber);
              lanes &= ~lane;
            }
          }
          function movePendingFibersToMemoized(root2, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
            var memoizedUpdaters = root2.memoizedUpdaters;
            while (lanes > 0) {
              var index3 = laneToIndex(lanes);
              var lane = 1 << index3;
              var updaters = pendingUpdatersLaneMap[index3];
              if (updaters.size > 0) {
                updaters.forEach(function(fiber) {
                  var alternate = fiber.alternate;
                  if (alternate === null || !memoizedUpdaters.has(alternate)) {
                    memoizedUpdaters.add(fiber);
                  }
                });
                updaters.clear();
              }
              lanes &= ~lane;
            }
          }
          function getTransitionsForLanes(root2, lanes) {
            {
              return null;
            }
          }
          var DiscreteEventPriority = SyncLane;
          var ContinuousEventPriority = InputContinuousLane;
          var DefaultEventPriority = DefaultLane;
          var IdleEventPriority = IdleLane;
          var currentUpdatePriority = NoLane;
          function getCurrentUpdatePriority() {
            return currentUpdatePriority;
          }
          function setCurrentUpdatePriority(newPriority) {
            currentUpdatePriority = newPriority;
          }
          function runWithPriority(priority, fn2) {
            var previousPriority = currentUpdatePriority;
            try {
              currentUpdatePriority = priority;
              return fn2();
            } finally {
              currentUpdatePriority = previousPriority;
            }
          }
          function higherEventPriority(a3, b2) {
            return a3 !== 0 && a3 < b2 ? a3 : b2;
          }
          function lowerEventPriority(a3, b2) {
            return a3 === 0 || a3 > b2 ? a3 : b2;
          }
          function isHigherEventPriority(a3, b2) {
            return a3 !== 0 && a3 < b2;
          }
          function lanesToEventPriority(lanes) {
            var lane = getHighestPriorityLane(lanes);
            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
              return DiscreteEventPriority;
            }
            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
              return ContinuousEventPriority;
            }
            if (includesNonIdleWork(lane)) {
              return DefaultEventPriority;
            }
            return IdleEventPriority;
          }
          function isRootDehydrated(root2) {
            var currentState = root2.current.memoizedState;
            return currentState.isDehydrated;
          }
          var _attemptSynchronousHydration;
          function setAttemptSynchronousHydration(fn2) {
            _attemptSynchronousHydration = fn2;
          }
          function attemptSynchronousHydration(fiber) {
            _attemptSynchronousHydration(fiber);
          }
          var attemptContinuousHydration;
          function setAttemptContinuousHydration(fn2) {
            attemptContinuousHydration = fn2;
          }
          var attemptHydrationAtCurrentPriority;
          function setAttemptHydrationAtCurrentPriority(fn2) {
            attemptHydrationAtCurrentPriority = fn2;
          }
          var getCurrentUpdatePriority$1;
          function setGetCurrentUpdatePriority(fn2) {
            getCurrentUpdatePriority$1 = fn2;
          }
          var attemptHydrationAtPriority;
          function setAttemptHydrationAtPriority(fn2) {
            attemptHydrationAtPriority = fn2;
          }
          var hasScheduledReplayAttempt = false;
          var queuedDiscreteEvents = [];
          var queuedFocus = null;
          var queuedDrag = null;
          var queuedMouse = null;
          var queuedPointers = /* @__PURE__ */ new Map();
          var queuedPointerCaptures = /* @__PURE__ */ new Map();
          var queuedExplicitHydrationTargets = [];
          var discreteReplayableEvents = [
            "mousedown",
            "mouseup",
            "touchcancel",
            "touchend",
            "touchstart",
            "auxclick",
            "dblclick",
            "pointercancel",
            "pointerdown",
            "pointerup",
            "dragend",
            "dragstart",
            "drop",
            "compositionend",
            "compositionstart",
            "keydown",
            "keypress",
            "keyup",
            "input",
            "textInput",
            // Intentionally camelCase
            "copy",
            "cut",
            "paste",
            "click",
            "change",
            "contextmenu",
            "reset",
            "submit"
          ];
          function isDiscreteEventThatRequiresHydration(eventType) {
            return discreteReplayableEvents.indexOf(eventType) > -1;
          }
          function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            };
          }
          function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch (domEventName) {
              case "focusin":
              case "focusout":
                queuedFocus = null;
                break;
              case "dragenter":
              case "dragleave":
                queuedDrag = null;
                break;
              case "mouseover":
              case "mouseout":
                queuedMouse = null;
                break;
              case "pointerover":
              case "pointerout": {
                var pointerId = nativeEvent.pointerId;
                queuedPointers.delete(pointerId);
                break;
              }
              case "gotpointercapture":
              case "lostpointercapture": {
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
              }
            }
          }
          function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
              var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode(blockedOn);
                if (_fiber2 !== null) {
                  attemptContinuousHydration(_fiber2);
                }
              }
              return queuedEvent;
            }
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            var targetContainers = existingQueuedEvent.targetContainers;
            if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
              targetContainers.push(targetContainer);
            }
            return existingQueuedEvent;
          }
          function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch (domEventName) {
              case "focusin": {
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                return true;
              }
              case "dragenter": {
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                return true;
              }
              case "mouseover": {
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                return true;
              }
              case "pointerover": {
                var pointerEvent = nativeEvent;
                var pointerId = pointerEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                return true;
              }
              case "gotpointercapture": {
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                return true;
              }
            }
            return false;
          }
          function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted !== null) {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    queuedTarget.blockedOn = instance;
                    attemptHydrationAtPriority(queuedTarget.priority, function() {
                      attemptHydrationAtCurrentPriority(nearestMounted);
                    });
                    return;
                  }
                } else if (tag === HostRoot) {
                  var root2 = nearestMounted.stateNode;
                  if (isRootDehydrated(root2)) {
                    queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                    return;
                  }
                }
              }
            }
            queuedTarget.blockedOn = null;
          }
          function queueExplicitHydrationTarget(target) {
            var updatePriority = getCurrentUpdatePriority$1();
            var queuedTarget = {
              blockedOn: null,
              target,
              priority: updatePriority
            };
            var i5 = 0;
            for (; i5 < queuedExplicitHydrationTargets.length; i5++) {
              if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i5].priority)) {
                break;
              }
            }
            queuedExplicitHydrationTargets.splice(i5, 0, queuedTarget);
            if (i5 === 0) {
              attemptExplicitHydrationTarget(queuedTarget);
            }
          }
          function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (queuedEvent.blockedOn !== null) {
              return false;
            }
            var targetContainers = queuedEvent.targetContainers;
            while (targetContainers.length > 0) {
              var targetContainer = targetContainers[0];
              var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
              if (nextBlockedOn === null) {
                {
                  var nativeEvent = queuedEvent.nativeEvent;
                  var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                  setReplayingEvent(nativeEventClone);
                  nativeEvent.target.dispatchEvent(nativeEventClone);
                  resetReplayingEvent();
                }
              } else {
                var _fiber3 = getInstanceFromNode(nextBlockedOn);
                if (_fiber3 !== null) {
                  attemptContinuousHydration(_fiber3);
                }
                queuedEvent.blockedOn = nextBlockedOn;
                return false;
              }
              targetContainers.shift();
            }
            return true;
          }
          function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map3) {
            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
              map3.delete(key);
            }
          }
          function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
              queuedFocus = null;
            }
            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
              queuedDrag = null;
            }
            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
              queuedMouse = null;
            }
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
          }
          function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
              if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true;
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
              }
            }
          }
          function retryIfBlockedOn(unblocked) {
            if (queuedDiscreteEvents.length > 0) {
              scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
              for (var i5 = 1; i5 < queuedDiscreteEvents.length; i5++) {
                var queuedEvent = queuedDiscreteEvents[i5];
                if (queuedEvent.blockedOn === unblocked) {
                  queuedEvent.blockedOn = null;
                }
              }
            }
            if (queuedFocus !== null) {
              scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            }
            if (queuedDrag !== null) {
              scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            }
            if (queuedMouse !== null) {
              scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            }
            var unblock = function(queuedEvent2) {
              return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
            };
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
              var queuedTarget = queuedExplicitHydrationTargets[_i];
              if (queuedTarget.blockedOn === unblocked) {
                queuedTarget.blockedOn = null;
              }
            }
            while (queuedExplicitHydrationTargets.length > 0) {
              var nextExplicitTarget = queuedExplicitHydrationTargets[0];
              if (nextExplicitTarget.blockedOn !== null) {
                break;
              } else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) {
                  queuedExplicitHydrationTargets.shift();
                }
              }
            }
          }
          var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
          var _enabled = true;
          function setEnabled(enabled) {
            _enabled = !!enabled;
          }
          function isEnabled() {
            return _enabled;
          }
          function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
            var eventPriority = getEventPriority(domEventName);
            var listenerWrapper;
            switch (eventPriority) {
              case DiscreteEventPriority:
                listenerWrapper = dispatchDiscreteEvent;
                break;
              case ContinuousEventPriority:
                listenerWrapper = dispatchContinuousEvent;
                break;
              case DefaultEventPriority:
              default:
                listenerWrapper = dispatchEvent;
                break;
            }
            return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
          }
          function dispatchDiscreteEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(DiscreteEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchContinuousEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(ContinuousEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (!_enabled) {
              return;
            }
            {
              dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            }
          }
          function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn === null) {
              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              clearIfContinuousEvent(domEventName, nativeEvent);
              return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
              nativeEvent.stopPropagation();
              return;
            }
            clearIfContinuousEvent(domEventName, nativeEvent);
            if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
              while (blockedOn !== null) {
                var fiber = getInstanceFromNode(blockedOn);
                if (fiber !== null) {
                  attemptSynchronousHydration(fiber);
                }
                var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
                if (nextBlockedOn === null) {
                  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
                }
                if (nextBlockedOn === blockedOn) {
                  break;
                }
                blockedOn = nextBlockedOn;
              }
              if (blockedOn !== null) {
                nativeEvent.stopPropagation();
              }
              return;
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
          }
          var return_targetInst = null;
          function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return_targetInst = null;
            var nativeEventTarget = getEventTarget(nativeEvent);
            var targetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted === null) {
                targetInst = null;
              } else {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    return instance;
                  }
                  targetInst = null;
                } else if (tag === HostRoot) {
                  var root2 = nearestMounted.stateNode;
                  if (isRootDehydrated(root2)) {
                    return getContainerFromFiber(nearestMounted);
                  }
                  targetInst = null;
                } else if (nearestMounted !== targetInst) {
                  targetInst = null;
                }
              }
            }
            return_targetInst = targetInst;
            return null;
          }
          function getEventPriority(domEventName) {
            switch (domEventName) {
              case "cancel":
              case "click":
              case "close":
              case "contextmenu":
              case "copy":
              case "cut":
              case "auxclick":
              case "dblclick":
              case "dragend":
              case "dragstart":
              case "drop":
              case "focusin":
              case "focusout":
              case "input":
              case "invalid":
              case "keydown":
              case "keypress":
              case "keyup":
              case "mousedown":
              case "mouseup":
              case "paste":
              case "pause":
              case "play":
              case "pointercancel":
              case "pointerdown":
              case "pointerup":
              case "ratechange":
              case "reset":
              case "resize":
              case "seeked":
              case "submit":
              case "touchcancel":
              case "touchend":
              case "touchstart":
              case "volumechange":
              case "change":
              case "selectionchange":
              case "textInput":
              case "compositionstart":
              case "compositionend":
              case "compositionupdate":
              case "beforeblur":
              case "afterblur":
              case "beforeinput":
              case "blur":
              case "fullscreenchange":
              case "focus":
              case "hashchange":
              case "popstate":
              case "select":
              case "selectstart":
                return DiscreteEventPriority;
              case "drag":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "mousemove":
              case "mouseout":
              case "mouseover":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "scroll":
              case "toggle":
              case "touchmove":
              case "wheel":
              case "mouseenter":
              case "mouseleave":
              case "pointerenter":
              case "pointerleave":
                return ContinuousEventPriority;
              case "message": {
                var schedulerPriority = getCurrentPriorityLevel();
                switch (schedulerPriority) {
                  case ImmediatePriority:
                    return DiscreteEventPriority;
                  case UserBlockingPriority:
                    return ContinuousEventPriority;
                  case NormalPriority:
                  case LowPriority:
                    return DefaultEventPriority;
                  case IdlePriority:
                    return IdleEventPriority;
                  default:
                    return DefaultEventPriority;
                }
              }
              default:
                return DefaultEventPriority;
            }
          }
          function addEventBubbleListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, false);
            return listener;
          }
          function addEventCaptureListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, true);
            return listener;
          }
          function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive2) {
            target.addEventListener(eventType, listener, {
              capture: true,
              passive: passive2
            });
            return listener;
          }
          function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive2) {
            target.addEventListener(eventType, listener, {
              passive: passive2
            });
            return listener;
          }
          var root = null;
          var startText = null;
          var fallbackText = null;
          function initialize(nativeEventTarget) {
            root = nativeEventTarget;
            startText = getText();
            return true;
          }
          function reset() {
            root = null;
            startText = null;
            fallbackText = null;
          }
          function getData() {
            if (fallbackText) {
              return fallbackText;
            }
            var start3;
            var startValue = startText;
            var startLength = startValue.length;
            var end2;
            var endValue = getText();
            var endLength = endValue.length;
            for (start3 = 0; start3 < startLength; start3++) {
              if (startValue[start3] !== endValue[start3]) {
                break;
              }
            }
            var minEnd = startLength - start3;
            for (end2 = 1; end2 <= minEnd; end2++) {
              if (startValue[startLength - end2] !== endValue[endLength - end2]) {
                break;
              }
            }
            var sliceTail = end2 > 1 ? 1 - end2 : void 0;
            fallbackText = endValue.slice(start3, sliceTail);
            return fallbackText;
          }
          function getText() {
            if ("value" in root) {
              return root.value;
            }
            return root.textContent;
          }
          function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ("charCode" in nativeEvent) {
              charCode = nativeEvent.charCode;
              if (charCode === 0 && keyCode === 13) {
                charCode = 13;
              }
            } else {
              charCode = keyCode;
            }
            if (charCode === 10) {
              charCode = 13;
            }
            if (charCode >= 32 || charCode === 13) {
              return charCode;
            }
            return 0;
          }
          function functionThatReturnsTrue() {
            return true;
          }
          function functionThatReturnsFalse() {
            return false;
          }
          function createSyntheticEvent(Interface) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
              this._reactName = reactName;
              this._targetInst = targetInst;
              this.type = reactEventType;
              this.nativeEvent = nativeEvent;
              this.target = nativeEventTarget;
              this.currentTarget = null;
              for (var _propName in Interface) {
                if (!Interface.hasOwnProperty(_propName)) {
                  continue;
                }
                var normalize = Interface[_propName];
                if (normalize) {
                  this[_propName] = normalize(nativeEvent);
                } else {
                  this[_propName] = nativeEvent[_propName];
                }
              }
              var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
              if (defaultPrevented) {
                this.isDefaultPrevented = functionThatReturnsTrue;
              } else {
                this.isDefaultPrevented = functionThatReturnsFalse;
              }
              this.isPropagationStopped = functionThatReturnsFalse;
              return this;
            }
            assign(SyntheticBaseEvent.prototype, {
              preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.preventDefault) {
                  event.preventDefault();
                } else if (typeof event.returnValue !== "unknown") {
                  event.returnValue = false;
                }
                this.isDefaultPrevented = functionThatReturnsTrue;
              },
              stopPropagation: function() {
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.stopPropagation) {
                  event.stopPropagation();
                } else if (typeof event.cancelBubble !== "unknown") {
                  event.cancelBubble = true;
                }
                this.isPropagationStopped = functionThatReturnsTrue;
              },
              /**
               * We release all dispatched `SyntheticEvent`s after each event loop, adding
               * them back into the pool. This allows a way to hold onto a reference that
               * won't be added back into the pool.
               */
              persist: function() {
              },
              /**
               * Checks if this event should be released back into the pool.
               *
               * @return {boolean} True if this should not be released, false otherwise.
               */
              isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
          }
          var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          };
          var SyntheticEvent = createSyntheticEvent(EventInterface);
          var UIEventInterface = assign({}, EventInterface, {
            view: 0,
            detail: 0
          });
          var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
          var lastMovementX;
          var lastMovementY;
          var lastMouseEvent;
          function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
              if (lastMouseEvent && event.type === "mousemove") {
                lastMovementX = event.screenX - lastMouseEvent.screenX;
                lastMovementY = event.screenY - lastMouseEvent.screenY;
              } else {
                lastMovementX = 0;
                lastMovementY = 0;
              }
              lastMouseEvent = event;
            }
          }
          var MouseEventInterface = assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
              if (event.relatedTarget === void 0) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
              return event.relatedTarget;
            },
            movementX: function(event) {
              if ("movementX" in event) {
                return event.movementX;
              }
              updateMouseMovementPolyfillState(event);
              return lastMovementX;
            },
            movementY: function(event) {
              if ("movementY" in event) {
                return event.movementY;
              }
              return lastMovementY;
            }
          });
          var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
          var DragEventInterface = assign({}, MouseEventInterface, {
            dataTransfer: 0
          });
          var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
          var FocusEventInterface = assign({}, UIEventInterface, {
            relatedTarget: 0
          });
          var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
          var AnimationEventInterface = assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
          var ClipboardEventInterface = assign({}, EventInterface, {
            clipboardData: function(event) {
              return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
          });
          var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
          var CompositionEventInterface = assign({}, EventInterface, {
            data: 0
          });
          var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
          var SyntheticInputEvent = SyntheticCompositionEvent;
          var normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          };
          var translateToKey = {
            "8": "Backspace",
            "9": "Tab",
            "12": "Clear",
            "13": "Enter",
            "16": "Shift",
            "17": "Control",
            "18": "Alt",
            "19": "Pause",
            "20": "CapsLock",
            "27": "Escape",
            "32": " ",
            "33": "PageUp",
            "34": "PageDown",
            "35": "End",
            "36": "Home",
            "37": "ArrowLeft",
            "38": "ArrowUp",
            "39": "ArrowRight",
            "40": "ArrowDown",
            "45": "Insert",
            "46": "Delete",
            "112": "F1",
            "113": "F2",
            "114": "F3",
            "115": "F4",
            "116": "F5",
            "117": "F6",
            "118": "F7",
            "119": "F8",
            "120": "F9",
            "121": "F10",
            "122": "F11",
            "123": "F12",
            "144": "NumLock",
            "145": "ScrollLock",
            "224": "Meta"
          };
          function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if (key !== "Unidentified") {
                return key;
              }
            }
            if (nativeEvent.type === "keypress") {
              var charCode = getEventCharCode(nativeEvent);
              return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
              return translateToKey[nativeEvent.keyCode] || "Unidentified";
            }
            return "";
          }
          var modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
          function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
              return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
          }
          function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
          }
          var KeyboardEventInterface = assign({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            // Legacy Interface
            charCode: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              return 0;
            },
            keyCode: function(event) {
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            },
            which: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            }
          });
          var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
          var PointerEventInterface = assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          });
          var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
          var TouchEventInterface = assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
          });
          var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
          var TransitionEventInterface = assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
          var WheelEventInterface = assign({}, MouseEventInterface, {
            deltaX: function(event) {
              return "deltaX" in event ? event.deltaX : (
                // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
                "wheelDeltaX" in event ? -event.wheelDeltaX : 0
              );
            },
            deltaY: function(event) {
              return "deltaY" in event ? event.deltaY : (
                // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
                "wheelDeltaY" in event ? -event.wheelDeltaY : (
                  // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                  "wheelDelta" in event ? -event.wheelDelta : 0
                )
              );
            },
            deltaZ: 0,
            // Browsers without "deltaMode" is reporting in raw wheel delta where one
            // notch on the scroll is always +/- 120, roughly equivalent to pixels.
            // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
            // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
            deltaMode: 0
          });
          var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
          var END_KEYCODES = [9, 13, 27, 32];
          var START_KEYCODE = 229;
          var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
          var documentMode = null;
          if (canUseDOM && "documentMode" in document) {
            documentMode = document.documentMode;
          }
          var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
          var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
          var SPACEBAR_CODE = 32;
          var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
          function registerEvents() {
            registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
            registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          }
          var hasSpaceKeypress = false;
          function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
            !(nativeEvent.ctrlKey && nativeEvent.altKey);
          }
          function getCompositionEventType(domEventName) {
            switch (domEventName) {
              case "compositionstart":
                return "onCompositionStart";
              case "compositionend":
                return "onCompositionEnd";
              case "compositionupdate":
                return "onCompositionUpdate";
            }
          }
          function isFallbackCompositionStart(domEventName, nativeEvent) {
            return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
          }
          function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch (domEventName) {
              case "keyup":
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
              case "keydown":
                return nativeEvent.keyCode !== START_KEYCODE;
              case "keypress":
              case "mousedown":
              case "focusout":
                return true;
              default:
                return false;
            }
          }
          function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === "object" && "data" in detail) {
              return detail.data;
            }
            return null;
          }
          function isUsingKoreanIME(nativeEvent) {
            return nativeEvent.locale === "ko";
          }
          var isComposing = false;
          function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
              eventType = getCompositionEventType(domEventName);
            } else if (!isComposing) {
              if (isFallbackCompositionStart(domEventName, nativeEvent)) {
                eventType = "onCompositionStart";
              }
            } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
              eventType = "onCompositionEnd";
            }
            if (!eventType) {
              return null;
            }
            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
              if (!isComposing && eventType === "onCompositionStart") {
                isComposing = initialize(nativeEventTarget);
              } else if (eventType === "onCompositionEnd") {
                if (isComposing) {
                  fallbackData = getData();
                }
              }
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
            if (listeners.length > 0) {
              var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              if (fallbackData) {
                event.data = fallbackData;
              } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                  event.data = customData;
                }
              }
            }
          }
          function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch (domEventName) {
              case "compositionend":
                return getDataFromCustomEvent(nativeEvent);
              case "keypress":
                var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) {
                  return null;
                }
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
              case "textInput":
                var chars = nativeEvent.data;
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                  return null;
                }
                return chars;
              default:
                return null;
            }
          }
          function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing) {
              if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                var chars = getData();
                reset();
                isComposing = false;
                return chars;
              }
              return null;
            }
            switch (domEventName) {
              case "paste":
                return null;
              case "keypress":
                if (!isKeypressCommand(nativeEvent)) {
                  if (nativeEvent.char && nativeEvent.char.length > 1) {
                    return nativeEvent.char;
                  } else if (nativeEvent.which) {
                    return String.fromCharCode(nativeEvent.which);
                  }
                }
                return null;
              case "compositionend":
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
              default:
                return null;
            }
          }
          function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var chars;
            if (canUseTextInputEvent) {
              chars = getNativeBeforeInputChars(domEventName, nativeEvent);
            } else {
              chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
            }
            if (!chars) {
              return null;
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
            if (listeners.length > 0) {
              var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.data = chars;
            }
          }
          function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
          var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          };
          function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            if (nodeName === "input") {
              return !!supportedInputTypes[elem.type];
            }
            if (nodeName === "textarea") {
              return true;
            }
            return false;
          }
          function isEventSupported(eventNameSuffix) {
            if (!canUseDOM) {
              return false;
            }
            var eventName = "on" + eventNameSuffix;
            var isSupported = eventName in document;
            if (!isSupported) {
              var element = document.createElement("div");
              element.setAttribute(eventName, "return;");
              isSupported = typeof element[eventName] === "function";
            }
            return isSupported;
          }
          function registerEvents$1() {
            registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
          }
          function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
            enqueueStateRestore(target);
            var listeners = accumulateTwoPhaseListeners(inst, "onChange");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          var activeElement = null;
          var activeElementInst = null;
          function shouldUseChangeEvent(elem) {
            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName === "select" || nodeName === "input" && elem.type === "file";
          }
          function manualDispatchChangeEvent(nativeEvent) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
            batchedUpdates(runEventInBatch, dispatchQueue);
          }
          function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
          }
          function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) {
              return targetInst;
            }
          }
          function getTargetInstForChangeEvent(domEventName, targetInst) {
            if (domEventName === "change") {
              return targetInst;
            }
          }
          var isInputEventSupported = false;
          if (canUseDOM) {
            isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
          }
          function startWatchingForValueChange(target, targetInst) {
            activeElement = target;
            activeElementInst = targetInst;
            activeElement.attachEvent("onpropertychange", handlePropertyChange);
          }
          function stopWatchingForValueChange() {
            if (!activeElement) {
              return;
            }
            activeElement.detachEvent("onpropertychange", handlePropertyChange);
            activeElement = null;
            activeElementInst = null;
          }
          function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== "value") {
              return;
            }
            if (getInstIfValueChanged(activeElementInst)) {
              manualDispatchChangeEvent(nativeEvent);
            }
          }
          function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
            if (domEventName === "focusin") {
              stopWatchingForValueChange();
              startWatchingForValueChange(target, targetInst);
            } else if (domEventName === "focusout") {
              stopWatchingForValueChange();
            }
          }
          function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
            if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
              return getInstIfValueChanged(activeElementInst);
            }
          }
          function shouldUseClickEvent(elem) {
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
          }
          function getTargetInstForClickEvent(domEventName, targetInst) {
            if (domEventName === "click") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if (domEventName === "input" || domEventName === "change") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function handleControlledInputBlur(node) {
            var state = node._wrapperState;
            if (!state || !state.controlled || node.type !== "number") {
              return;
            }
            {
              setDefaultValue(node, "number", node.value);
            }
          }
          function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            var getTargetInstFunc, handleEventFunc;
            if (shouldUseChangeEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForChangeEvent;
            } else if (isTextInputElement(targetNode)) {
              if (isInputEventSupported) {
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              } else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                handleEventFunc = handleEventsForInputEventPolyfill;
              }
            } else if (shouldUseClickEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForClickEvent;
            }
            if (getTargetInstFunc) {
              var inst = getTargetInstFunc(domEventName, targetInst);
              if (inst) {
                createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                return;
              }
            }
            if (handleEventFunc) {
              handleEventFunc(domEventName, targetNode, targetInst);
            }
            if (domEventName === "focusout") {
              handleControlledInputBlur(targetNode);
            }
          }
          function registerEvents$2() {
            registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
            registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
            registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
            registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
          }
          function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
            var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
            if (isOverEvent && !isReplayingEvent(nativeEvent)) {
              var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
              if (related) {
                if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                  return;
                }
              }
            }
            if (!isOutEvent && !isOverEvent) {
              return;
            }
            var win;
            if (nativeEventTarget.window === nativeEventTarget) {
              win = nativeEventTarget;
            } else {
              var doc = nativeEventTarget.ownerDocument;
              if (doc) {
                win = doc.defaultView || doc.parentWindow;
              } else {
                win = window;
              }
            }
            var from2;
            var to2;
            if (isOutEvent) {
              var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
              from2 = targetInst;
              to2 = _related ? getClosestInstanceFromNode(_related) : null;
              if (to2 !== null) {
                var nearestMounted = getNearestMountedFiber(to2);
                if (to2 !== nearestMounted || to2.tag !== HostComponent && to2.tag !== HostText) {
                  to2 = null;
                }
              }
            } else {
              from2 = null;
              to2 = targetInst;
            }
            if (from2 === to2) {
              return;
            }
            var SyntheticEventCtor = SyntheticMouseEvent;
            var leaveEventType = "onMouseLeave";
            var enterEventType = "onMouseEnter";
            var eventTypePrefix = "mouse";
            if (domEventName === "pointerout" || domEventName === "pointerover") {
              SyntheticEventCtor = SyntheticPointerEvent;
              leaveEventType = "onPointerLeave";
              enterEventType = "onPointerEnter";
              eventTypePrefix = "pointer";
            }
            var fromNode = from2 == null ? win : getNodeFromInstance(from2);
            var toNode = to2 == null ? win : getNodeFromInstance(to2);
            var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from2, nativeEvent, nativeEventTarget);
            leave.target = fromNode;
            leave.relatedTarget = toNode;
            var enter = null;
            var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (nativeTargetInst === targetInst) {
              var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to2, nativeEvent, nativeEventTarget);
              enterEvent.target = toNode;
              enterEvent.relatedTarget = fromNode;
              enter = enterEvent;
            }
            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from2, to2);
          }
          function is(x3, y2) {
            return x3 === y2 && (x3 !== 0 || 1 / x3 === 1 / y2) || x3 !== x3 && y2 !== y2;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          function shallowEqual(objA, objB) {
            if (objectIs(objA, objB)) {
              return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
              return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
              return false;
            }
            for (var i5 = 0; i5 < keysA.length; i5++) {
              var currentKey = keysA[i5];
              if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
                return false;
              }
            }
            return true;
          }
          function getLeafNode(node) {
            while (node && node.firstChild) {
              node = node.firstChild;
            }
            return node;
          }
          function getSiblingNode(node) {
            while (node) {
              if (node.nextSibling) {
                return node.nextSibling;
              }
              node = node.parentNode;
            }
          }
          function getNodeForCharacterOffset(root2, offset2) {
            var node = getLeafNode(root2);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node) {
              if (node.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset2 && nodeEnd >= offset2) {
                  return {
                    node,
                    offset: offset2 - nodeStart
                  };
                }
                nodeStart = nodeEnd;
              }
              node = getLeafNode(getSiblingNode(node));
            }
          }
          function getOffsets(outerNode) {
            var ownerDocument = outerNode.ownerDocument;
            var win = ownerDocument && ownerDocument.defaultView || window;
            var selection = win.getSelection && win.getSelection();
            if (!selection || selection.rangeCount === 0) {
              return null;
            }
            var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
            try {
              anchorNode.nodeType;
              focusNode.nodeType;
            } catch (e3) {
              return null;
            }
            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
          }
          function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length = 0;
            var start3 = -1;
            var end2 = -1;
            var indexWithinAnchor = 0;
            var indexWithinFocus = 0;
            var node = outerNode;
            var parentNode = null;
            outer: while (true) {
              var next = null;
              while (true) {
                if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                  start3 = length + anchorOffset;
                }
                if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                  end2 = length + focusOffset;
                }
                if (node.nodeType === TEXT_NODE) {
                  length += node.nodeValue.length;
                }
                if ((next = node.firstChild) === null) {
                  break;
                }
                parentNode = node;
                node = next;
              }
              while (true) {
                if (node === outerNode) {
                  break outer;
                }
                if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                  start3 = length;
                }
                if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                  end2 = length;
                }
                if ((next = node.nextSibling) !== null) {
                  break;
                }
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next;
            }
            if (start3 === -1 || end2 === -1) {
              return null;
            }
            return {
              start: start3,
              end: end2
            };
          }
          function setOffsets(node, offsets) {
            var doc = node.ownerDocument || document;
            var win = doc && doc.defaultView || window;
            if (!win.getSelection) {
              return;
            }
            var selection = win.getSelection();
            var length = node.textContent.length;
            var start3 = Math.min(offsets.start, length);
            var end2 = offsets.end === void 0 ? start3 : Math.min(offsets.end, length);
            if (!selection.extend && start3 > end2) {
              var temp = end2;
              end2 = start3;
              start3 = temp;
            }
            var startMarker = getNodeForCharacterOffset(node, start3);
            var endMarker = getNodeForCharacterOffset(node, end2);
            if (startMarker && endMarker) {
              if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
                return;
              }
              var range = doc.createRange();
              range.setStart(startMarker.node, startMarker.offset);
              selection.removeAllRanges();
              if (start3 > end2) {
                selection.addRange(range);
                selection.extend(endMarker.node, endMarker.offset);
              } else {
                range.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range);
              }
            }
          }
          function isTextNode(node) {
            return node && node.nodeType === TEXT_NODE;
          }
          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ("contains" in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }
          function isInDocument(node) {
            return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
          }
          function isSameOriginFrame(iframe) {
            try {
              return typeof iframe.contentWindow.location.href === "string";
            } catch (err) {
              return false;
            }
          }
          function getActiveElementDeep() {
            var win = window;
            var element = getActiveElement();
            while (element instanceof win.HTMLIFrameElement) {
              if (isSameOriginFrame(element)) {
                win = element.contentWindow;
              } else {
                return element;
              }
              element = getActiveElement(win.document);
            }
            return element;
          }
          function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
          }
          function getSelectionInformation() {
            var focusedElem = getActiveElementDeep();
            return {
              focusedElem,
              selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
            };
          }
          function restoreSelection(priorSelectionInformation) {
            var curFocusedElem = getActiveElementDeep();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                setSelection(priorFocusedElem, priorSelectionRange);
              }
              var ancestors = [];
              var ancestor = priorFocusedElem;
              while (ancestor = ancestor.parentNode) {
                if (ancestor.nodeType === ELEMENT_NODE) {
                  ancestors.push({
                    element: ancestor,
                    left: ancestor.scrollLeft,
                    top: ancestor.scrollTop
                  });
                }
              }
              if (typeof priorFocusedElem.focus === "function") {
                priorFocusedElem.focus();
              }
              for (var i5 = 0; i5 < ancestors.length; i5++) {
                var info = ancestors[i5];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
          }
          function getSelection(input) {
            var selection;
            if ("selectionStart" in input) {
              selection = {
                start: input.selectionStart,
                end: input.selectionEnd
              };
            } else {
              selection = getOffsets(input);
            }
            return selection || {
              start: 0,
              end: 0
            };
          }
          function setSelection(input, offsets) {
            var start3 = offsets.start;
            var end2 = offsets.end;
            if (end2 === void 0) {
              end2 = start3;
            }
            if ("selectionStart" in input) {
              input.selectionStart = start3;
              input.selectionEnd = Math.min(end2, input.value.length);
            } else {
              setOffsets(input, offsets);
            }
          }
          var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
          function registerEvents$3() {
            registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
          }
          var activeElement$1 = null;
          var activeElementInst$1 = null;
          var lastSelection = null;
          var mouseDown = false;
          function getSelection$1(node) {
            if ("selectionStart" in node && hasSelectionCapabilities(node)) {
              return {
                start: node.selectionStart,
                end: node.selectionEnd
              };
            } else {
              var win = node.ownerDocument && node.ownerDocument.defaultView || window;
              var selection = win.getSelection();
              return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
              };
            }
          }
          function getEventTargetDocument(eventTarget) {
            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
          }
          function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc = getEventTargetDocument(nativeEventTarget);
            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
              return;
            }
            var currentSelection = getSelection$1(activeElement$1);
            if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
              lastSelection = currentSelection;
              var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
              if (listeners.length > 0) {
                var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event,
                  listeners
                });
                event.target = activeElement$1;
              }
            }
          }
          function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                  activeElement$1 = targetNode;
                  activeElementInst$1 = targetInst;
                  lastSelection = null;
                }
                break;
              case "focusout":
                activeElement$1 = null;
                activeElementInst$1 = null;
                lastSelection = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) {
                  break;
                }
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
          }
          function makePrefixMap(styleProp, eventName) {
            var prefixes2 = {};
            prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes2["Webkit" + styleProp] = "webkit" + eventName;
            prefixes2["Moz" + styleProp] = "moz" + eventName;
            return prefixes2;
          }
          var vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
          };
          var prefixedEventNames = {};
          var style = {};
          if (canUseDOM) {
            style = document.createElement("div").style;
            if (!("AnimationEvent" in window)) {
              delete vendorPrefixes.animationend.animation;
              delete vendorPrefixes.animationiteration.animation;
              delete vendorPrefixes.animationstart.animation;
            }
            if (!("TransitionEvent" in window)) {
              delete vendorPrefixes.transitionend.transition;
            }
          }
          function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) {
              return prefixedEventNames[eventName];
            } else if (!vendorPrefixes[eventName]) {
              return eventName;
            }
            var prefixMap = vendorPrefixes[eventName];
            for (var styleProp in prefixMap) {
              if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                return prefixedEventNames[eventName] = prefixMap[styleProp];
              }
            }
            return eventName;
          }
          var ANIMATION_END = getVendorPrefixedEventName("animationend");
          var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
          var ANIMATION_START = getVendorPrefixedEventName("animationstart");
          var TRANSITION_END = getVendorPrefixedEventName("transitionend");
          var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
          var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
          function registerSimpleEvent(domEventName, reactName) {
            topLevelEventsToReactNames.set(domEventName, reactName);
            registerTwoPhaseEvent(reactName, [domEventName]);
          }
          function registerSimpleEvents() {
            for (var i5 = 0; i5 < simpleEventPluginEvents.length; i5++) {
              var eventName = simpleEventPluginEvents[i5];
              var domEventName = eventName.toLowerCase();
              var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
              registerSimpleEvent(domEventName, "on" + capitalizedEvent);
            }
            registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
            registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
            registerSimpleEvent(ANIMATION_START, "onAnimationStart");
            registerSimpleEvent("dblclick", "onDoubleClick");
            registerSimpleEvent("focusin", "onFocus");
            registerSimpleEvent("focusout", "onBlur");
            registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
          }
          function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (reactName === void 0) {
              return;
            }
            var SyntheticEventCtor = SyntheticEvent;
            var reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (getEventCharCode(nativeEvent) === 0) {
                  return;
                }
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (nativeEvent.button === 2) {
                  return;
                }
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
            }
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            {
              var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
              // nonDelegatedEvents list in DOMPluginEventSystem.
              // Then we can remove this special list.
              // This is a breaking change that can wait until React 18.
              domEventName === "scroll";
              var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
              if (_listeners.length > 0) {
                var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event: _event,
                  listeners: _listeners
                });
              }
            }
          }
          registerSimpleEvents();
          registerEvents$2();
          registerEvents$1();
          registerEvents$3();
          registerEvents();
          function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
            if (shouldProcessPolyfillPlugins) {
              extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            }
          }
          var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
          var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
          function executeDispatch(event, listener, currentTarget) {
            var type = event.type || "unknown-event";
            event.currentTarget = currentTarget;
            invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
            event.currentTarget = null;
          }
          function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
            var previousInstance;
            if (inCapturePhase) {
              for (var i5 = dispatchListeners.length - 1; i5 >= 0; i5--) {
                var _dispatchListeners$i = dispatchListeners[i5], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, listener, currentTarget);
                previousInstance = instance;
              }
            } else {
              for (var _i = 0; _i < dispatchListeners.length; _i++) {
                var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
                if (_instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, _listener, _currentTarget);
                previousInstance = _instance;
              }
            }
          }
          function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            for (var i5 = 0; i5 < dispatchQueue.length; i5++) {
              var _dispatchQueue$i = dispatchQueue[i5], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
              processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
            }
            rethrowCaughtError();
          }
          function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var nativeEventTarget = getEventTarget(nativeEvent);
            var dispatchQueue = [];
            extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          }
          function listenToNonDelegatedEvent(domEventName, targetElement) {
            {
              if (!nonDelegatedEvents.has(domEventName)) {
                error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var isCapturePhaseListener = false;
            var listenerSet = getEventListenerSet(targetElement);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
              addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
              listenerSet.add(listenerSetKey);
            }
          }
          function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
            {
              if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
                error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var eventSystemFlags = 0;
            if (isCapturePhaseListener) {
              eventSystemFlags |= IS_CAPTURE_PHASE;
            }
            addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
          }
          var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
          function listenToAllSupportedEvents(rootContainerElement) {
            if (!rootContainerElement[listeningMarker]) {
              rootContainerElement[listeningMarker] = true;
              allNativeEvents.forEach(function(domEventName) {
                if (domEventName !== "selectionchange") {
                  if (!nonDelegatedEvents.has(domEventName)) {
                    listenToNativeEvent(domEventName, false, rootContainerElement);
                  }
                  listenToNativeEvent(domEventName, true, rootContainerElement);
                }
              });
              var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
              if (ownerDocument !== null) {
                if (!ownerDocument[listeningMarker]) {
                  ownerDocument[listeningMarker] = true;
                  listenToNativeEvent("selectionchange", false, ownerDocument);
                }
              }
            }
          }
          function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
            var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
            var isPassiveListener = void 0;
            if (passiveBrowserEventsSupported) {
              if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
                isPassiveListener = true;
              }
            }
            targetContainer = targetContainer;
            var unsubscribeListener;
            if (isCapturePhaseListener) {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
              }
            } else {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
              }
            }
          }
          function isMatchingRootContainer(grandContainer, targetContainer) {
            return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
          }
          function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var ancestorInst = targetInst;
            if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
              var targetContainerNode = targetContainer;
              if (targetInst !== null) {
                var node = targetInst;
                mainLoop: while (true) {
                  if (node === null) {
                    return;
                  }
                  var nodeTag = node.tag;
                  if (nodeTag === HostRoot || nodeTag === HostPortal) {
                    var container2 = node.stateNode.containerInfo;
                    if (isMatchingRootContainer(container2, targetContainerNode)) {
                      break;
                    }
                    if (nodeTag === HostPortal) {
                      var grandNode = node.return;
                      while (grandNode !== null) {
                        var grandTag = grandNode.tag;
                        if (grandTag === HostRoot || grandTag === HostPortal) {
                          var grandContainer = grandNode.stateNode.containerInfo;
                          if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                            return;
                          }
                        }
                        grandNode = grandNode.return;
                      }
                    }
                    while (container2 !== null) {
                      var parentNode = getClosestInstanceFromNode(container2);
                      if (parentNode === null) {
                        return;
                      }
                      var parentTag = parentNode.tag;
                      if (parentTag === HostComponent || parentTag === HostText) {
                        node = ancestorInst = parentNode;
                        continue mainLoop;
                      }
                      container2 = container2.parentNode;
                    }
                  }
                  node = node.return;
                }
              }
            }
            batchedUpdates(function() {
              return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
            });
          }
          function createDispatchListener(instance, listener, currentTarget) {
            return {
              instance,
              listener,
              currentTarget
            };
          }
          function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
            var captureName = reactName !== null ? reactName + "Capture" : null;
            var reactEventName = inCapturePhase ? captureName : reactName;
            var listeners = [];
            var instance = targetFiber;
            var lastHostComponent = null;
            while (instance !== null) {
              var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
              if (tag === HostComponent && stateNode !== null) {
                lastHostComponent = stateNode;
                if (reactEventName !== null) {
                  var listener = getListener(instance, reactEventName);
                  if (listener != null) {
                    listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                  }
                }
              }
              if (accumulateTargetOnly) {
                break;
              }
              instance = instance.return;
            }
            return listeners;
          }
          function accumulateTwoPhaseListeners(targetFiber, reactName) {
            var captureName = reactName + "Capture";
            var listeners = [];
            var instance = targetFiber;
            while (instance !== null) {
              var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                var captureListener = getListener(instance, captureName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
                var bubbleListener = getListener(instance, reactName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
              instance = instance.return;
            }
            return listeners;
          }
          function getParent(inst) {
            if (inst === null) {
              return null;
            }
            do {
              inst = inst.return;
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
              return inst;
            }
            return null;
          }
          function getLowestCommonAncestor(instA, instB) {
            var nodeA = instA;
            var nodeB = instB;
            var depthA = 0;
            for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
              depthA++;
            }
            var depthB = 0;
            for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
              depthB++;
            }
            while (depthA - depthB > 0) {
              nodeA = getParent(nodeA);
              depthA--;
            }
            while (depthB - depthA > 0) {
              nodeB = getParent(nodeB);
              depthB--;
            }
            var depth = depthA;
            while (depth--) {
              if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
                return nodeA;
              }
              nodeA = getParent(nodeA);
              nodeB = getParent(nodeB);
            }
            return null;
          }
          function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
            var registrationName = event._reactName;
            var listeners = [];
            var instance = target;
            while (instance !== null) {
              if (instance === common) {
                break;
              }
              var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
              if (alternate !== null && alternate === common) {
                break;
              }
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                if (inCapturePhase) {
                  var captureListener = getListener(instance, registrationName);
                  if (captureListener != null) {
                    listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                  }
                } else if (!inCapturePhase) {
                  var bubbleListener = getListener(instance, registrationName);
                  if (bubbleListener != null) {
                    listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                  }
                }
              }
              instance = instance.return;
            }
            if (listeners.length !== 0) {
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from2, to2) {
            var common = from2 && to2 ? getLowestCommonAncestor(from2, to2) : null;
            if (from2 !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from2, common, false);
            }
            if (to2 !== null && enterEvent !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to2, common, true);
            }
          }
          function getListenerSetKey(domEventName, capture) {
            return domEventName + "__" + (capture ? "capture" : "bubble");
          }
          var didWarnInvalidHydration = false;
          var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
          var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
          var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
          var AUTOFOCUS = "autoFocus";
          var CHILDREN = "children";
          var STYLE = "style";
          var HTML$1 = "__html";
          var warnedUnknownTags;
          var validatePropertiesInDevelopment;
          var warnForPropDifference;
          var warnForExtraAttributes;
          var warnForInvalidEventListener;
          var canDiffStyleForHydrationWarning;
          var normalizeHTML;
          {
            warnedUnknownTags = {
              // There are working polyfills for <dialog>. Let people use it.
              dialog: true,
              // Electron ships a custom <webview> tag to display external web content in
              // an isolated frame and process.
              // This tag is not present in non Electron environments such as JSDom which
              // is often used for testing purposes.
              // @see https://electronjs.org/docs/api/webview-tag
              webview: true
            };
            validatePropertiesInDevelopment = function(type, props) {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, {
                registrationNameDependencies,
                possibleRegistrationNames
              });
            };
            canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
            warnForPropDifference = function(propName, serverValue, clientValue) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
              var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
              if (normalizedServerValue === normalizedClientValue) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
            };
            warnForExtraAttributes = function(attributeNames) {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              var names2 = [];
              attributeNames.forEach(function(name) {
                names2.push(name);
              });
              error("Extra attributes from the server: %s", names2);
            };
            warnForInvalidEventListener = function(registrationName, listener) {
              if (listener === false) {
                error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
              } else {
                error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
              }
            };
            normalizeHTML = function(parent, html) {
              var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
              testElement.innerHTML = html;
              return testElement.innerHTML;
            };
          }
          var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
          var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
          function normalizeMarkupForTextOrAttribute(markup) {
            {
              checkHtmlStringCoercion(markup);
            }
            var markupString = typeof markup === "string" ? markup : "" + markup;
            return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
          }
          function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
            var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
            var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
            if (normalizedServerText === normalizedClientText) {
              return;
            }
            if (shouldWarnDev) {
              {
                if (!didWarnInvalidHydration) {
                  didWarnInvalidHydration = true;
                  error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
                }
              }
            }
            if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
              throw new Error("Text content does not match server-rendered HTML.");
            }
          }
          function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          }
          function noop3() {
          }
          function trapClickOnNonInteractiveElement(node) {
            node.onclick = noop3;
          }
          function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
            for (var propKey in nextProps) {
              if (!nextProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = nextProps[propKey];
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                setValueForStyles(domElement, nextProp);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  setInnerHTML(domElement, nextHtml);
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  var canSetTextContent = tag !== "textarea" || nextProp !== "";
                  if (canSetTextContent) {
                    setTextContent(domElement, nextProp);
                  }
                } else if (typeof nextProp === "number") {
                  setTextContent(domElement, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
              else if (propKey === AUTOFOCUS) ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (nextProp != null) {
                setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
              }
            }
          }
          function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
            for (var i5 = 0; i5 < updatePayload.length; i5 += 2) {
              var propKey = updatePayload[i5];
              var propValue = updatePayload[i5 + 1];
              if (propKey === STYLE) {
                setValueForStyles(domElement, propValue);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                setInnerHTML(domElement, propValue);
              } else if (propKey === CHILDREN) {
                setTextContent(domElement, propValue);
              } else {
                setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
              }
            }
          }
          function createElement15(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag;
            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
            var domElement;
            var namespaceURI = parentNamespace;
            if (namespaceURI === HTML_NAMESPACE) {
              namespaceURI = getIntrinsicNamespace(type);
            }
            if (namespaceURI === HTML_NAMESPACE) {
              {
                isCustomComponentTag = isCustomComponent(type, props);
                if (!isCustomComponentTag && type !== type.toLowerCase()) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
              if (type === "script") {
                var div = ownerDocument.createElement("div");
                div.innerHTML = "<script><\/script>";
                var firstChild = div.firstChild;
                domElement = div.removeChild(firstChild);
              } else if (typeof props.is === "string") {
                domElement = ownerDocument.createElement(type, {
                  is: props.is
                });
              } else {
                domElement = ownerDocument.createElement(type);
                if (type === "select") {
                  var node = domElement;
                  if (props.multiple) {
                    node.multiple = true;
                  } else if (props.size) {
                    node.size = props.size;
                  }
                }
              }
            } else {
              domElement = ownerDocument.createElementNS(namespaceURI, type);
            }
            {
              if (namespaceURI === HTML_NAMESPACE) {
                if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty.call(warnedUnknownTags, type)) {
                  warnedUnknownTags[type] = true;
                  error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
                }
              }
            }
            return domElement;
          }
          function createTextNode(text, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
          }
          function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
            var isCustomComponentTag = isCustomComponent(tag, rawProps);
            {
              validatePropertiesInDevelopment(tag, rawProps);
            }
            var props;
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                props = rawProps;
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "video":
              case "audio":
                for (var i5 = 0; i5 < mediaEventTypes.length; i5++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i5], domElement);
                }
                props = rawProps;
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                props = rawProps;
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                props = rawProps;
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                props = rawProps;
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              default:
                props = rawProps;
            }
            assertValidProps(tag, props);
            setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "option":
                postMountWrapper$1(domElement, rawProps);
                break;
              case "select":
                postMountWrapper$2(domElement, rawProps);
                break;
              default:
                if (typeof props.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
          }
          function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
            {
              validatePropertiesInDevelopment(tag, nextRawProps);
            }
            var updatePayload = null;
            var lastProps;
            var nextProps;
            switch (tag) {
              case "input":
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "select":
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "textarea":
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
              default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            assertValidProps(tag, nextProps);
            var propKey;
            var styleName;
            var styleUpdates = null;
            for (propKey in lastProps) {
              if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                continue;
              }
              if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle) {
                  if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
              else if (propKey === AUTOFOCUS) ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (!updatePayload) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, null);
              }
            }
            for (propKey in nextProps) {
              var nextProp = nextProps[propKey];
              var lastProp = lastProps != null ? lastProps[propKey] : void 0;
              if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                continue;
              }
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                if (lastProp) {
                  for (styleName in lastProp) {
                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = "";
                    }
                  }
                  for (styleName in nextProp) {
                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = nextProp[styleName];
                    }
                  }
                } else {
                  if (!styleUpdates) {
                    if (!updatePayload) {
                      updatePayload = [];
                    }
                    updatePayload.push(propKey, styleUpdates);
                  }
                  styleUpdates = nextProp;
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  if (lastHtml !== nextHtml) {
                    (updatePayload = updatePayload || []).push(propKey, nextHtml);
                  }
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string" || typeof nextProp === "number") {
                  (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
                if (!updatePayload && lastProp !== nextProp) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, nextProp);
              }
            }
            if (styleUpdates) {
              {
                validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
              }
              (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
            }
            return updatePayload;
          }
          function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
            if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
              updateChecked(domElement, nextRawProps);
            }
            var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
            var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
            switch (tag) {
              case "input":
                updateWrapper(domElement, nextRawProps);
                break;
              case "textarea":
                updateWrapper$1(domElement, nextRawProps);
                break;
              case "select":
                postUpdateWrapper(domElement, nextRawProps);
                break;
            }
          }
          function getPossibleStandardName(propName) {
            {
              var lowerCasedName = propName.toLowerCase();
              if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                return null;
              }
              return possibleStandardNames[lowerCasedName] || null;
            }
          }
          function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
            var isCustomComponentTag;
            var extraAttributeNames;
            {
              isCustomComponentTag = isCustomComponent(tag, rawProps);
              validatePropertiesInDevelopment(tag, rawProps);
            }
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "video":
              case "audio":
                for (var i5 = 0; i5 < mediaEventTypes.length; i5++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i5], domElement);
                }
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
            }
            assertValidProps(tag, rawProps);
            {
              extraAttributeNames = /* @__PURE__ */ new Set();
              var attributes = domElement.attributes;
              for (var _i = 0; _i < attributes.length; _i++) {
                var name = attributes[_i].name.toLowerCase();
                switch (name) {
                  case "value":
                    break;
                  case "checked":
                    break;
                  case "selected":
                    break;
                  default:
                    extraAttributeNames.add(attributes[_i].name);
                }
              }
            }
            var updatePayload = null;
            for (var propKey in rawProps) {
              if (!rawProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = rawProps[propKey];
              if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  if (domElement.textContent !== nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, nextProp];
                  }
                } else if (typeof nextProp === "number") {
                  if (domElement.textContent !== "" + nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, "" + nextProp];
                  }
                }
              } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
              typeof isCustomComponentTag === "boolean") {
                var serverValue = void 0;
                var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
                if (rawProps[SUPPRESS_HYDRATION_WARNING] === true) ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
                // TODO: Only ignore them on controlled tags.
                propKey === "value" || propKey === "checked" || propKey === "selected") ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var serverHTML = domElement.innerHTML;
                  var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                  if (nextHtml != null) {
                    var expectedHTML = normalizeHTML(domElement, nextHtml);
                    if (expectedHTML !== serverHTML) {
                      warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                  }
                } else if (propKey === STYLE) {
                  extraAttributeNames.delete(propKey);
                  if (canDiffStyleForHydrationWarning) {
                    var expectedStyle = createDangerousStringForStyles(nextProp);
                    serverValue = domElement.getAttribute("style");
                    if (expectedStyle !== serverValue) {
                      warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                  }
                } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  if (nextProp !== serverValue) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                  var isMismatchDueToBadCasing = false;
                  if (propertyInfo !== null) {
                    extraAttributeNames.delete(propertyInfo.attributeName);
                    serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                  } else {
                    var ownNamespace = parentNamespace;
                    if (ownNamespace === HTML_NAMESPACE) {
                      ownNamespace = getIntrinsicNamespace(tag);
                    }
                    if (ownNamespace === HTML_NAMESPACE) {
                      extraAttributeNames.delete(propKey.toLowerCase());
                    } else {
                      var standardName = getPossibleStandardName(propKey);
                      if (standardName !== null && standardName !== propKey) {
                        isMismatchDueToBadCasing = true;
                        extraAttributeNames.delete(standardName);
                      }
                      extraAttributeNames.delete(propKey);
                    }
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  }
                  var dontWarnCustomElement = enableCustomElementPropertySupport;
                  if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                }
              }
            }
            {
              if (shouldWarnDev) {
                if (
                  // $FlowFixMe - Should be inferred as not undefined.
                  extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
                ) {
                  warnForExtraAttributes(extraAttributeNames);
                }
              }
            }
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "select":
              case "option":
                break;
              default:
                if (typeof rawProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            return updatePayload;
          }
          function diffHydratedText(textNode, text, isConcurrentMode) {
            var isDifferent = textNode.nodeValue !== text;
            return isDifferent;
          }
          function warnForDeletedHydratableElement(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
            }
          }
          function warnForDeletedHydratableText(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedElement(parentNode, tag, props) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedText(parentNode, text) {
            {
              if (text === "") {
                return;
              }
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
            }
          }
          function restoreControlledState$3(domElement, tag, props) {
            switch (tag) {
              case "input":
                restoreControlledState(domElement, props);
                return;
              case "textarea":
                restoreControlledState$2(domElement, props);
                return;
              case "select":
                restoreControlledState$1(domElement, props);
                return;
            }
          }
          var validateDOMNesting = function() {
          };
          var updatedAncestorInfo = function() {
          };
          {
            var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
            var inScopeTags = [
              "applet",
              "caption",
              "html",
              "table",
              "td",
              "th",
              "marquee",
              "object",
              "template",
              // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
              // TODO: Distinguish by namespace here -- for <title>, including it here
              // errs on the side of fewer warnings
              "foreignObject",
              "desc",
              "title"
            ];
            var buttonScopeTags = inScopeTags.concat(["button"]);
            var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
            var emptyAncestorInfo = {
              current: null,
              formTag: null,
              aTagInScope: null,
              buttonTagInScope: null,
              nobrTagInScope: null,
              pTagInButtonScope: null,
              listItemTagAutoclosing: null,
              dlItemTagAutoclosing: null
            };
            updatedAncestorInfo = function(oldInfo, tag) {
              var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
              var info = {
                tag
              };
              if (inScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.aTagInScope = null;
                ancestorInfo.buttonTagInScope = null;
                ancestorInfo.nobrTagInScope = null;
              }
              if (buttonScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.pTagInButtonScope = null;
              }
              if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
                ancestorInfo.listItemTagAutoclosing = null;
                ancestorInfo.dlItemTagAutoclosing = null;
              }
              ancestorInfo.current = info;
              if (tag === "form") {
                ancestorInfo.formTag = info;
              }
              if (tag === "a") {
                ancestorInfo.aTagInScope = info;
              }
              if (tag === "button") {
                ancestorInfo.buttonTagInScope = info;
              }
              if (tag === "nobr") {
                ancestorInfo.nobrTagInScope = info;
              }
              if (tag === "p") {
                ancestorInfo.pTagInButtonScope = info;
              }
              if (tag === "li") {
                ancestorInfo.listItemTagAutoclosing = info;
              }
              if (tag === "dd" || tag === "dt") {
                ancestorInfo.dlItemTagAutoclosing = info;
              }
              return ancestorInfo;
            };
            var isTagValidWithParent = function(tag, parentTag) {
              switch (parentTag) {
                case "select":
                  return tag === "option" || tag === "optgroup" || tag === "#text";
                case "optgroup":
                  return tag === "option" || tag === "#text";
                case "option":
                  return tag === "#text";
                case "tr":
                  return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
                case "tbody":
                case "thead":
                case "tfoot":
                  return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
                case "colgroup":
                  return tag === "col" || tag === "template";
                case "table":
                  return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
                case "head":
                  return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
                case "html":
                  return tag === "head" || tag === "body" || tag === "frameset";
                case "frameset":
                  return tag === "frame";
                case "#document":
                  return tag === "html";
              }
              switch (tag) {
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
                case "rp":
                case "rt":
                  return impliedEndTags.indexOf(parentTag) === -1;
                case "body":
                case "caption":
                case "col":
                case "colgroup":
                case "frameset":
                case "frame":
                case "head":
                case "html":
                case "tbody":
                case "td":
                case "tfoot":
                case "th":
                case "thead":
                case "tr":
                  return parentTag == null;
              }
              return true;
            };
            var findInvalidAncestorForTag = function(tag, ancestorInfo) {
              switch (tag) {
                case "address":
                case "article":
                case "aside":
                case "blockquote":
                case "center":
                case "details":
                case "dialog":
                case "dir":
                case "div":
                case "dl":
                case "fieldset":
                case "figcaption":
                case "figure":
                case "footer":
                case "header":
                case "hgroup":
                case "main":
                case "menu":
                case "nav":
                case "ol":
                case "p":
                case "section":
                case "summary":
                case "ul":
                case "pre":
                case "listing":
                case "table":
                case "hr":
                case "xmp":
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return ancestorInfo.pTagInButtonScope;
                case "form":
                  return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                case "li":
                  return ancestorInfo.listItemTagAutoclosing;
                case "dd":
                case "dt":
                  return ancestorInfo.dlItemTagAutoclosing;
                case "button":
                  return ancestorInfo.buttonTagInScope;
                case "a":
                  return ancestorInfo.aTagInScope;
                case "nobr":
                  return ancestorInfo.nobrTagInScope;
              }
              return null;
            };
            var didWarn$1 = {};
            validateDOMNesting = function(childTag, childText, ancestorInfo) {
              ancestorInfo = ancestorInfo || emptyAncestorInfo;
              var parentInfo = ancestorInfo.current;
              var parentTag = parentInfo && parentInfo.tag;
              if (childText != null) {
                if (childTag != null) {
                  error("validateDOMNesting: when childText is passed, childTag should be null");
                }
                childTag = "#text";
              }
              var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
              var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
              var invalidParentOrAncestor = invalidParent || invalidAncestor;
              if (!invalidParentOrAncestor) {
                return;
              }
              var ancestorTag = invalidParentOrAncestor.tag;
              var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
              if (didWarn$1[warnKey]) {
                return;
              }
              didWarn$1[warnKey] = true;
              var tagDisplayName = childTag;
              var whitespaceInfo = "";
              if (childTag === "#text") {
                if (/\S/.test(childText)) {
                  tagDisplayName = "Text nodes";
                } else {
                  tagDisplayName = "Whitespace text nodes";
                  whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
                }
              } else {
                tagDisplayName = "<" + childTag + ">";
              }
              if (invalidParent) {
                var info = "";
                if (ancestorTag === "table" && childTag === "tr") {
                  info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
                }
                error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
              } else {
                error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
              }
            };
          }
          var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
          var SUSPENSE_START_DATA = "$";
          var SUSPENSE_END_DATA = "/$";
          var SUSPENSE_PENDING_START_DATA = "$?";
          var SUSPENSE_FALLBACK_START_DATA = "$!";
          var STYLE$1 = "style";
          var eventsEnabled = null;
          var selectionInformation = null;
          function getRootHostContext(rootContainerInstance) {
            var type;
            var namespace;
            var nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE: {
                type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
                var root2 = rootContainerInstance.documentElement;
                namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
                break;
              }
              default: {
                var container2 = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container2.namespaceURI || null;
                type = container2.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
              }
            }
            {
              var validatedTag = type.toLowerCase();
              var ancestorInfo = updatedAncestorInfo(null, validatedTag);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getChildHostContext(parentHostContext, type, rootContainerInstance) {
            {
              var parentHostContextDev = parentHostContext;
              var namespace = getChildNamespace(parentHostContextDev.namespace, type);
              var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getPublicInstance(instance) {
            return instance;
          }
          function prepareForCommit(containerInfo) {
            eventsEnabled = isEnabled();
            selectionInformation = getSelectionInformation();
            var activeInstance = null;
            setEnabled(false);
            return activeInstance;
          }
          function resetAfterCommit(containerInfo) {
            restoreSelection(selectionInformation);
            setEnabled(eventsEnabled);
            eventsEnabled = null;
            selectionInformation = null;
          }
          function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              validateDOMNesting(type, null, hostContextDev.ancestorInfo);
              if (typeof props.children === "string" || typeof props.children === "number") {
                var string = "" + props.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string, ownAncestorInfo);
              }
              parentNamespace = hostContextDev.namespace;
            }
            var domElement = createElement15(type, props, rootContainerInstance, parentNamespace);
            precacheFiberNode(internalInstanceHandle, domElement);
            updateFiberProps(domElement, props);
            return domElement;
          }
          function appendInitialChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
            setInitialProperties(domElement, type, props, rootContainerInstance);
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                return !!props.autoFocus;
              case "img":
                return true;
              default:
                return false;
            }
          }
          function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
            {
              var hostContextDev = hostContext;
              if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
                var string = "" + newProps.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string, ownAncestorInfo);
              }
            }
            return diffProperties(domElement, type, oldProps, newProps);
          }
          function shouldSetTextContent(type, props) {
            return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
          }
          function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
            {
              var hostContextDev = hostContext;
              validateDOMNesting(null, text, hostContextDev.ancestorInfo);
            }
            var textNode = createTextNode(text, rootContainerInstance);
            precacheFiberNode(internalInstanceHandle, textNode);
            return textNode;
          }
          function getCurrentEventPriority() {
            var currentEvent = window.event;
            if (currentEvent === void 0) {
              return DefaultEventPriority;
            }
            return getEventPriority(currentEvent.type);
          }
          var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
          var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
          var noTimeout = -1;
          var localPromise = typeof Promise === "function" ? Promise : void 0;
          var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback2) {
            return localPromise.resolve(null).then(callback2).catch(handleErrorInNextTick);
          } : scheduleTimeout;
          function handleErrorInNextTick(error2) {
            setTimeout(function() {
              throw error2;
            });
          }
          function commitMount(domElement, type, newProps, internalInstanceHandle) {
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                if (newProps.autoFocus) {
                  domElement.focus();
                }
                return;
              case "img": {
                if (newProps.src) {
                  domElement.src = newProps.src;
                }
                return;
              }
            }
          }
          function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
            updateProperties(domElement, updatePayload, type, oldProps, newProps);
            updateFiberProps(domElement, newProps);
          }
          function resetTextContent(domElement) {
            setTextContent(domElement, "");
          }
          function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
          }
          function appendChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function appendChildToContainer(container2, child) {
            var parentNode;
            if (container2.nodeType === COMMENT_NODE) {
              parentNode = container2.parentNode;
              parentNode.insertBefore(child, container2);
            } else {
              parentNode = container2;
              parentNode.appendChild(child);
            }
            var reactRootContainer = container2._reactRootContainer;
            if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
              trapClickOnNonInteractiveElement(parentNode);
            }
          }
          function insertBefore(parentInstance, child, beforeChild) {
            parentInstance.insertBefore(child, beforeChild);
          }
          function insertInContainerBefore(container2, child, beforeChild) {
            if (container2.nodeType === COMMENT_NODE) {
              container2.parentNode.insertBefore(child, beforeChild);
            } else {
              container2.insertBefore(child, beforeChild);
            }
          }
          function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
          }
          function removeChildFromContainer(container2, child) {
            if (container2.nodeType === COMMENT_NODE) {
              container2.parentNode.removeChild(child);
            } else {
              container2.removeChild(child);
            }
          }
          function clearSuspenseBoundary(parentInstance, suspenseInstance) {
            var node = suspenseInstance;
            var depth = 0;
            do {
              var nextNode = node.nextSibling;
              parentInstance.removeChild(node);
              if (nextNode && nextNode.nodeType === COMMENT_NODE) {
                var data = nextNode.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    parentInstance.removeChild(nextNode);
                    retryIfBlockedOn(suspenseInstance);
                    return;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                  depth++;
                }
              }
              node = nextNode;
            } while (node);
            retryIfBlockedOn(suspenseInstance);
          }
          function clearSuspenseBoundaryFromContainer(container2, suspenseInstance) {
            if (container2.nodeType === COMMENT_NODE) {
              clearSuspenseBoundary(container2.parentNode, suspenseInstance);
            } else if (container2.nodeType === ELEMENT_NODE) {
              clearSuspenseBoundary(container2, suspenseInstance);
            }
            retryIfBlockedOn(container2);
          }
          function hideInstance(instance) {
            instance = instance;
            var style2 = instance.style;
            if (typeof style2.setProperty === "function") {
              style2.setProperty("display", "none", "important");
            } else {
              style2.display = "none";
            }
          }
          function hideTextInstance(textInstance) {
            textInstance.nodeValue = "";
          }
          function unhideInstance(instance, props) {
            instance = instance;
            var styleProp = props[STYLE$1];
            var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
            instance.style.display = dangerousStyleValue("display", display);
          }
          function unhideTextInstance(textInstance, text) {
            textInstance.nodeValue = text;
          }
          function clearContainer(container2) {
            if (container2.nodeType === ELEMENT_NODE) {
              container2.textContent = "";
            } else if (container2.nodeType === DOCUMENT_NODE) {
              if (container2.documentElement) {
                container2.removeChild(container2.documentElement);
              }
            }
          }
          function canHydrateInstance(instance, type, props) {
            if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
              return null;
            }
            return instance;
          }
          function canHydrateTextInstance(instance, text) {
            if (text === "" || instance.nodeType !== TEXT_NODE) {
              return null;
            }
            return instance;
          }
          function canHydrateSuspenseInstance(instance) {
            if (instance.nodeType !== COMMENT_NODE) {
              return null;
            }
            return instance;
          }
          function isSuspenseInstancePending(instance) {
            return instance.data === SUSPENSE_PENDING_START_DATA;
          }
          function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA;
          }
          function getSuspenseInstanceFallbackErrorDetails(instance) {
            var dataset = instance.nextSibling && instance.nextSibling.dataset;
            var digest, message, stack;
            if (dataset) {
              digest = dataset.dgst;
              {
                message = dataset.msg;
                stack = dataset.stck;
              }
            }
            {
              return {
                message,
                digest,
                stack
              };
            }
          }
          function registerSuspenseInstanceRetry(instance, callback2) {
            instance._reactRetry = callback2;
          }
          function getNextHydratable(node) {
            for (; node != null; node = node.nextSibling) {
              var nodeType = node.nodeType;
              if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
                break;
              }
              if (nodeType === COMMENT_NODE) {
                var nodeData = node.data;
                if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                  break;
                }
                if (nodeData === SUSPENSE_END_DATA) {
                  return null;
                }
              }
            }
            return node;
          }
          function getNextHydratableSibling(instance) {
            return getNextHydratable(instance.nextSibling);
          }
          function getFirstHydratableChild(parentInstance) {
            return getNextHydratable(parentInstance.firstChild);
          }
          function getFirstHydratableChildWithinContainer(parentContainer) {
            return getNextHydratable(parentContainer.firstChild);
          }
          function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
            return getNextHydratable(parentInstance.nextSibling);
          }
          function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, instance);
            updateFiberProps(instance, props);
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              parentNamespace = hostContextDev.namespace;
            }
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
          }
          function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, textInstance);
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedText(textInstance, text);
          }
          function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, suspenseInstance);
          }
          function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            var node = suspenseInstance.nextSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    return getNextHydratableSibling(node);
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  depth++;
                }
              }
              node = node.nextSibling;
            }
            return null;
          }
          function getParentSuspenseInstance(targetInstance) {
            var node = targetInstance.previousSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  if (depth === 0) {
                    return node;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_END_DATA) {
                  depth++;
                }
              }
              node = node.previousSibling;
            }
            return null;
          }
          function commitHydratedContainer(container2) {
            retryIfBlockedOn(container2);
          }
          function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
          }
          function shouldDeleteUnhydratedTailInstances(parentType) {
            return parentType !== "head" && parentType !== "body";
          }
          function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
          }
          function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              var shouldWarnDev = true;
              checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
            }
          }
          function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
            {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentContainer, instance);
              } else if (instance.nodeType === COMMENT_NODE) ;
              else {
                warnForDeletedHydratableText(parentContainer, instance);
              }
            }
          }
          function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentNode, instance);
                } else if (instance.nodeType === COMMENT_NODE) ;
                else {
                  warnForDeletedHydratableText(parentNode, instance);
                }
              }
            }
          }
          function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentInstance, instance);
                } else if (instance.nodeType === COMMENT_NODE) ;
                else {
                  warnForDeletedHydratableText(parentInstance, instance);
                }
              }
            }
          }
          function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
            {
              warnForInsertedHydratedElement(parentContainer, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
            {
              warnForInsertedHydratedText(parentContainer, text);
            }
          }
          function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null) warnForInsertedHydratedElement(parentNode, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null) warnForInsertedHydratedText(parentNode, text);
            }
          }
          function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedElement(parentInstance, type);
              }
            }
          }
          function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedText(parentInstance, text);
              }
            }
          }
          function errorHydratingContainer(parentContainer) {
            {
              error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
            }
          }
          function preparePortalMount(portalInstance) {
            listenToAllSupportedEvents(portalInstance);
          }
          var randomKey = Math.random().toString(36).slice(2);
          var internalInstanceKey = "__reactFiber$" + randomKey;
          var internalPropsKey = "__reactProps$" + randomKey;
          var internalContainerInstanceKey = "__reactContainer$" + randomKey;
          var internalEventHandlersKey = "__reactEvents$" + randomKey;
          var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
          var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
          function detachDeletedInstance(node) {
            delete node[internalInstanceKey];
            delete node[internalPropsKey];
            delete node[internalEventHandlersKey];
            delete node[internalEventHandlerListenersKey];
            delete node[internalEventHandlesSetKey];
          }
          function precacheFiberNode(hostInst, node) {
            node[internalInstanceKey] = hostInst;
          }
          function markContainerAsRoot(hostRoot, node) {
            node[internalContainerInstanceKey] = hostRoot;
          }
          function unmarkContainerAsRoot(node) {
            node[internalContainerInstanceKey] = null;
          }
          function isContainerMarkedAsRoot(node) {
            return !!node[internalContainerInstanceKey];
          }
          function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
              return targetInst;
            }
            var parentNode = targetNode.parentNode;
            while (parentNode) {
              targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
              if (targetInst) {
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                  var suspenseInstance = getParentSuspenseInstance(targetNode);
                  while (suspenseInstance !== null) {
                    var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                    if (targetSuspenseInst) {
                      return targetSuspenseInst;
                    }
                    suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                  }
                }
                return targetInst;
              }
              targetNode = parentNode;
              parentNode = targetNode.parentNode;
            }
            return null;
          }
          function getInstanceFromNode(node) {
            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
            if (inst) {
              if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
                return inst;
              } else {
                return null;
              }
            }
            return null;
          }
          function getNodeFromInstance(inst) {
            if (inst.tag === HostComponent || inst.tag === HostText) {
              return inst.stateNode;
            }
            throw new Error("getNodeFromInstance: Invalid argument.");
          }
          function getFiberCurrentPropsFromNode(node) {
            return node[internalPropsKey] || null;
          }
          function updateFiberProps(node, props) {
            node[internalPropsKey] = props;
          }
          function getEventListenerSet(node) {
            var elementListenerSet = node[internalEventHandlersKey];
            if (elementListenerSet === void 0) {
              elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
            }
            return elementListenerSet;
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has2 = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has2(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var valueStack = [];
          var fiberStack;
          {
            fiberStack = [];
          }
          var index2 = -1;
          function createCursor(defaultValue) {
            return {
              current: defaultValue
            };
          }
          function pop(cursor, fiber) {
            if (index2 < 0) {
              {
                error("Unexpected pop.");
              }
              return;
            }
            {
              if (fiber !== fiberStack[index2]) {
                error("Unexpected Fiber popped.");
              }
            }
            cursor.current = valueStack[index2];
            valueStack[index2] = null;
            {
              fiberStack[index2] = null;
            }
            index2--;
          }
          function push(cursor, value, fiber) {
            index2++;
            valueStack[index2] = cursor.current;
            {
              fiberStack[index2] = fiber;
            }
            cursor.current = value;
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          var contextStackCursor = createCursor(emptyContextObject);
          var didPerformWorkStackCursor = createCursor(false);
          var previousContext = emptyContextObject;
          function getUnmaskedContext(workInProgress2, Component4, didPushOwnContextIfProvider) {
            {
              if (didPushOwnContextIfProvider && isContextProvider(Component4)) {
                return previousContext;
              }
              return contextStackCursor.current;
            }
          }
          function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
            {
              var instance = workInProgress2.stateNode;
              instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
          }
          function getMaskedContext(workInProgress2, unmaskedContext) {
            {
              var type = workInProgress2.type;
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var instance = workInProgress2.stateNode;
              if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                return instance.__reactInternalMemoizedMaskedChildContext;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
                checkPropTypes(contextTypes, context, "context", name);
              }
              if (instance) {
                cacheContext(workInProgress2, unmaskedContext, context);
              }
              return context;
            }
          }
          function hasContextChanged() {
            {
              return didPerformWorkStackCursor.current;
            }
          }
          function isContextProvider(type) {
            {
              var childContextTypes = type.childContextTypes;
              return childContextTypes !== null && childContextTypes !== void 0;
            }
          }
          function popContext(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function popTopLevelContextObject(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function pushTopLevelContextObject(fiber, context, didChange) {
            {
              if (contextStackCursor.current !== emptyContextObject) {
                throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
              }
              push(contextStackCursor, context, fiber);
              push(didPerformWorkStackCursor, didChange, fiber);
            }
          }
          function processChildContext(fiber, type, parentContext) {
            {
              var instance = fiber.stateNode;
              var childContextTypes = type.childContextTypes;
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
              {
                var name = getComponentNameFromFiber(fiber) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name);
              }
              return assign({}, parentContext, childContext);
            }
          }
          function pushContextProvider(workInProgress2) {
            {
              var instance = workInProgress2.stateNode;
              var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
              previousContext = contextStackCursor.current;
              push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
              push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
              return true;
            }
          }
          function invalidateContextProvider(workInProgress2, type, didChange) {
            {
              var instance = workInProgress2.stateNode;
              if (!instance) {
                throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
              }
              if (didChange) {
                var mergedContext = processChildContext(workInProgress2, type, previousContext);
                instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                pop(didPerformWorkStackCursor, workInProgress2);
                pop(contextStackCursor, workInProgress2);
                push(contextStackCursor, mergedContext, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              } else {
                pop(didPerformWorkStackCursor, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              }
            }
          }
          function findCurrentUnmaskedContext(fiber) {
            {
              if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
                throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
              }
              var node = fiber;
              do {
                switch (node.tag) {
                  case HostRoot:
                    return node.stateNode.context;
                  case ClassComponent: {
                    var Component4 = node.type;
                    if (isContextProvider(Component4)) {
                      return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    }
                    break;
                  }
                }
                node = node.return;
              } while (node !== null);
              throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          var LegacyRoot = 0;
          var ConcurrentRoot = 1;
          var syncQueue = null;
          var includesLegacySyncCallbacks = false;
          var isFlushingSyncQueue = false;
          function scheduleSyncCallback(callback2) {
            if (syncQueue === null) {
              syncQueue = [callback2];
            } else {
              syncQueue.push(callback2);
            }
          }
          function scheduleLegacySyncCallback(callback2) {
            includesLegacySyncCallbacks = true;
            scheduleSyncCallback(callback2);
          }
          function flushSyncCallbacksOnlyInLegacyMode() {
            if (includesLegacySyncCallbacks) {
              flushSyncCallbacks();
            }
          }
          function flushSyncCallbacks() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
              isFlushingSyncQueue = true;
              var i5 = 0;
              var previousUpdatePriority = getCurrentUpdatePriority();
              try {
                var isSync = true;
                var queue = syncQueue;
                setCurrentUpdatePriority(DiscreteEventPriority);
                for (; i5 < queue.length; i5++) {
                  var callback2 = queue[i5];
                  do {
                    callback2 = callback2(isSync);
                  } while (callback2 !== null);
                }
                syncQueue = null;
                includesLegacySyncCallbacks = false;
              } catch (error2) {
                if (syncQueue !== null) {
                  syncQueue = syncQueue.slice(i5 + 1);
                }
                scheduleCallback(ImmediatePriority, flushSyncCallbacks);
                throw error2;
              } finally {
                setCurrentUpdatePriority(previousUpdatePriority);
                isFlushingSyncQueue = false;
              }
            }
            return null;
          }
          var forkStack = [];
          var forkStackIndex = 0;
          var treeForkProvider = null;
          var treeForkCount = 0;
          var idStack = [];
          var idStackIndex = 0;
          var treeContextProvider = null;
          var treeContextId = 1;
          var treeContextOverflow = "";
          function isForkedChild(workInProgress2) {
            warnIfNotHydrating();
            return (workInProgress2.flags & Forked) !== NoFlags;
          }
          function getForksAtLevel(workInProgress2) {
            warnIfNotHydrating();
            return treeForkCount;
          }
          function getTreeId() {
            var overflow = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id.toString(32) + overflow;
          }
          function pushTreeFork(workInProgress2, totalChildren) {
            warnIfNotHydrating();
            forkStack[forkStackIndex++] = treeForkCount;
            forkStack[forkStackIndex++] = treeForkProvider;
            treeForkProvider = workInProgress2;
            treeForkCount = totalChildren;
          }
          function pushTreeId(workInProgress2, totalChildren, index3) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextProvider = workInProgress2;
            var baseIdWithLeadingBit = treeContextId;
            var baseOverflow = treeContextOverflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index3 + 1;
            var length = getBitLength(totalChildren) + baseLength;
            if (length > 30) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              var newOverflowBits = (1 << numberOfOverflowBits) - 1;
              var newOverflow = (baseId & newOverflowBits).toString(32);
              var restOfBaseId = baseId >> numberOfOverflowBits;
              var restOfBaseLength = baseLength - numberOfOverflowBits;
              var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
              var restOfNewBits = slot << restOfBaseLength;
              var id = restOfNewBits | restOfBaseId;
              var overflow = newOverflow + baseOverflow;
              treeContextId = 1 << restOfLength | id;
              treeContextOverflow = overflow;
            } else {
              var newBits = slot << baseLength;
              var _id = newBits | baseId;
              var _overflow = baseOverflow;
              treeContextId = 1 << length | _id;
              treeContextOverflow = _overflow;
            }
          }
          function pushMaterializedTreeId(workInProgress2) {
            warnIfNotHydrating();
            var returnFiber = workInProgress2.return;
            if (returnFiber !== null) {
              var numberOfForks = 1;
              var slotIndex = 0;
              pushTreeFork(workInProgress2, numberOfForks);
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          function getBitLength(number) {
            return 32 - clz32(number);
          }
          function getLeadingBit(id) {
            return 1 << getBitLength(id) - 1;
          }
          function popTreeContext(workInProgress2) {
            while (workInProgress2 === treeForkProvider) {
              treeForkProvider = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
              treeForkCount = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
            }
            while (workInProgress2 === treeContextProvider) {
              treeContextProvider = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextOverflow = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextId = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
            }
          }
          function getSuspendedTreeContext() {
            warnIfNotHydrating();
            if (treeContextProvider !== null) {
              return {
                id: treeContextId,
                overflow: treeContextOverflow
              };
            } else {
              return null;
            }
          }
          function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextId = suspendedContext.id;
            treeContextOverflow = suspendedContext.overflow;
            treeContextProvider = workInProgress2;
          }
          function warnIfNotHydrating() {
            {
              if (!getIsHydrating()) {
                error("Expected to be hydrating. This is a bug in React. Please file an issue.");
              }
            }
          }
          var hydrationParentFiber = null;
          var nextHydratableInstance = null;
          var isHydrating = false;
          var didSuspendOrErrorDEV = false;
          var hydrationErrors = null;
          function warnIfHydrating() {
            {
              if (isHydrating) {
                error("We should not be hydrating here. This is a bug in React. Please file a bug.");
              }
            }
          }
          function markDidThrowWhileHydratingDEV() {
            {
              didSuspendOrErrorDEV = true;
            }
          }
          function didSuspendOrErrorWhileHydratingDEV() {
            {
              return didSuspendOrErrorDEV;
            }
          }
          function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            return true;
          }
          function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            if (treeContext !== null) {
              restoreSuspendedTreeContext(fiber, treeContext);
            }
            return true;
          }
          function warnUnhydratedInstance(returnFiber, instance) {
            {
              switch (returnFiber.tag) {
                case HostRoot: {
                  didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                  break;
                }
                case HostComponent: {
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotHydrateInstance(
                    returnFiber.type,
                    returnFiber.memoizedProps,
                    returnFiber.stateNode,
                    instance,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                  break;
                }
              }
            }
          }
          function deleteHydratableInstance(returnFiber, instance) {
            warnUnhydratedInstance(returnFiber, instance);
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function warnNonhydratedInstance(returnFiber, fiber) {
            {
              if (didSuspendOrErrorDEV) {
                return;
              }
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  switch (fiber.tag) {
                    case HostComponent:
                      var type = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                      break;
                    case HostText:
                      var text = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                      break;
                  }
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  switch (fiber.tag) {
                    case HostComponent: {
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _type,
                        _props,
                        // TODO: Delete this argument when we remove the legacy root API.
                        isConcurrentMode
                      );
                      break;
                    }
                    case HostText: {
                      var _text = fiber.pendingProps;
                      var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableTextInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _text,
                        // TODO: Delete this argument when we remove the legacy root API.
                        _isConcurrentMode
                      );
                      break;
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  var _parentInstance = suspenseState.dehydrated;
                  if (_parentInstance !== null) switch (fiber.tag) {
                    case HostComponent:
                      var _type2 = fiber.type;
                      var _props2 = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                      break;
                    case HostText:
                      var _text2 = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                      break;
                  }
                  break;
                }
                default:
                  return;
              }
            }
          }
          function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
            warnNonhydratedInstance(returnFiber, fiber);
          }
          function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
              case HostComponent: {
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                  fiber.stateNode = instance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = getFirstHydratableChild(instance);
                  return true;
                }
                return false;
              }
              case HostText: {
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);
                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              case SuspenseComponent: {
                var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
                if (suspenseInstance !== null) {
                  var suspenseState = {
                    dehydrated: suspenseInstance,
                    treeContext: getSuspendedTreeContext(),
                    retryLane: OffscreenLane
                  };
                  fiber.memoizedState = suspenseState;
                  var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                  dehydratedFragment.return = fiber;
                  fiber.child = dehydratedFragment;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              default:
                return false;
            }
          }
          function shouldClientRenderOnMismatch(fiber) {
            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
          }
          function throwOnHydrationMismatch(fiber) {
            throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
          }
          function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
              return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              nextInstance = getNextHydratableSibling(firstAttemptedInstance);
              var prevHydrationParentFiber = hydrationParentFiber;
              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
              }
              deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
            }
          }
          function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            var instance = fiber.stateNode;
            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
              return true;
            }
            return false;
          }
          function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            if (shouldUpdate) {
              var returnFiber = hydrationParentFiber;
              if (returnFiber !== null) {
                switch (returnFiber.tag) {
                  case HostRoot: {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedContainerTextInstance(
                      parentContainer,
                      textInstance,
                      textContent,
                      // TODO: Delete this argument when we remove the legacy root API.
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostComponent: {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      textInstance,
                      textContent,
                      // TODO: Delete this argument when we remove the legacy root API.
                      _isConcurrentMode2
                    );
                    break;
                  }
                }
              }
            }
            return shouldUpdate;
          }
          function prepareToHydrateHostSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            hydrateSuspenseInstance(suspenseInstance, fiber);
          }
          function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
          }
          function popToNextHostParent(fiber) {
            var parent = fiber.return;
            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
              parent = parent.return;
            }
            hydrationParentFiber = parent;
          }
          function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
              return false;
            }
            if (!isHydrating) {
              popToNextHostParent(fiber);
              isHydrating = true;
              return false;
            }
            if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
              var nextInstance = nextHydratableInstance;
              if (nextInstance) {
                if (shouldClientRenderOnMismatch(fiber)) {
                  warnIfUnhydratedTailNodes(fiber);
                  throwOnHydrationMismatch();
                } else {
                  while (nextInstance) {
                    deleteHydratableInstance(fiber, nextInstance);
                    nextInstance = getNextHydratableSibling(nextInstance);
                  }
                }
              }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
              nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
              nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
          }
          function hasUnhydratedTailNodes() {
            return isHydrating && nextHydratableInstance !== null;
          }
          function warnIfUnhydratedTailNodes(fiber) {
            var nextInstance = nextHydratableInstance;
            while (nextInstance) {
              warnUnhydratedInstance(fiber, nextInstance);
              nextInstance = getNextHydratableSibling(nextInstance);
            }
          }
          function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
            didSuspendOrErrorDEV = false;
          }
          function upgradeHydrationErrorsToRecoverable() {
            if (hydrationErrors !== null) {
              queueRecoverableErrors(hydrationErrors);
              hydrationErrors = null;
            }
          }
          function getIsHydrating() {
            return isHydrating;
          }
          function queueHydrationError(error2) {
            if (hydrationErrors === null) {
              hydrationErrors = [error2];
            } else {
              hydrationErrors.push(error2);
            }
          }
          var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
          var NoTransition = null;
          function requestCurrentTransition() {
            return ReactCurrentBatchConfig$1.transition;
          }
          var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance) {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function(fiber, instance) {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          };
          {
            var findStrictRoot = function(fiber) {
              var maybeStrictRoot = null;
              var node = fiber;
              while (node !== null) {
                if (node.mode & StrictLegacyMode) {
                  maybeStrictRoot = node;
                }
                node = node.return;
              }
              return maybeStrictRoot;
            };
            var setToSortedString = function(set3) {
              var array = [];
              set3.forEach(function(value) {
                array.push(value);
              });
              return array.sort().join(", ");
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
              if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                return;
              }
              if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
              instance.componentWillMount.__suppressDeprecationWarning !== true) {
                pendingComponentWillMountWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
                pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                pendingComponentWillReceivePropsWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                pendingComponentWillUpdateWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
                pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
              var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillMountWarnings.length > 0) {
                pendingComponentWillMountWarnings.forEach(function(fiber) {
                  componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillMountWarnings = [];
              }
              var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillMountWarnings = [];
              }
              var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillReceivePropsWarnings.length > 0) {
                pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillReceivePropsWarnings = [];
              }
              var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              }
              var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillUpdateWarnings.length > 0) {
                pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                  componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillUpdateWarnings = [];
              }
              var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
              }
              if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
              }
              if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
              }
              if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
              }
              if (componentWillMountUniqueNames.size > 0) {
                var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
              }
              if (componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
              }
              if (componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
              }
            };
            var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
              var strictRoot = findStrictRoot(fiber);
              if (strictRoot === null) {
                error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return;
              }
              if (didWarnAboutLegacyContext.has(fiber.type)) {
                return;
              }
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
                if (warningsForRoot === void 0) {
                  warningsForRoot = [];
                  pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                }
                warningsForRoot.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
              pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                if (fiberArray.length === 0) {
                  return;
                }
                var firstFiber = fiberArray[0];
                var uniqueNames = /* @__PURE__ */ new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                try {
                  setCurrentFiber(firstFiber);
                  error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
                } finally {
                  resetCurrentFiber();
                }
              });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
              pendingComponentWillMountWarnings = [];
              pendingUNSAFE_ComponentWillMountWarnings = [];
              pendingComponentWillReceivePropsWarnings = [];
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              pendingComponentWillUpdateWarnings = [];
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
              pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            };
          }
          var didWarnAboutMaps;
          var didWarnAboutGenerators;
          var didWarnAboutStringRefs;
          var ownerHasKeyUseWarning;
          var ownerHasFunctionTypeWarning;
          var warnForMissingKey = function(child, returnFiber) {
          };
          {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function(child, returnFiber) {
              if (child === null || typeof child !== "object") {
                return;
              }
              if (!child._store || child._store.validated || child.key != null) {
                return;
              }
              if (typeof child._store !== "object") {
                throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
              }
              child._store.validated = true;
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasKeyUseWarning[componentName]) {
                return;
              }
              ownerHasKeyUseWarning[componentName] = true;
              error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
            };
          }
          function isReactClass(type) {
            return type.prototype && type.prototype.isReactComponent;
          }
          function coerceRef(returnFiber, current2, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
              {
                if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
                // because these cannot be automatically converted to an arrow function
                // using a codemod. Therefore, we don't have to warn about string refs again.
                !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with "Function components cannot have string refs"
                !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
                !(typeof element.type === "function" && !isReactClass(element.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
                element._owner) {
                  var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                  if (!didWarnAboutStringRefs[componentName]) {
                    {
                      error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);
                    }
                    didWarnAboutStringRefs[componentName] = true;
                  }
                }
              }
              if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                  var ownerFiber = owner;
                  if (ownerFiber.tag !== ClassComponent) {
                    throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                  }
                  inst = ownerFiber.stateNode;
                }
                if (!inst) {
                  throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                }
                var resolvedInst = inst;
                {
                  checkPropStringCoercion(mixedRef, "ref");
                }
                var stringRef = "" + mixedRef;
                if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                  return current2.ref;
                }
                var ref = function(value) {
                  var refs = resolvedInst.refs;
                  if (value === null) {
                    delete refs[stringRef];
                  } else {
                    refs[stringRef] = value;
                  }
                };
                ref._stringRef = stringRef;
                return ref;
              } else {
                if (typeof mixedRef !== "string") {
                  throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                }
                if (!element._owner) {
                  throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                }
              }
            }
            return mixedRef;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            var childString = Object.prototype.toString.call(newChild);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          function warnOnFunctionType(returnFiber) {
            {
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasFunctionTypeWarning[componentName]) {
                return;
              }
              ownerHasFunctionTypeWarning[componentName] = true;
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
          function resolveLazy(lazyType) {
            var payload = lazyType._payload;
            var init = lazyType._init;
            return init(payload);
          }
          function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (!shouldTrackSideEffects) {
                return;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [childToDelete];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(childToDelete);
              }
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) {
                return null;
              }
              var childToDelete = currentFirstChild;
              while (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
              }
              return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
              var existingChildren = /* @__PURE__ */ new Map();
              var existingChild = currentFirstChild;
              while (existingChild !== null) {
                if (existingChild.key !== null) {
                  existingChildren.set(existingChild.key, existingChild);
                } else {
                  existingChildren.set(existingChild.index, existingChild);
                }
                existingChild = existingChild.sibling;
              }
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              var clone2 = createWorkInProgress(fiber, pendingProps);
              clone2.index = 0;
              clone2.sibling = null;
              return clone2;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects) {
                newFiber.flags |= Forked;
                return lastPlacedIndex;
              }
              var current2 = newFiber.alternate;
              if (current2 !== null) {
                var oldIndex = current2.index;
                if (oldIndex < lastPlacedIndex) {
                  newFiber.flags |= Placement;
                  return lastPlacedIndex;
                } else {
                  return oldIndex;
                }
              } else {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              }
            }
            function placeSingleChild(newFiber) {
              if (shouldTrackSideEffects && newFiber.alternate === null) {
                newFiber.flags |= Placement;
              }
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, lanes) {
              if (current2 === null || current2.tag !== HostText) {
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, textContent);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateElement(returnFiber, current2, element, lanes) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE) {
                return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
              }
              if (current2 !== null) {
                if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
                isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
                // We need to do this after the Hot Reloading check above,
                // because hot reloading has different semantics than prod because
                // it doesn't resuspend. So we can't let the call below suspend.
                typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                  var existing = useFiber(current2, element.props);
                  existing.ref = coerceRef(returnFiber, current2, element);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
              var created = createFiberFromElement(element, returnFiber.mode, lanes);
              created.ref = coerceRef(returnFiber, current2, element);
              created.return = returnFiber;
              return created;
            }
            function updatePortal(returnFiber, current2, portal, lanes) {
              if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, portal.children || []);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateFragment2(returnFiber, current2, fragment, lanes, key) {
              if (current2 === null || current2.tag !== Fragment11) {
                var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, fragment);
                existing.return = returnFiber;
                return existing;
              }
            }
            function createChild(returnFiber, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                    _created.ref = coerceRef(returnFiber, null, newChild);
                    _created.return = returnFiber;
                    return _created;
                  }
                  case REACT_PORTAL_TYPE: {
                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                    _created2.return = returnFiber;
                    return _created2;
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return createChild(returnFiber, init(payload), lanes);
                  }
                }
                if (isArray3(newChild) || getIteratorFn(newChild)) {
                  var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                  _created3.return = returnFiber;
                  return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
              var key = oldFiber !== null ? oldFiber.key : null;
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                if (key !== null) {
                  return null;
                }
                return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    if (newChild.key === key) {
                      return updateElement(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_PORTAL_TYPE: {
                    if (newChild.key === key) {
                      return updatePortal(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return updateSlot(returnFiber, oldFiber, init(payload), lanes);
                  }
                }
                if (isArray3(newChild) || getIteratorFn(newChild)) {
                  if (key !== null) {
                    return null;
                  }
                  return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                  }
                  case REACT_PORTAL_TYPE: {
                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                  }
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
                }
                if (isArray3(newChild) || getIteratorFn(newChild)) {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;
                  return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function warnOnInvalidKey(child, knownKeys, returnFiber) {
              {
                if (typeof child !== "object" || child === null) {
                  return knownKeys;
                }
                switch (child.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key = child.key;
                    if (typeof key !== "string") {
                      break;
                    }
                    if (knownKeys === null) {
                      knownKeys = /* @__PURE__ */ new Set();
                      knownKeys.add(key);
                      break;
                    }
                    if (!knownKeys.has(key)) {
                      knownKeys.add(key);
                      break;
                    }
                    error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                    break;
                  case REACT_LAZY_TYPE:
                    var payload = child._payload;
                    var init = child._init;
                    warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                    break;
                }
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
              {
                var knownKeys = null;
                for (var i5 = 0; i5 < newChildren.length; i5++) {
                  var child = newChildren[i5];
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                  if (_newFiber === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber;
                  } else {
                    previousNewFiber.sibling = _newFiber;
                  }
                  previousNewFiber = _newFiber;
                }
                if (getIsHydrating()) {
                  var _numberOfForks = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber2.alternate !== null) {
                      existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber2;
                  } else {
                    previousNewFiber.sibling = _newFiber2;
                  }
                  previousNewFiber = _newFiber2;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks2 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks2);
              }
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
              var iteratorFn = getIteratorFn(newChildrenIterable);
              if (typeof iteratorFn !== "function") {
                throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
              }
              {
                if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
                newChildrenIterable[Symbol.toStringTag] === "Generator") {
                  if (!didWarnAboutGenerators) {
                    error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                  }
                  didWarnAboutGenerators = true;
                }
                if (newChildrenIterable.entries === iteratorFn) {
                  if (!didWarnAboutMaps) {
                    error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren) {
                  var knownKeys = null;
                  var _step = _newChildren.next();
                  for (; !_step.done; _step = _newChildren.next()) {
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                  }
                }
              }
              var newChildren = iteratorFn.call(newChildrenIterable);
              if (newChildren == null) {
                throw new Error("An iterable object provided no iterator.");
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              var step = newChildren.next();
              for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step.done) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; !step.done; newIdx++, step = newChildren.next()) {
                  var _newFiber3 = createChild(returnFiber, step.value, lanes);
                  if (_newFiber3 === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber3;
                  } else {
                    previousNewFiber.sibling = _newFiber3;
                  }
                  previousNewFiber = _newFiber3;
                }
                if (getIsHydrating()) {
                  var _numberOfForks3 = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks3);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                if (_newFiber4 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber4.alternate !== null) {
                      existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber4;
                  } else {
                    previousNewFiber.sibling = _newFiber4;
                  }
                  previousNewFiber = _newFiber4;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks4 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks4);
              }
              return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
              if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
              }
              deleteRemainingChildren(returnFiber, currentFirstChild);
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
              var key = element.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  var elementType = element.type;
                  if (elementType === REACT_FRAGMENT_TYPE) {
                    if (child.tag === Fragment11) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var existing = useFiber(child, element.props.children);
                      existing.return = returnFiber;
                      {
                        existing._debugSource = element._source;
                        existing._debugOwner = element._owner;
                      }
                      return existing;
                    }
                  } else {
                    if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                    isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                    // We need to do this after the Hot Reloading check above,
                    // because hot reloading has different semantics than prod because
                    // it doesn't resuspend. So we can't let the call below suspend.
                    typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var _existing = useFiber(child, element.props);
                      _existing.ref = coerceRef(returnFiber, child, element);
                      _existing.return = returnFiber;
                      {
                        _existing._debugSource = element._source;
                        _existing._debugOwner = element._owner;
                      }
                      return _existing;
                    }
                  }
                  deleteRemainingChildren(returnFiber, child);
                  break;
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
              } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
              }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
              var key = portal.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, portal.children || []);
                    existing.return = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                    break;
                  }
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
              var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
              if (isUnkeyedTopLevelFragment) {
                newChild = newChild.props.children;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
                }
                if (isArray3(newChild)) {
                  return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
                }
                if (getIteratorFn(newChild)) {
                  return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers2;
          }
          var reconcileChildFibers = ChildReconciler(true);
          var mountChildFibers = ChildReconciler(false);
          function cloneChildFibers(current2, workInProgress2) {
            if (current2 !== null && workInProgress2.child !== current2.child) {
              throw new Error("Resuming work not yet implemented.");
            }
            if (workInProgress2.child === null) {
              return;
            }
            var currentChild = workInProgress2.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress2.child = newChild;
            newChild.return = workInProgress2;
            while (currentChild.sibling !== null) {
              currentChild = currentChild.sibling;
              newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
              newChild.return = workInProgress2;
            }
            newChild.sibling = null;
          }
          function resetChildFibers(workInProgress2, lanes) {
            var child = workInProgress2.child;
            while (child !== null) {
              resetWorkInProgress(child, lanes);
              child = child.sibling;
            }
          }
          var valueCursor = createCursor(null);
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var currentlyRenderingFiber = null;
          var lastContextDependency = null;
          var lastFullyObservedContext = null;
          var isDisallowedContextReadInDEV = false;
          function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function enterDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = true;
            }
          }
          function exitDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function pushProvider(providerFiber, context, nextValue) {
            {
              push(valueCursor, context._currentValue, providerFiber);
              context._currentValue = nextValue;
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            }
          }
          function popProvider(context, providerFiber) {
            var currentValue = valueCursor.current;
            pop(valueCursor, providerFiber);
            {
              {
                context._currentValue = currentValue;
              }
            }
          }
          function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
            var node = parent;
            while (node !== null) {
              var alternate = node.alternate;
              if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
                node.childLanes = mergeLanes(node.childLanes, renderLanes2);
                if (alternate !== null) {
                  alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                }
              } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
              if (node === propagationRoot) {
                break;
              }
              node = node.return;
            }
            {
              if (node !== propagationRoot) {
                error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function propagateContextChange(workInProgress2, context, renderLanes2) {
            {
              propagateContextChange_eager(workInProgress2, context, renderLanes2);
            }
          }
          function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
            var fiber = workInProgress2.child;
            if (fiber !== null) {
              fiber.return = workInProgress2;
            }
            while (fiber !== null) {
              var nextFiber = void 0;
              var list = fiber.dependencies;
              if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while (dependency !== null) {
                  if (dependency.context === context) {
                    if (fiber.tag === ClassComponent) {
                      var lane = pickArbitraryLane(renderLanes2);
                      var update = createUpdate(NoTimestamp, lane);
                      update.tag = ForceUpdate;
                      var updateQueue = fiber.updateQueue;
                      if (updateQueue === null) ;
                      else {
                        var sharedQueue = updateQueue.shared;
                        var pending = sharedQueue.pending;
                        if (pending === null) {
                          update.next = update;
                        } else {
                          update.next = pending.next;
                          pending.next = update;
                        }
                        sharedQueue.pending = update;
                      }
                    }
                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                      alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                    }
                    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                    list.lanes = mergeLanes(list.lanes, renderLanes2);
                    break;
                  }
                  dependency = dependency.next;
                }
              } else if (fiber.tag === ContextProvider) {
                nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
              } else if (fiber.tag === DehydratedFragment) {
                var parentSuspense = fiber.return;
                if (parentSuspense === null) {
                  throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
                }
                parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
                var _alternate = parentSuspense.alternate;
                if (_alternate !== null) {
                  _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
                }
                scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
                nextFiber = fiber.sibling;
              } else {
                nextFiber = fiber.child;
              }
              if (nextFiber !== null) {
                nextFiber.return = fiber;
              } else {
                nextFiber = fiber;
                while (nextFiber !== null) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  var sibling = nextFiber.sibling;
                  if (sibling !== null) {
                    sibling.return = nextFiber.return;
                    nextFiber = sibling;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              }
              fiber = nextFiber;
            }
          }
          function prepareToReadContext(workInProgress2, renderLanes2) {
            currentlyRenderingFiber = workInProgress2;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            var dependencies = workInProgress2.dependencies;
            if (dependencies !== null) {
              {
                var firstContext = dependencies.firstContext;
                if (firstContext !== null) {
                  if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                    markWorkInProgressReceivedUpdate();
                  }
                  dependencies.firstContext = null;
                }
              }
            }
          }
          function readContext(context) {
            {
              if (isDisallowedContextReadInDEV) {
                error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            var value = context._currentValue;
            if (lastFullyObservedContext === context) ;
            else {
              var contextItem = {
                context,
                memoizedValue: value,
                next: null
              };
              if (lastContextDependency === null) {
                if (currentlyRenderingFiber === null) {
                  throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                }
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                  lanes: NoLanes,
                  firstContext: contextItem
                };
              } else {
                lastContextDependency = lastContextDependency.next = contextItem;
              }
            }
            return value;
          }
          var concurrentQueues = null;
          function pushConcurrentUpdateQueue(queue) {
            if (concurrentQueues === null) {
              concurrentQueues = [queue];
            } else {
              concurrentQueues.push(queue);
            }
          }
          function finishQueueingConcurrentUpdates() {
            if (concurrentQueues !== null) {
              for (var i5 = 0; i5 < concurrentQueues.length; i5++) {
                var queue = concurrentQueues[i5];
                var lastInterleavedUpdate = queue.interleaved;
                if (lastInterleavedUpdate !== null) {
                  queue.interleaved = null;
                  var firstInterleavedUpdate = lastInterleavedUpdate.next;
                  var lastPendingUpdate = queue.pending;
                  if (lastPendingUpdate !== null) {
                    var firstPendingUpdate = lastPendingUpdate.next;
                    lastPendingUpdate.next = firstInterleavedUpdate;
                    lastInterleavedUpdate.next = firstPendingUpdate;
                  }
                  queue.pending = lastInterleavedUpdate;
                }
              }
              concurrentQueues = null;
            }
          }
          function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
          }
          function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentRenderForLane(fiber, lane) {
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
          function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
            {
              if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
            var node = sourceFiber;
            var parent = sourceFiber.return;
            while (parent !== null) {
              parent.childLanes = mergeLanes(parent.childLanes, lane);
              alternate = parent.alternate;
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, lane);
              } else {
                {
                  if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                  }
                }
              }
              node = parent;
              parent = parent.return;
            }
            if (node.tag === HostRoot) {
              var root2 = node.stateNode;
              return root2;
            } else {
              return null;
            }
          }
          var UpdateState = 0;
          var ReplaceState = 1;
          var ForceUpdate = 2;
          var CaptureUpdate = 3;
          var hasForceUpdate = false;
          var didWarnUpdateInsideUpdate;
          var currentlyProcessingQueue;
          {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
          }
          function initializeUpdateQueue(fiber) {
            var queue = {
              baseState: fiber.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: {
                pending: null,
                interleaved: null,
                lanes: NoLanes
              },
              effects: null
            };
            fiber.updateQueue = queue;
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            var queue = workInProgress2.updateQueue;
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var clone2 = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: currentQueue.firstBaseUpdate,
                lastBaseUpdate: currentQueue.lastBaseUpdate,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = clone2;
            }
          }
          function createUpdate(eventTime, lane) {
            var update = {
              eventTime,
              lane,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
            return update;
          }
          function enqueueUpdate(fiber, update, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return null;
            }
            var sharedQueue = updateQueue.shared;
            {
              if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate = true;
              }
            }
            if (isUnsafeClassRenderPhaseUpdate()) {
              var pending = sharedQueue.pending;
              if (pending === null) {
                update.next = update;
              } else {
                update.next = pending.next;
                pending.next = update;
              }
              sharedQueue.pending = update;
              return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
            } else {
              return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
            }
          }
          function entangleTransitions(root2, fiber, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return;
            }
            var sharedQueue = updateQueue.shared;
            if (isTransitionLane(lane)) {
              var queueLanes = sharedQueue.lanes;
              queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              sharedQueue.lanes = newQueueLanes;
              markRootEntangled(root2, newQueueLanes);
            }
          }
          function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
            var queue = workInProgress2.updateQueue;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              if (queue === currentQueue) {
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                  var update = firstBaseUpdate;
                  do {
                    var clone2 = {
                      eventTime: update.eventTime,
                      lane: update.lane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    if (newLast === null) {
                      newFirst = newLast = clone2;
                    } else {
                      newLast.next = clone2;
                      newLast = clone2;
                    }
                    update = update.next;
                  } while (update !== null);
                  if (newLast === null) {
                    newFirst = newLast = capturedUpdate;
                  } else {
                    newLast.next = capturedUpdate;
                    newLast = capturedUpdate;
                  }
                } else {
                  newFirst = newLast = capturedUpdate;
                }
                queue = {
                  baseState: currentQueue.baseState,
                  firstBaseUpdate: newFirst,
                  lastBaseUpdate: newLast,
                  shared: currentQueue.shared,
                  effects: currentQueue.effects
                };
                workInProgress2.updateQueue = queue;
                return;
              }
            }
            var lastBaseUpdate = queue.lastBaseUpdate;
            if (lastBaseUpdate === null) {
              queue.firstBaseUpdate = capturedUpdate;
            } else {
              lastBaseUpdate.next = capturedUpdate;
            }
            queue.lastBaseUpdate = capturedUpdate;
          }
          function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
            switch (update.tag) {
              case ReplaceState: {
                var payload = update.payload;
                if (typeof payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  var nextState = payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                  return nextState;
                }
                return payload;
              }
              case CaptureUpdate: {
                workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
              }
              case UpdateState: {
                var _payload = update.payload;
                var partialState;
                if (typeof _payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  partialState = _payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        _payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                } else {
                  partialState = _payload;
                }
                if (partialState === null || partialState === void 0) {
                  return prevState;
                }
                return assign({}, prevState, partialState);
              }
              case ForceUpdate: {
                hasForceUpdate = true;
                return prevState;
              }
            }
            return prevState;
          }
          function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
            var queue = workInProgress2.updateQueue;
            hasForceUpdate = false;
            {
              currentlyProcessingQueue = queue.shared;
            }
            var firstBaseUpdate = queue.firstBaseUpdate;
            var lastBaseUpdate = queue.lastBaseUpdate;
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
              queue.shared.pending = null;
              var lastPendingUpdate = pendingQueue;
              var firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = null;
              if (lastBaseUpdate === null) {
                firstBaseUpdate = firstPendingUpdate;
              } else {
                lastBaseUpdate.next = firstPendingUpdate;
              }
              lastBaseUpdate = lastPendingUpdate;
              var current2 = workInProgress2.alternate;
              if (current2 !== null) {
                var currentQueue = current2.updateQueue;
                var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                  if (currentLastBaseUpdate === null) {
                    currentQueue.firstBaseUpdate = firstPendingUpdate;
                  } else {
                    currentLastBaseUpdate.next = firstPendingUpdate;
                  }
                  currentQueue.lastBaseUpdate = lastPendingUpdate;
                }
              }
            }
            if (firstBaseUpdate !== null) {
              var newState = queue.baseState;
              var newLanes = NoLanes;
              var newBaseState = null;
              var newFirstBaseUpdate = null;
              var newLastBaseUpdate = null;
              var update = firstBaseUpdate;
              do {
                var updateLane = update.lane;
                var updateEventTime = update.eventTime;
                if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                  var clone2 = {
                    eventTime: updateEventTime,
                    lane: updateLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLastBaseUpdate === null) {
                    newFirstBaseUpdate = newLastBaseUpdate = clone2;
                    newBaseState = newState;
                  } else {
                    newLastBaseUpdate = newLastBaseUpdate.next = clone2;
                  }
                  newLanes = mergeLanes(newLanes, updateLane);
                } else {
                  if (newLastBaseUpdate !== null) {
                    var _clone = {
                      eventTime: updateEventTime,
                      // This update is going to be committed so we never want uncommit
                      // it. Using NoLane works because 0 is a subset of all bitmasks, so
                      // this will never be skipped by the check above.
                      lane: NoLane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                  }
                  newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                  var callback2 = update.callback;
                  if (callback2 !== null && // If the update was already committed, we should not queue its
                  // callback again.
                  update.lane !== NoLane) {
                    workInProgress2.flags |= Callback;
                    var effects2 = queue.effects;
                    if (effects2 === null) {
                      queue.effects = [update];
                    } else {
                      effects2.push(update);
                    }
                  }
                }
                update = update.next;
                if (update === null) {
                  pendingQueue = queue.shared.pending;
                  if (pendingQueue === null) {
                    break;
                  } else {
                    var _lastPendingUpdate = pendingQueue;
                    var _firstPendingUpdate = _lastPendingUpdate.next;
                    _lastPendingUpdate.next = null;
                    update = _firstPendingUpdate;
                    queue.lastBaseUpdate = _lastPendingUpdate;
                    queue.shared.pending = null;
                  }
                }
              } while (true);
              if (newLastBaseUpdate === null) {
                newBaseState = newState;
              }
              queue.baseState = newBaseState;
              queue.firstBaseUpdate = newFirstBaseUpdate;
              queue.lastBaseUpdate = newLastBaseUpdate;
              var lastInterleaved = queue.shared.interleaved;
              if (lastInterleaved !== null) {
                var interleaved = lastInterleaved;
                do {
                  newLanes = mergeLanes(newLanes, interleaved.lane);
                  interleaved = interleaved.next;
                } while (interleaved !== lastInterleaved);
              } else if (firstBaseUpdate === null) {
                queue.shared.lanes = NoLanes;
              }
              markSkippedUpdateLanes(newLanes);
              workInProgress2.lanes = newLanes;
              workInProgress2.memoizedState = newState;
            }
            {
              currentlyProcessingQueue = null;
            }
          }
          function callCallback(callback2, context) {
            if (typeof callback2 !== "function") {
              throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback2));
            }
            callback2.call(context);
          }
          function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
          }
          function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
          }
          function commitUpdateQueue(finishedWork, finishedQueue, instance) {
            var effects2 = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects2 !== null) {
              for (var i5 = 0; i5 < effects2.length; i5++) {
                var effect4 = effects2[i5];
                var callback2 = effect4.callback;
                if (callback2 !== null) {
                  effect4.callback = null;
                  callCallback(callback2, instance);
                }
              }
            }
          }
          var NO_CONTEXT = {};
          var contextStackCursor$1 = createCursor(NO_CONTEXT);
          var contextFiberStackCursor = createCursor(NO_CONTEXT);
          var rootInstanceStackCursor = createCursor(NO_CONTEXT);
          function requiredContext(c3) {
            if (c3 === NO_CONTEXT) {
              throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
            return c3;
          }
          function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push(rootInstanceStackCursor, nextRootInstance, fiber);
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop(contextStackCursor$1, fiber);
            push(contextStackCursor$1, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            var context = requiredContext(contextStackCursor$1.current);
            return context;
          }
          function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context, fiber.type);
            if (context === nextContext) {
              return;
            }
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, nextContext, fiber);
          }
          function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
              return;
            }
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
          }
          var DefaultSuspenseContext = 0;
          var SubtreeSuspenseContextMask = 1;
          var InvisibleParentSuspenseContext = 1;
          var ForceSuspenseFallback = 2;
          var suspenseStackCursor = createCursor(DefaultSuspenseContext);
          function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
          }
          function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
          }
          function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
          }
          function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
          }
          function pushSuspenseContext(fiber, newContext) {
            push(suspenseStackCursor, newContext, fiber);
          }
          function popSuspenseContext(fiber) {
            pop(suspenseStackCursor, fiber);
          }
          function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
            var nextState = workInProgress2.memoizedState;
            if (nextState !== null) {
              if (nextState.dehydrated !== null) {
                return true;
              }
              return false;
            }
            var props = workInProgress2.memoizedProps;
            {
              return true;
            }
          }
          function findFirstSuspended(row) {
            var node = row;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  var dehydrated = state.dehydrated;
                  if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                    return node;
                  }
                }
              } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
              // keep track of whether it suspended or not.
              node.memoizedProps.revealOrder !== void 0) {
                var didSuspend = (node.flags & DidCapture) !== NoFlags;
                if (didSuspend) {
                  return node;
                }
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === row) {
                return null;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === row) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          var NoFlags$1 = (
            /*   */
            0
          );
          var HasEffect = (
            /* */
            1
          );
          var Insertion = (
            /*  */
            2
          );
          var Layout = (
            /*    */
            4
          );
          var Passive$1 = (
            /*   */
            8
          );
          var workInProgressSources = [];
          function resetWorkInProgressVersions() {
            for (var i5 = 0; i5 < workInProgressSources.length; i5++) {
              var mutableSource = workInProgressSources[i5];
              {
                mutableSource._workInProgressVersionPrimary = null;
              }
            }
            workInProgressSources.length = 0;
          }
          function registerMutableSourceForHydration(root2, mutableSource) {
            var getVersion = mutableSource._getVersion;
            var version2 = getVersion(mutableSource._source);
            if (root2.mutableSourceEagerHydrationData == null) {
              root2.mutableSourceEagerHydrationData = [mutableSource, version2];
            } else {
              root2.mutableSourceEagerHydrationData.push(mutableSource, version2);
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
          var didWarnAboutMismatchedHooksForComponent;
          var didWarnUncachedGetSnapshot;
          {
            didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
          }
          var renderLanes = NoLanes;
          var currentlyRenderingFiber$1 = null;
          var currentHook = null;
          var workInProgressHook = null;
          var didScheduleRenderPhaseUpdate = false;
          var didScheduleRenderPhaseUpdateDuringThisPass = false;
          var localIdCounter = 0;
          var globalClientIdCounter = 0;
          var RE_RENDER_LIMIT = 25;
          var currentHookNameInDev = null;
          var hookTypesDev = null;
          var hookTypesUpdateIndexDev = -1;
          var ignorePreviousDependencies = false;
          function mountHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev === null) {
                hookTypesDev = [hookName];
              } else {
                hookTypesDev.push(hookName);
              }
            }
          }
          function updateHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev !== null) {
                hookTypesUpdateIndexDev++;
                if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                  warnOnHookMismatchInDev(hookName);
                }
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            {
              if (deps !== void 0 && deps !== null && !isArray3(deps)) {
                error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
              }
            }
          }
          function warnOnHookMismatchInDev(currentHookName) {
            {
              var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                didWarnAboutMismatchedHooksForComponent.add(componentName);
                if (hookTypesDev !== null) {
                  var table = "";
                  var secondColumnStart = 30;
                  for (var i5 = 0; i5 <= hookTypesUpdateIndexDev; i5++) {
                    var oldHookName = hookTypesDev[i5];
                    var newHookName = i5 === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i5 + 1 + ". " + oldHookName;
                    while (row.length < secondColumnStart) {
                      row += " ";
                    }
                    row += newHookName + "\n";
                    table += row;
                  }
                  error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                }
              }
            }
          }
          function throwInvalidHookError() {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            {
              if (ignorePreviousDependencies) {
                return false;
              }
            }
            if (prevDeps === null) {
              {
                error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
              }
            }
            for (var i5 = 0; i5 < prevDeps.length && i5 < nextDeps.length; i5++) {
              if (objectIs(nextDeps[i5], prevDeps[i5])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component4, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress2;
            {
              hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
              hookTypesUpdateIndexDev = -1;
              ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
            }
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.lanes = NoLanes;
            {
              if (current2 !== null && current2.memoizedState !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
              } else if (hookTypesDev !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
              } else {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
              }
            }
            var children = Component4(props, secondArg);
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
              var numberOfReRenders = 0;
              do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                localIdCounter = 0;
                if (numberOfReRenders >= RE_RENDER_LIMIT) {
                  throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                }
                numberOfReRenders += 1;
                {
                  ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress2.updateQueue = null;
                {
                  hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component4(props, secondArg);
              } while (didScheduleRenderPhaseUpdateDuringThisPass);
            }
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            {
              workInProgress2._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              currentHookNameInDev = null;
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
              // and creates false positives. To make this work in legacy mode, we'd
              // need to mark fibers that commit in an incomplete state, somehow. For
              // now I'll disable the warning that most of the bugs that would trigger
              // it are either exclusive to concurrent mode or exist in both.
              (current2.mode & ConcurrentMode) !== NoMode) {
                error("Internal React error: Expected static flag was missing. Please notify the React team.");
              }
            }
            didScheduleRenderPhaseUpdate = false;
            if (didRenderTooFewHooks) {
              throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
            }
            return children;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            localIdCounter = 0;
            return didRenderIdHook;
          }
          function bailoutHooks(current2, workInProgress2, lanes) {
            workInProgress2.updateQueue = current2.updateQueue;
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
            } else {
              workInProgress2.flags &= ~(Passive | Update);
            }
            current2.lanes = removeLanes(current2.lanes, lanes);
          }
          function resetHooksAfterThrow() {
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
              var hook = currentlyRenderingFiber$1.memoizedState;
              while (hook !== null) {
                var queue = hook.queue;
                if (queue !== null) {
                  queue.pending = null;
                }
                hook = hook.next;
              }
              didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              currentHookNameInDev = null;
              isUpdatingOpaqueValueInRenderPhase = false;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
              workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
              var current2 = currentlyRenderingFiber$1.alternate;
              if (current2 !== null) {
                nextCurrentHook = current2.memoizedState;
              } else {
                nextCurrentHook = null;
              }
            } else {
              nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
              nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
              nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
              workInProgressHook = nextWorkInProgressHook;
              nextWorkInProgressHook = workInProgressHook.next;
              currentHook = nextCurrentHook;
            } else {
              if (nextCurrentHook === null) {
                throw new Error("Rendered more hooks than during the previous render.");
              }
              currentHook = nextCurrentHook;
              var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
              } else {
                workInProgressHook = workInProgressHook.next = newHook;
              }
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return {
              lastEffect: null,
              stores: null
            };
          }
          function basicStateReducer(state, action) {
            return typeof action === "function" ? action(state) : action;
          }
          function mountReducer(reducer, initialArg, init) {
            var hook = mountWorkInProgressHook();
            var initialState;
            if (init !== void 0) {
              initialState = init(initialArg);
            } else {
              initialState = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var current2 = currentHook;
            var baseQueue = current2.baseQueue;
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              {
                if (current2.baseQueue !== baseQueue) {
                  error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
                }
              }
              current2.baseQueue = baseQueue = pendingQueue;
              queue.pending = null;
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = current2.baseState;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              var update = first;
              do {
                var updateLane = update.lane;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                  var clone2 = {
                    lane: updateLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  };
                  if (newBaseQueueLast === null) {
                    newBaseQueueFirst = newBaseQueueLast = clone2;
                    newBaseState = newState;
                  } else {
                    newBaseQueueLast = newBaseQueueLast.next = clone2;
                  }
                  currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                  markSkippedUpdateLanes(updateLane);
                } else {
                  if (newBaseQueueLast !== null) {
                    var _clone = {
                      // This update is going to be committed so we never want uncommit
                      // it. Using NoLane works because 0 is a subset of all bitmasks, so
                      // this will never be skipped by the check above.
                      lane: NoLane,
                      action: update.action,
                      hasEagerState: update.hasEagerState,
                      eagerState: update.eagerState,
                      next: null
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  if (update.hasEagerState) {
                    newState = update.eagerState;
                  } else {
                    var action = update.action;
                    newState = reducer(newState, action);
                  }
                }
                update = update.next;
              } while (update !== null && update !== first);
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              hook.baseState = newBaseState;
              hook.baseQueue = newBaseQueueLast;
              queue.lastRenderedState = newState;
            }
            var lastInterleaved = queue.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                var interleavedLane = interleaved.lane;
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
                markSkippedUpdateLanes(interleavedLane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (baseQueue === null) {
              queue.lanes = NoLanes;
            }
            var dispatch = queue.dispatch;
            return [hook.memoizedState, dispatch];
          }
          function rerenderReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var dispatch = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
              queue.pending = null;
              var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                newState = reducer(newState, action);
                update = update.next;
              } while (update !== firstRenderPhaseUpdate);
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              if (hook.baseQueue === null) {
                hook.baseState = newState;
              }
              queue.lastRenderedState = newState;
            }
            return [newState, dispatch];
          }
          function mountMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function updateMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = mountWorkInProgressHook();
            var nextSnapshot;
            var isHydrating2 = getIsHydrating();
            if (isHydrating2) {
              if (getServerSnapshot === void 0) {
                throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
              }
              nextSnapshot = getServerSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  if (nextSnapshot !== getServerSnapshot()) {
                    error("The result of getServerSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
            } else {
              nextSnapshot = getSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  var cachedSnapshot = getSnapshot();
                  if (!objectIs(nextSnapshot, cachedSnapshot)) {
                    error("The result of getSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
              var root2 = getWorkInProgressRoot();
              if (root2 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root2, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            hook.memoizedState = nextSnapshot;
            var inst = {
              value: nextSnapshot,
              getSnapshot
            };
            hook.queue = inst;
            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            return nextSnapshot;
          }
          function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = updateWorkInProgressHook();
            var nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var prevSnapshot = hook.memoizedState;
            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
            if (snapshotChanged) {
              hook.memoizedState = nextSnapshot;
              markWorkInProgressReceivedUpdate();
            }
            var inst = hook.queue;
            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
            // checking whether we scheduled a subscription effect above.
            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
              fiber.flags |= Passive;
              pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
              var root2 = getWorkInProgressRoot();
              if (root2 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root2, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            return nextSnapshot;
          }
          function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
            fiber.flags |= StoreConsistency;
            var check = {
              getSnapshot,
              value: renderedSnapshot
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.stores = [check];
            } else {
              var stores = componentUpdateQueue.stores;
              if (stores === null) {
                componentUpdateQueue.stores = [check];
              } else {
                stores.push(check);
              }
            }
          }
          function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
            inst.value = nextSnapshot;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          }
          function subscribeToStore(fiber, inst, subscribe) {
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceStoreRerender(fiber);
              }
            };
            return subscribe(handleStoreChange);
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error2) {
              return true;
            }
          }
          function forceStoreRerender(fiber) {
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          }
          function mountState(initialState) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState === "function") {
              initialState = initialState();
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateState(initialState) {
            return updateReducer(basicStateReducer);
          }
          function rerenderState(initialState) {
            return rerenderReducer(basicStateReducer);
          }
          function pushEffect(tag, create, destroy, deps) {
            var effect4 = {
              tag,
              create,
              destroy,
              deps,
              // Circular
              next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.lastEffect = effect4.next = effect4;
            } else {
              var lastEffect = componentUpdateQueue.lastEffect;
              if (lastEffect === null) {
                componentUpdateQueue.lastEffect = effect4.next = effect4;
              } else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect4;
                effect4.next = firstEffect;
                componentUpdateQueue.lastEffect = effect4;
              }
            }
            return effect4;
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            {
              var _ref2 = {
                current: initialValue
              };
              hook.memoizedState = _ref2;
              return _ref2;
            }
          }
          function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
          }
          function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
          }
          function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var destroy = void 0;
            if (currentHook !== null) {
              var prevEffect = currentHook.memoizedState;
              destroy = prevEffect.destroy;
              if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
                  return;
                }
              }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
          }
          function mountEffect(create, deps) {
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
            } else {
              return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
            }
          }
          function updateEffect(create, deps) {
            return updateEffectImpl(Passive, Passive$1, create, deps);
          }
          function mountInsertionEffect(create, deps) {
            return mountEffectImpl(Update, Insertion, create, deps);
          }
          function updateInsertionEffect(create, deps) {
            return updateEffectImpl(Update, Insertion, create, deps);
          }
          function mountLayoutEffect(create, deps) {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, create, deps);
          }
          function updateLayoutEffect(create, deps) {
            return updateEffectImpl(Update, Layout, create, deps);
          }
          function imperativeHandleEffect(create, ref) {
            if (typeof ref === "function") {
              var refCallback = ref;
              var _inst = create();
              refCallback(_inst);
              return function() {
                refCallback(null);
              };
            } else if (ref !== null && ref !== void 0) {
              var refObject = ref;
              {
                if (!refObject.hasOwnProperty("current")) {
                  error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                }
              }
              var _inst2 = create();
              refObject.current = _inst2;
              return function() {
                refObject.current = null;
              };
            }
          }
          function mountImperativeHandle(ref, create, deps) {
            {
              if (typeof create !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
          }
          function updateImperativeHandle(ref, create, deps) {
            {
              if (typeof create !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
          }
          function mountDebugValue(value, formatterFn) {
          }
          var updateDebugValue = mountDebugValue;
          function mountCallback(callback2, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            hook.memoizedState = [callback2, nextDeps];
            return callback2;
          }
          function updateCallback(callback2, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            hook.memoizedState = [callback2, nextDeps];
            return callback2;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function mountDeferredValue(value) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = value;
            return value;
          }
          function updateDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            var resolvedCurrentHook = currentHook;
            var prevValue = resolvedCurrentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
          function rerenderDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            if (currentHook === null) {
              hook.memoizedState = value;
              return value;
            } else {
              var prevValue = currentHook.memoizedState;
              return updateDeferredValueImpl(hook, prevValue, value);
            }
          }
          function updateDeferredValueImpl(hook, prevValue, value) {
            var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
            if (shouldDeferValue) {
              if (!objectIs(value, prevValue)) {
                var deferredLane = claimNextTransitionLane();
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
                markSkippedUpdateLanes(deferredLane);
                hook.baseState = true;
              }
              return prevValue;
            } else {
              if (hook.baseState) {
                hook.baseState = false;
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = value;
              return value;
            }
          }
          function startTransition(setPending, callback2, options2) {
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
            setPending(true);
            var prevTransition = ReactCurrentBatchConfig$2.transition;
            ReactCurrentBatchConfig$2.transition = {};
            var currentTransition = ReactCurrentBatchConfig$2.transition;
            {
              ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              setPending(false);
              callback2();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$2.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          function mountTransition() {
            var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
            var start3 = startTransition.bind(null, setPending);
            var hook = mountWorkInProgressHook();
            hook.memoizedState = start3;
            return [isPending, start3];
          }
          function updateTransition() {
            var _updateState = updateState(), isPending = _updateState[0];
            var hook = updateWorkInProgressHook();
            var start3 = hook.memoizedState;
            return [isPending, start3];
          }
          function rerenderTransition() {
            var _rerenderState = rerenderState(), isPending = _rerenderState[0];
            var hook = updateWorkInProgressHook();
            var start3 = hook.memoizedState;
            return [isPending, start3];
          }
          var isUpdatingOpaqueValueInRenderPhase = false;
          function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
            {
              return isUpdatingOpaqueValueInRenderPhase;
            }
          }
          function mountId() {
            var hook = mountWorkInProgressHook();
            var root2 = getWorkInProgressRoot();
            var identifierPrefix = root2.identifierPrefix;
            var id;
            if (getIsHydrating()) {
              var treeId = getTreeId();
              id = ":" + identifierPrefix + "R" + treeId;
              var localId = localIdCounter++;
              if (localId > 0) {
                id += "H" + localId.toString(32);
              }
              id += ":";
            } else {
              var globalClientId = globalClientIdCounter++;
              id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
            }
            hook.memoizedState = id;
            return id;
          }
          function updateId() {
            var hook = updateWorkInProgressHook();
            var id = hook.memoizedState;
            return id;
          }
          function dispatchReducerAction(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root2 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitionUpdate(root2, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function dispatchSetState(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var alternate = fiber.alternate;
              if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                  var prevDispatcher;
                  {
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                  }
                  try {
                    var currentState = queue.lastRenderedState;
                    var eagerState = lastRenderedReducer(currentState, action);
                    update.hasEagerState = true;
                    update.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) {
                      enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                      return;
                    }
                  } catch (error2) {
                  } finally {
                    {
                      ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                  }
                }
              }
              var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root2 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitionUpdate(root2, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function isRenderPhaseUpdate(fiber) {
            var alternate = fiber.alternate;
            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
          }
          function enqueueRenderPhaseUpdate(queue, update) {
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            var pending = queue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            queue.pending = update;
          }
          function entangleTransitionUpdate(root2, queue, lane) {
            if (isTransitionLane(lane)) {
              var queueLanes = queue.lanes;
              queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              queue.lanes = newQueueLanes;
              markRootEntangled(root2, newQueueLanes);
            }
          }
          function markUpdateInDevTools(fiber, lane, action) {
            {
              markStateUpdateScheduled(fiber, lane);
            }
          }
          var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useInsertionEffect: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useMutableSource: throwInvalidHookError,
            useSyncExternalStore: throwInvalidHookError,
            useId: throwInvalidHookError,
            unstable_isNewReconciler: enableNewReconciler
          };
          var HooksDispatcherOnMountInDEV = null;
          var HooksDispatcherOnMountWithHookTypesInDEV = null;
          var HooksDispatcherOnUpdateInDEV = null;
          var HooksDispatcherOnRerenderInDEV = null;
          var InvalidNestedHooksDispatcherOnMountInDEV = null;
          var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
          var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          {
            var warnInvalidContextAccess = function() {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            };
            var warnInvalidHookAccess = function() {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            };
            HooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback2, deps) {
                currentHookNameInDev = "useCallback";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountCallback(callback2, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback2, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return mountCallback(callback2, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return mountImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback2, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback2, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback2, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback2, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback2, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountCallback(callback2, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback2, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback2, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback2, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback2, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
          }
          var now$1 = Scheduler.unstable_now;
          var commitTime = 0;
          var layoutEffectStartTime = -1;
          var profilerStartTime = -1;
          var passiveEffectStartTime = -1;
          var currentUpdateIsNested = false;
          var nestedUpdateScheduled = false;
          function isCurrentUpdateNested() {
            return currentUpdateIsNested;
          }
          function markNestedUpdateScheduled() {
            {
              nestedUpdateScheduled = true;
            }
          }
          function resetNestedUpdateFlag() {
            {
              currentUpdateIsNested = false;
              nestedUpdateScheduled = false;
            }
          }
          function syncNestedUpdateFlag() {
            {
              currentUpdateIsNested = nestedUpdateScheduled;
              nestedUpdateScheduled = false;
            }
          }
          function getCommitTime() {
            return commitTime;
          }
          function recordCommitTime() {
            commitTime = now$1();
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now$1();
            if (fiber.actualStartTime < 0) {
              fiber.actualStartTime = now$1();
            }
          }
          function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
          }
          function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
              var elapsedTime = now$1() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              if (overrideBaseTime) {
                fiber.selfBaseDuration = elapsedTime;
              }
              profilerStartTime = -1;
            }
          }
          function recordLayoutEffectDuration(fiber) {
            if (layoutEffectStartTime >= 0) {
              var elapsedTime = now$1() - layoutEffectStartTime;
              layoutEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root2 = parentFiber.stateNode;
                    root2.effectDuration += elapsedTime;
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    parentStateNode.effectDuration += elapsedTime;
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function recordPassiveEffectDuration(fiber) {
            if (passiveEffectStartTime >= 0) {
              var elapsedTime = now$1() - passiveEffectStartTime;
              passiveEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root2 = parentFiber.stateNode;
                    if (root2 !== null) {
                      root2.passiveEffectDuration += elapsedTime;
                    }
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    if (parentStateNode !== null) {
                      parentStateNode.passiveEffectDuration += elapsedTime;
                    }
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function startLayoutEffectTimer() {
            layoutEffectStartTime = now$1();
          }
          function startPassiveEffectTimer() {
            passiveEffectStartTime = now$1();
          }
          function transferActualDuration(fiber) {
            var child = fiber.child;
            while (child) {
              fiber.actualDuration += child.actualDuration;
              child = child.sibling;
            }
          }
          function resolveDefaultProps(Component4, baseProps) {
            if (Component4 && Component4.defaultProps) {
              var props = assign({}, baseProps);
              var defaultProps = Component4.defaultProps;
              for (var propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          var fakeInternalInstance = {};
          var didWarnAboutStateAssignmentForComponent;
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          var didWarnAboutLegacyContext$1;
          {
            didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            didWarnAboutLegacyContext$1 = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback2, callerName) {
              if (callback2 === null || typeof callback2 === "function") {
                return;
              }
              var key = callerName + "_" + callback2;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback2);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentNameFromType(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
            Object.defineProperty(fakeInternalInstance, "_processChildContext", {
              enumerable: false,
              value: function() {
                throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
              }
            });
            Object.freeze(fakeInternalInstance);
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState;
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  partialState = getDerivedStateFromProps(nextProps, prevState);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
            workInProgress2.memoizedState = memoizedState;
            if (workInProgress2.lanes === NoLanes) {
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = memoizedState;
            }
          }
          var classComponentUpdater = {
            isMounted,
            enqueueSetState: function(inst, payload, callback2) {
              var fiber = get2(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.payload = payload;
              if (callback2 !== void 0 && callback2 !== null) {
                {
                  warnOnInvalidCallback(callback2, "setState");
                }
                update.callback = callback2;
              }
              var root2 = enqueueUpdate(fiber, update, lane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitions(root2, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueReplaceState: function(inst, payload, callback2) {
              var fiber = get2(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ReplaceState;
              update.payload = payload;
              if (callback2 !== void 0 && callback2 !== null) {
                {
                  warnOnInvalidCallback(callback2, "replaceState");
                }
                update.callback = callback2;
              }
              var root2 = enqueueUpdate(fiber, update, lane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitions(root2, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueForceUpdate: function(inst, callback2) {
              var fiber = get2(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ForceUpdate;
              if (callback2 !== void 0 && callback2 !== null) {
                {
                  warnOnInvalidCallback(callback2, "forceUpdate");
                }
                update.callback = callback2;
              }
              var root2 = enqueueUpdate(fiber, update, lane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitions(root2, fiber, lane);
              }
              {
                markForceUpdateScheduled(fiber, lane);
              }
            }
          };
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress2.stateNode;
            if (typeof instance.shouldComponentUpdate === "function") {
              var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                if (shouldUpdate === void 0) {
                  error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
                }
              }
              return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
              return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
            }
            return true;
          }
          function checkClassInstance(workInProgress2, ctor, newProps) {
            var instance = workInProgress2.stateNode;
            {
              var name = getComponentNameFromType(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
                } else {
                  error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
              }
              if (instance.propTypes) {
                error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
              }
              if (instance.contextType) {
                error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
              }
              {
                if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
                // this one.
                (workInProgress2.mode & StrictLegacyMode) === NoMode) {
                  didWarnAboutLegacyContext$1.add(ctor);
                  error("%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead\n\n.Learn more about this warning here: https://reactjs.org/link/legacy-context", name);
                }
                if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
                // this one.
                (workInProgress2.mode & StrictLegacyMode) === NoMode) {
                  didWarnAboutLegacyContext$1.add(ctor);
                  error("%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", name);
                }
                if (instance.contextTypes) {
                  error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
              }
              if (instance.defaultProps) {
                error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray3(_state))) {
                error("%s.state: must be set to an object or null", name);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
              }
            }
          }
          function adoptClassInstance(workInProgress2, instance) {
            instance.updater = classComponentUpdater;
            workInProgress2.stateNode = instance;
            set2(instance, workInProgress2);
            {
              instance._reactInternalInstance = fakeInternalInstance;
            }
          }
          function constructClassInstance(workInProgress2, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid = (
                  // Allow null for conditional declaration
                  contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
                );
                if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              var contextTypes = ctor.contextTypes;
              isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
              context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
            }
            var instance = new ctor(props, context);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance = new ctor(props, context);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
            adoptClassInstance(workInProgress2, instance);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentNameFromType(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            if (isLegacyContextConsumer) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return instance;
          }
          function callComponentWillMount(workInProgress2, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
            var oldState = instance.state;
            if (typeof instance.componentWillReceiveProps === "function") {
              instance.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            if (instance.state !== oldState) {
              {
                var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
                if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                  didWarnAboutStateAssignmentForComponent.add(componentName);
                  error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                }
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            {
              checkClassInstance(workInProgress2, ctor, newProps);
            }
            var instance = workInProgress2.stateNode;
            instance.props = newProps;
            instance.state = workInProgress2.memoizedState;
            instance.refs = {};
            initializeUpdateQueue(workInProgress2);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              instance.context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
              }
              {
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
              }
            }
            instance.state = workInProgress2.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(workInProgress2, instance);
              processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
          }
          function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            var oldProps = workInProgress2.memoizedProps;
            instance.props = oldProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidMount === "function") {
                var fiberFlags = Update;
                {
                  fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= fiberFlags;
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                if (typeof instance.componentWillMount === "function") {
                  instance.componentWillMount();
                }
                if (typeof instance.UNSAFE_componentWillMount === "function") {
                  instance.UNSAFE_componentWillMount();
                }
              }
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags = Update;
                {
                  _fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags;
              }
            } else {
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags2 = Update;
                {
                  _fiberFlags2 |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags2 |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags2;
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            var unresolvedOldProps = workInProgress2.memoizedProps;
            var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
            instance.props = oldProps;
            var unresolvedNewProps = workInProgress2.pendingProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
            // both before and after `shouldComponentUpdate` has been called. Not ideal,
            // but I'm loath to refactor this function. This only happens for memoized
            // components so it's not that common.
            enableLazyContextPropagation;
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
                if (typeof instance.componentWillUpdate === "function") {
                  instance.componentWillUpdate(newProps, newState, nextContext);
                }
                if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                }
              }
              if (typeof instance.componentDidUpdate === "function") {
                workInProgress2.flags |= Update;
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                workInProgress2.flags |= Snapshot;
              }
            } else {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function createCapturedValueAtFiber(value, source) {
            return {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source),
              digest: null
            };
          }
          function createCapturedValue(value, digest, stack) {
            return {
              value,
              source: null,
              stack: stack != null ? stack : null,
              digest: digest != null ? digest : null
            };
          }
          function showErrorDialog(boundary, errorInfo) {
            return true;
          }
          function logCapturedError(boundary, errorInfo) {
            try {
              var logError = showErrorDialog(boundary, errorInfo);
              if (logError === false) {
                return;
              }
              var error2 = errorInfo.value;
              if (true) {
                var source = errorInfo.source;
                var stack = errorInfo.stack;
                var componentStack = stack !== null ? stack : "";
                if (error2 != null && error2._suppressLogging) {
                  if (boundary.tag === ClassComponent) {
                    return;
                  }
                  console["error"](error2);
                }
                var componentName = source ? getComponentNameFromFiber(source) : null;
                var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                var errorBoundaryMessage;
                if (boundary.tag === HostRoot) {
                  errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
                } else {
                  var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                  errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                }
                var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                console["error"](combinedMessage);
              } else {
                console["error"](error2);
              }
            } catch (e3) {
              setTimeout(function() {
                throw e3;
              });
            }
          }
          var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
          function createRootErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            update.payload = {
              element: null
            };
            var error2 = errorInfo.value;
            update.callback = function() {
              onUncaughtError(error2);
              logCapturedError(fiber, errorInfo);
            };
            return update;
          }
          function createClassErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === "function") {
              var error$1 = errorInfo.value;
              update.payload = function() {
                return getDerivedStateFromError(error$1);
              };
              update.callback = function() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
              };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === "function") {
              update.callback = function callback2() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
                if (typeof getDerivedStateFromError !== "function") {
                  markLegacyErrorBoundaryAsFailed(this);
                }
                var error$12 = errorInfo.value;
                var stack = errorInfo.stack;
                this.componentDidCatch(error$12, {
                  componentStack: stack !== null ? stack : ""
                });
                {
                  if (typeof getDerivedStateFromError !== "function") {
                    if (!includesSomeLane(fiber.lanes, SyncLane)) {
                      error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                    }
                  }
                }
              };
            }
            return update;
          }
          function attachPingListener(root2, wakeable, lanes) {
            var pingCache = root2.pingCache;
            var threadIDs;
            if (pingCache === null) {
              pingCache = root2.pingCache = new PossiblyWeakMap$1();
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            } else {
              threadIDs = pingCache.get(wakeable);
              if (threadIDs === void 0) {
                threadIDs = /* @__PURE__ */ new Set();
                pingCache.set(wakeable, threadIDs);
              }
            }
            if (!threadIDs.has(lanes)) {
              threadIDs.add(lanes);
              var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
              {
                if (isDevToolsPresent) {
                  restorePendingUpdaters(root2, lanes);
                }
              }
              wakeable.then(ping, ping);
            }
          }
          function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {
            var wakeables = suspenseBoundary.updateQueue;
            if (wakeables === null) {
              var updateQueue = /* @__PURE__ */ new Set();
              updateQueue.add(wakeable);
              suspenseBoundary.updateQueue = updateQueue;
            } else {
              wakeables.add(wakeable);
            }
          }
          function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
            var tag = sourceFiber.tag;
            if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef10 || tag === SimpleMemoComponent)) {
              var currentSource = sourceFiber.alternate;
              if (currentSource) {
                sourceFiber.updateQueue = currentSource.updateQueue;
                sourceFiber.memoizedState = currentSource.memoizedState;
                sourceFiber.lanes = currentSource.lanes;
              } else {
                sourceFiber.updateQueue = null;
                sourceFiber.memoizedState = null;
              }
            }
          }
          function getNearestSuspenseBoundaryToCapture(returnFiber) {
            var node = returnFiber;
            do {
              if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
                return node;
              }
              node = node.return;
            } while (node !== null);
            return null;
          }
          function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {
            if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
              if (suspenseBoundary === returnFiber) {
                suspenseBoundary.flags |= ShouldCapture;
              } else {
                suspenseBoundary.flags |= DidCapture;
                sourceFiber.flags |= ForceUpdateForLegacySuspense;
                sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                if (sourceFiber.tag === ClassComponent) {
                  var currentSourceFiber = sourceFiber.alternate;
                  if (currentSourceFiber === null) {
                    sourceFiber.tag = IncompleteClassComponent;
                  } else {
                    var update = createUpdate(NoTimestamp, SyncLane);
                    update.tag = ForceUpdate;
                    enqueueUpdate(sourceFiber, update, SyncLane);
                  }
                }
                sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
              }
              return suspenseBoundary;
            }
            suspenseBoundary.flags |= ShouldCapture;
            suspenseBoundary.lanes = rootRenderLanes;
            return suspenseBoundary;
          }
          function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= Incomplete;
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root2, rootRenderLanes);
              }
            }
            if (value !== null && typeof value === "object" && typeof value.then === "function") {
              var wakeable = value;
              resetSuspendedComponent(sourceFiber);
              {
                if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                  markDidThrowWhileHydratingDEV();
                }
              }
              var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (suspenseBoundary !== null) {
                suspenseBoundary.flags &= ~ForceClientRender;
                markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
                if (suspenseBoundary.mode & ConcurrentMode) {
                  attachPingListener(root2, wakeable, rootRenderLanes);
                }
                attachRetryListener(suspenseBoundary, root2, wakeable);
                return;
              } else {
                if (!includesSyncLane(rootRenderLanes)) {
                  attachPingListener(root2, wakeable, rootRenderLanes);
                  renderDidSuspendDelayIfPossible();
                  return;
                }
                var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
                value = uncaughtSuspenseError;
              }
            } else {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
                var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                if (_suspenseBoundary !== null) {
                  if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                    _suspenseBoundary.flags |= ForceClientRender;
                  }
                  markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
                  queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                  return;
                }
              }
            }
            value = createCapturedValueAtFiber(value, sourceFiber);
            renderDidError(value);
            var workInProgress2 = returnFiber;
            do {
              switch (workInProgress2.tag) {
                case HostRoot: {
                  var _errorInfo = value;
                  workInProgress2.flags |= ShouldCapture;
                  var lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  return;
                }
                case ClassComponent:
                  var errorInfo = value;
                  var ctor = workInProgress2.type;
                  var instance = workInProgress2.stateNode;
                  if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                    workInProgress2.flags |= ShouldCapture;
                    var _lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                    var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                    enqueueCapturedUpdate(workInProgress2, _update);
                    return;
                  }
                  break;
              }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2 !== null);
          }
          function getSuspendedCache() {
            {
              return null;
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var didReceiveUpdate = false;
          var didWarnAboutBadClass;
          var didWarnAboutModulePatternComponent;
          var didWarnAboutContextTypeOnFunctionComponent;
          var didWarnAboutGetDerivedStateOnFunctionComponent;
          var didWarnAboutFunctionRefs;
          var didWarnAboutReassigningProps;
          var didWarnAboutRevealOrder;
          var didWarnAboutTailOptions;
          var didWarnAboutDefaultPropsOnFunctionComponent;
          {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
            didWarnAboutDefaultPropsOnFunctionComponent = {};
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
            if (current2 === null) {
              workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
            }
          }
          function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          }
          function updateForwardRef(current2, workInProgress2, Component4, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component4.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component4)
                  );
                }
              }
            }
            var render2 = Component4.render;
            var ref = workInProgress2.ref;
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component4, nextProps, renderLanes2) {
            if (current2 === null) {
              var type = Component4.type;
              if (isSimpleFunctionComponent(type) && Component4.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
              Component4.defaultProps === void 0) {
                var resolvedType = type;
                {
                  resolvedType = resolveFunctionForHotReloading(type);
                }
                workInProgress2.tag = SimpleMemoComponent;
                workInProgress2.type = resolvedType;
                {
                  validateFunctionComponentInDev(workInProgress2, type);
                }
                return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
              }
              {
                var innerPropTypes = type.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(type)
                  );
                }
                if (Component4.defaultProps !== void 0) {
                  var componentName = getComponentNameFromType(type) || "Unknown";
                  if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                    error("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", componentName);
                    didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
                  }
                }
              }
              var child = createFiberFromTypeAndProps(Component4.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
              child.ref = workInProgress2.ref;
              child.return = workInProgress2;
              workInProgress2.child = child;
              return child;
            }
            {
              var _type = Component4.type;
              var _innerPropTypes = _type.propTypes;
              if (_innerPropTypes) {
                checkPropTypes(
                  _innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(_type)
                );
              }
            }
            var currentChild = current2.child;
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
            if (!hasScheduledUpdateOrContext) {
              var prevProps = currentChild.memoizedProps;
              var compare = Component4.compare;
              compare = compare !== null ? compare : shallowEqual;
              if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            }
            workInProgress2.flags |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress2.ref;
            newChild.return = workInProgress2;
            workInProgress2.child = newChild;
            return newChild;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component4, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerMemoType = workInProgress2.elementType;
                if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                  var lazyComponent = outerMemoType;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    outerMemoType = init(payload);
                  } catch (x3) {
                    outerMemoType = null;
                  }
                  var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      nextProps,
                      // Resolved (SimpleMemoComponent has no defaultProps)
                      "prop",
                      getComponentNameFromType(outerMemoType)
                    );
                  }
                }
              }
            }
            if (current2 !== null) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
              workInProgress2.type === current2.type) {
                didReceiveUpdate = false;
                workInProgress2.pendingProps = nextProps = prevProps;
                if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                  workInProgress2.lanes = current2.lanes;
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                }
              }
            }
            return updateFunctionComponent(current2, workInProgress2, Component4, nextProps, renderLanes2);
          }
          function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            var prevState = current2 !== null ? current2.memoizedState : null;
            if (nextProps.mode === "hidden" || enableLegacyHidden) {
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                var nextState = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = nextState;
                pushRenderLanes(workInProgress2, renderLanes2);
              } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
                var spawnedCachePool = null;
                var nextBaseLanes;
                if (prevState !== null) {
                  var prevBaseLanes = prevState.baseLanes;
                  nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
                } else {
                  nextBaseLanes = renderLanes2;
                }
                workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                  baseLanes: nextBaseLanes,
                  cachePool: spawnedCachePool,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState;
                workInProgress2.updateQueue = null;
                pushRenderLanes(workInProgress2, nextBaseLanes);
                return null;
              } else {
                var _nextState2 = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState2;
                var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
                pushRenderLanes(workInProgress2, subtreeRenderLanes2);
              }
            } else {
              var _subtreeRenderLanes;
              if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
                workInProgress2.memoizedState = null;
              } else {
                _subtreeRenderLanes = renderLanes2;
              }
              pushRenderLanes(workInProgress2, _subtreeRenderLanes);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateFragment(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMode(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateProfiler(current2, workInProgress2, renderLanes2) {
            {
              workInProgress2.flags |= Update;
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
              }
            }
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markRef(current2, workInProgress2) {
            var ref = workInProgress2.ref;
            if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
              workInProgress2.flags |= Ref;
              {
                workInProgress2.flags |= RefStatic;
              }
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component4, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component4.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component4)
                  );
                }
              }
            }
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component4, true);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, Component4, nextProps, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, Component4, nextProps, context, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component4, nextProps, renderLanes2) {
            {
              switch (shouldError(workInProgress2)) {
                case false: {
                  var _instance = workInProgress2.stateNode;
                  var ctor = workInProgress2.type;
                  var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                  var state = tempInstance.state;
                  _instance.updater.enqueueSetState(_instance, state, null);
                  break;
                }
                case true: {
                  workInProgress2.flags |= DidCapture;
                  workInProgress2.flags |= ShouldCapture;
                  var error$1 = new Error("Simulated error coming from DevTools");
                  var lane = pickArbitraryLane(renderLanes2);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  break;
                }
              }
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component4.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component4)
                  );
                }
              }
            }
            var hasContext;
            if (isContextProvider(Component4)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var instance = workInProgress2.stateNode;
            var shouldUpdate;
            if (instance === null) {
              resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
              constructClassInstance(workInProgress2, Component4, nextProps);
              mountClassInstance(workInProgress2, Component4, nextProps, renderLanes2);
              shouldUpdate = true;
            } else if (current2 === null) {
              shouldUpdate = resumeMountClassInstance(workInProgress2, Component4, nextProps, renderLanes2);
            } else {
              shouldUpdate = updateClassInstance(current2, workInProgress2, Component4, nextProps, renderLanes2);
            }
            var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component4, shouldUpdate, hasContext, renderLanes2);
            {
              var inst = workInProgress2.stateNode;
              if (shouldUpdate && inst.props !== nextProps) {
                if (!didWarnAboutReassigningProps) {
                  error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            return nextUnitOfWork;
          }
          function finishClassComponent(current2, workInProgress2, Component4, shouldUpdate, hasContext, renderLanes2) {
            markRef(current2, workInProgress2);
            var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (!shouldUpdate && !didCaptureError) {
              if (hasContext) {
                invalidateContextProvider(workInProgress2, Component4, false);
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var instance = workInProgress2.stateNode;
            ReactCurrentOwner$1.current = workInProgress2;
            var nextChildren;
            if (didCaptureError && typeof Component4.getDerivedStateFromError !== "function") {
              nextChildren = null;
              {
                stopProfilerTimerIfRunning();
              }
            } else {
              {
                markComponentRenderStarted(workInProgress2);
              }
              {
                setIsRendering(true);
                nextChildren = instance.render();
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    instance.render();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                setIsRendering(false);
              }
              {
                markComponentRenderStopped();
              }
            }
            workInProgress2.flags |= PerformedWork;
            if (current2 !== null && didCaptureError) {
              forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            workInProgress2.memoizedState = instance.state;
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component4, true);
            }
            return workInProgress2.child;
          }
          function pushHostRootContext(workInProgress2) {
            var root2 = workInProgress2.stateNode;
            if (root2.pendingContext) {
              pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
            } else if (root2.context) {
              pushTopLevelContextObject(workInProgress2, root2.context, false);
            }
            pushHostContainer(workInProgress2, root2.containerInfo);
          }
          function updateHostRoot(current2, workInProgress2, renderLanes2) {
            pushHostRootContext(workInProgress2);
            if (current2 === null) {
              throw new Error("Should have a current fiber. This is a bug in React.");
            }
            var nextProps = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            var prevChildren = prevState.element;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            var root2 = workInProgress2.stateNode;
            var nextChildren = nextState.element;
            if (prevState.isDehydrated) {
              var overrideState = {
                element: nextChildren,
                isDehydrated: false,
                cache: nextState.cache,
                pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
                transitions: nextState.transitions
              };
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = overrideState;
              workInProgress2.memoizedState = overrideState;
              if (workInProgress2.flags & ForceClientRender) {
                var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
              } else if (nextChildren !== prevChildren) {
                var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
              } else {
                enterHydrationState(workInProgress2);
                var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
                workInProgress2.child = child;
                var node = child;
                while (node) {
                  node.flags = node.flags & ~Placement | Hydrating;
                  node = node.sibling;
                }
              }
            } else {
              resetHydrationState();
              if (nextChildren === prevChildren) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
            resetHydrationState();
            queueHydrationError(recoverableError);
            workInProgress2.flags |= ForceClientRender;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostComponent(current2, workInProgress2, renderLanes2) {
            pushHostContext(workInProgress2);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var type = workInProgress2.type;
            var nextProps = workInProgress2.pendingProps;
            var prevProps = current2 !== null ? current2.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type, nextProps);
            if (isDirectTextChild) {
              nextChildren = null;
            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
              workInProgress2.flags |= ContentReset;
            }
            markRef(current2, workInProgress2);
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostText(current2, workInProgress2) {
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            return null;
          }
          function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var lazyComponent = elementType;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;
            var Component4 = init(payload);
            workInProgress2.type = Component4;
            var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component4);
            var resolvedProps = resolveDefaultProps(Component4, props);
            var child;
            switch (resolvedTag) {
              case FunctionComponent: {
                {
                  validateFunctionComponentInDev(workInProgress2, Component4);
                  workInProgress2.type = Component4 = resolveFunctionForHotReloading(Component4);
                }
                child = updateFunctionComponent(null, workInProgress2, Component4, resolvedProps, renderLanes2);
                return child;
              }
              case ClassComponent: {
                {
                  workInProgress2.type = Component4 = resolveClassForHotReloading(Component4);
                }
                child = updateClassComponent(null, workInProgress2, Component4, resolvedProps, renderLanes2);
                return child;
              }
              case ForwardRef10: {
                {
                  workInProgress2.type = Component4 = resolveForwardRefForHotReloading(Component4);
                }
                child = updateForwardRef(null, workInProgress2, Component4, resolvedProps, renderLanes2);
                return child;
              }
              case MemoComponent: {
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = Component4.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        resolvedProps,
                        // Resolved for outer only
                        "prop",
                        getComponentNameFromType(Component4)
                      );
                    }
                  }
                }
                child = updateMemoComponent(
                  null,
                  workInProgress2,
                  Component4,
                  resolveDefaultProps(Component4.type, resolvedProps),
                  // The inner type can have defaults too
                  renderLanes2
                );
                return child;
              }
            }
            var hint = "";
            {
              if (Component4 !== null && typeof Component4 === "object" && Component4.$$typeof === REACT_LAZY_TYPE) {
                hint = " Did you wrap a component in React.lazy() more than once?";
              }
            }
            throw new Error("Element type is invalid. Received a promise that resolves to: " + Component4 + ". " + ("Lazy element type must resolve to a class or function." + hint));
          }
          function mountIncompleteClassComponent(_current, workInProgress2, Component4, nextProps, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            workInProgress2.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component4)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            constructClassInstance(workInProgress2, Component4, nextProps);
            mountClassInstance(workInProgress2, Component4, nextProps, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component4, true, hasContext, renderLanes2);
          }
          function mountIndeterminateComponent(_current, workInProgress2, Component4, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component4, false);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var value;
            var hasId;
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              if (Component4.prototype && typeof Component4.prototype.render === "function") {
                var componentName = getComponentNameFromType(Component4) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
              }
              setIsRendering(true);
              ReactCurrentOwner$1.current = workInProgress2;
              value = renderWithHooks(null, workInProgress2, Component4, props, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            {
              if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                var _componentName = getComponentNameFromType(Component4) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (
              // Run these checks in production only if the flag is off.
              // Eventually we'll delete this branch altogether.
              typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
            ) {
              {
                var _componentName2 = getComponentNameFromType(Component4) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              workInProgress2.tag = ClassComponent;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              var hasContext = false;
              if (isContextProvider(Component4)) {
                hasContext = true;
                pushContextProvider(workInProgress2);
              } else {
                hasContext = false;
              }
              workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
              initializeUpdateQueue(workInProgress2);
              adoptClassInstance(workInProgress2, value);
              mountClassInstance(workInProgress2, Component4, props, renderLanes2);
              return finishClassComponent(null, workInProgress2, Component4, true, hasContext, renderLanes2);
            } else {
              workInProgress2.tag = FunctionComponent;
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    value = renderWithHooks(null, workInProgress2, Component4, props, context, renderLanes2);
                    hasId = checkDidRenderIdHook();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
              }
              if (getIsHydrating() && hasId) {
                pushMaterializedTreeId(workInProgress2);
              }
              reconcileChildren(null, workInProgress2, value, renderLanes2);
              {
                validateFunctionComponentInDev(workInProgress2, Component4);
              }
              return workInProgress2.child;
            }
          }
          function validateFunctionComponentInDev(workInProgress2, Component4) {
            {
              if (Component4) {
                if (Component4.childContextTypes) {
                  error("%s(...): childContextTypes cannot be defined on a function component.", Component4.displayName || Component4.name || "Component");
                }
              }
              if (workInProgress2.ref !== null) {
                var info = "";
                var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
                var warningKey = ownerName || "";
                var debugSource = workInProgress2._debugSource;
                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }
                if (!didWarnAboutFunctionRefs[warningKey]) {
                  didWarnAboutFunctionRefs[warningKey] = true;
                  error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                }
              }
              if (Component4.defaultProps !== void 0) {
                var componentName = getComponentNameFromType(Component4) || "Unknown";
                if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                  error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
                  didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
                }
              }
              if (typeof Component4.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentNameFromType(Component4) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component4.contextType === "object" && Component4.contextType !== null) {
                var _componentName4 = getComponentNameFromType(Component4) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          var SUSPENDED_MARKER = {
            dehydrated: null,
            treeContext: null,
            retryLane: NoLane
          };
          function mountSuspenseOffscreenState(renderLanes2) {
            return {
              baseLanes: renderLanes2,
              cachePool: getSuspendedCache(),
              transitions: null
            };
          }
          function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
            var cachePool = null;
            return {
              baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
              cachePool,
              transitions: prevOffscreenState.transitions
            };
          }
          function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              var suspenseState = current2.memoizedState;
              if (suspenseState === null) {
                return false;
              }
            }
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          }
          function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
            return removeLanes(current2.childLanes, renderLanes2);
          }
          function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            {
              if (shouldSuspend2(workInProgress2)) {
                workInProgress2.flags |= DidCapture;
              }
            }
            var suspenseContext = suspenseStackCursor.current;
            var showFallback = false;
            var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
              showFallback = true;
              workInProgress2.flags &= ~DidCapture;
            } else {
              if (current2 === null || current2.memoizedState !== null) {
                {
                  suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                }
              }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress2, suspenseContext);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null) {
                var dehydrated = suspenseState.dehydrated;
                if (dehydrated !== null) {
                  return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
                }
              }
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var primaryChildFragment = workInProgress2.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
              } else {
                return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
              }
            } else {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var _dehydrated = prevState.dehydrated;
                if (_dehydrated !== null) {
                  return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
                }
              }
              if (showFallback) {
                var _nextFallbackChildren = nextProps.fallback;
                var _nextPrimaryChildren = nextProps.children;
                var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
                var _primaryChildFragment2 = workInProgress2.child;
                var prevOffscreenState = current2.child.memoizedState;
                _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              } else {
                var _nextPrimaryChildren2 = nextProps.children;
                var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
                workInProgress2.memoizedState = null;
                return _primaryChildFragment3;
              }
            }
          }
          function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            primaryChildFragment.return = workInProgress2;
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var progressedPrimaryFragment = workInProgress2.child;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            var fallbackChildFragment;
            if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
              }
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            } else {
              primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            }
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
          }
          function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
            return createWorkInProgress(current2, offscreenProps);
          }
          function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
              mode: "visible",
              children: primaryChildren
            });
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              primaryChildFragment.lanes = renderLanes2;
            }
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = null;
            if (currentFallbackChildFragment !== null) {
              var deletions = workInProgress2.deletions;
              if (deletions === null) {
                workInProgress2.deletions = [currentFallbackChildFragment];
                workInProgress2.flags |= ChildDeletion;
              } else {
                deletions.push(currentFallbackChildFragment);
              }
            }
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            if (
              // In legacy mode, we commit the primary tree as if it successfully
              // completed, even though it's in an inconsistent state.
              (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
              // already cloned. In legacy mode, the only case where this isn't true is
              // when DevTools forces us to display a fallback; we skip the first render
              // pass entirely and go straight to rendering the fallback. (In Concurrent
              // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
              // only codepath.)
              workInProgress2.child !== currentPrimaryChildFragment
            ) {
              var progressedPrimaryFragment = workInProgress2.child;
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
              }
              workInProgress2.deletions = null;
            } else {
              primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
              primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
            }
            var fallbackChildFragment;
            if (currentFallbackChildFragment !== null) {
              fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
            } else {
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
              fallbackChildFragment.flags |= Placement;
            }
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
            if (recoverableError !== null) {
              queueHydrationError(recoverableError);
            }
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            var nextProps = workInProgress2.pendingProps;
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            primaryChildFragment.flags |= Placement;
            workInProgress2.memoizedState = null;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var fiberMode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
              reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            }
            return fallbackChildFragment;
          }
          function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              {
                error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
              }
              workInProgress2.lanes = laneToLanes(SyncLane);
            } else if (isSuspenseInstanceFallback(suspenseInstance)) {
              workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
            } else {
              workInProgress2.lanes = laneToLanes(OffscreenLane);
            }
            return null;
          }
          function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
            if (!didSuspend) {
              warnIfHydrating();
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                return retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2,
                  // TODO: When we delete legacy mode, we should make this error argument
                  // required  every concurrent mode path that causes hydration to
                  // de-opt to client rendering should have an error message.
                  null
                );
              }
              if (isSuspenseInstanceFallback(suspenseInstance)) {
                var digest, message, stack;
                {
                  var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                  digest = _getSuspenseInstanceF.digest;
                  message = _getSuspenseInstanceF.message;
                  stack = _getSuspenseInstanceF.stack;
                }
                var error2;
                if (message) {
                  error2 = new Error(message);
                } else {
                  error2 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
                }
                var capturedValue = createCapturedValue(error2, digest, stack);
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
              }
              var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
              if (didReceiveUpdate || hasContextChanged2) {
                var root2 = getWorkInProgressRoot();
                if (root2 !== null) {
                  var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);
                  if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                    suspenseState.retryLane = attemptHydrationAtLane;
                    var eventTime = NoTimestamp;
                    enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                    scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane, eventTime);
                  }
                }
                renderDidSuspendDelayIfPossible();
                var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
              } else if (isSuspenseInstancePending(suspenseInstance)) {
                workInProgress2.flags |= DidCapture;
                workInProgress2.child = current2.child;
                var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
                registerSuspenseInstanceRetry(suspenseInstance, retry);
                return null;
              } else {
                reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
                var primaryChildren = nextProps.children;
                var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
                primaryChildFragment.flags |= Hydrating;
                return primaryChildFragment;
              }
            } else {
              if (workInProgress2.flags & ForceClientRender) {
                workInProgress2.flags &= ~ForceClientRender;
                var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
              } else if (workInProgress2.memoizedState !== null) {
                workInProgress2.child = current2.child;
                workInProgress2.flags |= DidCapture;
                return null;
              } else {
                var nextPrimaryChildren = nextProps.children;
                var nextFallbackChildren = nextProps.fallback;
                var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var _primaryChildFragment4 = workInProgress2.child;
                _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              }
            }
          }
          function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
            fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
          }
          function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
            var node = firstChild;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
                }
              } else if (node.tag === SuspenseListComponent) {
                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function findLastContentRow(firstChild) {
            var row = firstChild;
            var lastContentRow = null;
            while (row !== null) {
              var currentRow = row.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                lastContentRow = row;
              }
              row = row.sibling;
            }
            return lastContentRow;
          }
          function validateRevealOrder(revealOrder) {
            {
              if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                didWarnAboutRevealOrder[revealOrder] = true;
                if (typeof revealOrder === "string") {
                  switch (revealOrder.toLowerCase()) {
                    case "together":
                    case "forwards":
                    case "backwards": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    case "forward":
                    case "backward": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    default:
                      error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                      break;
                  }
                } else {
                  error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                }
              }
            }
          }
          function validateTailOptions(tailMode, revealOrder) {
            {
              if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                if (tailMode !== "collapsed" && tailMode !== "hidden") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                }
              }
            }
          }
          function validateSuspenseListNestedChild(childSlot, index3) {
            {
              var isAnArray = isArray3(childSlot);
              var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
              if (isAnArray || isIterable) {
                var type = isAnArray ? "array" : "iterable";
                error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index3, type);
                return false;
              }
            }
            return true;
          }
          function validateSuspenseListChildren(children, revealOrder) {
            {
              if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
                if (isArray3(children)) {
                  for (var i5 = 0; i5 < children.length; i5++) {
                    if (!validateSuspenseListNestedChild(children[i5], i5)) {
                      return;
                    }
                  }
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if (typeof iteratorFn === "function") {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                      var step = childrenIterator.next();
                      var _i = 0;
                      for (; !step.done; step = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step.value, _i)) {
                          return;
                        }
                        _i++;
                      }
                    }
                  } else {
                    error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                  }
                }
              }
            }
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailMode
              };
            } else {
              renderState.isBackwards = isBackwards;
              renderState.rendering = null;
              renderState.renderingStartTime = 0;
              renderState.last = lastContentRow;
              renderState.tail = tail;
              renderState.tailMode = tailMode;
            }
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
              suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              workInProgress2.flags |= DidCapture;
            } else {
              var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
              if (didSuspendBefore) {
                propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
              }
              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress2, suspenseContext);
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              workInProgress2.memoizedState = null;
            } else {
              switch (revealOrder) {
                case "forwards": {
                  var lastContentRow = findLastContentRow(workInProgress2.child);
                  var tail;
                  if (lastContentRow === null) {
                    tail = workInProgress2.child;
                    workInProgress2.child = null;
                  } else {
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    // isBackwards
                    tail,
                    lastContentRow,
                    tailMode
                  );
                  break;
                }
                case "backwards": {
                  var _tail = null;
                  var row = workInProgress2.child;
                  workInProgress2.child = null;
                  while (row !== null) {
                    var currentRow = row.alternate;
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                      workInProgress2.child = row;
                      break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    true,
                    // isBackwards
                    _tail,
                    null,
                    // last
                    tailMode
                  );
                  break;
                }
                case "together": {
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    // isBackwards
                    null,
                    // tail
                    null,
                    // last
                    void 0
                  );
                  break;
                }
                default: {
                  workInProgress2.memoizedState = null;
                }
              }
            }
            return workInProgress2.child;
          }
          function updatePortalComponent(current2, workInProgress2, renderLanes2) {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            var nextChildren = workInProgress2.pendingProps;
            if (current2 === null) {
              workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
          function updateContextProvider(current2, workInProgress2, renderLanes2) {
            var providerType = workInProgress2.type;
            var context = providerType._context;
            var newProps = workInProgress2.pendingProps;
            var oldProps = workInProgress2.memoizedProps;
            var newValue = newProps.value;
            {
              if (!("value" in newProps)) {
                if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                  hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                  error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
                }
              }
              var providerPropTypes = workInProgress2.type.propTypes;
              if (providerPropTypes) {
                checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
              }
            }
            pushProvider(workInProgress2, context, newValue);
            {
              if (oldProps !== null) {
                var oldValue = oldProps.value;
                if (objectIs(oldValue, newValue)) {
                  if (oldProps.children === newProps.children && !hasContextChanged()) {
                    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  }
                } else {
                  propagateContextChange(workInProgress2, context, renderLanes2);
                }
              }
            }
            var newChildren = newProps.children;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingContextAsConsumer = false;
          function updateContextConsumer(current2, workInProgress2, renderLanes2) {
            var context = workInProgress2.type;
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var newProps = workInProgress2.pendingProps;
            var render2 = newProps.children;
            {
              if (typeof render2 !== "function") {
                error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var newValue = readContext(context);
            {
              markComponentRenderStarted(workInProgress2);
            }
            var newChildren;
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              newChildren = render2(newValue);
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
          }
          function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              if (current2 !== null) {
                current2.alternate = null;
                workInProgress2.alternate = null;
                workInProgress2.flags |= Placement;
              }
            }
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              workInProgress2.dependencies = current2.dependencies;
            }
            {
              stopProfilerTimerIfRunning();
            }
            markSkippedUpdateLanes(workInProgress2.lanes);
            if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
              {
                return null;
              }
            }
            cloneChildFibers(current2, workInProgress2);
            return workInProgress2.child;
          }
          function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
            {
              var returnFiber = oldWorkInProgress.return;
              if (returnFiber === null) {
                throw new Error("Cannot swap the root fiber.");
              }
              current2.alternate = null;
              oldWorkInProgress.alternate = null;
              newWorkInProgress.index = oldWorkInProgress.index;
              newWorkInProgress.sibling = oldWorkInProgress.sibling;
              newWorkInProgress.return = oldWorkInProgress.return;
              newWorkInProgress.ref = oldWorkInProgress.ref;
              if (oldWorkInProgress === returnFiber.child) {
                returnFiber.child = newWorkInProgress;
              } else {
                var prevSibling = returnFiber.child;
                if (prevSibling === null) {
                  throw new Error("Expected parent to have a child.");
                }
                while (prevSibling.sibling !== oldWorkInProgress) {
                  prevSibling = prevSibling.sibling;
                  if (prevSibling === null) {
                    throw new Error("Expected to find the previous sibling.");
                  }
                }
                prevSibling.sibling = newWorkInProgress;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [current2];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(current2);
              }
              newWorkInProgress.flags |= Placement;
              return newWorkInProgress;
            }
          }
          function checkScheduledUpdateOrContext(current2, renderLanes2) {
            var updateLanes = current2.lanes;
            if (includesSomeLane(updateLanes, renderLanes2)) {
              return true;
            }
            return false;
          }
          function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
            switch (workInProgress2.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress2);
                var root2 = workInProgress2.stateNode;
                resetHydrationState();
                break;
              case HostComponent:
                pushHostContext(workInProgress2);
                break;
              case ClassComponent: {
                var Component4 = workInProgress2.type;
                if (isContextProvider(Component4)) {
                  pushContextProvider(workInProgress2);
                }
                break;
              }
              case HostPortal:
                pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                break;
              case ContextProvider: {
                var newValue = workInProgress2.memoizedProps.value;
                var context = workInProgress2.type._context;
                pushProvider(workInProgress2, context, newValue);
                break;
              }
              case Profiler:
                {
                  var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                  if (hasChildWork) {
                    workInProgress2.flags |= Update;
                  }
                  {
                    var stateNode = workInProgress2.stateNode;
                    stateNode.effectDuration = 0;
                    stateNode.passiveEffectDuration = 0;
                  }
                }
                break;
              case SuspenseComponent: {
                var state = workInProgress2.memoizedState;
                if (state !== null) {
                  if (state.dehydrated !== null) {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    workInProgress2.flags |= DidCapture;
                    return null;
                  }
                  var primaryChildFragment = workInProgress2.child;
                  var primaryChildLanes = primaryChildFragment.childLanes;
                  if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                    return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                  } else {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                    if (child !== null) {
                      return child.sibling;
                    } else {
                      return null;
                    }
                  }
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                }
                break;
              }
              case SuspenseListComponent: {
                var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (didSuspendBefore) {
                  if (_hasChildWork) {
                    return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                  }
                  workInProgress2.flags |= DidCapture;
                }
                var renderState = workInProgress2.memoizedState;
                if (renderState !== null) {
                  renderState.rendering = null;
                  renderState.tail = null;
                  renderState.lastEffect = null;
                }
                pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                if (_hasChildWork) {
                  break;
                } else {
                  return null;
                }
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                workInProgress2.lanes = NoLanes;
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          function beginWork(current2, workInProgress2, renderLanes2) {
            {
              if (workInProgress2._debugNeedsRemount && current2 !== null) {
                return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
              }
            }
            if (current2 !== null) {
              var oldProps = current2.memoizedProps;
              var newProps = workInProgress2.pendingProps;
              if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
              workInProgress2.type !== current2.type) {
                didReceiveUpdate = true;
              } else {
                var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
                if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
                // may not be work scheduled on `current`, so we check for this flag.
                (workInProgress2.flags & DidCapture) === NoFlags) {
                  didReceiveUpdate = false;
                  return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
                }
                if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                } else {
                  didReceiveUpdate = false;
                }
              }
            } else {
              didReceiveUpdate = false;
              if (getIsHydrating() && isForkedChild(workInProgress2)) {
                var slotIndex = workInProgress2.index;
                var numberOfForks = getForksAtLevel();
                pushTreeId(workInProgress2, numberOfForks, slotIndex);
              }
            }
            workInProgress2.lanes = NoLanes;
            switch (workInProgress2.tag) {
              case IndeterminateComponent: {
                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
              }
              case LazyComponent: {
                var elementType = workInProgress2.elementType;
                return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
              }
              case FunctionComponent: {
                var Component4 = workInProgress2.type;
                var unresolvedProps = workInProgress2.pendingProps;
                var resolvedProps = workInProgress2.elementType === Component4 ? unresolvedProps : resolveDefaultProps(Component4, unresolvedProps);
                return updateFunctionComponent(current2, workInProgress2, Component4, resolvedProps, renderLanes2);
              }
              case ClassComponent: {
                var _Component = workInProgress2.type;
                var _unresolvedProps = workInProgress2.pendingProps;
                var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
                return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
              }
              case HostRoot:
                return updateHostRoot(current2, workInProgress2, renderLanes2);
              case HostComponent:
                return updateHostComponent(current2, workInProgress2, renderLanes2);
              case HostText:
                return updateHostText(current2, workInProgress2);
              case SuspenseComponent:
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              case HostPortal:
                return updatePortalComponent(current2, workInProgress2, renderLanes2);
              case ForwardRef10: {
                var type = workInProgress2.type;
                var _unresolvedProps2 = workInProgress2.pendingProps;
                var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
              }
              case Fragment11:
                return updateFragment(current2, workInProgress2, renderLanes2);
              case Mode:
                return updateMode(current2, workInProgress2, renderLanes2);
              case Profiler:
                return updateProfiler(current2, workInProgress2, renderLanes2);
              case ContextProvider:
                return updateContextProvider(current2, workInProgress2, renderLanes2);
              case ContextConsumer:
                return updateContextConsumer(current2, workInProgress2, renderLanes2);
              case MemoComponent: {
                var _type2 = workInProgress2.type;
                var _unresolvedProps3 = workInProgress2.pendingProps;
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        _resolvedProps3,
                        // Resolved for outer only
                        "prop",
                        getComponentNameFromType(_type2)
                      );
                    }
                  }
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
              }
              case SimpleMemoComponent: {
                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
              }
              case IncompleteClassComponent: {
                var _Component2 = workInProgress2.type;
                var _unresolvedProps4 = workInProgress2.pendingProps;
                var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
                return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
              }
              case SuspenseListComponent: {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent: {
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function markUpdate(workInProgress2) {
            workInProgress2.flags |= Update;
          }
          function markRef$1(workInProgress2) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
          var appendAllChildren;
          var updateHostContainer;
          var updateHostComponent$1;
          var updateHostText$1;
          {
            appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  appendInitialChild(parent, node.stateNode);
                } else if (node.tag === HostPortal) ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            updateHostContainer = function(current2, workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
              var oldProps = current2.memoizedProps;
              if (oldProps === newProps) {
                return;
              }
              var instance = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
              workInProgress2.updateQueue = updatePayload;
              if (updatePayload) {
                markUpdate(workInProgress2);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress2);
              }
            };
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (getIsHydrating()) {
              return;
            }
            switch (renderState.tailMode) {
              case "hidden": {
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while (tailNode !== null) {
                  if (tailNode.alternate !== null) {
                    lastTailNode = tailNode;
                  }
                  tailNode = tailNode.sibling;
                }
                if (lastTailNode === null) {
                  renderState.tail = null;
                } else {
                  lastTailNode.sibling = null;
                }
                break;
              }
              case "collapsed": {
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while (_tailNode !== null) {
                  if (_tailNode.alternate !== null) {
                    _lastTailNode = _tailNode;
                  }
                  _tailNode = _tailNode.sibling;
                }
                if (_lastTailNode === null) {
                  if (!hasRenderedATailFallback && renderState.tail !== null) {
                    renderState.tail.sibling = null;
                  } else {
                    renderState.tail = null;
                  }
                } else {
                  _lastTailNode.sibling = null;
                }
                break;
              }
            }
          }
          function bubbleProperties(completedWork) {
            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
            var newChildLanes = NoLanes;
            var subtreeFlags = NoFlags;
            if (!didBailout) {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var actualDuration = completedWork.actualDuration;
                var treeBaseDuration = completedWork.selfBaseDuration;
                var child = completedWork.child;
                while (child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                  subtreeFlags |= child.subtreeFlags;
                  subtreeFlags |= child.flags;
                  actualDuration += child.actualDuration;
                  treeBaseDuration += child.treeBaseDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
                completedWork.treeBaseDuration = treeBaseDuration;
              } else {
                var _child = completedWork.child;
                while (_child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                  subtreeFlags |= _child.subtreeFlags;
                  subtreeFlags |= _child.flags;
                  _child.return = completedWork;
                  _child = _child.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            } else {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var _treeBaseDuration = completedWork.selfBaseDuration;
                var _child2 = completedWork.child;
                while (_child2 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                  subtreeFlags |= _child2.subtreeFlags & StaticMask;
                  subtreeFlags |= _child2.flags & StaticMask;
                  _treeBaseDuration += _child2.treeBaseDuration;
                  _child2 = _child2.sibling;
                }
                completedWork.treeBaseDuration = _treeBaseDuration;
              } else {
                var _child3 = completedWork.child;
                while (_child3 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                  subtreeFlags |= _child3.subtreeFlags & StaticMask;
                  subtreeFlags |= _child3.flags & StaticMask;
                  _child3.return = completedWork;
                  _child3 = _child3.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            }
            completedWork.childLanes = newChildLanes;
            return didBailout;
          }
          function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
            if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
              warnIfUnhydratedTailNodes(workInProgress2);
              resetHydrationState();
              workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
              return false;
            }
            var wasHydrated = popHydrationState(workInProgress2);
            if (nextState !== null && nextState.dehydrated !== null) {
              if (current2 === null) {
                if (!wasHydrated) {
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                }
                prepareToHydrateHostSuspenseInstance(workInProgress2);
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var isTimedOutSuspense = nextState !== null;
                    if (isTimedOutSuspense) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              } else {
                resetHydrationState();
                if ((workInProgress2.flags & DidCapture) === NoFlags) {
                  workInProgress2.memoizedState = null;
                }
                workInProgress2.flags |= Update;
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var _isTimedOutSuspense = nextState !== null;
                    if (_isTimedOutSuspense) {
                      var _primaryChildFragment = workInProgress2.child;
                      if (_primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              }
            } else {
              upgradeHydrationErrorsToRecoverable();
              return true;
            }
          }
          function completeWork(current2, workInProgress2, renderLanes2) {
            var newProps = workInProgress2.pendingProps;
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case LazyComponent:
              case SimpleMemoComponent:
              case FunctionComponent:
              case ForwardRef10:
              case Fragment11:
              case Mode:
              case Profiler:
              case ContextConsumer:
              case MemoComponent:
                bubbleProperties(workInProgress2);
                return null;
              case ClassComponent: {
                var Component4 = workInProgress2.type;
                if (isContextProvider(Component4)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostRoot: {
                var fiberRoot = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }
                if (current2 === null || current2.child === null) {
                  var wasHydrated = popHydrationState(workInProgress2);
                  if (wasHydrated) {
                    markUpdate(workInProgress2);
                  } else {
                    if (current2 !== null) {
                      var prevState = current2.memoizedState;
                      if (
                        // Check if this is a client root
                        !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                        (workInProgress2.flags & ForceClientRender) !== NoFlags
                      ) {
                        workInProgress2.flags |= Snapshot;
                        upgradeHydrationErrorsToRecoverable();
                      }
                    }
                  }
                }
                updateHostContainer(current2, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress2.type;
                if (current2 !== null && workInProgress2.stateNode != null) {
                  updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                  if (current2.ref !== workInProgress2.ref) {
                    markRef$1(workInProgress2);
                  }
                } else {
                  if (!newProps) {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                  var currentHostContext = getHostContext();
                  var _wasHydrated = popHydrationState(workInProgress2);
                  if (_wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                    appendAllChildren(instance, workInProgress2, false, false);
                    workInProgress2.stateNode = instance;
                    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                      markUpdate(workInProgress2);
                    }
                  }
                  if (workInProgress2.ref !== null) {
                    markRef$1(workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostText: {
                var newText = newProps;
                if (current2 && workInProgress2.stateNode != null) {
                  var oldText = current2.memoizedProps;
                  updateHostText$1(current2, workInProgress2, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                  }
                  var _rootContainerInstance = getRootHostContainer();
                  var _currentHostContext = getHostContext();
                  var _wasHydrated2 = popHydrationState(workInProgress2);
                  if (_wasHydrated2) {
                    if (prepareToHydrateHostTextInstance(workInProgress2)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var nextState = workInProgress2.memoizedState;
                if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                  var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                  if (!fallthroughToNormalSuspensePath) {
                    if (workInProgress2.flags & ShouldCapture) {
                      return workInProgress2;
                    } else {
                      return null;
                    }
                  }
                }
                if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                  workInProgress2.lanes = renderLanes2;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
                if (nextDidTimeout !== prevDidTimeout) {
                  if (nextDidTimeout) {
                    var _offscreenFiber2 = workInProgress2.child;
                    _offscreenFiber2.flags |= Visibility;
                    if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                      var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                      if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                        renderDidSuspend();
                      } else {
                        renderDidSuspendDelayIfPossible();
                      }
                    }
                  }
                }
                var wakeables = workInProgress2.updateQueue;
                if (wakeables !== null) {
                  workInProgress2.flags |= Update;
                }
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    if (nextDidTimeout) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                updateHostContainer(current2, workInProgress2);
                if (current2 === null) {
                  preparePortalMount(workInProgress2.stateNode.containerInfo);
                }
                bubbleProperties(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              case IncompleteClassComponent: {
                var _Component = workInProgress2.type;
                if (isContextProvider(_Component)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                var renderState = workInProgress2.memoizedState;
                if (renderState === null) {
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                  if (!didSuspendAlready) {
                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                    if (!cannotBeSuspended) {
                      var row = workInProgress2.child;
                      while (row !== null) {
                        var suspended = findFirstSuspended(row);
                        if (suspended !== null) {
                          didSuspendAlready = true;
                          workInProgress2.flags |= DidCapture;
                          cutOffTailIfNeeded(renderState, false);
                          var newThenables = suspended.updateQueue;
                          if (newThenables !== null) {
                            workInProgress2.updateQueue = newThenables;
                            workInProgress2.flags |= Update;
                          }
                          workInProgress2.subtreeFlags = NoFlags;
                          resetChildFibers(workInProgress2, renderLanes2);
                          pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                          return workInProgress2.child;
                        }
                        row = row.sibling;
                      }
                    }
                    if (renderState.tail !== null && now() > getRenderTargetTime()) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  } else {
                    cutOffTailIfNeeded(renderState, false);
                  }
                } else {
                  if (!didSuspendAlready) {
                    var _suspended = findFirstSuspended(renderedTail);
                    if (_suspended !== null) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      var _newThenables = _suspended.updateQueue;
                      if (_newThenables !== null) {
                        workInProgress2.updateQueue = _newThenables;
                        workInProgress2.flags |= Update;
                      }
                      cutOffTailIfNeeded(renderState, true);
                      if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                        bubbleProperties(workInProgress2);
                        return null;
                      }
                    } else if (
                      // The time it took to render last row is greater than the remaining
                      // time we have to render. So rendering one more row would likely
                      // exceed it.
                      now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                    ) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  }
                  if (renderState.isBackwards) {
                    renderedTail.sibling = workInProgress2.child;
                    workInProgress2.child = renderedTail;
                  } else {
                    var previousSibling = renderState.last;
                    if (previousSibling !== null) {
                      previousSibling.sibling = renderedTail;
                    } else {
                      workInProgress2.child = renderedTail;
                    }
                    renderState.last = renderedTail;
                  }
                }
                if (renderState.tail !== null) {
                  var next = renderState.tail;
                  renderState.rendering = next;
                  renderState.tail = next.sibling;
                  renderState.renderingStartTime = now();
                  next.sibling = null;
                  var suspenseContext = suspenseStackCursor.current;
                  if (didSuspendAlready) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                  } else {
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                  }
                  pushSuspenseContext(workInProgress2, suspenseContext);
                  return next;
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                popRenderLanes(workInProgress2);
                var _nextState = workInProgress2.memoizedState;
                var nextIsHidden = _nextState !== null;
                if (current2 !== null) {
                  var _prevState = current2.memoizedState;
                  var prevIsHidden = _prevState !== null;
                  if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding  it only pre-renders.
                  !enableLegacyHidden) {
                    workInProgress2.flags |= Visibility;
                  }
                }
                if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                  bubbleProperties(workInProgress2);
                } else {
                  if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                    bubbleProperties(workInProgress2);
                    {
                      if (workInProgress2.subtreeFlags & (Placement | Update)) {
                        workInProgress2.flags |= Visibility;
                      }
                    }
                  }
                }
                return null;
              }
              case CacheComponent: {
                return null;
              }
              case TracingMarkerComponent: {
                return null;
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function unwindWork(current2, workInProgress2, renderLanes2) {
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case ClassComponent: {
                var Component4 = workInProgress2.type;
                if (isContextProvider(Component4)) {
                  popContext(workInProgress2);
                }
                var flags = workInProgress2.flags;
                if (flags & ShouldCapture) {
                  workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case HostRoot: {
                var root2 = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var _flags = workInProgress2.flags;
                if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                  workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                  return workInProgress2;
                }
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var suspenseState = workInProgress2.memoizedState;
                if (suspenseState !== null && suspenseState.dehydrated !== null) {
                  if (workInProgress2.alternate === null) {
                    throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                  }
                  resetHydrationState();
                }
                var _flags2 = workInProgress2.flags;
                if (_flags2 & ShouldCapture) {
                  workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                return null;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(workInProgress2);
                return null;
              case CacheComponent:
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
            popTreeContext(interruptedWork);
            switch (interruptedWork.tag) {
              case ClassComponent: {
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== void 0) {
                  popContext(interruptedWork);
                }
                break;
              }
              case HostRoot: {
                var root2 = interruptedWork.stateNode;
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
              }
              case HostComponent: {
                popHostContext(interruptedWork);
                break;
              }
              case HostPortal:
                popHostContainer(interruptedWork);
                break;
              case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
              case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
              case ContextProvider:
                var context = interruptedWork.type._context;
                popProvider(context, interruptedWork);
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
            }
          }
          var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          {
            didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
          }
          var offscreenSubtreeIsHidden = false;
          var offscreenSubtreeWasHidden = false;
          var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
          var nextEffect = null;
          var inProgressLanes = null;
          var inProgressRoot = null;
          function reportUncaughtErrorInDEV(error2) {
            {
              invokeGuardedCallback(null, function() {
                throw error2;
              });
              clearCaughtError();
            }
          }
          var callComponentWillUnmountWithTimer = function(current2, instance) {
            instance.props = current2.memoizedProps;
            instance.state = current2.memoizedState;
            if (current2.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                instance.componentWillUnmount();
              } finally {
                recordLayoutEffectDuration(current2);
              }
            } else {
              instance.componentWillUnmount();
            }
          };
          function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
            try {
              commitHookEffectListMount(Layout, current2);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
            try {
              callComponentWillUnmountWithTimer(current2, instance);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentDidMount();
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyAttachRef(current2, nearestMountedAncestor) {
            try {
              commitAttachRef(current2);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyDetachRef(current2, nearestMountedAncestor) {
            var ref = current2.ref;
            if (ref !== null) {
              if (typeof ref === "function") {
                var retVal;
                try {
                  if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      retVal = ref(null);
                    } finally {
                      recordLayoutEffectDuration(current2);
                    }
                  } else {
                    retVal = ref(null);
                  }
                } catch (error2) {
                  captureCommitPhaseError(current2, nearestMountedAncestor, error2);
                }
                {
                  if (typeof retVal === "function") {
                    error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                  }
                }
              } else {
                ref.current = null;
              }
            }
          }
          function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          var focusedInstanceHandle = null;
          var shouldFireAfterActiveInstanceBlur = false;
          function commitBeforeMutationEffects(root2, firstChild) {
            focusedInstanceHandle = prepareForCommit(root2.containerInfo);
            nextEffect = firstChild;
            commitBeforeMutationEffects_begin();
            var shouldFire = shouldFireAfterActiveInstanceBlur;
            shouldFireAfterActiveInstanceBlur = false;
            focusedInstanceHandle = null;
            return shouldFire;
          }
          function commitBeforeMutationEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitBeforeMutationEffects_complete();
              }
            }
          }
          function commitBeforeMutationEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                commitBeforeMutationEffectsOnFiber(fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitBeforeMutationEffectsOnFiber(finishedWork) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            if ((flags & Snapshot) !== NoFlags) {
              setCurrentFiber(finishedWork);
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef10:
                case SimpleMemoComponent: {
                  break;
                }
                case ClassComponent: {
                  if (current2 !== null) {
                    var prevProps = current2.memoizedProps;
                    var prevState = current2.memoizedState;
                    var instance = finishedWork.stateNode;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                    {
                      var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                      if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                        didWarnSet.add(finishedWork.type);
                        error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                      }
                    }
                    instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                  }
                  break;
                }
                case HostRoot: {
                  {
                    var root2 = finishedWork.stateNode;
                    clearContainer(root2.containerInfo);
                  }
                  break;
                }
                case HostComponent:
                case HostText:
                case HostPortal:
                case IncompleteClassComponent:
                  break;
                default: {
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              resetCurrentFiber();
            }
          }
          function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect4 = firstEffect;
              do {
                if ((effect4.tag & flags) === flags) {
                  var destroy = effect4.destroy;
                  effect4.destroy = void 0;
                  if (destroy !== void 0) {
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStarted(finishedWork);
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStarted(finishedWork);
                      }
                    }
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(true);
                      }
                    }
                    safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(false);
                      }
                    }
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStopped();
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStopped();
                      }
                    }
                  }
                }
                effect4 = effect4.next;
              } while (effect4 !== firstEffect);
            }
          }
          function commitHookEffectListMount(flags, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect4 = firstEffect;
              do {
                if ((effect4.tag & flags) === flags) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStarted(finishedWork);
                    }
                  }
                  var create = effect4.create;
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  effect4.destroy = create();
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStopped();
                    }
                  }
                  {
                    var destroy = effect4.destroy;
                    if (destroy !== void 0 && typeof destroy !== "function") {
                      var hookName = void 0;
                      if ((effect4.tag & Layout) !== NoFlags) {
                        hookName = "useLayoutEffect";
                      } else if ((effect4.tag & Insertion) !== NoFlags) {
                        hookName = "useInsertionEffect";
                      } else {
                        hookName = "useEffect";
                      }
                      var addendum = void 0;
                      if (destroy === null) {
                        addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                      } else if (typeof destroy.then === "function") {
                        addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                      } else {
                        addendum = " You returned: " + destroy;
                      }
                      error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                    }
                  }
                }
                effect4 = effect4.next;
              } while (effect4 !== firstEffect);
            }
          }
          function commitPassiveEffectDurations(finishedRoot, finishedWork) {
            {
              if ((finishedWork.flags & Update) !== NoFlags) {
                switch (finishedWork.tag) {
                  case Profiler: {
                    var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                    var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                    var commitTime2 = getCommitTime();
                    var phase = finishedWork.alternate === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onPostCommit === "function") {
                      onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                    }
                    var parentFiber = finishedWork.return;
                    outer: while (parentFiber !== null) {
                      switch (parentFiber.tag) {
                        case HostRoot:
                          var root2 = parentFiber.stateNode;
                          root2.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                        case Profiler:
                          var parentStateNode = parentFiber.stateNode;
                          parentStateNode.passiveEffectDuration += passiveEffectDuration;
                          break outer;
                      }
                      parentFiber = parentFiber.return;
                    }
                    break;
                  }
                }
              }
            }
          }
          function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
            if ((finishedWork.flags & LayoutMask) !== NoFlags) {
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef10:
                case SimpleMemoComponent: {
                  if (!offscreenSubtreeWasHidden) {
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        commitHookEffectListMount(Layout | HasEffect, finishedWork);
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    }
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = finishedWork.stateNode;
                  if (finishedWork.flags & Update) {
                    if (!offscreenSubtreeWasHidden) {
                      if (current2 === null) {
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidMount();
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidMount();
                        }
                      } else {
                        var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                        var prevState = current2.memoizedState;
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        }
                      }
                    }
                  }
                  var updateQueue = finishedWork.updateQueue;
                  if (updateQueue !== null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    commitUpdateQueue(finishedWork, updateQueue, instance);
                  }
                  break;
                }
                case HostRoot: {
                  var _updateQueue = finishedWork.updateQueue;
                  if (_updateQueue !== null) {
                    var _instance = null;
                    if (finishedWork.child !== null) {
                      switch (finishedWork.child.tag) {
                        case HostComponent:
                          _instance = getPublicInstance(finishedWork.child.stateNode);
                          break;
                        case ClassComponent:
                          _instance = finishedWork.child.stateNode;
                          break;
                      }
                    }
                    commitUpdateQueue(finishedWork, _updateQueue, _instance);
                  }
                  break;
                }
                case HostComponent: {
                  var _instance2 = finishedWork.stateNode;
                  if (current2 === null && finishedWork.flags & Update) {
                    var type = finishedWork.type;
                    var props = finishedWork.memoizedProps;
                    commitMount(_instance2, type, props);
                  }
                  break;
                }
                case HostText: {
                  break;
                }
                case HostPortal: {
                  break;
                }
                case Profiler: {
                  {
                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                    var effectDuration = finishedWork.stateNode.effectDuration;
                    var commitTime2 = getCommitTime();
                    var phase = current2 === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onRender === "function") {
                      onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                    }
                    {
                      if (typeof onCommit === "function") {
                        onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                      }
                      enqueuePendingPassiveProfilerEffect(finishedWork);
                      var parentFiber = finishedWork.return;
                      outer: while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root2 = parentFiber.stateNode;
                            root2.effectDuration += effectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.effectDuration += effectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                  break;
                }
                case SuspenseListComponent:
                case IncompleteClassComponent:
                case ScopeComponent:
                case OffscreenComponent:
                case LegacyHiddenComponent:
                case TracingMarkerComponent: {
                  break;
                }
                default:
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (!offscreenSubtreeWasHidden) {
              {
                if (finishedWork.flags & Ref) {
                  commitAttachRef(finishedWork);
                }
              }
            }
          }
          function reappearLayoutEffectsOnFiber(node) {
            switch (node.tag) {
              case FunctionComponent:
              case ForwardRef10:
              case SimpleMemoComponent: {
                if (node.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    safelyCallCommitHookLayoutEffectListMount(node, node.return);
                  } finally {
                    recordLayoutEffectDuration(node);
                  }
                } else {
                  safelyCallCommitHookLayoutEffectListMount(node, node.return);
                }
                break;
              }
              case ClassComponent: {
                var instance = node.stateNode;
                if (typeof instance.componentDidMount === "function") {
                  safelyCallComponentDidMount(node, node.return, instance);
                }
                safelyAttachRef(node, node.return);
                break;
              }
              case HostComponent: {
                safelyAttachRef(node, node.return);
                break;
              }
            }
          }
          function hideOrUnhideAllChildren(finishedWork, isHidden) {
            var hostSubtreeRoot = null;
            {
              var node = finishedWork;
              while (true) {
                if (node.tag === HostComponent) {
                  if (hostSubtreeRoot === null) {
                    hostSubtreeRoot = node;
                    try {
                      var instance = node.stateNode;
                      if (isHidden) {
                        hideInstance(instance);
                      } else {
                        unhideInstance(node.stateNode, node.memoizedProps);
                      }
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                } else if (node.tag === HostText) {
                  if (hostSubtreeRoot === null) {
                    try {
                      var _instance3 = node.stateNode;
                      if (isHidden) {
                        hideTextInstance(_instance3);
                      } else {
                        unhideTextInstance(_instance3, node.memoizedProps);
                      }
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === finishedWork) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === finishedWork) {
                    return;
                  }
                  if (hostSubtreeRoot === node) {
                    hostSubtreeRoot = null;
                  }
                  node = node.return;
                }
                if (hostSubtreeRoot === node) {
                  hostSubtreeRoot = null;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
          }
          function commitAttachRef(finishedWork) {
            var ref = finishedWork.ref;
            if (ref !== null) {
              var instance = finishedWork.stateNode;
              var instanceToUse;
              switch (finishedWork.tag) {
                case HostComponent:
                  instanceToUse = getPublicInstance(instance);
                  break;
                default:
                  instanceToUse = instance;
              }
              if (typeof ref === "function") {
                var retVal;
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(instanceToUse);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                } else {
                  retVal = ref(instanceToUse);
                }
                {
                  if (typeof retVal === "function") {
                    error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                  }
                }
              } else {
                {
                  if (!ref.hasOwnProperty("current")) {
                    error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                  }
                }
                ref.current = instanceToUse;
              }
            }
          }
          function detachFiberMutation(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.return = null;
            }
            fiber.return = null;
          }
          function detachFiberAfterEffects(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              fiber.alternate = null;
              detachFiberAfterEffects(alternate);
            }
            {
              fiber.child = null;
              fiber.deletions = null;
              fiber.sibling = null;
              if (fiber.tag === HostComponent) {
                var hostInstance = fiber.stateNode;
                if (hostInstance !== null) {
                  detachDeletedInstance(hostInstance);
                }
              }
              fiber.stateNode = null;
              {
                fiber._debugOwner = null;
              }
              {
                fiber.return = null;
                fiber.dependencies = null;
                fiber.memoizedProps = null;
                fiber.memoizedState = null;
                fiber.pendingProps = null;
                fiber.stateNode = null;
                fiber.updateQueue = null;
              }
            }
          }
          function getHostParentFiber(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
              if (isHostParent(parent)) {
                return parent;
              }
              parent = parent.return;
            }
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          }
          function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
          }
          function getHostSibling(fiber) {
            var node = fiber;
            siblings: while (true) {
              while (node.sibling === null) {
                if (node.return === null || isHostParent(node.return)) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
              while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                if (node.flags & Placement) {
                  continue siblings;
                }
                if (node.child === null || node.tag === HostPortal) {
                  continue siblings;
                } else {
                  node.child.return = node;
                  node = node.child;
                }
              }
              if (!(node.flags & Placement)) {
                return node.stateNode;
              }
            }
          }
          function commitPlacement(finishedWork) {
            var parentFiber = getHostParentFiber(finishedWork);
            switch (parentFiber.tag) {
              case HostComponent: {
                var parent = parentFiber.stateNode;
                if (parentFiber.flags & ContentReset) {
                  resetTextContent(parent);
                  parentFiber.flags &= ~ContentReset;
                }
                var before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              }
              case HostRoot:
              case HostPortal: {
                var _parent = parentFiber.stateNode.containerInfo;
                var _before = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
                break;
              }
              default:
                throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertInContainerBefore(parent, stateNode, before);
              } else {
                appendChildToContainer(parent, stateNode);
              }
            } else if (tag === HostPortal) ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function insertOrAppendPlacementNode(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertBefore(parent, stateNode, before);
              } else {
                appendChild(parent, stateNode);
              }
            } else if (tag === HostPortal) ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNode(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          var hostParent = null;
          var hostParentIsContainer = false;
          function commitDeletionEffects(root2, returnFiber, deletedFiber) {
            {
              var parent = returnFiber;
              findParent: while (parent !== null) {
                switch (parent.tag) {
                  case HostComponent: {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break findParent;
                  }
                  case HostRoot: {
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                  case HostPortal: {
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break findParent;
                  }
                }
                parent = parent.return;
              }
              if (hostParent === null) {
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              }
              commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
            }
            detachFiberMutation(deletedFiber);
          }
          function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
            var child = parent.child;
            while (child !== null) {
              commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
              child = child.sibling;
            }
          }
          function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
            onCommitUnmount(deletedFiber);
            switch (deletedFiber.tag) {
              case HostComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                }
              }
              case HostText: {
                {
                  var prevHostParent = hostParent;
                  var prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = prevHostParent;
                  hostParentIsContainer = prevHostParentIsContainer;
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      removeChildFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      removeChild(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case DehydratedFragment: {
                {
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                {
                  var _prevHostParent = hostParent;
                  var _prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = deletedFiber.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = _prevHostParent;
                  hostParentIsContainer = _prevHostParentIsContainer;
                }
                return;
              }
              case FunctionComponent:
              case ForwardRef10:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  var updateQueue = deletedFiber.updateQueue;
                  if (updateQueue !== null) {
                    var lastEffect = updateQueue.lastEffect;
                    if (lastEffect !== null) {
                      var firstEffect = lastEffect.next;
                      var effect4 = firstEffect;
                      do {
                        var _effect = effect4, destroy = _effect.destroy, tag = _effect.tag;
                        if (destroy !== void 0) {
                          if ((tag & Insertion) !== NoFlags$1) {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          } else if ((tag & Layout) !== NoFlags$1) {
                            {
                              markComponentLayoutEffectUnmountStarted(deletedFiber);
                            }
                            if (deletedFiber.mode & ProfileMode) {
                              startLayoutEffectTimer();
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                              recordLayoutEffectDuration(deletedFiber);
                            } else {
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            }
                            {
                              markComponentLayoutEffectUnmountStopped();
                            }
                          }
                        }
                        effect4 = effect4.next;
                      } while (effect4 !== firstEffect);
                    }
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ClassComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                  var instance = deletedFiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ScopeComponent: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case OffscreenComponent: {
                if (
                  // TODO: Remove this dead flag
                  deletedFiber.mode & ConcurrentMode
                ) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                }
                break;
              }
              default: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
            }
          }
          function commitSuspenseCallback(finishedWork) {
            var newState = finishedWork.memoizedState;
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState === null) {
              var current2 = finishedWork.alternate;
              if (current2 !== null) {
                var prevState = current2.memoizedState;
                if (prevState !== null) {
                  var suspenseInstance = prevState.dehydrated;
                  if (suspenseInstance !== null) {
                    commitHydratedSuspenseInstance(suspenseInstance);
                  }
                }
              }
            }
          }
          function attachSuspenseRetryListeners(finishedWork) {
            var wakeables = finishedWork.updateQueue;
            if (wakeables !== null) {
              finishedWork.updateQueue = null;
              var retryCache = finishedWork.stateNode;
              if (retryCache === null) {
                retryCache = finishedWork.stateNode = new PossiblyWeakSet();
              }
              wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                  retryCache.add(wakeable);
                  {
                    if (isDevToolsPresent) {
                      if (inProgressLanes !== null && inProgressRoot !== null) {
                        restorePendingUpdaters(inProgressRoot, inProgressLanes);
                      } else {
                        throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                      }
                    }
                  }
                  wakeable.then(retry, retry);
                }
              });
            }
          }
          function commitMutationEffects(root2, finishedWork, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root2;
            setCurrentFiber(finishedWork);
            commitMutationEffectsOnFiber(finishedWork, root2);
            setCurrentFiber(finishedWork);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {
            var deletions = parentFiber.deletions;
            if (deletions !== null) {
              for (var i5 = 0; i5 < deletions.length; i5++) {
                var childToDelete = deletions[i5];
                try {
                  commitDeletionEffects(root2, parentFiber, childToDelete);
                } catch (error2) {
                  captureCommitPhaseError(childToDelete, parentFiber, error2);
                }
              }
            }
            var prevDebugFiber = getCurrentFiber();
            if (parentFiber.subtreeFlags & MutationMask) {
              var child = parentFiber.child;
              while (child !== null) {
                setCurrentFiber(child);
                commitMutationEffectsOnFiber(child, root2);
                child = child.sibling;
              }
            }
            setCurrentFiber(prevDebugFiber);
          }
          function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef10:
              case MemoComponent:
              case SimpleMemoComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  try {
                    commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                    commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                    recordLayoutEffectDuration(finishedWork);
                  } else {
                    try {
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
                return;
              }
              case ClassComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                return;
              }
              case HostComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                {
                  if (finishedWork.flags & ContentReset) {
                    var instance = finishedWork.stateNode;
                    try {
                      resetTextContent(instance);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                  if (flags & Update) {
                    var _instance4 = finishedWork.stateNode;
                    if (_instance4 != null) {
                      var newProps = finishedWork.memoizedProps;
                      var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                      var type = finishedWork.type;
                      var updatePayload = finishedWork.updateQueue;
                      finishedWork.updateQueue = null;
                      if (updatePayload !== null) {
                        try {
                          commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                        } catch (error2) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostText: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (finishedWork.stateNode === null) {
                      throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    var textInstance = finishedWork.stateNode;
                    var newText = finishedWork.memoizedProps;
                    var oldText = current2 !== null ? current2.memoizedProps : newText;
                    try {
                      commitTextUpdate(textInstance, oldText, newText);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
                return;
              }
              case HostRoot: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (current2 !== null) {
                      var prevRootState = current2.memoizedState;
                      if (prevRootState.isDehydrated) {
                        try {
                          commitHydratedContainer(root2.containerInfo);
                        } catch (error2) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
              case SuspenseComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                var offscreenFiber = finishedWork.child;
                if (offscreenFiber.flags & Visibility) {
                  var offscreenInstance = offscreenFiber.stateNode;
                  var newState = offscreenFiber.memoizedState;
                  var isHidden = newState !== null;
                  offscreenInstance.isHidden = isHidden;
                  if (isHidden) {
                    var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                    if (!wasHidden) {
                      markCommitTimeOfFallback();
                    }
                  }
                }
                if (flags & Update) {
                  try {
                    commitSuspenseCallback(finishedWork);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case OffscreenComponent: {
                var _wasHidden = current2 !== null && current2.memoizedState !== null;
                if (
                  // TODO: Remove this dead flag
                  finishedWork.mode & ConcurrentMode
                ) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                }
                commitReconciliationEffects(finishedWork);
                if (flags & Visibility) {
                  var _offscreenInstance = finishedWork.stateNode;
                  var _newState = finishedWork.memoizedState;
                  var _isHidden = _newState !== null;
                  var offscreenBoundary = finishedWork;
                  _offscreenInstance.isHidden = _isHidden;
                  {
                    if (_isHidden) {
                      if (!_wasHidden) {
                        if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                          nextEffect = offscreenBoundary;
                          var offscreenChild = offscreenBoundary.child;
                          while (offscreenChild !== null) {
                            nextEffect = offscreenChild;
                            disappearLayoutEffects_begin(offscreenChild);
                            offscreenChild = offscreenChild.sibling;
                          }
                        }
                      }
                    }
                  }
                  {
                    hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                  }
                }
                return;
              }
              case SuspenseListComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case ScopeComponent: {
                return;
              }
              default: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
            }
          }
          function commitReconciliationEffects(finishedWork) {
            var flags = finishedWork.flags;
            if (flags & Placement) {
              try {
                commitPlacement(finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              finishedWork.flags &= ~Placement;
            }
            if (flags & Hydrating) {
              finishedWork.flags &= ~Hydrating;
            }
          }
          function commitLayoutEffects(finishedWork, root2, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root2;
            nextEffect = finishedWork;
            commitLayoutEffects_begin(finishedWork, root2, committedLanes);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {
            var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent && isModernRoot) {
                var isHidden = fiber.memoizedState !== null;
                var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
                if (newOffscreenSubtreeIsHidden) {
                  commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                  continue;
                } else {
                  var current2 = fiber.alternate;
                  var wasHidden = current2 !== null && current2.memoizedState !== null;
                  var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                  var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                  if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                    nextEffect = fiber;
                    reappearLayoutEffects_begin(fiber);
                  }
                  var child = firstChild;
                  while (child !== null) {
                    nextEffect = child;
                    commitLayoutEffects_begin(
                      child,
                      // New root; bubble back up to here and stop.
                      root2,
                      committedLanes
                    );
                    child = child.sibling;
                  }
                  nextEffect = fiber;
                  offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                  commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                  continue;
                }
              }
              if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
              }
            }
          }
          function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & LayoutMask) !== NoFlags) {
                var current2 = fiber.alternate;
                setCurrentFiber(fiber);
                try {
                  commitLayoutEffectOnFiber(root2, current2, fiber, committedLanes);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function disappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef10:
                case MemoComponent:
                case SimpleMemoComponent: {
                  if (fiber.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout, fiber, fiber.return);
                    } finally {
                      recordLayoutEffectDuration(fiber);
                    }
                  } else {
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  }
                  break;
                }
                case ClassComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
                case HostComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  break;
                }
                case OffscreenComponent: {
                  var isHidden = fiber.memoizedState !== null;
                  if (isHidden) {
                    disappearLayoutEffects_complete(subtreeRoot);
                    continue;
                  }
                  break;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                disappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function disappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function reappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent) {
                var isHidden = fiber.memoizedState !== null;
                if (isHidden) {
                  reappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                reappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function reappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                reappearLayoutEffectsOnFiber(fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {
            nextEffect = finishedWork;
            commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);
          }
          function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);
              }
            }
          }
          function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                try {
                  commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef10:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                  } finally {
                    recordPassiveEffectDuration(finishedWork);
                  }
                } else {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffects(firstChild) {
            nextEffect = firstChild;
            commitPassiveUnmountEffects_begin();
          }
          function commitPassiveUnmountEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
                var deletions = fiber.deletions;
                if (deletions !== null) {
                  for (var i5 = 0; i5 < deletions.length; i5++) {
                    var fiberToDelete = deletions[i5];
                    nextEffect = fiberToDelete;
                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                  }
                  {
                    var previousFiber = fiber.alternate;
                    if (previousFiber !== null) {
                      var detachedChild = previousFiber.child;
                      if (detachedChild !== null) {
                        previousFiber.child = null;
                        do {
                          var detachedSibling = detachedChild.sibling;
                          detachedChild.sibling = null;
                          detachedChild = detachedSibling;
                        } while (detachedChild !== null);
                      }
                    }
                  }
                  nextEffect = fiber;
                }
              }
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffects_complete();
              }
            }
          }
          function commitPassiveUnmountEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                commitPassiveUnmountOnFiber(fiber);
                resetCurrentFiber();
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveUnmountOnFiber(finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef10:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                  recordPassiveEffectDuration(finishedWork);
                } else {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
              resetCurrentFiber();
              var child = fiber.child;
              if (child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var sibling = fiber.sibling;
              var returnFiber = fiber.return;
              {
                detachFiberAfterEffects(fiber);
                if (fiber === deletedSubtreeRoot) {
                  nextEffect = null;
                  return;
                }
              }
              if (sibling !== null) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                return;
              }
              nextEffect = returnFiber;
            }
          }
          function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
            switch (current2.tag) {
              case FunctionComponent:
              case ForwardRef10:
              case SimpleMemoComponent: {
                if (current2.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                  recordPassiveEffectDuration(current2);
                } else {
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                }
                break;
              }
            }
          }
          function invokeLayoutEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef10:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Layout | HasEffect, fiber);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  try {
                    instance.componentDidMount();
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef10:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
              }
            }
          }
          function invokeLayoutEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef10:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef10:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                }
              }
            }
          }
          var COMPONENT_TYPE = 0;
          var HAS_PSEUDO_CLASS_TYPE = 1;
          var ROLE_TYPE = 2;
          var TEST_NAME_TYPE = 3;
          var TEXT_TYPE = 4;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            COMPONENT_TYPE = symbolFor("selector.component");
            HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
            ROLE_TYPE = symbolFor("selector.role");
            TEST_NAME_TYPE = symbolFor("selector.test_id");
            TEXT_TYPE = symbolFor("selector.text");
          }
          var commitHooks = [];
          function onCommitRoot$1() {
            {
              commitHooks.forEach(function(commitHook) {
                return commitHook();
              });
            }
          }
          var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
          function isLegacyActEnvironment(fiber) {
            {
              var isReactActEnvironmentGlobal = (
                // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
                typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
              );
              var jestIsDefined = typeof jest !== "undefined";
              return jestIsDefined && isReactActEnvironmentGlobal !== false;
            }
          }
          function isConcurrentActEnvironment() {
            {
              var isReactActEnvironmentGlobal = (
                // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
                typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
              );
              if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
                error("The current testing environment is not configured to support act(...)");
              }
              return isReactActEnvironmentGlobal;
            }
          }
          var ceil = Math.ceil;
          var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
          var NoContext = (
            /*             */
            0
          );
          var BatchedContext = (
            /*               */
            1
          );
          var RenderContext = (
            /*                */
            2
          );
          var CommitContext = (
            /*                */
            4
          );
          var RootInProgress = 0;
          var RootFatalErrored = 1;
          var RootErrored = 2;
          var RootSuspended = 3;
          var RootSuspendedWithDelay = 4;
          var RootCompleted = 5;
          var RootDidNotComplete = 6;
          var executionContext = NoContext;
          var workInProgressRoot = null;
          var workInProgress = null;
          var workInProgressRootRenderLanes = NoLanes;
          var subtreeRenderLanes = NoLanes;
          var subtreeRenderLanesCursor = createCursor(NoLanes);
          var workInProgressRootExitStatus = RootInProgress;
          var workInProgressRootFatalError = null;
          var workInProgressRootIncludedLanes = NoLanes;
          var workInProgressRootSkippedLanes = NoLanes;
          var workInProgressRootInterleavedUpdatedLanes = NoLanes;
          var workInProgressRootPingedLanes = NoLanes;
          var workInProgressRootConcurrentErrors = null;
          var workInProgressRootRecoverableErrors = null;
          var globalMostRecentFallbackTime = 0;
          var FALLBACK_THROTTLE_MS = 500;
          var workInProgressRootRenderTargetTime = Infinity;
          var RENDER_TIMEOUT_MS = 500;
          var workInProgressTransitions = null;
          function resetRenderTimer() {
            workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
          }
          function getRenderTargetTime() {
            return workInProgressRootRenderTargetTime;
          }
          var hasUncaughtError = false;
          var firstUncaughtError = null;
          var legacyErrorBoundariesThatAlreadyFailed = null;
          var rootDoesHavePassiveEffects = false;
          var rootWithPendingPassiveEffects = null;
          var pendingPassiveEffectsLanes = NoLanes;
          var pendingPassiveProfilerEffects = [];
          var pendingPassiveTransitions = null;
          var NESTED_UPDATE_LIMIT = 50;
          var nestedUpdateCount = 0;
          var rootWithNestedUpdates = null;
          var isFlushingPassiveEffects = false;
          var didScheduleUpdateDuringPassiveEffects = false;
          var NESTED_PASSIVE_UPDATE_LIMIT = 50;
          var nestedPassiveUpdateCount = 0;
          var rootWithPassiveNestedUpdates = null;
          var currentEventTime = NoTimestamp;
          var currentEventTransitionLane = NoLanes;
          var isRunningInsertionEffect = false;
          function getWorkInProgressRoot() {
            return workInProgressRoot;
          }
          function requestEventTime() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              return now();
            }
            if (currentEventTime !== NoTimestamp) {
              return currentEventTime;
            }
            currentEventTime = now();
            return currentEventTime;
          }
          function requestUpdateLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
              return pickArbitraryLane(workInProgressRootRenderLanes);
            }
            var isTransition = requestCurrentTransition() !== NoTransition;
            if (isTransition) {
              if (ReactCurrentBatchConfig$3.transition !== null) {
                var transition = ReactCurrentBatchConfig$3.transition;
                if (!transition._updatedFibers) {
                  transition._updatedFibers = /* @__PURE__ */ new Set();
                }
                transition._updatedFibers.add(fiber);
              }
              if (currentEventTransitionLane === NoLane) {
                currentEventTransitionLane = claimNextTransitionLane();
              }
              return currentEventTransitionLane;
            }
            var updateLane = getCurrentUpdatePriority();
            if (updateLane !== NoLane) {
              return updateLane;
            }
            var eventLane = getCurrentEventPriority();
            return eventLane;
          }
          function requestRetryLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            }
            return claimNextRetryLane();
          }
          function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {
            checkForNestedUpdates();
            {
              if (isRunningInsertionEffect) {
                error("useInsertionEffect must not schedule updates.");
              }
            }
            {
              if (isFlushingPassiveEffects) {
                didScheduleUpdateDuringPassiveEffects = true;
              }
            }
            markRootUpdated(root2, lane, eventTime);
            if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {
              warnAboutRenderPhaseUpdatesInDEV(fiber);
            } else {
              {
                if (isDevToolsPresent) {
                  addFiberToLanesMap(root2, fiber, lane);
                }
              }
              warnIfUpdatesNotWrappedWithActDEV(fiber);
              if (root2 === workInProgressRoot) {
                if ((executionContext & RenderContext) === NoContext) {
                  workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
                }
                if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                  markRootSuspended$1(root2, workInProgressRootRenderLanes);
                }
              }
              ensureRootIsScheduled(root2, eventTime);
              if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
              !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {
            var current2 = root2.current;
            current2.lanes = lane;
            markRootUpdated(root2, lane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
          }
          function isUnsafeClassRenderPhaseUpdate(fiber) {
            return (
              // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
              // decided not to enable it.
              (executionContext & RenderContext) !== NoContext
            );
          }
          function ensureRootIsScheduled(root2, currentTime) {
            var existingCallbackNode = root2.callbackNode;
            markStarvedLanesAsExpired(root2, currentTime);
            var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (nextLanes === NoLanes) {
              if (existingCallbackNode !== null) {
                cancelCallback$1(existingCallbackNode);
              }
              root2.callbackNode = null;
              root2.callbackPriority = NoLane;
              return;
            }
            var newCallbackPriority = getHighestPriorityLane(nextLanes);
            var existingCallbackPriority = root2.callbackPriority;
            if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
            // Scheduler task, rather than an `act` task, cancel it and re-scheduled
            // on the `act` queue.
            !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
              {
                if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                  error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              return;
            }
            if (existingCallbackNode != null) {
              cancelCallback$1(existingCallbackNode);
            }
            var newCallbackNode;
            if (newCallbackPriority === SyncLane) {
              if (root2.tag === LegacyRoot) {
                if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                  ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
                }
                scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));
              } else {
                scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
              }
              {
                if (ReactCurrentActQueue$1.current !== null) {
                  ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
                } else {
                  scheduleMicrotask(function() {
                    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                      flushSyncCallbacks();
                    }
                  });
                }
              }
              newCallbackNode = null;
            } else {
              var schedulerPriorityLevel;
              switch (lanesToEventPriority(nextLanes)) {
                case DiscreteEventPriority:
                  schedulerPriorityLevel = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriorityLevel = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriorityLevel = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriorityLevel = IdlePriority;
                  break;
                default:
                  schedulerPriorityLevel = NormalPriority;
                  break;
              }
              newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
            }
            root2.callbackPriority = newCallbackPriority;
            root2.callbackNode = newCallbackNode;
          }
          function performConcurrentWorkOnRoot(root2, didTimeout) {
            {
              resetNestedUpdateFlag();
            }
            currentEventTime = NoTimestamp;
            currentEventTransitionLane = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var originalCallbackNode = root2.callbackNode;
            var didFlushPassiveEffects = flushPassiveEffects();
            if (didFlushPassiveEffects) {
              if (root2.callbackNode !== originalCallbackNode) {
                return null;
              }
            }
            var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (lanes === NoLanes) {
              return null;
            }
            var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;
            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);
            if (exitStatus !== RootInProgress) {
              if (exitStatus === RootErrored) {
                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                if (errorRetryLanes !== NoLanes) {
                  lanes = errorRetryLanes;
                  exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root2, NoLanes);
                markRootSuspended$1(root2, lanes);
                ensureRootIsScheduled(root2, now());
                throw fatalError;
              }
              if (exitStatus === RootDidNotComplete) {
                markRootSuspended$1(root2, lanes);
              } else {
                var renderWasConcurrent = !includesBlockingLane(root2, lanes);
                var finishedWork = root2.current.alternate;
                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                  exitStatus = renderRootSync(root2, lanes);
                  if (exitStatus === RootErrored) {
                    var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                    if (_errorRetryLanes !== NoLanes) {
                      lanes = _errorRetryLanes;
                      exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);
                    }
                  }
                  if (exitStatus === RootFatalErrored) {
                    var _fatalError = workInProgressRootFatalError;
                    prepareFreshStack(root2, NoLanes);
                    markRootSuspended$1(root2, lanes);
                    ensureRootIsScheduled(root2, now());
                    throw _fatalError;
                  }
                }
                root2.finishedWork = finishedWork;
                root2.finishedLanes = lanes;
                finishConcurrentRender(root2, exitStatus, lanes);
              }
            }
            ensureRootIsScheduled(root2, now());
            if (root2.callbackNode === originalCallbackNode) {
              return performConcurrentWorkOnRoot.bind(null, root2);
            }
            return null;
          }
          function recoverFromConcurrentError(root2, errorRetryLanes) {
            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
            if (isRootDehydrated(root2)) {
              var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);
              rootWorkInProgress.flags |= ForceClientRender;
              {
                errorHydratingContainer(root2.containerInfo);
              }
            }
            var exitStatus = renderRootSync(root2, errorRetryLanes);
            if (exitStatus !== RootErrored) {
              var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
              if (errorsFromSecondAttempt !== null) {
                queueRecoverableErrors(errorsFromSecondAttempt);
              }
            }
            return exitStatus;
          }
          function queueRecoverableErrors(errors) {
            if (workInProgressRootRecoverableErrors === null) {
              workInProgressRootRecoverableErrors = errors;
            } else {
              workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
            }
          }
          function finishConcurrentRender(root2, exitStatus, lanes) {
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored: {
                throw new Error("Root did not complete. This is a bug in React.");
              }
              case RootErrored: {
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspended: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
                !shouldForceFlushFallbacksInDEV()) {
                  var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
                  if (msUntilTimeout > 10) {
                    var nextLanes = getNextLanes(root2, NoLanes);
                    if (nextLanes !== NoLanes) {
                      break;
                    }
                    var suspendedLanes = root2.suspendedLanes;
                    if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                      var eventTime = requestEventTime();
                      markRootPinged(root2, suspendedLanes);
                      break;
                    }
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspendedWithDelay: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyTransitions(lanes)) {
                  break;
                }
                if (!shouldForceFlushFallbacksInDEV()) {
                  var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
                  var eventTimeMs = mostRecentEventTime;
                  var timeElapsedMs = now() - eventTimeMs;
                  var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                  if (_msUntilTimeout > 10) {
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootCompleted: {
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              default: {
                throw new Error("Unknown root exit status.");
              }
            }
          }
          function isRenderConsistentWithExternalStores(finishedWork) {
            var node = finishedWork;
            while (true) {
              if (node.flags & StoreConsistency) {
                var updateQueue = node.updateQueue;
                if (updateQueue !== null) {
                  var checks = updateQueue.stores;
                  if (checks !== null) {
                    for (var i5 = 0; i5 < checks.length; i5++) {
                      var check = checks[i5];
                      var getSnapshot = check.getSnapshot;
                      var renderedValue = check.value;
                      try {
                        if (!objectIs(getSnapshot(), renderedValue)) {
                          return false;
                        }
                      } catch (error2) {
                        return false;
                      }
                    }
                  }
                }
              }
              var child = node.child;
              if (node.subtreeFlags & StoreConsistency && child !== null) {
                child.return = node;
                node = child;
                continue;
              }
              if (node === finishedWork) {
                return true;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return true;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return true;
          }
          function markRootSuspended$1(root2, suspendedLanes) {
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
            markRootSuspended(root2, suspendedLanes);
          }
          function performSyncWorkOnRoot(root2) {
            {
              syncNestedUpdateFlag();
            }
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            flushPassiveEffects();
            var lanes = getNextLanes(root2, NoLanes);
            if (!includesSomeLane(lanes, SyncLane)) {
              ensureRootIsScheduled(root2, now());
              return null;
            }
            var exitStatus = renderRootSync(root2, lanes);
            if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root2, NoLanes);
              markRootSuspended$1(root2, lanes);
              ensureRootIsScheduled(root2, now());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            var finishedWork = root2.current.alternate;
            root2.finishedWork = finishedWork;
            root2.finishedLanes = lanes;
            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
            ensureRootIsScheduled(root2, now());
            return null;
          }
          function flushRoot(root2, lanes) {
            if (lanes !== NoLanes) {
              markRootEntangled(root2, mergeLanes(lanes, SyncLane));
              ensureRootIsScheduled(root2, now());
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                resetRenderTimer();
                flushSyncCallbacks();
              }
            }
          }
          function batchedUpdates$1(fn2, a3) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return fn2(a3);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
              !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function discreteUpdates(fn2, a3, b2, c3, d5) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              return fn2(a3, b2, c3, d5);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              if (executionContext === NoContext) {
                resetRenderTimer();
              }
            }
          }
          function flushSync3(fn2) {
            if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushPassiveEffects();
            }
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              if (fn2) {
                return fn2();
              } else {
                return void 0;
              }
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              executionContext = prevExecutionContext;
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                flushSyncCallbacks();
              }
            }
          }
          function isAlreadyRendering() {
            return (executionContext & (RenderContext | CommitContext)) !== NoContext;
          }
          function pushRenderLanes(fiber, lanes) {
            push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
          }
          function popRenderLanes(fiber) {
            subtreeRenderLanes = subtreeRenderLanesCursor.current;
            pop(subtreeRenderLanesCursor, fiber);
          }
          function prepareFreshStack(root2, lanes) {
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            var timeoutHandle = root2.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
              root2.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
              var interruptedWork = workInProgress.return;
              while (interruptedWork !== null) {
                var current2 = interruptedWork.alternate;
                unwindInterruptedWork(current2, interruptedWork);
                interruptedWork = interruptedWork.return;
              }
            }
            workInProgressRoot = root2;
            var rootWorkInProgress = createWorkInProgress(root2.current, null);
            workInProgress = rootWorkInProgress;
            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
            workInProgressRootExitStatus = RootInProgress;
            workInProgressRootFatalError = null;
            workInProgressRootSkippedLanes = NoLanes;
            workInProgressRootInterleavedUpdatedLanes = NoLanes;
            workInProgressRootPingedLanes = NoLanes;
            workInProgressRootConcurrentErrors = null;
            workInProgressRootRecoverableErrors = null;
            finishQueueingConcurrentUpdates();
            {
              ReactStrictModeWarnings.discardPendingWarnings();
            }
            return rootWorkInProgress;
          }
          function handleError(root2, thrownValue) {
            do {
              var erroredWork = workInProgress;
              try {
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber();
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                  workInProgressRootExitStatus = RootFatalErrored;
                  workInProgressRootFatalError = thrownValue;
                  workInProgress = null;
                  return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                }
                if (enableSchedulingProfiler) {
                  markComponentRenderStopped();
                  if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                    var wakeable = thrownValue;
                    markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                  } else {
                    markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                  }
                }
                throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
              } catch (yetAnotherThrownValue) {
                thrownValue = yetAnotherThrownValue;
                if (workInProgress === erroredWork && erroredWork !== null) {
                  erroredWork = erroredWork.return;
                  workInProgress = erroredWork;
                } else {
                  erroredWork = workInProgress;
                }
                continue;
              }
              return;
            } while (true);
          }
          function pushDispatcher() {
            var prevDispatcher = ReactCurrentDispatcher$2.current;
            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
              return ContextOnlyDispatcher;
            } else {
              return prevDispatcher;
            }
          }
          function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$2.current = prevDispatcher;
          }
          function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now();
          }
          function markSkippedUpdateLanes(lane) {
            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
          }
          function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootSuspended;
            }
          }
          function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
              workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
              markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
            }
          }
          function renderDidError(error2) {
            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
              workInProgressRootExitStatus = RootErrored;
            }
            if (workInProgressRootConcurrentErrors === null) {
              workInProgressRootConcurrentErrors = [error2];
            } else {
              workInProgressRootConcurrentErrors.push(error2);
            }
          }
          function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootInProgress;
          }
          function renderRootSync(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root2.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root2, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              prepareFreshStack(root2, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopSync();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            executionContext = prevExecutionContext;
            popDispatcher(prevDispatcher);
            if (workInProgress !== null) {
              throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
          function workLoopSync() {
            while (workInProgress !== null) {
              performUnitOfWork(workInProgress);
            }
          }
          function renderRootConcurrent(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root2.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root2, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              resetRenderTimer();
              prepareFreshStack(root2, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopConcurrent();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            popDispatcher(prevDispatcher);
            executionContext = prevExecutionContext;
            if (workInProgress !== null) {
              {
                markRenderYielded();
              }
              return RootInProgress;
            } else {
              {
                markRenderStopped();
              }
              workInProgressRoot = null;
              workInProgressRootRenderLanes = NoLanes;
              return workInProgressRootExitStatus;
            }
          }
          function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
              performUnitOfWork(workInProgress);
            }
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            setCurrentFiber(unitOfWork);
            var next;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              startProfilerTimer(unitOfWork);
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            } else {
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next === null) {
              completeUnitOfWork(unitOfWork);
            } else {
              workInProgress = next;
            }
            ReactCurrentOwner$2.current = null;
          }
          function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
              var current2 = completedWork.alternate;
              var returnFiber = completedWork.return;
              if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) {
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                } else {
                  startProfilerTimer(completedWork);
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next !== null) {
                  workInProgress = next;
                  return;
                }
              } else {
                var _next = unwindWork(current2, completedWork);
                if (_next !== null) {
                  _next.flags &= HostEffectMask;
                  workInProgress = _next;
                  return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                  var actualDuration = completedWork.actualDuration;
                  var child = completedWork.child;
                  while (child !== null) {
                    actualDuration += child.actualDuration;
                    child = child.sibling;
                  }
                  completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                  returnFiber.flags |= Incomplete;
                  returnFiber.subtreeFlags = NoFlags;
                  returnFiber.deletions = null;
                } else {
                  workInProgressRootExitStatus = RootDidNotComplete;
                  workInProgress = null;
                  return;
                }
              }
              var siblingFiber = completedWork.sibling;
              if (siblingFiber !== null) {
                workInProgress = siblingFiber;
                return;
              }
              completedWork = returnFiber;
              workInProgress = completedWork;
            } while (completedWork !== null);
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootCompleted;
            }
          }
          function commitRoot(root2, recoverableErrors, transitions) {
            var previousUpdateLanePriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);
            } finally {
              ReactCurrentBatchConfig$3.transition = prevTransition;
              setCurrentUpdatePriority(previousUpdateLanePriority);
            }
            return null;
          }
          function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {
            do {
              flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var finishedWork = root2.finishedWork;
            var lanes = root2.finishedLanes;
            {
              markCommitStarted(lanes);
            }
            if (finishedWork === null) {
              {
                markCommitStopped();
              }
              return null;
            } else {
              {
                if (lanes === NoLanes) {
                  error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
                }
              }
            }
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            if (finishedWork === root2.current) {
              throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
            }
            root2.callbackNode = null;
            root2.callbackPriority = NoLane;
            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
            markRootFinished(root2, remainingLanes);
            if (root2 === workInProgressRoot) {
              workInProgressRoot = null;
              workInProgress = null;
              workInProgressRootRenderLanes = NoLanes;
            }
            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                pendingPassiveTransitions = transitions;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            if (subtreeHasEffects || rootHasEffect) {
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              ReactCurrentBatchConfig$3.transition = null;
              var previousPriority = getCurrentUpdatePriority();
              setCurrentUpdatePriority(DiscreteEventPriority);
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              ReactCurrentOwner$2.current = null;
              var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root2, finishedWork);
              {
                recordCommitTime();
              }
              commitMutationEffects(root2, finishedWork, lanes);
              resetAfterCommit(root2.containerInfo);
              root2.current = finishedWork;
              {
                markLayoutEffectsStarted(lanes);
              }
              commitLayoutEffects(finishedWork, root2, lanes);
              {
                markLayoutEffectsStopped();
              }
              requestPaint();
              executionContext = prevExecutionContext;
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            } else {
              root2.current = finishedWork;
              {
                recordCommitTime();
              }
            }
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = false;
              rootWithPendingPassiveEffects = root2;
              pendingPassiveEffectsLanes = lanes;
            } else {
              {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
              }
            }
            remainingLanes = root2.pendingLanes;
            if (remainingLanes === NoLanes) {
              legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
              if (!rootDidHavePassiveEffects) {
                commitDoubleInvokeEffectsInDEV(root2.current, false);
              }
            }
            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
            {
              if (isDevToolsPresent) {
                root2.memoizedUpdaters.clear();
              }
            }
            {
              onCommitRoot$1();
            }
            ensureRootIsScheduled(root2, now());
            if (recoverableErrors !== null) {
              var onRecoverableError = root2.onRecoverableError;
              for (var i5 = 0; i5 < recoverableErrors.length; i5++) {
                var recoverableError = recoverableErrors[i5];
                var componentStack = recoverableError.stack;
                var digest = recoverableError.digest;
                onRecoverableError(recoverableError.value, {
                  componentStack,
                  digest
                });
              }
            }
            if (hasUncaughtError) {
              hasUncaughtError = false;
              var error$1 = firstUncaughtError;
              firstUncaughtError = null;
              throw error$1;
            }
            if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {
              flushPassiveEffects();
            }
            remainingLanes = root2.pendingLanes;
            if (includesSomeLane(remainingLanes, SyncLane)) {
              {
                markNestedUpdateScheduled();
              }
              if (root2 === rootWithNestedUpdates) {
                nestedUpdateCount++;
              } else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root2;
              }
            } else {
              nestedUpdateCount = 0;
            }
            flushSyncCallbacks();
            {
              markCommitStopped();
            }
            return null;
          }
          function flushPassiveEffects() {
            if (rootWithPendingPassiveEffects !== null) {
              var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
              var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              var previousPriority = getCurrentUpdatePriority();
              try {
                ReactCurrentBatchConfig$3.transition = null;
                setCurrentUpdatePriority(priority);
                return flushPassiveEffectsImpl();
              } finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$3.transition = prevTransition;
              }
            }
            return false;
          }
          function enqueuePendingPassiveProfilerEffect(fiber) {
            {
              pendingPassiveProfilerEffects.push(fiber);
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
          }
          function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
              return false;
            }
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root2 = rootWithPendingPassiveEffects;
            var lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Cannot flush passive effects while already rendering.");
            }
            {
              isFlushingPassiveEffects = true;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            {
              markPassiveEffectsStarted(lanes);
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountEffects(root2.current);
            commitPassiveMountEffects(root2, root2.current, lanes, transitions);
            {
              var profilerEffects = pendingPassiveProfilerEffects;
              pendingPassiveProfilerEffects = [];
              for (var i5 = 0; i5 < profilerEffects.length; i5++) {
                var _fiber = profilerEffects[i5];
                commitPassiveEffectDurations(root2, _fiber);
              }
            }
            {
              markPassiveEffectsStopped();
            }
            {
              commitDoubleInvokeEffectsInDEV(root2.current, true);
            }
            executionContext = prevExecutionContext;
            flushSyncCallbacks();
            {
              if (didScheduleUpdateDuringPassiveEffects) {
                if (root2 === rootWithPassiveNestedUpdates) {
                  nestedPassiveUpdateCount++;
                } else {
                  nestedPassiveUpdateCount = 0;
                  rootWithPassiveNestedUpdates = root2;
                }
              } else {
                nestedPassiveUpdateCount = 0;
              }
              isFlushingPassiveEffects = false;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            onPostCommitRoot(root2);
            {
              var stateNode = root2.current.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
            return true;
          }
          function isAlreadyFailedLegacyErrorBoundary(instance) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
          }
          function markLegacyErrorBoundaryAsFailed(instance) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
              legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
            } else {
              legacyErrorBoundariesThatAlreadyFailed.add(instance);
            }
          }
          function prepareToThrowUncaughtError(error2) {
            if (!hasUncaughtError) {
              hasUncaughtError = true;
              firstUncaughtError = error2;
            }
          }
          var onUncaughtError = prepareToThrowUncaughtError;
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
            var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);
            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
            var root2 = enqueueUpdate(rootFiber, update, SyncLane);
            var eventTime = requestEventTime();
            if (root2 !== null) {
              markRootUpdated(root2, SyncLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
            }
          }
          function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
            {
              reportUncaughtErrorInDEV(error$1);
              setIsRunningInsertionEffect(false);
            }
            if (sourceFiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
              return;
            }
            var fiber = null;
            {
              fiber = nearestMountedAncestor;
            }
            while (fiber !== null) {
              if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
                return;
              } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                  var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                  var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                  var root2 = enqueueUpdate(fiber, update, SyncLane);
                  var eventTime = requestEventTime();
                  if (root2 !== null) {
                    markRootUpdated(root2, SyncLane, eventTime);
                    ensureRootIsScheduled(root2, eventTime);
                  }
                  return;
                }
              }
              fiber = fiber.return;
            }
            {
              error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
            }
          }
          function pingSuspendedRoot(root2, wakeable, pingedLanes) {
            var pingCache = root2.pingCache;
            if (pingCache !== null) {
              pingCache.delete(wakeable);
            }
            var eventTime = requestEventTime();
            markRootPinged(root2, pingedLanes);
            warnIfSuspenseResolutionNotWrappedWithActDEV(root2);
            if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
              if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                prepareFreshStack(root2, NoLanes);
              } else {
                workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
              }
            }
            ensureRootIsScheduled(root2, eventTime);
          }
          function retryTimedOutBoundary(boundaryFiber, retryLane) {
            if (retryLane === NoLane) {
              retryLane = requestRetryLane(boundaryFiber);
            }
            var eventTime = requestEventTime();
            var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
            if (root2 !== null) {
              markRootUpdated(root2, retryLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
            }
          }
          function retryDehydratedSuspenseBoundary(boundaryFiber) {
            var suspenseState = boundaryFiber.memoizedState;
            var retryLane = NoLane;
            if (suspenseState !== null) {
              retryLane = suspenseState.retryLane;
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = NoLane;
            var retryCache;
            switch (boundaryFiber.tag) {
              case SuspenseComponent:
                retryCache = boundaryFiber.stateNode;
                var suspenseState = boundaryFiber.memoizedState;
                if (suspenseState !== null) {
                  retryLane = suspenseState.retryLane;
                }
                break;
              case SuspenseListComponent:
                retryCache = boundaryFiber.stateNode;
                break;
              default:
                throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
            }
            if (retryCache !== null) {
              retryCache.delete(wakeable);
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
          }
          function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = null;
              throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
            }
            {
              if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
                error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
              }
            }
          }
          function flushRenderPhaseStrictModeWarningsInDEV() {
            {
              ReactStrictModeWarnings.flushLegacyContextWarning();
              {
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
              }
            }
          }
          function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
            {
              setCurrentFiber(fiber);
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
              }
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
              }
              resetCurrentFiber();
            }
          }
          function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
            {
              var current2 = firstChild;
              var subtreeRoot = null;
              while (current2 !== null) {
                var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
                if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                  current2 = current2.child;
                } else {
                  if ((current2.flags & fiberFlags) !== NoFlags) {
                    invokeEffectFn(current2);
                  }
                  if (current2.sibling !== null) {
                    current2 = current2.sibling;
                  } else {
                    current2 = subtreeRoot = current2.return;
                  }
                }
              }
            }
          }
          var didWarnStateUpdateForNotYetMountedComponent = null;
          function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            {
              if ((executionContext & RenderContext) !== NoContext) {
                return;
              }
              if (!(fiber.mode & ConcurrentMode)) {
                return;
              }
              var tag = fiber.tag;
              if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef10 && tag !== MemoComponent && tag !== SimpleMemoComponent) {
                return;
              }
              var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForNotYetMountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          var beginWork$1;
          {
            var dummyFiber = null;
            beginWork$1 = function(current2, unitOfWork, lanes) {
              var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
              try {
                return beginWork(current2, unitOfWork, lanes);
              } catch (originalError) {
                if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                  throw originalError;
                }
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(current2, unitOfWork);
                assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                if (unitOfWork.mode & ProfileMode) {
                  startProfilerTimer(unitOfWork);
                }
                invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
                if (hasCaughtError()) {
                  var replayError = clearCaughtError();
                  if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                    originalError._suppressLogging = true;
                  }
                }
                throw originalError;
              }
            };
          }
          var didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent;
          {
            didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
          }
          function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
              if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                switch (fiber.tag) {
                  case FunctionComponent:
                  case ForwardRef10:
                  case SimpleMemoComponent: {
                    var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                    var dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                      var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                      error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                    }
                    break;
                  }
                  case ClassComponent: {
                    if (!didWarnAboutUpdateInRender) {
                      error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                      didWarnAboutUpdateInRender = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          function restorePendingUpdaters(root2, lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                memoizedUpdaters.forEach(function(schedulingFiber) {
                  addFiberToLanesMap(root2, schedulingFiber, lanes);
                });
              }
            }
          }
          var fakeActCallbackNode = {};
          function scheduleCallback$1(priorityLevel, callback2) {
            {
              var actQueue = ReactCurrentActQueue$1.current;
              if (actQueue !== null) {
                actQueue.push(callback2);
                return fakeActCallbackNode;
              } else {
                return scheduleCallback(priorityLevel, callback2);
              }
            }
          }
          function cancelCallback$1(callbackNode) {
            if (callbackNode === fakeActCallbackNode) {
              return;
            }
            return cancelCallback(callbackNode);
          }
          function shouldForceFlushFallbacksInDEV() {
            return ReactCurrentActQueue$1.current !== null;
          }
          function warnIfUpdatesNotWrappedWithActDEV(fiber) {
            {
              if (fiber.mode & ConcurrentMode) {
                if (!isConcurrentActEnvironment()) {
                  return;
                }
              } else {
                if (!isLegacyActEnvironment()) {
                  return;
                }
                if (executionContext !== NoContext) {
                  return;
                }
                if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef10 && fiber.tag !== SimpleMemoComponent) {
                  return;
                }
              }
              if (ReactCurrentActQueue$1.current === null) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {
            {
              if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
                error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
              }
            }
          }
          function setIsRunningInsertionEffect(isRunning) {
            {
              isRunningInsertionEffect = isRunning;
            }
          }
          var resolveFamily = null;
          var failedBoundaries = null;
          var setRefreshHandler = function(handler) {
            {
              resolveFamily = handler;
            }
          };
          function resolveFunctionForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                return type;
              }
              return family.current;
            }
          }
          function resolveClassForHotReloading(type) {
            return resolveFunctionForHotReloading(type);
          }
          function resolveForwardRefForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                if (type !== null && type !== void 0 && typeof type.render === "function") {
                  var currentRender = resolveFunctionForHotReloading(type.render);
                  if (type.render !== currentRender) {
                    var syntheticType = {
                      $$typeof: REACT_FORWARD_REF_TYPE,
                      render: currentRender
                    };
                    if (type.displayName !== void 0) {
                      syntheticType.displayName = type.displayName;
                    }
                    return syntheticType;
                  }
                }
                return type;
              }
              return family.current;
            }
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            {
              if (resolveFamily === null) {
                return false;
              }
              var prevType = fiber.elementType;
              var nextType = element.type;
              var needsCompareFamilies = false;
              var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
              switch (fiber.tag) {
                case ClassComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case FunctionComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case ForwardRef10: {
                  if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case MemoComponent:
                case SimpleMemoComponent: {
                  if ($$typeofNextType === REACT_MEMO_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                default:
                  return false;
              }
              if (needsCompareFamilies) {
                var prevFamily = resolveFamily(prevType);
                if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                  return true;
                }
              }
              return false;
            }
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            {
              if (resolveFamily === null) {
                return;
              }
              if (typeof WeakSet !== "function") {
                return;
              }
              if (failedBoundaries === null) {
                failedBoundaries = /* @__PURE__ */ new WeakSet();
              }
              failedBoundaries.add(fiber);
            }
          }
          var scheduleRefresh = function(root2, update) {
            {
              if (resolveFamily === null) {
                return;
              }
              var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
              flushPassiveEffects();
              flushSync3(function() {
                scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
              });
            }
          };
          var scheduleRoot = function(root2, element) {
            {
              if (root2.context !== emptyContextObject) {
                return;
              }
              flushPassiveEffects();
              flushSync3(function() {
                updateContainer(element, root2, null, null);
              });
            }
          };
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
              var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef10:
                  candidateType = type.render;
                  break;
              }
              if (resolveFamily === null) {
                throw new Error("Expected resolveFamily to be set during hot reload.");
              }
              var needsRender = false;
              var needsRemount = false;
              if (candidateType !== null) {
                var family = resolveFamily(candidateType);
                if (family !== void 0) {
                  if (staleFamilies.has(family)) {
                    needsRemount = true;
                  } else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) {
                      needsRemount = true;
                    } else {
                      needsRender = true;
                    }
                  }
                }
              }
              if (failedBoundaries !== null) {
                if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                  needsRemount = true;
                }
              }
              if (needsRemount) {
                fiber._debugNeedsRemount = true;
              }
              if (needsRemount || needsRender) {
                var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (_root !== null) {
                  scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
                }
              }
              if (child !== null && !needsRemount) {
                scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
              }
              if (sibling !== null) {
                scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
              }
            }
          }
          var findHostInstancesForRefresh = function(root2, families) {
            {
              var hostInstances = /* @__PURE__ */ new Set();
              var types = new Set(families.map(function(family) {
                return family.current;
              }));
              findHostInstancesForMatchingFibersRecursively(root2.current, types, hostInstances);
              return hostInstances;
            }
          };
          function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
            {
              var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef10:
                  candidateType = type.render;
                  break;
              }
              var didMatch = false;
              if (candidateType !== null) {
                if (types.has(candidateType)) {
                  didMatch = true;
                }
              }
              if (didMatch) {
                findHostInstancesForFiberShallowly(fiber, hostInstances);
              } else {
                if (child !== null) {
                  findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
                }
              }
              if (sibling !== null) {
                findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
              }
            }
          }
          function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
              if (foundHostInstances) {
                return;
              }
              var node = fiber;
              while (true) {
                switch (node.tag) {
                  case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                  case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                  case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                }
                if (node.return === null) {
                  throw new Error("Expected to reach root first.");
                }
                node = node.return;
              }
            }
          }
          function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var node = fiber;
              var foundHostInstances = false;
              while (true) {
                if (node.tag === HostComponent) {
                  foundHostInstances = true;
                  hostInstances.add(node.stateNode);
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === fiber) {
                  return foundHostInstances;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === fiber) {
                    return foundHostInstances;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
            return false;
          }
          var hasBadMapPolyfill;
          {
            hasBadMapPolyfill = false;
            try {
              var nonExtensibleObject = Object.preventExtensions({});
              /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
              /* @__PURE__ */ new Set([nonExtensibleObject]);
            } catch (e3) {
              hasBadMapPolyfill = true;
            }
          }
          function FiberNode(tag, pendingProps, key, mode) {
            this.tag = tag;
            this.key = key;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode;
            this.flags = NoFlags;
            this.subtreeFlags = NoFlags;
            this.deletions = null;
            this.lanes = NoLanes;
            this.childLanes = NoLanes;
            this.alternate = null;
            {
              this.actualDuration = Number.NaN;
              this.actualStartTime = Number.NaN;
              this.selfBaseDuration = Number.NaN;
              this.treeBaseDuration = Number.NaN;
              this.actualDuration = 0;
              this.actualStartTime = -1;
              this.selfBaseDuration = 0;
              this.treeBaseDuration = 0;
            }
            {
              this._debugSource = null;
              this._debugOwner = null;
              this._debugNeedsRemount = false;
              this._debugHookTypes = null;
              if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                Object.preventExtensions(this);
              }
            }
          }
          var createFiber = function(tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
          };
          function shouldConstruct$1(Component4) {
            var prototype = Component4.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function isSimpleFunctionComponent(type) {
            return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
          }
          function resolveLazyComponentTag(Component4) {
            if (typeof Component4 === "function") {
              return shouldConstruct$1(Component4) ? ClassComponent : FunctionComponent;
            } else if (Component4 !== void 0 && Component4 !== null) {
              var $$typeof = Component4.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                return ForwardRef10;
              }
              if ($$typeof === REACT_MEMO_TYPE) {
                return MemoComponent;
              }
            }
            return IndeterminateComponent;
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            if (workInProgress2 === null) {
              workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
              workInProgress2.elementType = current2.elementType;
              workInProgress2.type = current2.type;
              workInProgress2.stateNode = current2.stateNode;
              {
                workInProgress2._debugSource = current2._debugSource;
                workInProgress2._debugOwner = current2._debugOwner;
                workInProgress2._debugHookTypes = current2._debugHookTypes;
              }
              workInProgress2.alternate = current2;
              current2.alternate = workInProgress2;
            } else {
              workInProgress2.pendingProps = pendingProps;
              workInProgress2.type = current2.type;
              workInProgress2.flags = NoFlags;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              {
                workInProgress2.actualDuration = 0;
                workInProgress2.actualStartTime = -1;
              }
            }
            workInProgress2.flags = current2.flags & StaticMask;
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
            {
              workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
              switch (workInProgress2.tag) {
                case IndeterminateComponent:
                case FunctionComponent:
                case SimpleMemoComponent:
                  workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                  break;
                case ClassComponent:
                  workInProgress2.type = resolveClassForHotReloading(current2.type);
                  break;
                case ForwardRef10:
                  workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                  break;
              }
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderLanes2) {
            workInProgress2.flags &= StaticMask | Placement;
            var current2 = workInProgress2.alternate;
            if (current2 === null) {
              workInProgress2.childLanes = NoLanes;
              workInProgress2.lanes = renderLanes2;
              workInProgress2.child = null;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.memoizedProps = null;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.dependencies = null;
              workInProgress2.stateNode = null;
              {
                workInProgress2.selfBaseDuration = 0;
                workInProgress2.treeBaseDuration = 0;
              }
            } else {
              workInProgress2.childLanes = current2.childLanes;
              workInProgress2.lanes = current2.lanes;
              workInProgress2.child = current2.child;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              workInProgress2.memoizedProps = current2.memoizedProps;
              workInProgress2.memoizedState = current2.memoizedState;
              workInProgress2.updateQueue = current2.updateQueue;
              workInProgress2.type = current2.type;
              var currentDependencies = current2.dependencies;
              workInProgress2.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
              };
              {
                workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                workInProgress2.treeBaseDuration = current2.treeBaseDuration;
              }
            }
            return workInProgress2;
          }
          function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
            var mode;
            if (tag === ConcurrentRoot) {
              mode = ConcurrentMode;
              if (isStrictMode === true) {
                mode |= StrictLegacyMode;
                {
                  mode |= StrictEffectsMode;
                }
              }
            } else {
              mode = NoMode;
            }
            if (isDevToolsPresent) {
              mode |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode);
          }
          function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
            var fiberTag = IndeterminateComponent;
            var resolvedType = type;
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                fiberTag = ClassComponent;
                {
                  resolvedType = resolveClassForHotReloading(resolvedType);
                }
              } else {
                {
                  resolvedType = resolveFunctionForHotReloading(resolvedType);
                }
              }
            } else if (typeof type === "string") {
              fiberTag = HostComponent;
            } else {
              getTag: switch (type) {
                case REACT_FRAGMENT_TYPE:
                  return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                case REACT_STRICT_MODE_TYPE:
                  fiberTag = Mode;
                  mode |= StrictLegacyMode;
                  if ((mode & ConcurrentMode) !== NoMode) {
                    mode |= StrictEffectsMode;
                  }
                  break;
                case REACT_PROFILER_TYPE:
                  return createFiberFromProfiler(pendingProps, mode, lanes, key);
                case REACT_SUSPENSE_TYPE:
                  return createFiberFromSuspense(pendingProps, mode, lanes, key);
                case REACT_SUSPENSE_LIST_TYPE:
                  return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                case REACT_OFFSCREEN_TYPE:
                  return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_SCOPE_TYPE:
                case REACT_CACHE_TYPE:
                case REACT_TRACING_MARKER_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                default: {
                  if (typeof type === "object" && type !== null) {
                    switch (type.$$typeof) {
                      case REACT_PROVIDER_TYPE:
                        fiberTag = ContextProvider;
                        break getTag;
                      case REACT_CONTEXT_TYPE:
                        fiberTag = ContextConsumer;
                        break getTag;
                      case REACT_FORWARD_REF_TYPE:
                        fiberTag = ForwardRef10;
                        {
                          resolvedType = resolveForwardRefForHotReloading(resolvedType);
                        }
                        break getTag;
                      case REACT_MEMO_TYPE:
                        fiberTag = MemoComponent;
                        break getTag;
                      case REACT_LAZY_TYPE:
                        fiberTag = LazyComponent;
                        resolvedType = null;
                        break getTag;
                    }
                  }
                  var info = "";
                  {
                    if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                      info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                    }
                    var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                    if (ownerName) {
                      info += "\n\nCheck the render method of `" + ownerName + "`.";
                    }
                  }
                  throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
                }
              }
            }
            var fiber = createFiber(fiberTag, pendingProps, key, mode);
            fiber.elementType = type;
            fiber.type = resolvedType;
            fiber.lanes = lanes;
            {
              fiber._debugOwner = owner;
            }
            return fiber;
          }
          function createFiberFromElement(element, mode, lanes) {
            var owner = null;
            {
              owner = element._owner;
            }
            var type = element.type;
            var key = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
            {
              fiber._debugSource = element._source;
              fiber._debugOwner = element._owner;
            }
            return fiber;
          }
          function createFiberFromFragment(elements2, mode, lanes, key) {
            var fiber = createFiber(Fragment11, elements2, key, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromProfiler(pendingProps, mode, lanes, key) {
            {
              if (typeof pendingProps.id !== "string") {
                error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
              }
            }
            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.lanes = lanes;
            {
              fiber.stateNode = {
                effectDuration: 0,
                passiveEffectDuration: 0
              };
            }
            return fiber;
          }
          function createFiberFromSuspense(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
            fiber.elementType = REACT_OFFSCREEN_TYPE;
            fiber.lanes = lanes;
            var primaryChildInstance = {
              isHidden: false
            };
            fiber.stateNode = primaryChildInstance;
            return fiber;
          }
          function createFiberFromText(content, mode, lanes) {
            var fiber = createFiber(HostText, content, null, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = "DELETED";
            return fiber;
          }
          function createFiberFromDehydratedFragment(dehydratedNode) {
            var fiber = createFiber(DehydratedFragment, null, null, NoMode);
            fiber.stateNode = dehydratedNode;
            return fiber;
          }
          function createFiberFromPortal(portal, mode, lanes) {
            var pendingProps = portal.children !== null ? portal.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
            fiber.lanes = lanes;
            fiber.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              // Used by persistent updates
              implementation: portal.implementation
            };
            return fiber;
          }
          function assignFiberPropertiesInDEV(target, source) {
            if (target === null) {
              target = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target.tag = source.tag;
            target.key = source.key;
            target.elementType = source.elementType;
            target.type = source.type;
            target.stateNode = source.stateNode;
            target.return = source.return;
            target.child = source.child;
            target.sibling = source.sibling;
            target.index = source.index;
            target.ref = source.ref;
            target.pendingProps = source.pendingProps;
            target.memoizedProps = source.memoizedProps;
            target.updateQueue = source.updateQueue;
            target.memoizedState = source.memoizedState;
            target.dependencies = source.dependencies;
            target.mode = source.mode;
            target.flags = source.flags;
            target.subtreeFlags = source.subtreeFlags;
            target.deletions = source.deletions;
            target.lanes = source.lanes;
            target.childLanes = source.childLanes;
            target.alternate = source.alternate;
            {
              target.actualDuration = source.actualDuration;
              target.actualStartTime = source.actualStartTime;
              target.selfBaseDuration = source.selfBaseDuration;
              target.treeBaseDuration = source.treeBaseDuration;
            }
            target._debugSource = source._debugSource;
            target._debugOwner = source._debugOwner;
            target._debugNeedsRemount = source._debugNeedsRemount;
            target._debugHookTypes = source._debugHookTypes;
            return target;
          }
          function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
            this.tag = tag;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.current = null;
            this.pingCache = null;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.callbackNode = null;
            this.callbackPriority = NoLane;
            this.eventTimes = createLaneMap(NoLanes);
            this.expirationTimes = createLaneMap(NoTimestamp);
            this.pendingLanes = NoLanes;
            this.suspendedLanes = NoLanes;
            this.pingedLanes = NoLanes;
            this.expiredLanes = NoLanes;
            this.mutableReadLanes = NoLanes;
            this.finishedLanes = NoLanes;
            this.entangledLanes = NoLanes;
            this.entanglements = createLaneMap(NoLanes);
            this.identifierPrefix = identifierPrefix;
            this.onRecoverableError = onRecoverableError;
            {
              this.mutableSourceEagerHydrationData = null;
            }
            {
              this.effectDuration = 0;
              this.passiveEffectDuration = 0;
            }
            {
              this.memoizedUpdaters = /* @__PURE__ */ new Set();
              var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
              for (var _i = 0; _i < TotalLanes; _i++) {
                pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
              }
            }
            {
              switch (tag) {
                case ConcurrentRoot:
                  this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                  break;
                case LegacyRoot:
                  this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                  break;
              }
            }
          }
          function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
            root2.current = uninitializedFiber;
            uninitializedFiber.stateNode = root2;
            {
              var _initialState2 = {
                element: initialChildren,
                isDehydrated: hydrate2,
                cache: null,
                // not enabled yet
                transitions: null,
                pendingSuspenseBoundaries: null
              };
              uninitializedFiber.memoizedState = _initialState2;
            }
            initializeUpdateQueue(uninitializedFiber);
            return root2;
          }
          var ReactVersion = "18.3.1";
          function createPortal2(children, containerInfo, implementation) {
            var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            {
              checkKeyStringCoercion(key);
            }
            return {
              // This tag allow us to uniquely identify this as a React Portal
              $$typeof: REACT_PORTAL_TYPE,
              key: key == null ? null : "" + key,
              children,
              containerInfo,
              implementation
            };
          }
          var didWarnAboutNestedUpdates;
          var didWarnAboutFindNodeInStrictMode;
          {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
              return emptyContextObject;
            }
            var fiber = get2(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
              var Component4 = fiber.type;
              if (isContextProvider(Component4)) {
                return processChildContext(fiber, Component4, parentContext);
              }
            }
            return parentContext;
          }
          function findHostInstanceWithWarning(component, methodName) {
            {
              var fiber = get2(component);
              if (fiber === void 0) {
                if (typeof component.render === "function") {
                  throw new Error("Unable to find node on an unmounted component.");
                } else {
                  var keys = Object.keys(component).join(",");
                  throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
                }
              }
              var hostFiber = findCurrentHostFiber(fiber);
              if (hostFiber === null) {
                return null;
              }
              if (hostFiber.mode & StrictLegacyMode) {
                var componentName = getComponentNameFromFiber(fiber) || "Component";
                if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                  didWarnAboutFindNodeInStrictMode[componentName] = true;
                  var previousFiber = current;
                  try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictLegacyMode) {
                      error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    } else {
                      error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    }
                  } finally {
                    if (previousFiber) {
                      setCurrentFiber(previousFiber);
                    } else {
                      resetCurrentFiber();
                    }
                  }
                }
              }
              return hostFiber.stateNode;
            }
          }
          function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = false;
            var initialChildren = null;
            return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          }
          function createHydrationContainer(initialChildren, callback2, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = true;
            var root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            root2.context = getContextForSubtree(null);
            var current2 = root2.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current2);
            var update = createUpdate(eventTime, lane);
            update.callback = callback2 !== void 0 && callback2 !== null ? callback2 : null;
            enqueueUpdate(current2, update, lane);
            scheduleInitialHydrationOnRoot(root2, lane, eventTime);
            return root2;
          }
          function updateContainer(element, container2, parentComponent, callback2) {
            {
              onScheduleRoot(container2, element);
            }
            var current$1 = container2.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current$1);
            {
              markRenderScheduled(lane);
            }
            var context = getContextForSubtree(parentComponent);
            if (container2.context === null) {
              container2.context = context;
            } else {
              container2.pendingContext = context;
            }
            {
              if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                didWarnAboutNestedUpdates = true;
                error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
              }
            }
            var update = createUpdate(eventTime, lane);
            update.payload = {
              element
            };
            callback2 = callback2 === void 0 ? null : callback2;
            if (callback2 !== null) {
              {
                if (typeof callback2 !== "function") {
                  error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback2);
                }
              }
              update.callback = callback2;
            }
            var root2 = enqueueUpdate(current$1, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, current$1, lane, eventTime);
              entangleTransitions(root2, current$1, lane);
            }
            return lane;
          }
          function getPublicRootInstance(container2) {
            var containerFiber = container2.current;
            if (!containerFiber.child) {
              return null;
            }
            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
              default:
                return containerFiber.child.stateNode;
            }
          }
          function attemptSynchronousHydration$1(fiber) {
            switch (fiber.tag) {
              case HostRoot: {
                var root2 = fiber.stateNode;
                if (isRootDehydrated(root2)) {
                  var lanes = getHighestPriorityPendingLanes(root2);
                  flushRoot(root2, lanes);
                }
                break;
              }
              case SuspenseComponent: {
                flushSync3(function() {
                  var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                  if (root3 !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);
                  }
                });
                var retryLane = SyncLane;
                markRetryLaneIfNotHydrated(fiber, retryLane);
                break;
              }
            }
          }
          function markRetryLaneImpl(fiber, retryLane) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
            }
          }
          function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            var alternate = fiber.alternate;
            if (alternate) {
              markRetryLaneImpl(alternate, retryLane);
            }
          }
          function attemptContinuousHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = SelectiveHydrationLane;
            var root2 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptHydrationAtCurrentPriority$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = requestUpdateLane(fiber);
            var root2 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          var shouldErrorImpl = function(fiber) {
            return null;
          };
          function shouldError(fiber) {
            return shouldErrorImpl(fiber);
          }
          var shouldSuspendImpl = function(fiber) {
            return false;
          };
          function shouldSuspend2(fiber) {
            return shouldSuspendImpl(fiber);
          }
          var overrideHookState = null;
          var overrideHookStateDeletePath = null;
          var overrideHookStateRenamePath = null;
          var overrideProps = null;
          var overridePropsDeletePath = null;
          var overridePropsRenamePath = null;
          var scheduleUpdate = null;
          var setErrorHandler = null;
          var setSuspenseHandler = null;
          {
            var copyWithDeleteImpl = function(obj, path, index3) {
              var key = path[index3];
              var updated = isArray3(obj) ? obj.slice() : assign({}, obj);
              if (index3 + 1 === path.length) {
                if (isArray3(updated)) {
                  updated.splice(key, 1);
                } else {
                  delete updated[key];
                }
                return updated;
              }
              updated[key] = copyWithDeleteImpl(obj[key], path, index3 + 1);
              return updated;
            };
            var copyWithDelete = function(obj, path) {
              return copyWithDeleteImpl(obj, path, 0);
            };
            var copyWithRenameImpl = function(obj, oldPath, newPath, index3) {
              var oldKey = oldPath[index3];
              var updated = isArray3(obj) ? obj.slice() : assign({}, obj);
              if (index3 + 1 === oldPath.length) {
                var newKey = newPath[index3];
                updated[newKey] = updated[oldKey];
                if (isArray3(updated)) {
                  updated.splice(oldKey, 1);
                } else {
                  delete updated[oldKey];
                }
              } else {
                updated[oldKey] = copyWithRenameImpl(
                  // $FlowFixMe number or string is fine here
                  obj[oldKey],
                  oldPath,
                  newPath,
                  index3 + 1
                );
              }
              return updated;
            };
            var copyWithRename = function(obj, oldPath, newPath) {
              if (oldPath.length !== newPath.length) {
                warn("copyWithRename() expects paths of the same length");
                return;
              } else {
                for (var i5 = 0; i5 < newPath.length - 1; i5++) {
                  if (oldPath[i5] !== newPath[i5]) {
                    warn("copyWithRename() expects paths to be the same except for the deepest key");
                    return;
                  }
                }
              }
              return copyWithRenameImpl(obj, oldPath, newPath, 0);
            };
            var copyWithSetImpl = function(obj, path, index3, value) {
              if (index3 >= path.length) {
                return value;
              }
              var key = path[index3];
              var updated = isArray3(obj) ? obj.slice() : assign({}, obj);
              updated[key] = copyWithSetImpl(obj[key], path, index3 + 1, value);
              return updated;
            };
            var copyWithSet = function(obj, path, value) {
              return copyWithSetImpl(obj, path, 0, value);
            };
            var findHook = function(fiber, id) {
              var currentHook2 = fiber.memoizedState;
              while (currentHook2 !== null && id > 0) {
                currentHook2 = currentHook2.next;
                id--;
              }
              return currentHook2;
            };
            overrideHookState = function(fiber, id, path, value) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithSet(hook.memoizedState, path, value);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root2 !== null) {
                  scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateDeletePath = function(fiber, id, path) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithDelete(hook.memoizedState, path);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root2 !== null) {
                  scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root2 !== null) {
                  scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideProps = function(fiber, path, value) {
              fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsDeletePath = function(fiber, path) {
              fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsRenamePath = function(fiber, oldPath, newPath) {
              fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            scheduleUpdate = function(fiber) {
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            setErrorHandler = function(newShouldErrorImpl) {
              shouldErrorImpl = newShouldErrorImpl;
            };
            setSuspenseHandler = function(newShouldSuspendImpl) {
              shouldSuspendImpl = newShouldSuspendImpl;
            };
          }
          function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          function emptyFindFiberByHostInstance(instance) {
            return null;
          }
          function getCurrentFiberForDevTools() {
            return current;
          }
          function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals({
              bundleType: devToolsConfig.bundleType,
              version: devToolsConfig.version,
              rendererPackageName: devToolsConfig.rendererPackageName,
              rendererConfig: devToolsConfig.rendererConfig,
              overrideHookState,
              overrideHookStateDeletePath,
              overrideHookStateRenamePath,
              overrideProps,
              overridePropsDeletePath,
              overridePropsRenamePath,
              setErrorHandler,
              setSuspenseHandler,
              scheduleUpdate,
              currentDispatcherRef: ReactCurrentDispatcher2,
              findHostInstanceByFiber,
              findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
              // React Refresh
              findHostInstancesForRefresh,
              scheduleRefresh,
              scheduleRoot,
              setRefreshHandler,
              // Enables DevTools to append owner stacks to error messages in DEV mode.
              getCurrentFiber: getCurrentFiberForDevTools,
              // Enables DevTools to detect reconciler version rather than renderer version
              // which may not match for third party renderers.
              reconcilerVersion: ReactVersion
            });
          }
          var defaultOnRecoverableError = typeof reportError === "function" ? (
            // In modern browsers, reportError will dispatch an error event,
            // emulating an uncaught JavaScript error.
            reportError
          ) : function(error2) {
            console["error"](error2);
          };
          function ReactDOMRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
            var root2 = this._internalRoot;
            if (root2 === null) {
              throw new Error("Cannot update an unmounted root.");
            }
            {
              if (typeof arguments[1] === "function") {
                error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              } else if (isValidContainer(arguments[1])) {
                error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
              } else if (typeof arguments[1] !== "undefined") {
                error("You passed a second argument to root.render(...) but it only accepts one argument.");
              }
              var container2 = root2.containerInfo;
              if (container2.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(root2.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container2) {
                    error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                  }
                }
              }
            }
            updateContainer(children, root2, null, null);
          };
          ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
            {
              if (typeof arguments[0] === "function") {
                error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
            }
            var root2 = this._internalRoot;
            if (root2 !== null) {
              this._internalRoot = null;
              var container2 = root2.containerInfo;
              {
                if (isAlreadyRendering()) {
                  error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
                }
              }
              flushSync3(function() {
                updateContainer(null, root2, null, null);
              });
              unmarkContainerAsRoot(container2);
            }
          };
          function createRoot2(container2, options2) {
            if (!isValidContainer(container2)) {
              throw new Error("createRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container2);
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            var transitionCallbacks = null;
            if (options2 !== null && options2 !== void 0) {
              {
                if (options2.hydrate) {
                  warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
                } else {
                  if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                    error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                  }
                }
              }
              if (options2.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options2.identifierPrefix !== void 0) {
                identifierPrefix = options2.identifierPrefix;
              }
              if (options2.onRecoverableError !== void 0) {
                onRecoverableError = options2.onRecoverableError;
              }
              if (options2.transitionCallbacks !== void 0) {
                transitionCallbacks = options2.transitionCallbacks;
              }
            }
            var root2 = createContainer(container2, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root2.current, container2);
            var rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
            listenToAllSupportedEvents(rootContainerElement);
            return new ReactDOMRoot(root2);
          }
          function ReactDOMHydrationRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          function scheduleHydration(target) {
            if (target) {
              queueExplicitHydrationTarget(target);
            }
          }
          ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
          function hydrateRoot(container2, initialChildren, options2) {
            if (!isValidContainer(container2)) {
              throw new Error("hydrateRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container2);
            {
              if (initialChildren === void 0) {
                error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
              }
            }
            var hydrationCallbacks = options2 != null ? options2 : null;
            var mutableSources = options2 != null && options2.hydratedSources || null;
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            if (options2 !== null && options2 !== void 0) {
              if (options2.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options2.identifierPrefix !== void 0) {
                identifierPrefix = options2.identifierPrefix;
              }
              if (options2.onRecoverableError !== void 0) {
                onRecoverableError = options2.onRecoverableError;
              }
            }
            var root2 = createHydrationContainer(initialChildren, null, container2, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root2.current, container2);
            listenToAllSupportedEvents(container2);
            if (mutableSources) {
              for (var i5 = 0; i5 < mutableSources.length; i5++) {
                var mutableSource = mutableSources[i5];
                registerMutableSourceForHydration(root2, mutableSource);
              }
            }
            return new ReactDOMHydrationRoot(root2);
          }
          function isValidContainer(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
          }
          function isValidContainerLegacy(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
          }
          function warnIfReactDOMContainerInDEV(container2) {
            {
              if (container2.nodeType === ELEMENT_NODE && container2.tagName && container2.tagName.toUpperCase() === "BODY") {
                error("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
              }
              if (isContainerMarkedAsRoot(container2)) {
                if (container2._reactRootContainer) {
                  error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
                } else {
                  error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
                }
              }
            }
          }
          var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
          var topLevelUpdateWarnings;
          {
            topLevelUpdateWarnings = function(container2) {
              if (container2._reactRootContainer && container2.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(container2._reactRootContainer.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container2) {
                    error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                  }
                }
              }
              var isRootRenderedBySomeReact = !!container2._reactRootContainer;
              var rootEl = getReactRootElementInContainer(container2);
              var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
              if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
                error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
              }
              if (container2.nodeType === ELEMENT_NODE && container2.tagName && container2.tagName.toUpperCase() === "BODY") {
                error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
              }
            };
          }
          function getReactRootElementInContainer(container2) {
            if (!container2) {
              return null;
            }
            if (container2.nodeType === DOCUMENT_NODE) {
              return container2.documentElement;
            } else {
              return container2.firstChild;
            }
          }
          function noopOnRecoverableError() {
          }
          function legacyCreateRootFromDOMContainer(container2, initialChildren, parentComponent, callback2, isHydrationContainer) {
            if (isHydrationContainer) {
              if (typeof callback2 === "function") {
                var originalCallback = callback2;
                callback2 = function() {
                  var instance = getPublicRootInstance(root2);
                  originalCallback.call(instance);
                };
              }
              var root2 = createHydrationContainer(
                initialChildren,
                callback2,
                container2,
                LegacyRoot,
                null,
                // hydrationCallbacks
                false,
                // isStrictMode
                false,
                // concurrentUpdatesByDefaultOverride,
                "",
                // identifierPrefix
                noopOnRecoverableError
              );
              container2._reactRootContainer = root2;
              markContainerAsRoot(root2.current, container2);
              var rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
              listenToAllSupportedEvents(rootContainerElement);
              flushSync3();
              return root2;
            } else {
              var rootSibling;
              while (rootSibling = container2.lastChild) {
                container2.removeChild(rootSibling);
              }
              if (typeof callback2 === "function") {
                var _originalCallback = callback2;
                callback2 = function() {
                  var instance = getPublicRootInstance(_root);
                  _originalCallback.call(instance);
                };
              }
              var _root = createContainer(
                container2,
                LegacyRoot,
                null,
                // hydrationCallbacks
                false,
                // isStrictMode
                false,
                // concurrentUpdatesByDefaultOverride,
                "",
                // identifierPrefix
                noopOnRecoverableError
              );
              container2._reactRootContainer = _root;
              markContainerAsRoot(_root.current, container2);
              var _rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
              listenToAllSupportedEvents(_rootContainerElement);
              flushSync3(function() {
                updateContainer(initialChildren, _root, parentComponent, callback2);
              });
              return _root;
            }
          }
          function warnOnInvalidCallback$1(callback2, callerName) {
            {
              if (callback2 !== null && typeof callback2 !== "function") {
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback2);
              }
            }
          }
          function legacyRenderSubtreeIntoContainer(parentComponent, children, container2, forceHydrate, callback2) {
            {
              topLevelUpdateWarnings(container2);
              warnOnInvalidCallback$1(callback2 === void 0 ? null : callback2, "render");
            }
            var maybeRoot = container2._reactRootContainer;
            var root2;
            if (!maybeRoot) {
              root2 = legacyCreateRootFromDOMContainer(container2, children, parentComponent, callback2, forceHydrate);
            } else {
              root2 = maybeRoot;
              if (typeof callback2 === "function") {
                var originalCallback = callback2;
                callback2 = function() {
                  var instance = getPublicRootInstance(root2);
                  originalCallback.call(instance);
                };
              }
              updateContainer(children, root2, parentComponent, callback2);
            }
            return getPublicRootInstance(root2);
          }
          var didWarnAboutFindDOMNode = false;
          function findDOMNode2(componentOrElement) {
            {
              if (!didWarnAboutFindDOMNode) {
                didWarnAboutFindDOMNode = true;
                error("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node");
              }
              var owner = ReactCurrentOwner$3.current;
              if (owner !== null && owner.stateNode !== null) {
                var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                if (!warnedAboutRefsInRender) {
                  error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
                }
                owner.stateNode._warnedAboutRefsInRender = true;
              }
            }
            if (componentOrElement == null) {
              return null;
            }
            if (componentOrElement.nodeType === ELEMENT_NODE) {
              return componentOrElement;
            }
            {
              return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
            }
          }
          function hydrate(element, container2, callback2) {
            {
              error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container2)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container2, true, callback2);
          }
          function render(element, container2, callback2) {
            {
              error("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container2)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container2, false, callback2);
          }
          function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback2) {
            {
              error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(containerNode)) {
              throw new Error("Target container is not a DOM element.");
            }
            if (parentComponent == null || !has(parentComponent)) {
              throw new Error("parentComponent must be a valid React Component");
            }
            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback2);
          }
          var didWarnAboutUnmountComponentAtNode = false;
          function unmountComponentAtNode(container2) {
            {
              if (!didWarnAboutUnmountComponentAtNode) {
                didWarnAboutUnmountComponentAtNode = true;
                error("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot");
              }
            }
            if (!isValidContainerLegacy(container2)) {
              throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
              }
            }
            if (container2._reactRootContainer) {
              {
                var rootEl = getReactRootElementInContainer(container2);
                var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
                if (renderedByDifferentReact) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
                }
              }
              flushSync3(function() {
                legacyRenderSubtreeIntoContainer(null, null, container2, false, function() {
                  container2._reactRootContainer = null;
                  unmarkContainerAsRoot(container2);
                });
              });
              return true;
            } else {
              {
                var _rootEl = getReactRootElementInContainer(container2);
                var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
                var isContainerReactRoot = container2.nodeType === ELEMENT_NODE && isValidContainerLegacy(container2.parentNode) && !!container2.parentNode._reactRootContainer;
                if (hasNonRootReactChild) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
                }
              }
              return false;
            }
          }
          setAttemptSynchronousHydration(attemptSynchronousHydration$1);
          setAttemptContinuousHydration(attemptContinuousHydration$1);
          setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
          setGetCurrentUpdatePriority(getCurrentUpdatePriority);
          setAttemptHydrationAtPriority(runWithPriority);
          {
            if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
            Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
            Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
              error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
          }
          setRestoreImplementation(restoreControlledState$3);
          setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync3);
          function createPortal$1(children, container2) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!isValidContainer(container2)) {
              throw new Error("Target container is not a DOM element.");
            }
            return createPortal2(children, container2, null, key);
          }
          function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback2) {
            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback2);
          }
          var Internals = {
            usingClientEntryPoint: false,
            // Keep in sync with ReactTestUtils.js.
            // This is an array for better minification.
            Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
          };
          function createRoot$1(container2, options2) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return createRoot2(container2, options2);
          }
          function hydrateRoot$1(container2, initialChildren, options2) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return hydrateRoot(container2, initialChildren, options2);
          }
          function flushSync$1(fn2) {
            {
              if (isAlreadyRendering()) {
                error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
              }
            }
            return flushSync3(fn2);
          }
          var foundDevTools = injectIntoDevTools({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: ReactVersion,
            rendererPackageName: "react-dom"
          });
          {
            if (!foundDevTools && canUseDOM && window.top === window.self) {
              if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
                var protocol = window.location.protocol;
                if (/^(https?|file):$/.test(protocol)) {
                  console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
                }
              }
            }
          }
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
          exports.createPortal = createPortal$1;
          exports.createRoot = createRoot$1;
          exports.findDOMNode = findDOMNode2;
          exports.flushSync = flushSync$1;
          exports.hydrate = hydrate;
          exports.hydrateRoot = hydrateRoot$1;
          exports.render = render;
          exports.unmountComponentAtNode = unmountComponentAtNode;
          exports.unstable_batchedUpdates = batchedUpdates$1;
          exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports) {
      "use strict";
      var m5 = require_react_dom();
      if (false) {
        exports.createRoot = m5.createRoot;
        exports.hydrateRoot = m5.hydrateRoot;
      } else {
        i5 = m5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports.createRoot = function(c3, o10) {
          i5.usingClientEntryPoint = true;
          try {
            return m5.createRoot(c3, o10);
          } finally {
            i5.usingClientEntryPoint = false;
          }
        };
        exports.hydrateRoot = function(c3, h3, o10) {
          i5.usingClientEntryPoint = true;
          try {
            return m5.hydrateRoot(c3, h3, o10);
          } finally {
            i5.usingClientEntryPoint = false;
          }
        };
      }
      var i5;
    }
  });

  // node_modules/url-search-params-polyfill/index.js
  var require_url_search_params_polyfill = __commonJS({
    "node_modules/url-search-params-polyfill/index.js"(exports) {
      (function(self2) {
        "use strict";
        var nativeURLSearchParams = function() {
          try {
            if (self2.URLSearchParams && new self2.URLSearchParams("foo=bar").get("foo") === "bar") {
              return self2.URLSearchParams;
            }
          } catch (e3) {
          }
          return null;
        }(), isSupportObjectConstructor = nativeURLSearchParams && new nativeURLSearchParams({ a: 1 }).toString() === "a=1", decodesPlusesCorrectly = nativeURLSearchParams && new nativeURLSearchParams("s=%2B").get("s") === "+", __URLSearchParams__ = "__URLSearchParams__", encodesAmpersandsCorrectly = nativeURLSearchParams ? function() {
          var ampersandTest = new nativeURLSearchParams();
          ampersandTest.append("s", " &");
          return ampersandTest.toString() === "s=+%26";
        }() : true, prototype = URLSearchParamsPolyfill.prototype, iterable = !!(self2.Symbol && self2.Symbol.iterator);
        if (nativeURLSearchParams && isSupportObjectConstructor && decodesPlusesCorrectly && encodesAmpersandsCorrectly) {
          return;
        }
        function URLSearchParamsPolyfill(search) {
          search = search || "";
          if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {
            search = search.toString();
          }
          this[__URLSearchParams__] = parseToDict(search);
        }
        prototype.append = function(name, value) {
          appendTo(this[__URLSearchParams__], name, value);
        };
        prototype["delete"] = function(name) {
          delete this[__URLSearchParams__][name];
        };
        prototype.get = function(name) {
          var dict = this[__URLSearchParams__];
          return this.has(name) ? dict[name][0] : null;
        };
        prototype.getAll = function(name) {
          var dict = this[__URLSearchParams__];
          return this.has(name) ? dict[name].slice(0) : [];
        };
        prototype.has = function(name) {
          return hasOwnProperty(this[__URLSearchParams__], name);
        };
        prototype.set = function set2(name, value) {
          this[__URLSearchParams__][name] = ["" + value];
        };
        prototype.toString = function() {
          var dict = this[__URLSearchParams__], query = [], i5, key, name, value;
          for (key in dict) {
            name = encode2(key);
            for (i5 = 0, value = dict[key]; i5 < value.length; i5++) {
              query.push(name + "=" + encode2(value[i5]));
            }
          }
          return query.join("&");
        };
        var forSureUsePolyfill = !decodesPlusesCorrectly;
        var useProxy = !forSureUsePolyfill && nativeURLSearchParams && !isSupportObjectConstructor && self2.Proxy;
        var propValue;
        if (useProxy) {
          propValue = new Proxy(nativeURLSearchParams, {
            construct: function(target, args) {
              return new target(new URLSearchParamsPolyfill(args[0]).toString());
            }
          });
          propValue.toString = Function.prototype.toString.bind(URLSearchParamsPolyfill);
        } else {
          propValue = URLSearchParamsPolyfill;
        }
        Object.defineProperty(self2, "URLSearchParams", {
          value: propValue
        });
        var USPProto = self2.URLSearchParams.prototype;
        USPProto.polyfill = true;
        USPProto.forEach = USPProto.forEach || function(callback2, thisArg) {
          var dict = parseToDict(this.toString());
          Object.getOwnPropertyNames(dict).forEach(function(name) {
            dict[name].forEach(function(value) {
              callback2.call(thisArg, value, name, this);
            }, this);
          }, this);
        };
        USPProto.sort = USPProto.sort || function() {
          var dict = parseToDict(this.toString()), keys = [], k, i5, j2;
          for (k in dict) {
            keys.push(k);
          }
          keys.sort();
          for (i5 = 0; i5 < keys.length; i5++) {
            this["delete"](keys[i5]);
          }
          for (i5 = 0; i5 < keys.length; i5++) {
            var key = keys[i5], values = dict[key];
            for (j2 = 0; j2 < values.length; j2++) {
              this.append(key, values[j2]);
            }
          }
        };
        USPProto.keys = USPProto.keys || function() {
          var items = [];
          this.forEach(function(item, name) {
            items.push(name);
          });
          return makeIterator(items);
        };
        USPProto.values = USPProto.values || function() {
          var items = [];
          this.forEach(function(item) {
            items.push(item);
          });
          return makeIterator(items);
        };
        USPProto.entries = USPProto.entries || function() {
          var items = [];
          this.forEach(function(item, name) {
            items.push([name, item]);
          });
          return makeIterator(items);
        };
        if (iterable) {
          USPProto[self2.Symbol.iterator] = USPProto[self2.Symbol.iterator] || USPProto.entries;
        }
        function encode2(str) {
          var replace = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+",
            "%00": "\0"
          };
          return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function(match) {
            return replace[match];
          });
        }
        function decode2(str) {
          return str.replace(/[ +]/g, "%20").replace(/(%[a-f0-9]{2})+/ig, function(match) {
            return decodeURIComponent(match);
          });
        }
        function makeIterator(arr) {
          var iterator = {
            next: function() {
              var value = arr.shift();
              return { done: value === void 0, value };
            }
          };
          if (iterable) {
            iterator[self2.Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function parseToDict(search) {
          var dict = {};
          if (typeof search === "object") {
            if (isArray3(search)) {
              for (var i5 = 0; i5 < search.length; i5++) {
                var item = search[i5];
                if (isArray3(item) && item.length === 2) {
                  appendTo(dict, item[0], item[1]);
                } else {
                  throw new TypeError("Failed to construct 'URLSearchParams': Sequence initializer must only contain pair elements");
                }
              }
            } else {
              for (var key in search) {
                if (search.hasOwnProperty(key)) {
                  appendTo(dict, key, search[key]);
                }
              }
            }
          } else {
            if (search.indexOf("?") === 0) {
              search = search.slice(1);
            }
            var pairs = search.split("&");
            for (var j2 = 0; j2 < pairs.length; j2++) {
              var value = pairs[j2], index2 = value.indexOf("=");
              if (-1 < index2) {
                appendTo(dict, decode2(value.slice(0, index2)), decode2(value.slice(index2 + 1)));
              } else {
                if (value) {
                  appendTo(dict, decode2(value), "");
                }
              }
            }
          }
          return dict;
        }
        function appendTo(dict, name, value) {
          var val = typeof value === "string" ? value : value !== null && value !== void 0 && typeof value.toString === "function" ? value.toString() : JSON.stringify(value);
          if (hasOwnProperty(dict, name)) {
            dict[name].push(val);
          } else {
            dict[name] = [val];
          }
        }
        function isArray3(val) {
          return !!val && "[object Array]" === Object.prototype.toString.call(val);
        }
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
      })(typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : exports);
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React92 = require_react();
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactSharedInternals = React92.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error(format2) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x3) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var assign = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix2;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix2 === void 0) {
                try {
                  throw Error();
                } catch (x3) {
                  var match = x3.stack.trim().match(/\n( *(at )?)/);
                  prefix2 = match && match[1] || "";
                }
              }
              return "\n" + prefix2 + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x3) {
                    control = x3;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x3) {
                    control = x3;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x3) {
                  control = x3;
                }
                fn2();
              }
            } catch (sample2) {
              if (sample2 && control && typeof sample2.stack === "string") {
                var sampleLines = sample2.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s7 = sampleLines.length - 1;
                var c3 = controlLines.length - 1;
                while (s7 >= 1 && c3 >= 0 && sampleLines[s7] !== controlLines[c3]) {
                  c3--;
                }
                for (; s7 >= 1 && c3 >= 0; s7--, c3--) {
                  if (sampleLines[s7] !== controlLines[c3]) {
                    if (s7 !== 1 || c3 !== 1) {
                      do {
                        s7--;
                        c3--;
                        if (c3 < 0 || sampleLines[s7] !== controlLines[c3]) {
                          var _frame = "\n" + sampleLines[s7].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s7 >= 1 && c3 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component4) {
            var prototype = Component4.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x3) {
                  }
                }
              }
            }
            return "";
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray3(a3) {
            return isArrayImpl(a3);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e3) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown;
          var specialPropRefWarningShown;
          var didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config) {
            {
              if (hasOwnProperty.call(config, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.ref !== void 0;
          }
          function hasValidKey(config) {
            {
              if (hasOwnProperty.call(config, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.key !== void 0;
          }
          function warnIfStringRefCannotBeAutoConverted(config, self2) {
            {
              if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          function defineKeyPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingKey = function() {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingKey.isReactWarning = true;
              Object.defineProperty(props, "key", {
                get: warnAboutAccessingKey,
                configurable: true
              });
            }
          }
          function defineRefPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingRef = function() {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingRef.isReactWarning = true;
              Object.defineProperty(props, "ref", {
                get: warnAboutAccessingRef,
                configurable: true
              });
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              // This tag allows us to uniquely identify this as a React Element
              $$typeof: REACT_ELEMENT_TYPE,
              // Built-in properties that belong on the element
              type,
              key,
              ref,
              props,
              // Record the component responsible for creating this element.
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function jsxDEV(type, config, maybeKey, source, self2) {
            {
              var propName;
              var props = {};
              var key = null;
              var ref = null;
              if (maybeKey !== void 0) {
                {
                  checkKeyStringCoercion(maybeKey);
                }
                key = "" + maybeKey;
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              if (hasValidRef(config)) {
                ref = config.ref;
                warnIfStringRefCannotBeAutoConverted(config, self2);
              }
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config[propName];
                }
              }
              if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;
                for (propName in defaultProps) {
                  if (props[propName] === void 0) {
                    props[propName] = defaultProps[propName];
                  }
                }
              }
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
              return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function isValidElement(object) {
            {
              return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            }
          }
          function getDeclarationErrorAddendum() {
            {
              if (ReactCurrentOwner$1.current) {
                var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
                if (name) {
                  return "\n\nCheck the render method of `" + name + "`.";
                }
              }
              return "";
            }
          }
          function getSourceInfoErrorAddendum(source) {
            {
              if (source !== void 0) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, "");
                var lineNumber = source.lineNumber;
                return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
              }
              return "";
            }
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            {
              var info = getDeclarationErrorAddendum();
              if (!info) {
                var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                  info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
              }
              return info;
            }
          }
          function validateExplicitKey(element, parentType) {
            {
              if (!element._store || element._store.validated || element.key != null) {
                return;
              }
              element._store.validated = true;
              var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
              if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
              }
              ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
              var childOwner = "";
              if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
                childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
              }
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            {
              if (typeof node !== "object") {
                return;
              }
              if (isArray3(node)) {
                for (var i5 = 0; i5 < node.length; i5++) {
                  var child = node[i5];
                  if (isValidElement(child)) {
                    validateExplicitKey(child, parentType);
                  }
                }
              } else if (isValidElement(node)) {
                if (node._store) {
                  node._store.validated = true;
                }
              } else if (node) {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === "function") {
                  if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while (!(step = iterator.next()).done) {
                      if (isValidElement(step.value)) {
                        validateExplicitKey(step.value, parentType);
                      }
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i5 = 0; i5 < keys.length; i5++) {
                var key = keys[i5];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          var didWarnAboutKeySpread = {};
          function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
            {
              var validType = isValidElementType(type);
              if (!validType) {
                var info = "";
                if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendum(source);
                if (sourceInfo) {
                  info += sourceInfo;
                } else {
                  info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                  typeString = "null";
                } else if (isArray3(type)) {
                  typeString = "array";
                } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                  typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                  info = " Did you accidentally export a JSX literal instead of a component?";
                } else {
                  typeString = typeof type;
                }
                error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
              var element = jsxDEV(type, props, key, source, self2);
              if (element == null) {
                return element;
              }
              if (validType) {
                var children = props.children;
                if (children !== void 0) {
                  if (isStaticChildren) {
                    if (isArray3(children)) {
                      for (var i5 = 0; i5 < children.length; i5++) {
                        validateChildKeys(children[i5], type);
                      }
                      if (Object.freeze) {
                        Object.freeze(children);
                      }
                    } else {
                      error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                    }
                  } else {
                    validateChildKeys(children, type);
                  }
                }
              }
              {
                if (hasOwnProperty.call(props, "key")) {
                  var componentName = getComponentNameFromType(type);
                  var keys = Object.keys(props).filter(function(k) {
                    return k !== "key";
                  });
                  var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
                  if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                    var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                    error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                    didWarnAboutKeySpread[componentName + beforeExample] = true;
                  }
                }
              }
              if (type === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
              } else {
                validatePropTypes(element);
              }
              return element;
            }
          }
          function jsxWithValidationStatic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, true);
            }
          }
          function jsxWithValidationDynamic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, false);
            }
          }
          var jsx11 = jsxWithValidationDynamic;
          var jsxs4 = jsxWithValidationStatic;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.jsx = jsx11;
          exports.jsxs = jsxs4;
        })();
      }
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
  var require_use_sync_external_store_shim_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React92 = require_react();
          var ReactSharedInternals = React92.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error(format2) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          function is(x3, y2) {
            return x3 === y2 && (x3 !== 0 || 1 / x3 === 1 / y2) || x3 !== x3 && y2 !== y2;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          var useState29 = React92.useState, useEffect30 = React92.useEffect, useLayoutEffect4 = React92.useLayoutEffect, useDebugValue = React92.useDebugValue;
          var didWarnOld18Alpha = false;
          var didWarnUncachedGetSnapshot = false;
          function useSyncExternalStore2(subscribe, getSnapshot, getServerSnapshot) {
            {
              if (!didWarnOld18Alpha) {
                if (React92.startTransition !== void 0) {
                  didWarnOld18Alpha = true;
                  error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
                }
              }
            }
            var value = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedValue = getSnapshot();
                if (!objectIs(value, cachedValue)) {
                  error("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var _useState = useState29({
              inst: {
                value,
                getSnapshot
              }
            }), inst = _useState[0].inst, forceUpdate = _useState[1];
            useLayoutEffect4(function() {
              inst.value = value;
              inst.getSnapshot = getSnapshot;
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            }, [subscribe, value, getSnapshot]);
            useEffect30(function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
              var handleStoreChange = function() {
                if (checkIfSnapshotChanged(inst)) {
                  forceUpdate({
                    inst
                  });
                }
              };
              return subscribe(handleStoreChange);
            }, [subscribe]);
            useDebugValue(value);
            return value;
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error2) {
              return true;
            }
          }
          function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
            return getSnapshot();
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var isServerEnvironment = !canUseDOM;
          var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
          var useSyncExternalStore$2 = React92.useSyncExternalStore !== void 0 ? React92.useSyncExternalStore : shim;
          exports.useSyncExternalStore = useSyncExternalStore$2;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_use_sync_external_store_shim_development();
      }
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
  var require_with_selector_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React92 = require_react();
          var shim = require_shim();
          function is(x3, y2) {
            return x3 === y2 && (x3 !== 0 || 1 / x3 === 1 / y2) || x3 !== x3 && y2 !== y2;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          var useSyncExternalStore2 = shim.useSyncExternalStore;
          var useRef12 = React92.useRef, useEffect30 = React92.useEffect, useMemo7 = React92.useMemo, useDebugValue = React92.useDebugValue;
          function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
            var instRef = useRef12(null);
            var inst;
            if (instRef.current === null) {
              inst = {
                hasValue: false,
                value: null
              };
              instRef.current = inst;
            } else {
              inst = instRef.current;
            }
            var _useMemo = useMemo7(function() {
              var hasMemo = false;
              var memoizedSnapshot;
              var memoizedSelection;
              var memoizedSelector = function(nextSnapshot) {
                if (!hasMemo) {
                  hasMemo = true;
                  memoizedSnapshot = nextSnapshot;
                  var _nextSelection = selector(nextSnapshot);
                  if (isEqual2 !== void 0) {
                    if (inst.hasValue) {
                      var currentSelection = inst.value;
                      if (isEqual2(currentSelection, _nextSelection)) {
                        memoizedSelection = currentSelection;
                        return currentSelection;
                      }
                    }
                  }
                  memoizedSelection = _nextSelection;
                  return _nextSelection;
                }
                var prevSnapshot = memoizedSnapshot;
                var prevSelection = memoizedSelection;
                if (objectIs(prevSnapshot, nextSnapshot)) {
                  return prevSelection;
                }
                var nextSelection = selector(nextSnapshot);
                if (isEqual2 !== void 0 && isEqual2(prevSelection, nextSelection)) {
                  return prevSelection;
                }
                memoizedSnapshot = nextSnapshot;
                memoizedSelection = nextSelection;
                return nextSelection;
              };
              var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
              var getSnapshotWithSelector = function() {
                return memoizedSelector(getSnapshot());
              };
              var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              };
              return [getSnapshotWithSelector, getServerSnapshotWithSelector];
            }, [getSnapshot, getServerSnapshot, selector, isEqual2]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
            var value = useSyncExternalStore2(subscribe, getSelection, getServerSelection);
            useEffect30(function() {
              inst.hasValue = true;
              inst.value = value;
            }, [value]);
            useDebugValue(value);
            return value;
          }
          exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/use-sync-external-store/shim/with-selector.js
  var require_with_selector = __commonJS({
    "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_with_selector_development();
      }
    }
  });

  // node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
          function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element3 = REACT_ELEMENT_TYPE;
          var ForwardRef10 = REACT_FORWARD_REF_TYPE;
          var Fragment11 = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense3 = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement2(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element3;
          exports.ForwardRef = ForwardRef10;
          exports.Fragment = Fragment11;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense3;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement2;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_is_development();
      }
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i5 = 0; i5 < 10; i5++) {
            test2["_" + String.fromCharCode(i5)] = i5;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
            return test2[n2];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from2;
        var to2 = toObject(target);
        var symbols;
        for (var s7 = 1; s7 < arguments.length; s7++) {
          from2 = Object(arguments[s7]);
          for (var key in from2) {
            if (hasOwnProperty.call(from2, key)) {
              to2[key] = from2[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from2);
            for (var i5 = 0; i5 < symbols.length; i5++) {
              if (propIsEnumerable.call(from2, symbols[i5])) {
                to2[symbols[i5]] = from2[symbols[i5]];
              }
            }
          }
        }
        return to2;
      };
    }
  });

  // node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module.exports = ReactPropTypesSecret;
    }
  });

  // node_modules/prop-types/lib/has.js
  var require_has = __commonJS({
    "node_modules/prop-types/lib/has.js"(exports, module) {
      module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/prop-types/checkPropTypes.js
  var require_checkPropTypes = __commonJS({
    "node_modules/prop-types/checkPropTypes.js"(exports, module) {
      "use strict";
      var printWarning = function() {
      };
      if (true) {
        ReactPropTypesSecret = require_ReactPropTypesSecret();
        loggedTypeFailures = {};
        has = require_has();
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x3) {
          }
        };
      }
      var ReactPropTypesSecret;
      var loggedTypeFailures;
      var has;
      function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
        if (true) {
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error(
                    (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                  );
                  err.name = "Invariant Violation";
                  throw err;
                }
                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
              } catch (ex) {
                error = ex;
              }
              if (error && !(error instanceof Error)) {
                printWarning(
                  (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
                );
              }
              if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                loggedTypeFailures[error.message] = true;
                var stack = getStack ? getStack() : "";
                printWarning(
                  "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
                );
              }
            }
          }
        }
      }
      checkPropTypes.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      };
      module.exports = checkPropTypes;
    }
  });

  // node_modules/prop-types/factoryWithTypeCheckers.js
  var require_factoryWithTypeCheckers = __commonJS({
    "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
      "use strict";
      var ReactIs = require_react_is();
      var assign = require_object_assign();
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      var has = require_has();
      var checkPropTypes = require_checkPropTypes();
      var printWarning = function() {
      };
      if (true) {
        printWarning = function(text) {
          var message = "Warning: " + text;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x3) {
          }
        };
      }
      function emptyFunctionThatReturnsNull() {
        return null;
      }
      module.exports = function(isValidElement, throwOnDirectAccess) {
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var ANONYMOUS = "<<anonymous>>";
        var ReactPropTypes = {
          array: createPrimitiveTypeChecker("array"),
          bigint: createPrimitiveTypeChecker("bigint"),
          bool: createPrimitiveTypeChecker("boolean"),
          func: createPrimitiveTypeChecker("function"),
          number: createPrimitiveTypeChecker("number"),
          object: createPrimitiveTypeChecker("object"),
          string: createPrimitiveTypeChecker("string"),
          symbol: createPrimitiveTypeChecker("symbol"),
          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker
        };
        function is(x3, y2) {
          if (x3 === y2) {
            return x3 !== 0 || 1 / x3 === 1 / y2;
          } else {
            return x3 !== x3 && y2 !== y2;
          }
        }
        function PropTypeError(message, data) {
          this.message = message;
          this.data = data && typeof data === "object" ? data : {};
          this.stack = "";
        }
        PropTypeError.prototype = Error.prototype;
        function createChainableTypeChecker(validate) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
                var err = new Error(
                  "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                );
                err.name = "Invariant Violation";
                throw err;
              } else if (typeof console !== "undefined") {
                var cacheKey = componentName + ":" + propName;
                if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                manualPropTypeWarningCount < 3) {
                  printWarning(
                    "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                  );
                  manualPropTypeCallCache[cacheKey] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                }
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
              }
              return null;
            } else {
              return validate(props, propName, componentName, location, propFullName);
            }
          }
          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
          function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
              var preciseType = getPreciseType(propValue);
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
                { expectedType }
              );
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunctionThatReturnsNull);
        }
        function createArrayOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i5 = 0; i5 < propValue.length; i5++) {
              var error = typeChecker(propValue, i5, componentName, location, propFullName + "[" + i5 + "]", ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createInstanceTypeChecker(expectedClass) {
          function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              var expectedClassName = expectedClass.name || ANONYMOUS;
              var actualClassName = getClassName(props[propName]);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning(
                  "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
                );
              } else {
                printWarning("Invalid argument supplied to oneOf, expected an array.");
              }
            }
            return emptyFunctionThatReturnsNull;
          }
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for (var i5 = 0; i5 < expectedValues.length; i5++) {
              if (is(propValue, expectedValues[i5])) {
                return null;
              }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
              var type = getPreciseType(value);
              if (type === "symbol") {
                return String(value);
              }
              return value;
            });
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createObjectOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
              if (has(propValue, key)) {
                var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
                if (error instanceof Error) {
                  return error;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
            return emptyFunctionThatReturnsNull;
          }
          for (var i5 = 0; i5 < arrayOfTypeCheckers.length; i5++) {
            var checker = arrayOfTypeCheckers[i5];
            if (typeof checker !== "function") {
              printWarning(
                "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i5 + "."
              );
              return emptyFunctionThatReturnsNull;
            }
          }
          function validate(props, propName, componentName, location, propFullName) {
            var expectedTypes = [];
            for (var i6 = 0; i6 < arrayOfTypeCheckers.length; i6++) {
              var checker2 = arrayOfTypeCheckers[i6];
              var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
              if (checkerResult == null) {
                return null;
              }
              if (checkerResult.data && has(checkerResult.data, "expectedType")) {
                expectedTypes.push(checkerResult.data.expectedType);
              }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createNodeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function invalidValidatorError(componentName, location, propFullName, key, type) {
          return new PropTypeError(
            (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
          );
        }
        function createShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
              var checker = shapeTypes[key];
              if (typeof checker !== "function") {
                return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
              }
              var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createStrictShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            var allKeys = assign({}, props[propName], shapeTypes);
            for (var key in allKeys) {
              var checker = shapeTypes[key];
              if (has(shapeTypes, key) && typeof checker !== "function") {
                return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
              }
              if (!checker) {
                return new PropTypeError(
                  "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                );
              }
              var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function isNode(propValue) {
          switch (typeof propValue) {
            case "number":
            case "string":
            case "undefined":
              return true;
            case "boolean":
              return !propValue;
            case "object":
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement(propValue)) {
                return true;
              }
              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                var iterator = iteratorFn.call(propValue);
                var step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode(step.value)) {
                      return false;
                    }
                  }
                } else {
                  while (!(step = iterator.next()).done) {
                    var entry = step.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }
              return true;
            default:
              return false;
          }
        }
        function isSymbol(propType, propValue) {
          if (propType === "symbol") {
            return true;
          }
          if (!propValue) {
            return false;
          }
          if (propValue["@@toStringTag"] === "Symbol") {
            return true;
          }
          if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
          }
          return false;
        }
        function getPropType(propValue) {
          var propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return "array";
          }
          if (propValue instanceof RegExp) {
            return "object";
          }
          if (isSymbol(propType, propValue)) {
            return "symbol";
          }
          return propType;
        }
        function getPreciseType(propValue) {
          if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
          }
          var propType = getPropType(propValue);
          if (propType === "object") {
            if (propValue instanceof Date) {
              return "date";
            } else if (propValue instanceof RegExp) {
              return "regexp";
            }
          }
          return propType;
        }
        function getPostfixForTypeWarning(value) {
          var type = getPreciseType(value);
          switch (type) {
            case "array":
            case "object":
              return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
              return "a " + type;
            default:
              return type;
          }
        }
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }
        ReactPropTypes.checkPropTypes = checkPropTypes;
        ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "node_modules/prop-types/index.js"(exports, module) {
      if (true) {
        ReactIs = require_react_is();
        throwOnDirectAccess = true;
        module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module.exports = null();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // node_modules/flatpickr/dist/flatpickr.js
  var require_flatpickr = __commonJS({
    "node_modules/flatpickr/dist/flatpickr.js"(exports, module) {
      (function(global2, factory2) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.flatpickr = factory2());
      })(exports, function() {
        "use strict";
        var __assign = function() {
          __assign = Object.assign || function __assign2(t7) {
            for (var s7, i5 = 1, n2 = arguments.length; i5 < n2; i5++) {
              s7 = arguments[i5];
              for (var p3 in s7) if (Object.prototype.hasOwnProperty.call(s7, p3)) t7[p3] = s7[p3];
            }
            return t7;
          };
          return __assign.apply(this, arguments);
        };
        function __spreadArrays() {
          for (var s7 = 0, i5 = 0, il = arguments.length; i5 < il; i5++) s7 += arguments[i5].length;
          for (var r6 = Array(s7), k = 0, i5 = 0; i5 < il; i5++)
            for (var a3 = arguments[i5], j2 = 0, jl = a3.length; j2 < jl; j2++, k++)
              r6[k] = a3[j2];
          return r6;
        }
        var HOOKS = [
          "onChange",
          "onClose",
          "onDayCreate",
          "onDestroy",
          "onKeyDown",
          "onMonthChange",
          "onOpen",
          "onParseConfig",
          "onReady",
          "onValueUpdate",
          "onYearChange",
          "onPreCalendarPosition"
        ];
        var defaults2 = {
          _disable: [],
          allowInput: false,
          allowInvalidPreload: false,
          altFormat: "F j, Y",
          altInput: false,
          altInputClass: "form-control input",
          animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
          ariaDateFormat: "F j, Y",
          autoFillDefaultTime: true,
          clickOpens: true,
          closeOnSelect: true,
          conjunction: ", ",
          dateFormat: "Y-m-d",
          defaultHour: 12,
          defaultMinute: 0,
          defaultSeconds: 0,
          disable: [],
          disableMobile: false,
          enableSeconds: false,
          enableTime: false,
          errorHandler: function(err) {
            return typeof console !== "undefined" && console.warn(err);
          },
          getWeek: function(givenDate) {
            var date = new Date(givenDate.getTime());
            date.setHours(0, 0, 0, 0);
            date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
            var week1 = new Date(date.getFullYear(), 0, 4);
            return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
          },
          hourIncrement: 1,
          ignoredFocusElements: [],
          inline: false,
          locale: "default",
          minuteIncrement: 5,
          mode: "single",
          monthSelectorType: "dropdown",
          nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
          noCalendar: false,
          now: /* @__PURE__ */ new Date(),
          onChange: [],
          onClose: [],
          onDayCreate: [],
          onDestroy: [],
          onKeyDown: [],
          onMonthChange: [],
          onOpen: [],
          onParseConfig: [],
          onReady: [],
          onValueUpdate: [],
          onYearChange: [],
          onPreCalendarPosition: [],
          plugins: [],
          position: "auto",
          positionElement: void 0,
          prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
          shorthandCurrentMonth: false,
          showMonths: 1,
          static: false,
          time_24hr: false,
          weekNumbers: false,
          wrap: false
        };
        var english = {
          weekdays: {
            shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            longhand: [
              "Sunday",
              "Monday",
              "Tuesday",
              "Wednesday",
              "Thursday",
              "Friday",
              "Saturday"
            ]
          },
          months: {
            shorthand: [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec"
            ],
            longhand: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ]
          },
          daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
          firstDayOfWeek: 0,
          ordinal: function(nth) {
            var s7 = nth % 100;
            if (s7 > 3 && s7 < 21)
              return "th";
            switch (s7 % 10) {
              case 1:
                return "st";
              case 2:
                return "nd";
              case 3:
                return "rd";
              default:
                return "th";
            }
          },
          rangeSeparator: " to ",
          weekAbbreviation: "Wk",
          scrollTitle: "Scroll to increment",
          toggleTitle: "Click to toggle",
          amPM: ["AM", "PM"],
          yearAriaLabel: "Year",
          monthAriaLabel: "Month",
          hourAriaLabel: "Hour",
          minuteAriaLabel: "Minute",
          time_24hr: false
        };
        var pad2 = function(number, length) {
          if (length === void 0) {
            length = 2;
          }
          return ("000" + number).slice(length * -1);
        };
        var int = function(bool) {
          return bool === true ? 1 : 0;
        };
        function debounce3(fn2, wait) {
          var t7;
          return function() {
            var _this = this;
            var args = arguments;
            clearTimeout(t7);
            t7 = setTimeout(function() {
              return fn2.apply(_this, args);
            }, wait);
          };
        }
        var arrayify = function(obj) {
          return obj instanceof Array ? obj : [obj];
        };
        function toggleClass(elem, className, bool) {
          if (bool === true)
            return elem.classList.add(className);
          elem.classList.remove(className);
        }
        function createElement15(tag, className, content) {
          var e3 = window.document.createElement(tag);
          className = className || "";
          content = content || "";
          e3.className = className;
          if (content !== void 0)
            e3.textContent = content;
          return e3;
        }
        function clearNode(node) {
          while (node.firstChild)
            node.removeChild(node.firstChild);
        }
        function findParent(node, condition) {
          if (condition(node))
            return node;
          else if (node.parentNode)
            return findParent(node.parentNode, condition);
          return void 0;
        }
        function createNumberInput(inputClassName, opts) {
          var wrapper = createElement15("div", "numInputWrapper"), numInput = createElement15("input", "numInput " + inputClassName), arrowUp = createElement15("span", "arrowUp"), arrowDown = createElement15("span", "arrowDown");
          if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
            numInput.type = "number";
          } else {
            numInput.type = "text";
            numInput.pattern = "\\d*";
          }
          if (opts !== void 0)
            for (var key in opts)
              numInput.setAttribute(key, opts[key]);
          wrapper.appendChild(numInput);
          wrapper.appendChild(arrowUp);
          wrapper.appendChild(arrowDown);
          return wrapper;
        }
        function getEventTarget(event) {
          try {
            if (typeof event.composedPath === "function") {
              var path = event.composedPath();
              return path[0];
            }
            return event.target;
          } catch (error) {
            return event.target;
          }
        }
        var doNothing = function() {
          return void 0;
        };
        var monthToStr = function(monthNumber, shorthand, locale) {
          return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
        };
        var revFormat = {
          D: doNothing,
          F: function(dateObj, monthName, locale) {
            dateObj.setMonth(locale.months.longhand.indexOf(monthName));
          },
          G: function(dateObj, hour) {
            dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
          },
          H: function(dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
          },
          J: function(dateObj, day) {
            dateObj.setDate(parseFloat(day));
          },
          K: function(dateObj, amPM, locale) {
            dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
          },
          M: function(dateObj, shortMonth, locale) {
            dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
          },
          S: function(dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
          },
          U: function(_2, unixSeconds) {
            return new Date(parseFloat(unixSeconds) * 1e3);
          },
          W: function(dateObj, weekNum, locale) {
            var weekNumber = parseInt(weekNum);
            var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
            date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
            return date;
          },
          Y: function(dateObj, year) {
            dateObj.setFullYear(parseFloat(year));
          },
          Z: function(_2, ISODate) {
            return new Date(ISODate);
          },
          d: function(dateObj, day) {
            dateObj.setDate(parseFloat(day));
          },
          h: function(dateObj, hour) {
            dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
          },
          i: function(dateObj, minutes) {
            dateObj.setMinutes(parseFloat(minutes));
          },
          j: function(dateObj, day) {
            dateObj.setDate(parseFloat(day));
          },
          l: doNothing,
          m: function(dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
          },
          n: function(dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
          },
          s: function(dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
          },
          u: function(_2, unixMillSeconds) {
            return new Date(parseFloat(unixMillSeconds));
          },
          w: doNothing,
          y: function(dateObj, year) {
            dateObj.setFullYear(2e3 + parseFloat(year));
          }
        };
        var tokenRegex = {
          D: "",
          F: "",
          G: "(\\d\\d|\\d)",
          H: "(\\d\\d|\\d)",
          J: "(\\d\\d|\\d)\\w+",
          K: "",
          M: "",
          S: "(\\d\\d|\\d)",
          U: "(.+)",
          W: "(\\d\\d|\\d)",
          Y: "(\\d{4})",
          Z: "(.+)",
          d: "(\\d\\d|\\d)",
          h: "(\\d\\d|\\d)",
          i: "(\\d\\d|\\d)",
          j: "(\\d\\d|\\d)",
          l: "",
          m: "(\\d\\d|\\d)",
          n: "(\\d\\d|\\d)",
          s: "(\\d\\d|\\d)",
          u: "(.+)",
          w: "(\\d\\d|\\d)",
          y: "(\\d{2})"
        };
        var formats = {
          // get the date in UTC
          Z: function(date) {
            return date.toISOString();
          },
          // weekday name, short, e.g. Thu
          D: function(date, locale, options) {
            return locale.weekdays.shorthand[formats.w(date, locale, options)];
          },
          // full month name e.g. January
          F: function(date, locale, options) {
            return monthToStr(formats.n(date, locale, options) - 1, false, locale);
          },
          // padded hour 1-12
          G: function(date, locale, options) {
            return pad2(formats.h(date, locale, options));
          },
          // hours with leading zero e.g. 03
          H: function(date) {
            return pad2(date.getHours());
          },
          // day (1-30) with ordinal suffix e.g. 1st, 2nd
          J: function(date, locale) {
            return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
          },
          // AM/PM
          K: function(date, locale) {
            return locale.amPM[int(date.getHours() > 11)];
          },
          // shorthand month e.g. Jan, Sep, Oct, etc
          M: function(date, locale) {
            return monthToStr(date.getMonth(), true, locale);
          },
          // seconds 00-59
          S: function(date) {
            return pad2(date.getSeconds());
          },
          // unix timestamp
          U: function(date) {
            return date.getTime() / 1e3;
          },
          W: function(date, _2, options) {
            return options.getWeek(date);
          },
          // full year e.g. 2016, padded (0001-9999)
          Y: function(date) {
            return pad2(date.getFullYear(), 4);
          },
          // day in month, padded (01-30)
          d: function(date) {
            return pad2(date.getDate());
          },
          // hour from 1-12 (am/pm)
          h: function(date) {
            return date.getHours() % 12 ? date.getHours() % 12 : 12;
          },
          // minutes, padded with leading zero e.g. 09
          i: function(date) {
            return pad2(date.getMinutes());
          },
          // day in month (1-30)
          j: function(date) {
            return date.getDate();
          },
          // weekday name, full, e.g. Thursday
          l: function(date, locale) {
            return locale.weekdays.longhand[date.getDay()];
          },
          // padded month number (01-12)
          m: function(date) {
            return pad2(date.getMonth() + 1);
          },
          // the month number (1-12)
          n: function(date) {
            return date.getMonth() + 1;
          },
          // seconds 0-59
          s: function(date) {
            return date.getSeconds();
          },
          // Unix Milliseconds
          u: function(date) {
            return date.getTime();
          },
          // number of the day of the week
          w: function(date) {
            return date.getDay();
          },
          // last two digits of year e.g. 16 for 2016
          y: function(date) {
            return String(date.getFullYear()).substring(2);
          }
        };
        var createDateFormatter = function(_a9) {
          var _b2 = _a9.config, config = _b2 === void 0 ? defaults2 : _b2, _c = _a9.l10n, l10n = _c === void 0 ? english : _c, _d = _a9.isMobile, isMobile = _d === void 0 ? false : _d;
          return function(dateObj, frmt, overrideLocale) {
            var locale = overrideLocale || l10n;
            if (config.formatDate !== void 0 && !isMobile) {
              return config.formatDate(dateObj, frmt, locale);
            }
            return frmt.split("").map(function(c3, i5, arr) {
              return formats[c3] && arr[i5 - 1] !== "\\" ? formats[c3](dateObj, locale, config) : c3 !== "\\" ? c3 : "";
            }).join("");
          };
        };
        var createDateParser = function(_a9) {
          var _b2 = _a9.config, config = _b2 === void 0 ? defaults2 : _b2, _c = _a9.l10n, l10n = _c === void 0 ? english : _c;
          return function(date, givenFormat, timeless, customLocale) {
            if (date !== 0 && !date)
              return void 0;
            var locale = customLocale || l10n;
            var parsedDate;
            var dateOrig = date;
            if (date instanceof Date)
              parsedDate = new Date(date.getTime());
            else if (typeof date !== "string" && date.toFixed !== void 0)
              parsedDate = new Date(date);
            else if (typeof date === "string") {
              var format2 = givenFormat || (config || defaults2).dateFormat;
              var datestr = String(date).trim();
              if (datestr === "today") {
                parsedDate = /* @__PURE__ */ new Date();
                timeless = true;
              } else if (config && config.parseDate) {
                parsedDate = config.parseDate(date, format2);
              } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
                parsedDate = new Date(date);
              } else {
                var matched = void 0, ops = [];
                for (var i5 = 0, matchIndex = 0, regexStr = ""; i5 < format2.length; i5++) {
                  var token_1 = format2[i5];
                  var isBackSlash = token_1 === "\\";
                  var escaped = format2[i5 - 1] === "\\" || isBackSlash;
                  if (tokenRegex[token_1] && !escaped) {
                    regexStr += tokenRegex[token_1];
                    var match = new RegExp(regexStr).exec(date);
                    if (match && (matched = true)) {
                      ops[token_1 !== "Y" ? "push" : "unshift"]({
                        fn: revFormat[token_1],
                        val: match[++matchIndex]
                      });
                    }
                  } else if (!isBackSlash)
                    regexStr += ".";
                }
                parsedDate = !config || !config.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
                ops.forEach(function(_a10) {
                  var fn2 = _a10.fn, val = _a10.val;
                  return parsedDate = fn2(parsedDate, val, locale) || parsedDate;
                });
                parsedDate = matched ? parsedDate : void 0;
              }
            }
            if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
              config.errorHandler(new Error("Invalid date provided: " + dateOrig));
              return void 0;
            }
            if (timeless === true)
              parsedDate.setHours(0, 0, 0, 0);
            return parsedDate;
          };
        };
        function compareDates(date1, date2, timeless) {
          if (timeless === void 0) {
            timeless = true;
          }
          if (timeless !== false) {
            return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
          }
          return date1.getTime() - date2.getTime();
        }
        var isBetween = function(ts, ts1, ts2) {
          return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
        };
        var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
          return hours * 3600 + minutes * 60 + seconds;
        };
        var parseSeconds = function(secondsSinceMidnight) {
          var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
          return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
        };
        var duration = {
          DAY: 864e5
        };
        function getDefaultHours(config) {
          var hours = config.defaultHour;
          var minutes = config.defaultMinute;
          var seconds = config.defaultSeconds;
          if (config.minDate !== void 0) {
            var minHour = config.minDate.getHours();
            var minMinutes = config.minDate.getMinutes();
            var minSeconds = config.minDate.getSeconds();
            if (hours < minHour) {
              hours = minHour;
            }
            if (hours === minHour && minutes < minMinutes) {
              minutes = minMinutes;
            }
            if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
              seconds = config.minDate.getSeconds();
          }
          if (config.maxDate !== void 0) {
            var maxHr = config.maxDate.getHours();
            var maxMinutes = config.maxDate.getMinutes();
            hours = Math.min(hours, maxHr);
            if (hours === maxHr)
              minutes = Math.min(maxMinutes, minutes);
            if (hours === maxHr && minutes === maxMinutes)
              seconds = config.maxDate.getSeconds();
          }
          return { hours, minutes, seconds };
        }
        if (typeof Object.assign !== "function") {
          Object.assign = function(target) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
            }
            if (!target) {
              throw TypeError("Cannot convert undefined or null to object");
            }
            var _loop_1 = function(source2) {
              if (source2) {
                Object.keys(source2).forEach(function(key) {
                  return target[key] = source2[key];
                });
              }
            };
            for (var _a9 = 0, args_1 = args; _a9 < args_1.length; _a9++) {
              var source = args_1[_a9];
              _loop_1(source);
            }
            return target;
          };
        }
        var DEBOUNCED_CHANGE_MS = 300;
        function FlatpickrInstance(element, instanceConfig) {
          var self2 = {
            config: __assign(__assign({}, defaults2), flatpickr.defaultConfig),
            l10n: english
          };
          self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
          self2._handlers = [];
          self2.pluginElements = [];
          self2.loadedPlugins = [];
          self2._bind = bind;
          self2._setHoursFromDate = setHoursFromDate;
          self2._positionCalendar = positionCalendar;
          self2.changeMonth = changeMonth;
          self2.changeYear = changeYear;
          self2.clear = clear;
          self2.close = close;
          self2.onMouseOver = onMouseOver;
          self2._createElement = createElement15;
          self2.createDay = createDay;
          self2.destroy = destroy;
          self2.isEnabled = isEnabled;
          self2.jumpToDate = jumpToDate;
          self2.updateValue = updateValue;
          self2.open = open;
          self2.redraw = redraw;
          self2.set = set2;
          self2.setDate = setDate;
          self2.toggle = toggle;
          function setupHelperFunctions() {
            self2.utils = {
              getDaysInMonth: function(month, yr) {
                if (month === void 0) {
                  month = self2.currentMonth;
                }
                if (yr === void 0) {
                  yr = self2.currentYear;
                }
                if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
                  return 29;
                return self2.l10n.daysInMonth[month];
              }
            };
          }
          function init() {
            self2.element = self2.input = element;
            self2.isOpen = false;
            parseConfig();
            setupLocale();
            setupInputs();
            setupDates();
            setupHelperFunctions();
            if (!self2.isMobile)
              build();
            bindEvents();
            if (self2.selectedDates.length || self2.config.noCalendar) {
              if (self2.config.enableTime) {
                setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
              }
              updateValue(false);
            }
            setCalendarWidth();
            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            if (!self2.isMobile && isSafari) {
              positionCalendar();
            }
            triggerEvent("onReady");
          }
          function getClosestActiveElement() {
            var _a9;
            return ((_a9 = self2.calendarContainer) === null || _a9 === void 0 ? void 0 : _a9.getRootNode()).activeElement || document.activeElement;
          }
          function bindToInstance(fn2) {
            return fn2.bind(self2);
          }
          function setCalendarWidth() {
            var config = self2.config;
            if (config.weekNumbers === false && config.showMonths === 1) {
              return;
            } else if (config.noCalendar !== true) {
              window.requestAnimationFrame(function() {
                if (self2.calendarContainer !== void 0) {
                  self2.calendarContainer.style.visibility = "hidden";
                  self2.calendarContainer.style.display = "block";
                }
                if (self2.daysContainer !== void 0) {
                  var daysWidth = (self2.days.offsetWidth + 1) * config.showMonths;
                  self2.daysContainer.style.width = daysWidth + "px";
                  self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
                  self2.calendarContainer.style.removeProperty("visibility");
                  self2.calendarContainer.style.removeProperty("display");
                }
              });
            }
          }
          function updateTime(e3) {
            if (self2.selectedDates.length === 0) {
              var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
              var defaults3 = getDefaultHours(self2.config);
              defaultDate.setHours(defaults3.hours, defaults3.minutes, defaults3.seconds, defaultDate.getMilliseconds());
              self2.selectedDates = [defaultDate];
              self2.latestSelectedDateObj = defaultDate;
            }
            if (e3 !== void 0 && e3.type !== "blur") {
              timeWrapper(e3);
            }
            var prevValue = self2._input.value;
            setHoursFromInputs();
            updateValue();
            if (self2._input.value !== prevValue) {
              self2._debouncedChange();
            }
          }
          function ampm2military(hour, amPM) {
            return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
          }
          function military2ampm(hour) {
            switch (hour % 24) {
              case 0:
              case 12:
                return 12;
              default:
                return hour % 12;
            }
          }
          function setHoursFromInputs() {
            if (self2.hourElement === void 0 || self2.minuteElement === void 0)
              return;
            var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
            if (self2.amPM !== void 0) {
              hours = ampm2military(hours, self2.amPM.textContent);
            }
            var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
            var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
            if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
              var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
              var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
              var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
              if (currentTime > maxBound && currentTime < minBound) {
                var result = parseSeconds(minBound);
                hours = result[0];
                minutes = result[1];
                seconds = result[2];
              }
            } else {
              if (limitMaxHours) {
                var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
                hours = Math.min(hours, maxTime.getHours());
                if (hours === maxTime.getHours())
                  minutes = Math.min(minutes, maxTime.getMinutes());
                if (minutes === maxTime.getMinutes())
                  seconds = Math.min(seconds, maxTime.getSeconds());
              }
              if (limitMinHours) {
                var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
                hours = Math.max(hours, minTime.getHours());
                if (hours === minTime.getHours() && minutes < minTime.getMinutes())
                  minutes = minTime.getMinutes();
                if (minutes === minTime.getMinutes())
                  seconds = Math.max(seconds, minTime.getSeconds());
              }
            }
            setHours(hours, minutes, seconds);
          }
          function setHoursFromDate(dateObj) {
            var date = dateObj || self2.latestSelectedDateObj;
            if (date && date instanceof Date) {
              setHours(date.getHours(), date.getMinutes(), date.getSeconds());
            }
          }
          function setHours(hours, minutes, seconds) {
            if (self2.latestSelectedDateObj !== void 0) {
              self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
            }
            if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
              return;
            self2.hourElement.value = pad2(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
            self2.minuteElement.value = pad2(minutes);
            if (self2.amPM !== void 0)
              self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
            if (self2.secondElement !== void 0)
              self2.secondElement.value = pad2(seconds);
          }
          function onYearInput(event) {
            var eventTarget = getEventTarget(event);
            var year = parseInt(eventTarget.value) + (event.delta || 0);
            if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
              changeYear(year);
            }
          }
          function bind(element2, event, handler, options) {
            if (event instanceof Array)
              return event.forEach(function(ev) {
                return bind(element2, ev, handler, options);
              });
            if (element2 instanceof Array)
              return element2.forEach(function(el) {
                return bind(el, event, handler, options);
              });
            element2.addEventListener(event, handler, options);
            self2._handlers.push({
              remove: function() {
                return element2.removeEventListener(event, handler, options);
              }
            });
          }
          function triggerChange() {
            triggerEvent("onChange");
          }
          function bindEvents() {
            if (self2.config.wrap) {
              ["open", "close", "toggle", "clear"].forEach(function(evt) {
                Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
                  return bind(el, "click", self2[evt]);
                });
              });
            }
            if (self2.isMobile) {
              setupMobile();
              return;
            }
            var debouncedResize = debounce3(onResize, 50);
            self2._debouncedChange = debounce3(triggerChange, DEBOUNCED_CHANGE_MS);
            if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
              bind(self2.daysContainer, "mouseover", function(e3) {
                if (self2.config.mode === "range")
                  onMouseOver(getEventTarget(e3));
              });
            bind(self2._input, "keydown", onKeyDown);
            if (self2.calendarContainer !== void 0) {
              bind(self2.calendarContainer, "keydown", onKeyDown);
            }
            if (!self2.config.inline && !self2.config.static)
              bind(window, "resize", debouncedResize);
            if (window.ontouchstart !== void 0)
              bind(window.document, "touchstart", documentClick);
            else
              bind(window.document, "mousedown", documentClick);
            bind(window.document, "focus", documentClick, { capture: true });
            if (self2.config.clickOpens === true) {
              bind(self2._input, "focus", self2.open);
              bind(self2._input, "click", self2.open);
            }
            if (self2.daysContainer !== void 0) {
              bind(self2.monthNav, "click", onMonthNavClick);
              bind(self2.monthNav, ["keyup", "increment"], onYearInput);
              bind(self2.daysContainer, "click", selectDate);
            }
            if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
              var selText = function(e3) {
                return getEventTarget(e3).select();
              };
              bind(self2.timeContainer, ["increment"], updateTime);
              bind(self2.timeContainer, "blur", updateTime, { capture: true });
              bind(self2.timeContainer, "click", timeIncrement);
              bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
              if (self2.secondElement !== void 0)
                bind(self2.secondElement, "focus", function() {
                  return self2.secondElement && self2.secondElement.select();
                });
              if (self2.amPM !== void 0) {
                bind(self2.amPM, "click", function(e3) {
                  updateTime(e3);
                });
              }
            }
            if (self2.config.allowInput) {
              bind(self2._input, "blur", onBlur);
            }
          }
          function jumpToDate(jumpDate, triggerChange2) {
            var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
            var oldYear = self2.currentYear;
            var oldMonth = self2.currentMonth;
            try {
              if (jumpTo !== void 0) {
                self2.currentYear = jumpTo.getFullYear();
                self2.currentMonth = jumpTo.getMonth();
              }
            } catch (e3) {
              e3.message = "Invalid date supplied: " + jumpTo;
              self2.config.errorHandler(e3);
            }
            if (triggerChange2 && self2.currentYear !== oldYear) {
              triggerEvent("onYearChange");
              buildMonthSwitch();
            }
            if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
              triggerEvent("onMonthChange");
            }
            self2.redraw();
          }
          function timeIncrement(e3) {
            var eventTarget = getEventTarget(e3);
            if (~eventTarget.className.indexOf("arrow"))
              incrementNumInput(e3, eventTarget.classList.contains("arrowUp") ? 1 : -1);
          }
          function incrementNumInput(e3, delta, inputElem) {
            var target = e3 && getEventTarget(e3);
            var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
            var event = createEvent("increment");
            event.delta = delta;
            input && input.dispatchEvent(event);
          }
          function build() {
            var fragment = window.document.createDocumentFragment();
            self2.calendarContainer = createElement15("div", "flatpickr-calendar");
            self2.calendarContainer.tabIndex = -1;
            if (!self2.config.noCalendar) {
              fragment.appendChild(buildMonthNav());
              self2.innerContainer = createElement15("div", "flatpickr-innerContainer");
              if (self2.config.weekNumbers) {
                var _a9 = buildWeeks(), weekWrapper = _a9.weekWrapper, weekNumbers = _a9.weekNumbers;
                self2.innerContainer.appendChild(weekWrapper);
                self2.weekNumbers = weekNumbers;
                self2.weekWrapper = weekWrapper;
              }
              self2.rContainer = createElement15("div", "flatpickr-rContainer");
              self2.rContainer.appendChild(buildWeekdays());
              if (!self2.daysContainer) {
                self2.daysContainer = createElement15("div", "flatpickr-days");
                self2.daysContainer.tabIndex = -1;
              }
              buildDays();
              self2.rContainer.appendChild(self2.daysContainer);
              self2.innerContainer.appendChild(self2.rContainer);
              fragment.appendChild(self2.innerContainer);
            }
            if (self2.config.enableTime) {
              fragment.appendChild(buildTime());
            }
            toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
            toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
            toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
            self2.calendarContainer.appendChild(fragment);
            var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
            if (self2.config.inline || self2.config.static) {
              self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
              if (self2.config.inline) {
                if (!customAppend && self2.element.parentNode)
                  self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
                else if (self2.config.appendTo !== void 0)
                  self2.config.appendTo.appendChild(self2.calendarContainer);
              }
              if (self2.config.static) {
                var wrapper = createElement15("div", "flatpickr-wrapper");
                if (self2.element.parentNode)
                  self2.element.parentNode.insertBefore(wrapper, self2.element);
                wrapper.appendChild(self2.element);
                if (self2.altInput)
                  wrapper.appendChild(self2.altInput);
                wrapper.appendChild(self2.calendarContainer);
              }
            }
            if (!self2.config.static && !self2.config.inline)
              (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
          }
          function createDay(className, date, _dayNumber, i5) {
            var dateIsEnabled = isEnabled(date, true), dayElement = createElement15("span", className, date.getDate().toString());
            dayElement.dateObj = date;
            dayElement.$i = i5;
            dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
            if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
              self2.todayDateElem = dayElement;
              dayElement.classList.add("today");
              dayElement.setAttribute("aria-current", "date");
            }
            if (dateIsEnabled) {
              dayElement.tabIndex = -1;
              if (isDateSelected(date)) {
                dayElement.classList.add("selected");
                self2.selectedDateElem = dayElement;
                if (self2.config.mode === "range") {
                  toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
                  toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
                  if (className === "nextMonthDay")
                    dayElement.classList.add("inRange");
                }
              }
            } else {
              dayElement.classList.add("flatpickr-disabled");
            }
            if (self2.config.mode === "range") {
              if (isDateInRange(date) && !isDateSelected(date))
                dayElement.classList.add("inRange");
            }
            if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i5 % 7 === 6) {
              self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
            }
            triggerEvent("onDayCreate", dayElement);
            return dayElement;
          }
          function focusOnDayElem(targetNode) {
            targetNode.focus();
            if (self2.config.mode === "range")
              onMouseOver(targetNode);
          }
          function getFirstAvailableDay(delta) {
            var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
            var endMonth = delta > 0 ? self2.config.showMonths : -1;
            for (var m5 = startMonth; m5 != endMonth; m5 += delta) {
              var month = self2.daysContainer.children[m5];
              var startIndex = delta > 0 ? 0 : month.children.length - 1;
              var endIndex = delta > 0 ? month.children.length : -1;
              for (var i5 = startIndex; i5 != endIndex; i5 += delta) {
                var c3 = month.children[i5];
                if (c3.className.indexOf("hidden") === -1 && isEnabled(c3.dateObj))
                  return c3;
              }
            }
            return void 0;
          }
          function getNextAvailableDay(current, delta) {
            var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
            var endMonth = delta > 0 ? self2.config.showMonths : -1;
            var loopDelta = delta > 0 ? 1 : -1;
            for (var m5 = givenMonth - self2.currentMonth; m5 != endMonth; m5 += loopDelta) {
              var month = self2.daysContainer.children[m5];
              var startIndex = givenMonth - self2.currentMonth === m5 ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
              var numMonthDays = month.children.length;
              for (var i5 = startIndex; i5 >= 0 && i5 < numMonthDays && i5 != (delta > 0 ? numMonthDays : -1); i5 += loopDelta) {
                var c3 = month.children[i5];
                if (c3.className.indexOf("hidden") === -1 && isEnabled(c3.dateObj) && Math.abs(current.$i - i5) >= Math.abs(delta))
                  return focusOnDayElem(c3);
              }
            }
            self2.changeMonth(loopDelta);
            focusOnDay(getFirstAvailableDay(loopDelta), 0);
            return void 0;
          }
          function focusOnDay(current, offset2) {
            var activeElement = getClosestActiveElement();
            var dayFocused = isInView(activeElement || document.body);
            var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
            if (startElem === void 0) {
              self2._input.focus();
            } else if (!dayFocused) {
              focusOnDayElem(startElem);
            } else {
              getNextAvailableDay(startElem, offset2);
            }
          }
          function buildMonthDays(year, month) {
            var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
            var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
            var daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
            var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
            for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
              days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
            }
            for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
              days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
            }
            for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
              days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
            }
            var dayContainer = createElement15("div", "dayContainer");
            dayContainer.appendChild(days);
            return dayContainer;
          }
          function buildDays() {
            if (self2.daysContainer === void 0) {
              return;
            }
            clearNode(self2.daysContainer);
            if (self2.weekNumbers)
              clearNode(self2.weekNumbers);
            var frag = document.createDocumentFragment();
            for (var i5 = 0; i5 < self2.config.showMonths; i5++) {
              var d5 = new Date(self2.currentYear, self2.currentMonth, 1);
              d5.setMonth(self2.currentMonth + i5);
              frag.appendChild(buildMonthDays(d5.getFullYear(), d5.getMonth()));
            }
            self2.daysContainer.appendChild(frag);
            self2.days = self2.daysContainer.firstChild;
            if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
              onMouseOver();
            }
          }
          function buildMonthSwitch() {
            if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
              return;
            var shouldBuildMonth = function(month2) {
              if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
                return false;
              }
              return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
            };
            self2.monthsDropdownContainer.tabIndex = -1;
            self2.monthsDropdownContainer.innerHTML = "";
            for (var i5 = 0; i5 < 12; i5++) {
              if (!shouldBuildMonth(i5))
                continue;
              var month = createElement15("option", "flatpickr-monthDropdown-month");
              month.value = new Date(self2.currentYear, i5).getMonth().toString();
              month.textContent = monthToStr(i5, self2.config.shorthandCurrentMonth, self2.l10n);
              month.tabIndex = -1;
              if (self2.currentMonth === i5) {
                month.selected = true;
              }
              self2.monthsDropdownContainer.appendChild(month);
            }
          }
          function buildMonth() {
            var container2 = createElement15("div", "flatpickr-month");
            var monthNavFragment = window.document.createDocumentFragment();
            var monthElement;
            if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
              monthElement = createElement15("span", "cur-month");
            } else {
              self2.monthsDropdownContainer = createElement15("select", "flatpickr-monthDropdown-months");
              self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
              bind(self2.monthsDropdownContainer, "change", function(e3) {
                var target = getEventTarget(e3);
                var selectedMonth = parseInt(target.value, 10);
                self2.changeMonth(selectedMonth - self2.currentMonth);
                triggerEvent("onMonthChange");
              });
              buildMonthSwitch();
              monthElement = self2.monthsDropdownContainer;
            }
            var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
            var yearElement = yearInput.getElementsByTagName("input")[0];
            yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
            if (self2.config.minDate) {
              yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
            }
            if (self2.config.maxDate) {
              yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
              yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
            }
            var currentMonth = createElement15("div", "flatpickr-current-month");
            currentMonth.appendChild(monthElement);
            currentMonth.appendChild(yearInput);
            monthNavFragment.appendChild(currentMonth);
            container2.appendChild(monthNavFragment);
            return {
              container: container2,
              yearElement,
              monthElement
            };
          }
          function buildMonths() {
            clearNode(self2.monthNav);
            self2.monthNav.appendChild(self2.prevMonthNav);
            if (self2.config.showMonths) {
              self2.yearElements = [];
              self2.monthElements = [];
            }
            for (var m5 = self2.config.showMonths; m5--; ) {
              var month = buildMonth();
              self2.yearElements.push(month.yearElement);
              self2.monthElements.push(month.monthElement);
              self2.monthNav.appendChild(month.container);
            }
            self2.monthNav.appendChild(self2.nextMonthNav);
          }
          function buildMonthNav() {
            self2.monthNav = createElement15("div", "flatpickr-months");
            self2.yearElements = [];
            self2.monthElements = [];
            self2.prevMonthNav = createElement15("span", "flatpickr-prev-month");
            self2.prevMonthNav.innerHTML = self2.config.prevArrow;
            self2.nextMonthNav = createElement15("span", "flatpickr-next-month");
            self2.nextMonthNav.innerHTML = self2.config.nextArrow;
            buildMonths();
            Object.defineProperty(self2, "_hidePrevMonthArrow", {
              get: function() {
                return self2.__hidePrevMonthArrow;
              },
              set: function(bool) {
                if (self2.__hidePrevMonthArrow !== bool) {
                  toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
                  self2.__hidePrevMonthArrow = bool;
                }
              }
            });
            Object.defineProperty(self2, "_hideNextMonthArrow", {
              get: function() {
                return self2.__hideNextMonthArrow;
              },
              set: function(bool) {
                if (self2.__hideNextMonthArrow !== bool) {
                  toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
                  self2.__hideNextMonthArrow = bool;
                }
              }
            });
            self2.currentYearElement = self2.yearElements[0];
            updateNavigationCurrentMonth();
            return self2.monthNav;
          }
          function buildTime() {
            self2.calendarContainer.classList.add("hasTime");
            if (self2.config.noCalendar)
              self2.calendarContainer.classList.add("noCalendar");
            var defaults3 = getDefaultHours(self2.config);
            self2.timeContainer = createElement15("div", "flatpickr-time");
            self2.timeContainer.tabIndex = -1;
            var separator = createElement15("span", "flatpickr-time-separator", ":");
            var hourInput = createNumberInput("flatpickr-hour", {
              "aria-label": self2.l10n.hourAriaLabel
            });
            self2.hourElement = hourInput.getElementsByTagName("input")[0];
            var minuteInput = createNumberInput("flatpickr-minute", {
              "aria-label": self2.l10n.minuteAriaLabel
            });
            self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
            self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
            self2.hourElement.value = pad2(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults3.hours : military2ampm(defaults3.hours));
            self2.minuteElement.value = pad2(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults3.minutes);
            self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
            self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
            self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
            self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
            self2.hourElement.setAttribute("maxlength", "2");
            self2.minuteElement.setAttribute("min", "0");
            self2.minuteElement.setAttribute("max", "59");
            self2.minuteElement.setAttribute("maxlength", "2");
            self2.timeContainer.appendChild(hourInput);
            self2.timeContainer.appendChild(separator);
            self2.timeContainer.appendChild(minuteInput);
            if (self2.config.time_24hr)
              self2.timeContainer.classList.add("time24hr");
            if (self2.config.enableSeconds) {
              self2.timeContainer.classList.add("hasSeconds");
              var secondInput = createNumberInput("flatpickr-second");
              self2.secondElement = secondInput.getElementsByTagName("input")[0];
              self2.secondElement.value = pad2(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults3.seconds);
              self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
              self2.secondElement.setAttribute("min", "0");
              self2.secondElement.setAttribute("max", "59");
              self2.secondElement.setAttribute("maxlength", "2");
              self2.timeContainer.appendChild(createElement15("span", "flatpickr-time-separator", ":"));
              self2.timeContainer.appendChild(secondInput);
            }
            if (!self2.config.time_24hr) {
              self2.amPM = createElement15("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
              self2.amPM.title = self2.l10n.toggleTitle;
              self2.amPM.tabIndex = -1;
              self2.timeContainer.appendChild(self2.amPM);
            }
            return self2.timeContainer;
          }
          function buildWeekdays() {
            if (!self2.weekdayContainer)
              self2.weekdayContainer = createElement15("div", "flatpickr-weekdays");
            else
              clearNode(self2.weekdayContainer);
            for (var i5 = self2.config.showMonths; i5--; ) {
              var container2 = createElement15("div", "flatpickr-weekdaycontainer");
              self2.weekdayContainer.appendChild(container2);
            }
            updateWeekdays();
            return self2.weekdayContainer;
          }
          function updateWeekdays() {
            if (!self2.weekdayContainer) {
              return;
            }
            var firstDayOfWeek = self2.l10n.firstDayOfWeek;
            var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
            if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
              weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
            }
            for (var i5 = self2.config.showMonths; i5--; ) {
              self2.weekdayContainer.children[i5].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
            }
          }
          function buildWeeks() {
            self2.calendarContainer.classList.add("hasWeeks");
            var weekWrapper = createElement15("div", "flatpickr-weekwrapper");
            weekWrapper.appendChild(createElement15("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
            var weekNumbers = createElement15("div", "flatpickr-weeks");
            weekWrapper.appendChild(weekNumbers);
            return {
              weekWrapper,
              weekNumbers
            };
          }
          function changeMonth(value, isOffset) {
            if (isOffset === void 0) {
              isOffset = true;
            }
            var delta = isOffset ? value : value - self2.currentMonth;
            if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
              return;
            self2.currentMonth += delta;
            if (self2.currentMonth < 0 || self2.currentMonth > 11) {
              self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
              self2.currentMonth = (self2.currentMonth + 12) % 12;
              triggerEvent("onYearChange");
              buildMonthSwitch();
            }
            buildDays();
            triggerEvent("onMonthChange");
            updateNavigationCurrentMonth();
          }
          function clear(triggerChangeEvent, toInitial) {
            if (triggerChangeEvent === void 0) {
              triggerChangeEvent = true;
            }
            if (toInitial === void 0) {
              toInitial = true;
            }
            self2.input.value = "";
            if (self2.altInput !== void 0)
              self2.altInput.value = "";
            if (self2.mobileInput !== void 0)
              self2.mobileInput.value = "";
            self2.selectedDates = [];
            self2.latestSelectedDateObj = void 0;
            if (toInitial === true) {
              self2.currentYear = self2._initialDate.getFullYear();
              self2.currentMonth = self2._initialDate.getMonth();
            }
            if (self2.config.enableTime === true) {
              var _a9 = getDefaultHours(self2.config), hours = _a9.hours, minutes = _a9.minutes, seconds = _a9.seconds;
              setHours(hours, minutes, seconds);
            }
            self2.redraw();
            if (triggerChangeEvent)
              triggerEvent("onChange");
          }
          function close() {
            self2.isOpen = false;
            if (!self2.isMobile) {
              if (self2.calendarContainer !== void 0) {
                self2.calendarContainer.classList.remove("open");
              }
              if (self2._input !== void 0) {
                self2._input.classList.remove("active");
              }
            }
            triggerEvent("onClose");
          }
          function destroy() {
            if (self2.config !== void 0)
              triggerEvent("onDestroy");
            for (var i5 = self2._handlers.length; i5--; ) {
              self2._handlers[i5].remove();
            }
            self2._handlers = [];
            if (self2.mobileInput) {
              if (self2.mobileInput.parentNode)
                self2.mobileInput.parentNode.removeChild(self2.mobileInput);
              self2.mobileInput = void 0;
            } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
              if (self2.config.static && self2.calendarContainer.parentNode) {
                var wrapper = self2.calendarContainer.parentNode;
                wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                if (wrapper.parentNode) {
                  while (wrapper.firstChild)
                    wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                  wrapper.parentNode.removeChild(wrapper);
                }
              } else
                self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
            }
            if (self2.altInput) {
              self2.input.type = "text";
              if (self2.altInput.parentNode)
                self2.altInput.parentNode.removeChild(self2.altInput);
              delete self2.altInput;
            }
            if (self2.input) {
              self2.input.type = self2.input._type;
              self2.input.classList.remove("flatpickr-input");
              self2.input.removeAttribute("readonly");
            }
            [
              "_showTimeInput",
              "latestSelectedDateObj",
              "_hideNextMonthArrow",
              "_hidePrevMonthArrow",
              "__hideNextMonthArrow",
              "__hidePrevMonthArrow",
              "isMobile",
              "isOpen",
              "selectedDateElem",
              "minDateHasTime",
              "maxDateHasTime",
              "days",
              "daysContainer",
              "_input",
              "_positionElement",
              "innerContainer",
              "rContainer",
              "monthNav",
              "todayDateElem",
              "calendarContainer",
              "weekdayContainer",
              "prevMonthNav",
              "nextMonthNav",
              "monthsDropdownContainer",
              "currentMonthElement",
              "currentYearElement",
              "navigationCurrentMonth",
              "selectedDateElem",
              "config"
            ].forEach(function(k) {
              try {
                delete self2[k];
              } catch (_2) {
              }
            });
          }
          function isCalendarElem(elem) {
            return self2.calendarContainer.contains(elem);
          }
          function documentClick(e3) {
            if (self2.isOpen && !self2.config.inline) {
              var eventTarget_1 = getEventTarget(e3);
              var isCalendarElement = isCalendarElem(eventTarget_1);
              var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || // web components
              // e.path is not present in all browsers. circumventing typechecks
              e3.path && e3.path.indexOf && (~e3.path.indexOf(self2.input) || ~e3.path.indexOf(self2.altInput));
              var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e3.relatedTarget);
              var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
                return elem.contains(eventTarget_1);
              });
              if (lostFocus && isIgnored) {
                if (self2.config.allowInput) {
                  self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
                }
                if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
                  updateTime();
                }
                self2.close();
                if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
                  self2.clear(false);
              }
            }
          }
          function changeYear(newYear) {
            if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
              return;
            var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
            self2.currentYear = newYearNum || self2.currentYear;
            if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
              self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
            } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
              self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
            }
            if (isNewYear) {
              self2.redraw();
              triggerEvent("onYearChange");
              buildMonthSwitch();
            }
          }
          function isEnabled(date, timeless) {
            var _a9;
            if (timeless === void 0) {
              timeless = true;
            }
            var dateToCheck = self2.parseDate(date, void 0, timeless);
            if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
              return false;
            if (!self2.config.enable && self2.config.disable.length === 0)
              return true;
            if (dateToCheck === void 0)
              return false;
            var bool = !!self2.config.enable, array = (_a9 = self2.config.enable) !== null && _a9 !== void 0 ? _a9 : self2.config.disable;
            for (var i5 = 0, d5 = void 0; i5 < array.length; i5++) {
              d5 = array[i5];
              if (typeof d5 === "function" && d5(dateToCheck))
                return bool;
              else if (d5 instanceof Date && dateToCheck !== void 0 && d5.getTime() === dateToCheck.getTime())
                return bool;
              else if (typeof d5 === "string") {
                var parsed = self2.parseDate(d5, void 0, true);
                return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
              } else if (
                // disabled by range
                typeof d5 === "object" && dateToCheck !== void 0 && d5.from && d5.to && dateToCheck.getTime() >= d5.from.getTime() && dateToCheck.getTime() <= d5.to.getTime()
              )
                return bool;
            }
            return !bool;
          }
          function isInView(elem) {
            if (self2.daysContainer !== void 0)
              return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
            return false;
          }
          function onBlur(e3) {
            var isInput = e3.target === self2._input;
            var valueChanged = self2._input.value.trimEnd() !== getDateStr();
            if (isInput && valueChanged && !(e3.relatedTarget && isCalendarElem(e3.relatedTarget))) {
              self2.setDate(self2._input.value, true, e3.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
            }
          }
          function onKeyDown(e3) {
            var eventTarget = getEventTarget(e3);
            var isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
            var allowInput = self2.config.allowInput;
            var allowKeydown = self2.isOpen && (!allowInput || !isInput);
            var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
            if (e3.keyCode === 13 && isInput) {
              if (allowInput) {
                self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
                self2.close();
                return eventTarget.blur();
              } else {
                self2.open();
              }
            } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
              var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
              switch (e3.keyCode) {
                case 13:
                  if (isTimeObj) {
                    e3.preventDefault();
                    updateTime();
                    focusAndClose();
                  } else
                    selectDate(e3);
                  break;
                case 27:
                  e3.preventDefault();
                  focusAndClose();
                  break;
                case 8:
                case 46:
                  if (isInput && !self2.config.allowInput) {
                    e3.preventDefault();
                    self2.clear();
                  }
                  break;
                case 37:
                case 39:
                  if (!isTimeObj && !isInput) {
                    e3.preventDefault();
                    var activeElement = getClosestActiveElement();
                    if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
                      var delta_1 = e3.keyCode === 39 ? 1 : -1;
                      if (!e3.ctrlKey)
                        focusOnDay(void 0, delta_1);
                      else {
                        e3.stopPropagation();
                        changeMonth(delta_1);
                        focusOnDay(getFirstAvailableDay(1), 0);
                      }
                    }
                  } else if (self2.hourElement)
                    self2.hourElement.focus();
                  break;
                case 38:
                case 40:
                  e3.preventDefault();
                  var delta = e3.keyCode === 40 ? 1 : -1;
                  if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
                    if (e3.ctrlKey) {
                      e3.stopPropagation();
                      changeYear(self2.currentYear - delta);
                      focusOnDay(getFirstAvailableDay(1), 0);
                    } else if (!isTimeObj)
                      focusOnDay(void 0, delta * 7);
                  } else if (eventTarget === self2.currentYearElement) {
                    changeYear(self2.currentYear - delta);
                  } else if (self2.config.enableTime) {
                    if (!isTimeObj && self2.hourElement)
                      self2.hourElement.focus();
                    updateTime(e3);
                    self2._debouncedChange();
                  }
                  break;
                case 9:
                  if (isTimeObj) {
                    var elems = [
                      self2.hourElement,
                      self2.minuteElement,
                      self2.secondElement,
                      self2.amPM
                    ].concat(self2.pluginElements).filter(function(x3) {
                      return x3;
                    });
                    var i5 = elems.indexOf(eventTarget);
                    if (i5 !== -1) {
                      var target = elems[i5 + (e3.shiftKey ? -1 : 1)];
                      e3.preventDefault();
                      (target || self2._input).focus();
                    }
                  } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e3.shiftKey) {
                    e3.preventDefault();
                    self2._input.focus();
                  }
                  break;
              }
            }
            if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
              switch (e3.key) {
                case self2.l10n.amPM[0].charAt(0):
                case self2.l10n.amPM[0].charAt(0).toLowerCase():
                  self2.amPM.textContent = self2.l10n.amPM[0];
                  setHoursFromInputs();
                  updateValue();
                  break;
                case self2.l10n.amPM[1].charAt(0):
                case self2.l10n.amPM[1].charAt(0).toLowerCase():
                  self2.amPM.textContent = self2.l10n.amPM[1];
                  setHoursFromInputs();
                  updateValue();
                  break;
              }
            }
            if (isInput || isCalendarElem(eventTarget)) {
              triggerEvent("onKeyDown", e3);
            }
          }
          function onMouseOver(elem, cellClass) {
            if (cellClass === void 0) {
              cellClass = "flatpickr-day";
            }
            if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
              return;
            var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
            var containsDisabled = false;
            var minRange = 0, maxRange = 0;
            for (var t7 = rangeStartDate; t7 < rangeEndDate; t7 += duration.DAY) {
              if (!isEnabled(new Date(t7), true)) {
                containsDisabled = containsDisabled || t7 > rangeStartDate && t7 < rangeEndDate;
                if (t7 < initialDate && (!minRange || t7 > minRange))
                  minRange = t7;
                else if (t7 > initialDate && (!maxRange || t7 < maxRange))
                  maxRange = t7;
              }
            }
            var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
            hoverableCells.forEach(function(dayElem) {
              var date = dayElem.dateObj;
              var timestamp = date.getTime();
              var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
              if (outOfRange) {
                dayElem.classList.add("notAllowed");
                ["inRange", "startRange", "endRange"].forEach(function(c3) {
                  dayElem.classList.remove(c3);
                });
                return;
              } else if (containsDisabled && !outOfRange)
                return;
              ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c3) {
                dayElem.classList.remove(c3);
              });
              if (elem !== void 0) {
                elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
                if (initialDate < hoverDate && timestamp === initialDate)
                  dayElem.classList.add("startRange");
                else if (initialDate > hoverDate && timestamp === initialDate)
                  dayElem.classList.add("endRange");
                if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
                  dayElem.classList.add("inRange");
              }
            });
          }
          function onResize() {
            if (self2.isOpen && !self2.config.static && !self2.config.inline)
              positionCalendar();
          }
          function open(e3, positionElement) {
            if (positionElement === void 0) {
              positionElement = self2._positionElement;
            }
            if (self2.isMobile === true) {
              if (e3) {
                e3.preventDefault();
                var eventTarget = getEventTarget(e3);
                if (eventTarget) {
                  eventTarget.blur();
                }
              }
              if (self2.mobileInput !== void 0) {
                self2.mobileInput.focus();
                self2.mobileInput.click();
              }
              triggerEvent("onOpen");
              return;
            } else if (self2._input.disabled || self2.config.inline) {
              return;
            }
            var wasOpen = self2.isOpen;
            self2.isOpen = true;
            if (!wasOpen) {
              self2.calendarContainer.classList.add("open");
              self2._input.classList.add("active");
              triggerEvent("onOpen");
              positionCalendar(positionElement);
            }
            if (self2.config.enableTime === true && self2.config.noCalendar === true) {
              if (self2.config.allowInput === false && (e3 === void 0 || !self2.timeContainer.contains(e3.relatedTarget))) {
                setTimeout(function() {
                  return self2.hourElement.select();
                }, 50);
              }
            }
          }
          function minMaxDateSetter(type) {
            return function(date) {
              var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date, self2.config.dateFormat);
              var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
              if (dateObj !== void 0) {
                self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
              }
              if (self2.selectedDates) {
                self2.selectedDates = self2.selectedDates.filter(function(d5) {
                  return isEnabled(d5);
                });
                if (!self2.selectedDates.length && type === "min")
                  setHoursFromDate(dateObj);
                updateValue();
              }
              if (self2.daysContainer) {
                redraw();
                if (dateObj !== void 0)
                  self2.currentYearElement[type] = dateObj.getFullYear().toString();
                else
                  self2.currentYearElement.removeAttribute(type);
                self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
              }
            };
          }
          function parseConfig() {
            var boolOpts = [
              "wrap",
              "weekNumbers",
              "allowInput",
              "allowInvalidPreload",
              "clickOpens",
              "time_24hr",
              "enableTime",
              "noCalendar",
              "altInput",
              "shorthandCurrentMonth",
              "inline",
              "static",
              "enableSeconds",
              "disableMobile"
            ];
            var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
            var formats2 = {};
            self2.config.parseDate = userConfig.parseDate;
            self2.config.formatDate = userConfig.formatDate;
            Object.defineProperty(self2.config, "enable", {
              get: function() {
                return self2.config._enable;
              },
              set: function(dates) {
                self2.config._enable = parseDateRules(dates);
              }
            });
            Object.defineProperty(self2.config, "disable", {
              get: function() {
                return self2.config._disable;
              },
              set: function(dates) {
                self2.config._disable = parseDateRules(dates);
              }
            });
            var timeMode = userConfig.mode === "time";
            if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
              var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults2.dateFormat;
              formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
            }
            if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
              var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults2.altFormat;
              formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
            }
            Object.defineProperty(self2.config, "minDate", {
              get: function() {
                return self2.config._minDate;
              },
              set: minMaxDateSetter("min")
            });
            Object.defineProperty(self2.config, "maxDate", {
              get: function() {
                return self2.config._maxDate;
              },
              set: minMaxDateSetter("max")
            });
            var minMaxTimeSetter = function(type) {
              return function(val) {
                self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
              };
            };
            Object.defineProperty(self2.config, "minTime", {
              get: function() {
                return self2.config._minTime;
              },
              set: minMaxTimeSetter("min")
            });
            Object.defineProperty(self2.config, "maxTime", {
              get: function() {
                return self2.config._maxTime;
              },
              set: minMaxTimeSetter("max")
            });
            if (userConfig.mode === "time") {
              self2.config.noCalendar = true;
              self2.config.enableTime = true;
            }
            Object.assign(self2.config, formats2, userConfig);
            for (var i5 = 0; i5 < boolOpts.length; i5++)
              self2.config[boolOpts[i5]] = self2.config[boolOpts[i5]] === true || self2.config[boolOpts[i5]] === "true";
            HOOKS.filter(function(hook) {
              return self2.config[hook] !== void 0;
            }).forEach(function(hook) {
              self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
            });
            self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            for (var i5 = 0; i5 < self2.config.plugins.length; i5++) {
              var pluginConf = self2.config.plugins[i5](self2) || {};
              for (var key in pluginConf) {
                if (HOOKS.indexOf(key) > -1) {
                  self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
                } else if (typeof userConfig[key] === "undefined")
                  self2.config[key] = pluginConf[key];
              }
            }
            if (!userConfig.altInputClass) {
              self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
            }
            triggerEvent("onParseConfig");
          }
          function getInputElem() {
            return self2.config.wrap ? element.querySelector("[data-input]") : element;
          }
          function setupLocale() {
            if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
              self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
            self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
            tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
            tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
            tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
            tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
            tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
            var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
            if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
              self2.config.time_24hr = self2.l10n.time_24hr;
            }
            self2.formatDate = createDateFormatter(self2);
            self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
          }
          function positionCalendar(customPositionElement) {
            if (typeof self2.config.position === "function") {
              return void self2.config.position(self2, customPositionElement);
            }
            if (self2.calendarContainer === void 0)
              return;
            triggerEvent("onPreCalendarPosition");
            var positionElement = customPositionElement || self2._positionElement;
            var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
              return acc + child.offsetHeight;
            }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
            var top2 = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
            toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
            toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
            if (self2.config.inline)
              return;
            var left2 = window.pageXOffset + inputBounds.left;
            var isCenter = false;
            var isRight = false;
            if (configPosHorizontal === "center") {
              left2 -= (calendarWidth - inputBounds.width) / 2;
              isCenter = true;
            } else if (configPosHorizontal === "right") {
              left2 -= calendarWidth - inputBounds.width;
              isRight = true;
            }
            toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
            toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
            toggleClass(self2.calendarContainer, "arrowRight", isRight);
            var right2 = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
            var rightMost = left2 + calendarWidth > window.document.body.offsetWidth;
            var centerMost = right2 + calendarWidth > window.document.body.offsetWidth;
            toggleClass(self2.calendarContainer, "rightMost", rightMost);
            if (self2.config.static)
              return;
            self2.calendarContainer.style.top = top2 + "px";
            if (!rightMost) {
              self2.calendarContainer.style.left = left2 + "px";
              self2.calendarContainer.style.right = "auto";
            } else if (!centerMost) {
              self2.calendarContainer.style.left = "auto";
              self2.calendarContainer.style.right = right2 + "px";
            } else {
              var doc = getDocumentStyleSheet();
              if (doc === void 0)
                return;
              var bodyWidth = window.document.body.offsetWidth;
              var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
              var centerBefore = ".flatpickr-calendar.centerMost:before";
              var centerAfter = ".flatpickr-calendar.centerMost:after";
              var centerIndex = doc.cssRules.length;
              var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
              toggleClass(self2.calendarContainer, "rightMost", false);
              toggleClass(self2.calendarContainer, "centerMost", true);
              doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
              self2.calendarContainer.style.left = centerLeft + "px";
              self2.calendarContainer.style.right = "auto";
            }
          }
          function getDocumentStyleSheet() {
            var editableSheet = null;
            for (var i5 = 0; i5 < document.styleSheets.length; i5++) {
              var sheet = document.styleSheets[i5];
              if (!sheet.cssRules)
                continue;
              try {
                sheet.cssRules;
              } catch (err) {
                continue;
              }
              editableSheet = sheet;
              break;
            }
            return editableSheet != null ? editableSheet : createStyleSheet();
          }
          function createStyleSheet() {
            var style = document.createElement("style");
            document.head.appendChild(style);
            return style.sheet;
          }
          function redraw() {
            if (self2.config.noCalendar || self2.isMobile)
              return;
            buildMonthSwitch();
            updateNavigationCurrentMonth();
            buildDays();
          }
          function focusAndClose() {
            self2._input.focus();
            if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
              setTimeout(self2.close, 0);
            } else {
              self2.close();
            }
          }
          function selectDate(e3) {
            e3.preventDefault();
            e3.stopPropagation();
            var isSelectable = function(day) {
              return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
            };
            var t7 = findParent(getEventTarget(e3), isSelectable);
            if (t7 === void 0)
              return;
            var target = t7;
            var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
            var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
            self2.selectedDateElem = target;
            if (self2.config.mode === "single")
              self2.selectedDates = [selectedDate];
            else if (self2.config.mode === "multiple") {
              var selectedIndex = isDateSelected(selectedDate);
              if (selectedIndex)
                self2.selectedDates.splice(parseInt(selectedIndex), 1);
              else
                self2.selectedDates.push(selectedDate);
            } else if (self2.config.mode === "range") {
              if (self2.selectedDates.length === 2) {
                self2.clear(false, false);
              }
              self2.latestSelectedDateObj = selectedDate;
              self2.selectedDates.push(selectedDate);
              if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
                self2.selectedDates.sort(function(a3, b2) {
                  return a3.getTime() - b2.getTime();
                });
            }
            setHoursFromInputs();
            if (shouldChangeMonth) {
              var isNewYear = self2.currentYear !== selectedDate.getFullYear();
              self2.currentYear = selectedDate.getFullYear();
              self2.currentMonth = selectedDate.getMonth();
              if (isNewYear) {
                triggerEvent("onYearChange");
                buildMonthSwitch();
              }
              triggerEvent("onMonthChange");
            }
            updateNavigationCurrentMonth();
            buildDays();
            updateValue();
            if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
              focusOnDayElem(target);
            else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
              self2.selectedDateElem && self2.selectedDateElem.focus();
            }
            if (self2.hourElement !== void 0)
              self2.hourElement !== void 0 && self2.hourElement.focus();
            if (self2.config.closeOnSelect) {
              var single = self2.config.mode === "single" && !self2.config.enableTime;
              var range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
              if (single || range) {
                focusAndClose();
              }
            }
            triggerChange();
          }
          var CALLBACKS = {
            locale: [setupLocale, updateWeekdays],
            showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
            minDate: [jumpToDate],
            maxDate: [jumpToDate],
            positionElement: [updatePositionElement],
            clickOpens: [
              function() {
                if (self2.config.clickOpens === true) {
                  bind(self2._input, "focus", self2.open);
                  bind(self2._input, "click", self2.open);
                } else {
                  self2._input.removeEventListener("focus", self2.open);
                  self2._input.removeEventListener("click", self2.open);
                }
              }
            ]
          };
          function set2(option, value) {
            if (option !== null && typeof option === "object") {
              Object.assign(self2.config, option);
              for (var key in option) {
                if (CALLBACKS[key] !== void 0)
                  CALLBACKS[key].forEach(function(x3) {
                    return x3();
                  });
              }
            } else {
              self2.config[option] = value;
              if (CALLBACKS[option] !== void 0)
                CALLBACKS[option].forEach(function(x3) {
                  return x3();
                });
              else if (HOOKS.indexOf(option) > -1)
                self2.config[option] = arrayify(value);
            }
            self2.redraw();
            updateValue(true);
          }
          function setSelectedDate(inputDate, format2) {
            var dates = [];
            if (inputDate instanceof Array)
              dates = inputDate.map(function(d5) {
                return self2.parseDate(d5, format2);
              });
            else if (inputDate instanceof Date || typeof inputDate === "number")
              dates = [self2.parseDate(inputDate, format2)];
            else if (typeof inputDate === "string") {
              switch (self2.config.mode) {
                case "single":
                case "time":
                  dates = [self2.parseDate(inputDate, format2)];
                  break;
                case "multiple":
                  dates = inputDate.split(self2.config.conjunction).map(function(date) {
                    return self2.parseDate(date, format2);
                  });
                  break;
                case "range":
                  dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date) {
                    return self2.parseDate(date, format2);
                  });
                  break;
              }
            } else
              self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
            self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d5) {
              return d5 instanceof Date && isEnabled(d5, false);
            });
            if (self2.config.mode === "range")
              self2.selectedDates.sort(function(a3, b2) {
                return a3.getTime() - b2.getTime();
              });
          }
          function setDate(date, triggerChange2, format2) {
            if (triggerChange2 === void 0) {
              triggerChange2 = false;
            }
            if (format2 === void 0) {
              format2 = self2.config.dateFormat;
            }
            if (date !== 0 && !date || date instanceof Array && date.length === 0)
              return self2.clear(triggerChange2);
            setSelectedDate(date, format2);
            self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
            self2.redraw();
            jumpToDate(void 0, triggerChange2);
            setHoursFromDate();
            if (self2.selectedDates.length === 0) {
              self2.clear(false);
            }
            updateValue(triggerChange2);
            if (triggerChange2)
              triggerEvent("onChange");
          }
          function parseDateRules(arr) {
            return arr.slice().map(function(rule) {
              if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
                return self2.parseDate(rule, void 0, true);
              } else if (rule && typeof rule === "object" && rule.from && rule.to)
                return {
                  from: self2.parseDate(rule.from, void 0),
                  to: self2.parseDate(rule.to, void 0)
                };
              return rule;
            }).filter(function(x3) {
              return x3;
            });
          }
          function setupDates() {
            self2.selectedDates = [];
            self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
            var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
            if (preloadedDate)
              setSelectedDate(preloadedDate, self2.config.dateFormat);
            self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
            self2.currentYear = self2._initialDate.getFullYear();
            self2.currentMonth = self2._initialDate.getMonth();
            if (self2.selectedDates.length > 0)
              self2.latestSelectedDateObj = self2.selectedDates[0];
            if (self2.config.minTime !== void 0)
              self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
            if (self2.config.maxTime !== void 0)
              self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
            self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
            self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
          }
          function setupInputs() {
            self2.input = getInputElem();
            if (!self2.input) {
              self2.config.errorHandler(new Error("Invalid input element specified"));
              return;
            }
            self2.input._type = self2.input.type;
            self2.input.type = "text";
            self2.input.classList.add("flatpickr-input");
            self2._input = self2.input;
            if (self2.config.altInput) {
              self2.altInput = createElement15(self2.input.nodeName, self2.config.altInputClass);
              self2._input = self2.altInput;
              self2.altInput.placeholder = self2.input.placeholder;
              self2.altInput.disabled = self2.input.disabled;
              self2.altInput.required = self2.input.required;
              self2.altInput.tabIndex = self2.input.tabIndex;
              self2.altInput.type = "text";
              self2.input.setAttribute("type", "hidden");
              if (!self2.config.static && self2.input.parentNode)
                self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
            }
            if (!self2.config.allowInput)
              self2._input.setAttribute("readonly", "readonly");
            updatePositionElement();
          }
          function updatePositionElement() {
            self2._positionElement = self2.config.positionElement || self2._input;
          }
          function setupMobile() {
            var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
            self2.mobileInput = createElement15("input", self2.input.className + " flatpickr-mobile");
            self2.mobileInput.tabIndex = 1;
            self2.mobileInput.type = inputType;
            self2.mobileInput.disabled = self2.input.disabled;
            self2.mobileInput.required = self2.input.required;
            self2.mobileInput.placeholder = self2.input.placeholder;
            self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
            if (self2.selectedDates.length > 0) {
              self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
            }
            if (self2.config.minDate)
              self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
            if (self2.config.maxDate)
              self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
            if (self2.input.getAttribute("step"))
              self2.mobileInput.step = String(self2.input.getAttribute("step"));
            self2.input.type = "hidden";
            if (self2.altInput !== void 0)
              self2.altInput.type = "hidden";
            try {
              if (self2.input.parentNode)
                self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
            } catch (_a9) {
            }
            bind(self2.mobileInput, "change", function(e3) {
              self2.setDate(getEventTarget(e3).value, false, self2.mobileFormatStr);
              triggerEvent("onChange");
              triggerEvent("onClose");
            });
          }
          function toggle(e3) {
            if (self2.isOpen === true)
              return self2.close();
            self2.open(e3);
          }
          function triggerEvent(event, data) {
            if (self2.config === void 0)
              return;
            var hooks = self2.config[event];
            if (hooks !== void 0 && hooks.length > 0) {
              for (var i5 = 0; hooks[i5] && i5 < hooks.length; i5++)
                hooks[i5](self2.selectedDates, self2.input.value, self2, data);
            }
            if (event === "onChange") {
              self2.input.dispatchEvent(createEvent("change"));
              self2.input.dispatchEvent(createEvent("input"));
            }
          }
          function createEvent(name) {
            var e3 = document.createEvent("Event");
            e3.initEvent(name, true, true);
            return e3;
          }
          function isDateSelected(date) {
            for (var i5 = 0; i5 < self2.selectedDates.length; i5++) {
              var selectedDate = self2.selectedDates[i5];
              if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0)
                return "" + i5;
            }
            return false;
          }
          function isDateInRange(date) {
            if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
              return false;
            return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
          }
          function updateNavigationCurrentMonth() {
            if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
              return;
            self2.yearElements.forEach(function(yearElement, i5) {
              var d5 = new Date(self2.currentYear, self2.currentMonth, 1);
              d5.setMonth(self2.currentMonth + i5);
              if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
                self2.monthElements[i5].textContent = monthToStr(d5.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
              } else {
                self2.monthsDropdownContainer.value = d5.getMonth().toString();
              }
              yearElement.value = d5.getFullYear().toString();
            });
            self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
            self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
          }
          function getDateStr(specificFormat) {
            var format2 = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
            return self2.selectedDates.map(function(dObj) {
              return self2.formatDate(dObj, format2);
            }).filter(function(d5, i5, arr) {
              return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d5) === i5;
            }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
          }
          function updateValue(triggerChange2) {
            if (triggerChange2 === void 0) {
              triggerChange2 = true;
            }
            if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
              self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
            }
            self2.input.value = getDateStr(self2.config.dateFormat);
            if (self2.altInput !== void 0) {
              self2.altInput.value = getDateStr(self2.config.altFormat);
            }
            if (triggerChange2 !== false)
              triggerEvent("onValueUpdate");
          }
          function onMonthNavClick(e3) {
            var eventTarget = getEventTarget(e3);
            var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
            var isNextMonth = self2.nextMonthNav.contains(eventTarget);
            if (isPrevMonth || isNextMonth) {
              changeMonth(isPrevMonth ? -1 : 1);
            } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
              eventTarget.select();
            } else if (eventTarget.classList.contains("arrowUp")) {
              self2.changeYear(self2.currentYear + 1);
            } else if (eventTarget.classList.contains("arrowDown")) {
              self2.changeYear(self2.currentYear - 1);
            }
          }
          function timeWrapper(e3) {
            e3.preventDefault();
            var isKeyDown = e3.type === "keydown", eventTarget = getEventTarget(e3), input = eventTarget;
            if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
              self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
            }
            var min2 = parseFloat(input.getAttribute("min")), max2 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e3.delta || (isKeyDown ? e3.which === 38 ? 1 : -1 : 0);
            var newValue = curValue + step * delta;
            if (typeof input.value !== "undefined" && input.value.length === 2) {
              var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
              if (newValue < min2) {
                newValue = max2 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
                if (isMinuteElem)
                  incrementNumInput(void 0, -1, self2.hourElement);
              } else if (newValue > max2) {
                newValue = input === self2.hourElement ? newValue - max2 - int(!self2.amPM) : min2;
                if (isMinuteElem)
                  incrementNumInput(void 0, 1, self2.hourElement);
              }
              if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
                self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
              }
              input.value = pad2(newValue);
            }
          }
          init();
          return self2;
        }
        function _flatpickr(nodeList, config) {
          var nodes = Array.prototype.slice.call(nodeList).filter(function(x3) {
            return x3 instanceof HTMLElement;
          });
          var instances2 = [];
          for (var i5 = 0; i5 < nodes.length; i5++) {
            var node = nodes[i5];
            try {
              if (node.getAttribute("data-fp-omit") !== null)
                continue;
              if (node._flatpickr !== void 0) {
                node._flatpickr.destroy();
                node._flatpickr = void 0;
              }
              node._flatpickr = FlatpickrInstance(node, config || {});
              instances2.push(node._flatpickr);
            } catch (e3) {
              console.error(e3);
            }
          }
          return instances2.length === 1 ? instances2[0] : instances2;
        }
        if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
          HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
            return _flatpickr(this, config);
          };
          HTMLElement.prototype.flatpickr = function(config) {
            return _flatpickr([this], config);
          };
        }
        var flatpickr = function(selector, config) {
          if (typeof selector === "string") {
            return _flatpickr(window.document.querySelectorAll(selector), config);
          } else if (selector instanceof Node) {
            return _flatpickr([selector], config);
          } else {
            return _flatpickr(selector, config);
          }
        };
        flatpickr.defaultConfig = {};
        flatpickr.l10ns = {
          en: __assign({}, english),
          default: __assign({}, english)
        };
        flatpickr.localize = function(l10n) {
          flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
        };
        flatpickr.setDefaults = function(config) {
          flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
        };
        flatpickr.parseDate = createDateParser({});
        flatpickr.formatDate = createDateFormatter({});
        flatpickr.compareDates = compareDates;
        if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
          jQuery.fn.flatpickr = function(config) {
            return _flatpickr(this, config);
          };
        }
        Date.prototype.fp_incr = function(days) {
          return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
        };
        if (typeof window !== "undefined") {
          window.flatpickr = flatpickr;
        }
        return flatpickr;
      });
    }
  });

  // node_modules/react-flatpickr/build/index.js
  var require_build = __commonJS({
    "node_modules/react-flatpickr/build/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;
      var _react = _interopRequireWildcard(require_react());
      var _propTypes = _interopRequireDefault(require_prop_types());
      var _flatpickr = _interopRequireDefault(require_flatpickr());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _getRequireWildcardCache() {
        if (typeof WeakMap !== "function") return null;
        var cache = /* @__PURE__ */ new WeakMap();
        _getRequireWildcardCache = function _getRequireWildcardCache2() {
          return cache;
        };
        return cache;
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) {
          return cache.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache) {
          cache.set(obj, newObj);
        }
        return newObj;
      }
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _extends2() {
        _extends2 = Object.assign || function(target) {
          for (var i5 = 1; i5 < arguments.length; i5++) {
            var source = arguments[i5];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends2.apply(this, arguments);
      }
      function _objectWithoutProperties(source, excluded) {
        if (source == null) return {};
        var target = _objectWithoutPropertiesLoose(source, excluded);
        var key, i5;
        if (Object.getOwnPropertySymbols) {
          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
          for (i5 = 0; i5 < sourceSymbolKeys.length; i5++) {
            key = sourceSymbolKeys[i5];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
          }
        }
        return target;
      }
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null) return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i5;
        for (i5 = 0; i5 < sourceKeys.length; i5++) {
          key = sourceKeys[i5];
          if (excluded.indexOf(key) >= 0) continue;
          target[key] = source[key];
        }
        return target;
      }
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i5 = 1; i5 < arguments.length; i5++) {
          var source = arguments[i5] != null ? arguments[i5] : {};
          if (i5 % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i5 = 0; i5 < props.length; i5++) {
          var descriptor = props[i5];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o10, p3) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o11, p4) {
          o11.__proto__ = p4;
          return o11;
        };
        return _setPrototypeOf(o10, p3);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e3) {
          return false;
        }
      }
      function _getPrototypeOf(o10) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o11) {
          return o11.__proto__ || Object.getPrototypeOf(o11);
        };
        return _getPrototypeOf(o10);
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var hooks = ["onChange", "onOpen", "onClose", "onMonthChange", "onYearChange", "onReady", "onValueUpdate", "onDayCreate"];
      var hookPropType = _propTypes["default"].oneOfType([_propTypes["default"].func, _propTypes["default"].arrayOf(_propTypes["default"].func)]);
      var callbacks = ["onCreate", "onDestroy"];
      var callbackPropTypes = _propTypes["default"].func;
      var DateTimePicker = /* @__PURE__ */ function(_Component) {
        _inherits(DateTimePicker2, _Component);
        var _super = _createSuper(DateTimePicker2);
        function DateTimePicker2() {
          var _this;
          _classCallCheck(this, DateTimePicker2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "createFlatpickrInstance", function() {
            var options = _objectSpread({
              onClose: function onClose() {
                _this.node.blur && _this.node.blur();
              }
            }, _this.props.options);
            hooks.forEach(function(hook) {
              if (_this.props[hook]) {
                options[hook] = _this.props[hook];
              }
            });
            _this.flatpickr = (0, _flatpickr["default"])(_this.node, options);
            if (_this.props.hasOwnProperty("value")) {
              _this.flatpickr.setDate(_this.props.value, false);
            }
            var onCreate = _this.props.onCreate;
            if (onCreate) onCreate(_this.flatpickr);
          });
          _defineProperty(_assertThisInitialized(_this), "destroyFlatpickrInstance", function() {
            var onDestroy = _this.props.onDestroy;
            if (onDestroy) onDestroy(_this.flatpickr);
            _this.flatpickr.destroy();
            _this.flatpickr = null;
          });
          _defineProperty(_assertThisInitialized(_this), "handleNodeChange", function(node) {
            _this.node = node;
            if (_this.flatpickr) {
              _this.destroyFlatpickrInstance();
              _this.createFlatpickrInstance();
            }
          });
          return _this;
        }
        _createClass(DateTimePicker2, [{
          key: "componentDidUpdate",
          value: function componentDidUpdate(prevProps) {
            var _this2 = this;
            var options = this.props.options;
            var prevOptions = prevProps.options;
            hooks.forEach(function(hook) {
              if (_this2.props.hasOwnProperty(hook)) {
                options[hook] = _this2.props[hook];
              }
              if (prevProps.hasOwnProperty(hook)) {
                prevOptions[hook] = prevProps[hook];
              }
            });
            var optionsKeys = Object.getOwnPropertyNames(options);
            for (var index2 = optionsKeys.length - 1; index2 >= 0; index2--) {
              var key = optionsKeys[index2];
              var value = options[key];
              if (value !== prevOptions[key]) {
                if (hooks.indexOf(key) !== -1 && !Array.isArray(value)) {
                  value = [value];
                }
                this.flatpickr.set(key, value);
              }
            }
            if (this.props.hasOwnProperty("value") && this.props.value !== prevProps.value) {
              this.flatpickr.setDate(this.props.value, true);
            }
          }
        }, {
          key: "componentDidMount",
          value: function componentDidMount() {
            this.createFlatpickrInstance();
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.destroyFlatpickrInstance();
          }
        }, {
          key: "render",
          value: function render() {
            var _this$props = this.props, options = _this$props.options, defaultValue = _this$props.defaultValue, value = _this$props.value, children = _this$props.children, render2 = _this$props.render, props = _objectWithoutProperties(_this$props, ["options", "defaultValue", "value", "children", "render"]);
            hooks.forEach(function(hook) {
              delete props[hook];
            });
            callbacks.forEach(function(callback2) {
              delete props[callback2];
            });
            if (render2) return render2(_objectSpread(_objectSpread({}, props), {}, {
              defaultValue,
              value
            }), this.handleNodeChange);
            return options.wrap ? /* @__PURE__ */ _react["default"].createElement("div", _extends2({}, props, {
              ref: this.handleNodeChange
            }), children) : /* @__PURE__ */ _react["default"].createElement("input", _extends2({}, props, {
              defaultValue,
              ref: this.handleNodeChange
            }));
          }
        }]);
        return DateTimePicker2;
      }(_react.Component);
      _defineProperty(DateTimePicker, "propTypes", {
        defaultValue: _propTypes["default"].string,
        options: _propTypes["default"].object,
        onChange: hookPropType,
        onOpen: hookPropType,
        onClose: hookPropType,
        onMonthChange: hookPropType,
        onYearChange: hookPropType,
        onReady: hookPropType,
        onValueUpdate: hookPropType,
        onDayCreate: hookPropType,
        onCreate: callbackPropTypes,
        onDestroy: callbackPropTypes,
        value: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].array, _propTypes["default"].object, _propTypes["default"].number]),
        children: _propTypes["default"].node,
        className: _propTypes["default"].string,
        render: _propTypes["default"].func
      });
      _defineProperty(DateTimePicker, "defaultProps", {
        options: {}
      });
      var _default = DateTimePicker;
      exports["default"] = _default;
    }
  });

  // node_modules/dayjs/dayjs.min.js
  var require_dayjs_min = __commonJS({
    "node_modules/dayjs/dayjs.min.js"(exports, module) {
      !function(t7, e3) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e3() : "function" == typeof define && define.amd ? define(e3) : (t7 = "undefined" != typeof globalThis ? globalThis : t7 || self).dayjs = e3();
      }(exports, function() {
        "use strict";
        var t7 = 1e3, e3 = 6e4, n2 = 36e5, r6 = "millisecond", i5 = "second", s7 = "minute", u4 = "hour", a3 = "day", o10 = "week", f5 = "month", h3 = "quarter", c3 = "year", d5 = "date", l6 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M3 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t8) {
          var e4 = ["th", "st", "nd", "rd"], n3 = t8 % 100;
          return "[" + t8 + (e4[(n3 - 20) % 10] || e4[n3] || e4[0]) + "]";
        } }, m5 = function(t8, e4, n3) {
          var r7 = String(t8);
          return !r7 || r7.length >= e4 ? t8 : "" + Array(e4 + 1 - r7.length).join(n3) + t8;
        }, v3 = { s: m5, z: function(t8) {
          var e4 = -t8.utcOffset(), n3 = Math.abs(e4), r7 = Math.floor(n3 / 60), i6 = n3 % 60;
          return (e4 <= 0 ? "+" : "-") + m5(r7, 2, "0") + ":" + m5(i6, 2, "0");
        }, m: function t8(e4, n3) {
          if (e4.date() < n3.date()) return -t8(n3, e4);
          var r7 = 12 * (n3.year() - e4.year()) + (n3.month() - e4.month()), i6 = e4.clone().add(r7, f5), s8 = n3 - i6 < 0, u5 = e4.clone().add(r7 + (s8 ? -1 : 1), f5);
          return +(-(r7 + (n3 - i6) / (s8 ? i6 - u5 : u5 - i6)) || 0);
        }, a: function(t8) {
          return t8 < 0 ? Math.ceil(t8) || 0 : Math.floor(t8);
        }, p: function(t8) {
          return { M: f5, y: c3, w: o10, d: a3, D: d5, h: u4, m: s7, s: i5, ms: r6, Q: h3 }[t8] || String(t8 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t8) {
          return void 0 === t8;
        } }, g3 = "en", D2 = {};
        D2[g3] = M3;
        var p3 = function(t8) {
          return t8 instanceof _2;
        }, S2 = function t8(e4, n3, r7) {
          var i6;
          if (!e4) return g3;
          if ("string" == typeof e4) {
            var s8 = e4.toLowerCase();
            D2[s8] && (i6 = s8), n3 && (D2[s8] = n3, i6 = s8);
            var u5 = e4.split("-");
            if (!i6 && u5.length > 1) return t8(u5[0]);
          } else {
            var a4 = e4.name;
            D2[a4] = e4, i6 = a4;
          }
          return !r7 && i6 && (g3 = i6), i6 || !r7 && g3;
        }, w3 = function(t8, e4) {
          if (p3(t8)) return t8.clone();
          var n3 = "object" == typeof e4 ? e4 : {};
          return n3.date = t8, n3.args = arguments, new _2(n3);
        }, O3 = v3;
        O3.l = S2, O3.i = p3, O3.w = function(t8, e4) {
          return w3(t8, { locale: e4.$L, utc: e4.$u, x: e4.$x, $offset: e4.$offset });
        };
        var _2 = function() {
          function M4(t8) {
            this.$L = S2(t8.locale, null, true), this.parse(t8);
          }
          var m6 = M4.prototype;
          return m6.parse = function(t8) {
            this.$d = function(t9) {
              var e4 = t9.date, n3 = t9.utc;
              if (null === e4) return /* @__PURE__ */ new Date(NaN);
              if (O3.u(e4)) return /* @__PURE__ */ new Date();
              if (e4 instanceof Date) return new Date(e4);
              if ("string" == typeof e4 && !/Z$/i.test(e4)) {
                var r7 = e4.match($);
                if (r7) {
                  var i6 = r7[2] - 1 || 0, s8 = (r7[7] || "0").substring(0, 3);
                  return n3 ? new Date(Date.UTC(r7[1], i6, r7[3] || 1, r7[4] || 0, r7[5] || 0, r7[6] || 0, s8)) : new Date(r7[1], i6, r7[3] || 1, r7[4] || 0, r7[5] || 0, r7[6] || 0, s8);
                }
              }
              return new Date(e4);
            }(t8), this.$x = t8.x || {}, this.init();
          }, m6.init = function() {
            var t8 = this.$d;
            this.$y = t8.getFullYear(), this.$M = t8.getMonth(), this.$D = t8.getDate(), this.$W = t8.getDay(), this.$H = t8.getHours(), this.$m = t8.getMinutes(), this.$s = t8.getSeconds(), this.$ms = t8.getMilliseconds();
          }, m6.$utils = function() {
            return O3;
          }, m6.isValid = function() {
            return !(this.$d.toString() === l6);
          }, m6.isSame = function(t8, e4) {
            var n3 = w3(t8);
            return this.startOf(e4) <= n3 && n3 <= this.endOf(e4);
          }, m6.isAfter = function(t8, e4) {
            return w3(t8) < this.startOf(e4);
          }, m6.isBefore = function(t8, e4) {
            return this.endOf(e4) < w3(t8);
          }, m6.$g = function(t8, e4, n3) {
            return O3.u(t8) ? this[e4] : this.set(n3, t8);
          }, m6.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m6.valueOf = function() {
            return this.$d.getTime();
          }, m6.startOf = function(t8, e4) {
            var n3 = this, r7 = !!O3.u(e4) || e4, h4 = O3.p(t8), l7 = function(t9, e5) {
              var i6 = O3.w(n3.$u ? Date.UTC(n3.$y, e5, t9) : new Date(n3.$y, e5, t9), n3);
              return r7 ? i6 : i6.endOf(a3);
            }, $2 = function(t9, e5) {
              return O3.w(n3.toDate()[t9].apply(n3.toDate("s"), (r7 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e5)), n3);
            }, y3 = this.$W, M5 = this.$M, m7 = this.$D, v4 = "set" + (this.$u ? "UTC" : "");
            switch (h4) {
              case c3:
                return r7 ? l7(1, 0) : l7(31, 11);
              case f5:
                return r7 ? l7(1, M5) : l7(0, M5 + 1);
              case o10:
                var g4 = this.$locale().weekStart || 0, D3 = (y3 < g4 ? y3 + 7 : y3) - g4;
                return l7(r7 ? m7 - D3 : m7 + (6 - D3), M5);
              case a3:
              case d5:
                return $2(v4 + "Hours", 0);
              case u4:
                return $2(v4 + "Minutes", 1);
              case s7:
                return $2(v4 + "Seconds", 2);
              case i5:
                return $2(v4 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m6.endOf = function(t8) {
            return this.startOf(t8, false);
          }, m6.$set = function(t8, e4) {
            var n3, o11 = O3.p(t8), h4 = "set" + (this.$u ? "UTC" : ""), l7 = (n3 = {}, n3[a3] = h4 + "Date", n3[d5] = h4 + "Date", n3[f5] = h4 + "Month", n3[c3] = h4 + "FullYear", n3[u4] = h4 + "Hours", n3[s7] = h4 + "Minutes", n3[i5] = h4 + "Seconds", n3[r6] = h4 + "Milliseconds", n3)[o11], $2 = o11 === a3 ? this.$D + (e4 - this.$W) : e4;
            if (o11 === f5 || o11 === c3) {
              var y3 = this.clone().set(d5, 1);
              y3.$d[l7]($2), y3.init(), this.$d = y3.set(d5, Math.min(this.$D, y3.daysInMonth())).$d;
            } else l7 && this.$d[l7]($2);
            return this.init(), this;
          }, m6.set = function(t8, e4) {
            return this.clone().$set(t8, e4);
          }, m6.get = function(t8) {
            return this[O3.p(t8)]();
          }, m6.add = function(r7, h4) {
            var d6, l7 = this;
            r7 = Number(r7);
            var $2 = O3.p(h4), y3 = function(t8) {
              var e4 = w3(l7);
              return O3.w(e4.date(e4.date() + Math.round(t8 * r7)), l7);
            };
            if ($2 === f5) return this.set(f5, this.$M + r7);
            if ($2 === c3) return this.set(c3, this.$y + r7);
            if ($2 === a3) return y3(1);
            if ($2 === o10) return y3(7);
            var M5 = (d6 = {}, d6[s7] = e3, d6[u4] = n2, d6[i5] = t7, d6)[$2] || 1, m7 = this.$d.getTime() + r7 * M5;
            return O3.w(m7, this);
          }, m6.subtract = function(t8, e4) {
            return this.add(-1 * t8, e4);
          }, m6.format = function(t8) {
            var e4 = this, n3 = this.$locale();
            if (!this.isValid()) return n3.invalidDate || l6;
            var r7 = t8 || "YYYY-MM-DDTHH:mm:ssZ", i6 = O3.z(this), s8 = this.$H, u5 = this.$m, a4 = this.$M, o11 = n3.weekdays, f6 = n3.months, h4 = function(t9, n4, i7, s9) {
              return t9 && (t9[n4] || t9(e4, r7)) || i7[n4].slice(0, s9);
            }, c4 = function(t9) {
              return O3.s(s8 % 12 || 12, t9, "0");
            }, d6 = n3.meridiem || function(t9, e5, n4) {
              var r8 = t9 < 12 ? "AM" : "PM";
              return n4 ? r8.toLowerCase() : r8;
            }, $2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a4 + 1, MM: O3.s(a4 + 1, 2, "0"), MMM: h4(n3.monthsShort, a4, f6, 3), MMMM: h4(f6, a4), D: this.$D, DD: O3.s(this.$D, 2, "0"), d: String(this.$W), dd: h4(n3.weekdaysMin, this.$W, o11, 2), ddd: h4(n3.weekdaysShort, this.$W, o11, 3), dddd: o11[this.$W], H: String(s8), HH: O3.s(s8, 2, "0"), h: c4(1), hh: c4(2), a: d6(s8, u5, true), A: d6(s8, u5, false), m: String(u5), mm: O3.s(u5, 2, "0"), s: String(this.$s), ss: O3.s(this.$s, 2, "0"), SSS: O3.s(this.$ms, 3, "0"), Z: i6 };
            return r7.replace(y2, function(t9, e5) {
              return e5 || $2[t9] || i6.replace(":", "");
            });
          }, m6.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m6.diff = function(r7, d6, l7) {
            var $2, y3 = O3.p(d6), M5 = w3(r7), m7 = (M5.utcOffset() - this.utcOffset()) * e3, v4 = this - M5, g4 = O3.m(this, M5);
            return g4 = ($2 = {}, $2[c3] = g4 / 12, $2[f5] = g4, $2[h3] = g4 / 3, $2[o10] = (v4 - m7) / 6048e5, $2[a3] = (v4 - m7) / 864e5, $2[u4] = v4 / n2, $2[s7] = v4 / e3, $2[i5] = v4 / t7, $2)[y3] || v4, l7 ? g4 : O3.a(g4);
          }, m6.daysInMonth = function() {
            return this.endOf(f5).$D;
          }, m6.$locale = function() {
            return D2[this.$L];
          }, m6.locale = function(t8, e4) {
            if (!t8) return this.$L;
            var n3 = this.clone(), r7 = S2(t8, e4, true);
            return r7 && (n3.$L = r7), n3;
          }, m6.clone = function() {
            return O3.w(this.$d, this);
          }, m6.toDate = function() {
            return new Date(this.valueOf());
          }, m6.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m6.toISOString = function() {
            return this.$d.toISOString();
          }, m6.toString = function() {
            return this.$d.toUTCString();
          }, M4;
        }(), T4 = _2.prototype;
        return w3.prototype = T4, [["$ms", r6], ["$s", i5], ["$m", s7], ["$H", u4], ["$W", a3], ["$M", f5], ["$y", c3], ["$D", d5]].forEach(function(t8) {
          T4[t8[1]] = function(e4) {
            return this.$g(e4, t8[0], t8[1]);
          };
        }), w3.extend = function(t8, e4) {
          return t8.$i || (t8(e4, _2, w3), t8.$i = true), w3;
        }, w3.locale = S2, w3.isDayjs = p3, w3.unix = function(t8) {
          return w3(1e3 * t8);
        }, w3.en = D2[g3], w3.Ls = D2, w3.p = {}, w3;
      });
    }
  });

  // node_modules/dayjs/plugin/utc.js
  var require_utc = __commonJS({
    "node_modules/dayjs/plugin/utc.js"(exports, module) {
      !function(t7, i5) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = i5() : "function" == typeof define && define.amd ? define(i5) : (t7 = "undefined" != typeof globalThis ? globalThis : t7 || self).dayjs_plugin_utc = i5();
      }(exports, function() {
        "use strict";
        var t7 = "minute", i5 = /[+-]\d\d(?::?\d\d)?/g, e3 = /([+-]|\d\d)/g;
        return function(s7, f5, n2) {
          var u4 = f5.prototype;
          n2.utc = function(t8) {
            var i6 = { date: t8, utc: true, args: arguments };
            return new f5(i6);
          }, u4.utc = function(i6) {
            var e4 = n2(this.toDate(), { locale: this.$L, utc: true });
            return i6 ? e4.add(this.utcOffset(), t7) : e4;
          }, u4.local = function() {
            return n2(this.toDate(), { locale: this.$L, utc: false });
          };
          var o10 = u4.parse;
          u4.parse = function(t8) {
            t8.utc && (this.$u = true), this.$utils().u(t8.$offset) || (this.$offset = t8.$offset), o10.call(this, t8);
          };
          var r6 = u4.init;
          u4.init = function() {
            if (this.$u) {
              var t8 = this.$d;
              this.$y = t8.getUTCFullYear(), this.$M = t8.getUTCMonth(), this.$D = t8.getUTCDate(), this.$W = t8.getUTCDay(), this.$H = t8.getUTCHours(), this.$m = t8.getUTCMinutes(), this.$s = t8.getUTCSeconds(), this.$ms = t8.getUTCMilliseconds();
            } else r6.call(this);
          };
          var a3 = u4.utcOffset;
          u4.utcOffset = function(s8, f6) {
            var n3 = this.$utils().u;
            if (n3(s8)) return this.$u ? 0 : n3(this.$offset) ? a3.call(this) : this.$offset;
            if ("string" == typeof s8 && (s8 = function(t8) {
              void 0 === t8 && (t8 = "");
              var s9 = t8.match(i5);
              if (!s9) return null;
              var f7 = ("" + s9[0]).match(e3) || ["-", 0, 0], n4 = f7[0], u6 = 60 * +f7[1] + +f7[2];
              return 0 === u6 ? 0 : "+" === n4 ? u6 : -u6;
            }(s8), null === s8)) return this;
            var u5 = Math.abs(s8) <= 16 ? 60 * s8 : s8, o11 = this;
            if (f6) return o11.$offset = u5, o11.$u = 0 === s8, o11;
            if (0 !== s8) {
              var r7 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
              (o11 = this.local().add(u5 + r7, t7)).$offset = u5, o11.$x.$localOffset = r7;
            } else o11 = this.utc();
            return o11;
          };
          var h3 = u4.format;
          u4.format = function(t8) {
            var i6 = t8 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
            return h3.call(this, i6);
          }, u4.valueOf = function() {
            var t8 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
            return this.$d.valueOf() - 6e4 * t8;
          }, u4.isUTC = function() {
            return !!this.$u;
          }, u4.toISOString = function() {
            return this.toDate().toISOString();
          }, u4.toString = function() {
            return this.toDate().toUTCString();
          };
          var l6 = u4.toDate;
          u4.toDate = function(t8) {
            return "s" === t8 && this.$offset ? n2(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l6.call(this);
          };
          var c3 = u4.diff;
          u4.diff = function(t8, i6, e4) {
            if (t8 && this.$u === t8.$u) return c3.call(this, t8, i6, e4);
            var s8 = this.local(), f6 = n2(t8).local();
            return c3.call(s8, f6, i6, e4);
          };
        };
      });
    }
  });

  // node_modules/@jsonurl/jsonurl/dist/jsonurl.min.js
  var require_jsonurl_min = __commonJS({
    "node_modules/@jsonurl/jsonurl/dist/jsonurl.min.js"(exports, module) {
      !function(e3, t7) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = t7() : "function" == typeof define && define.amd ? define(t7) : (e3 = "undefined" != typeof globalThis ? globalThis : e3 || self).JsonURL = t7();
      }(exports, function() {
        "use strict";
        const e3 = "JSON->URL: expected literal value", t7 = "JSON->URL: unexpected character", r6 = "JSON->URL: unexpected end of text inside composite", s7 = "JSON->URL: unexpected text after composite", i5 = "JSON->URL: the empty string is not allowed", n2 = "JSON->URL: invalid escape sequence", o10 = "JSON->URL: invalid percent-encoded sequence", a3 = "JSON->URL: expected object value";
        function p3(e4, t8) {
          return void 0 === t8 ? e4 : e4 + " at position " + t8;
        }
        const u4 = 16, c3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 6, 6, 48, 10, 20, 20, 6, 6, 20, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 20, 6, 0, 48, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 6, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 6, 0];
        function l6(e4) {
          return e4 > 127 ? 0 : c3[e4];
        }
        class h3 {
          constructor(e4) {
            this.setOrDefault(e4, "allowEmptyUnquotedValues"), this.setOrDefault(e4, "allowEmptyUnquotedKeys"), this.setOrDefault(e4, "AQF"), this.setOrDefault(e4, "coerceNullToEmptyString"), this.setOrDefault(e4, "ignoreNullArrayMembers"), this.setOrDefault(e4, "ignoreNullObjectMembers"), this.setOrDefault(e4, "impliedArray"), this.setOrDefault(e4, "impliedObject"), this.setOrDefault(e4, "impliedStringLiterals"), this.setOrDefault(e4, "noEmptyComposite"), this.setOrDefault(e4, "wwwFormUrlEncoded");
          }
          setOrDefault(e4, t8, r7) {
            void 0 !== e4 && t8 in e4 ? t8 in this || (this[t8] = e4[t8]) : void 0 === r7 || t8 in this || (this[t8] = r7);
          }
          setOverride(e4, t8) {
            void 0 !== e4 && t8 in e4 && (this[t8] = e4[t8]);
          }
          setOrDefaultInt(e4, t8, r7) {
            this.setOrDefault(e4, t8, void 0 === r7 ? r7 : parseInt(r7));
          }
          isPresentAndTrue(e4) {
            return e4 in this && this[e4];
          }
        }
        class d5 extends h3 {
          constructor(e4, t8) {
            super(e4), this.setOrDefault(e4, "emptyValue"), this.setOrDefault(t8, "emptyValue", {}), this.setOverride(e4, "getMissingValue"), this.setOrDefaultInt(e4, "maxParseChars"), this.setOrDefaultInt(t8, "maxParseChars", 32768), this.setOrDefaultInt(e4, "maxParseDepth"), this.setOrDefaultInt(t8, "maxParseDepth", 32), this.setOrDefaultInt(e4, "maxParseValues"), this.setOrDefaultInt(t8, "maxParseValues", 4096), this.setOrDefault(e4, "nullValue"), this.setOrDefault(t8, "nullValue", null);
          }
          getMissingValue(e4, t8) {
            throw new SyntaxError(p3(a3, t8));
          }
        }
        class f5 extends h3 {
          constructor(e4) {
            super(e4);
            const t8 = !(void 0 === e4 || !("impliedStringLiterals" in e4) || !e4.impliedStringLiterals) || void 0;
            this.setOrDefault(e4, "allowEmptyUnquotedValues", t8), this.setOrDefault(e4, "allowEmptyUnquotedKeys", t8), this.setOrDefault(e4, "callFunctions"), this.setOrDefault(e4, "isImplied"), this.setOrDefault(e4, "ignoreNullArrayMembers", t8), this.setOrDefault(e4, "ignoreNullObjectMembers", t8), this.setOrDefault(e4, "ignoreUndefinedArrayMembers", t8), this.setOrDefault(e4, "ignoreUndefinedObjectMembers", t8), this.isImplied = this.isImplied || this.impliedArray || this.impliedObject;
          }
        }
        function m5(e4) {
          for (var t8 = arguments.length, r7 = new Array(t8 > 1 ? t8 - 1 : 0), s8 = 1; s8 < t8; s8++) r7[s8 - 1] = arguments[s8];
          return e4.toJsonURLText.apply(e4, r7);
        }
        const w3 = /\+/g, y2 = / /g, x3 = /(![\s\S]?)/g, O3 = /^[-A-Za-z0-9._~!$*;=@?/ ][-A-Za-z0-9._~!$*;=@?/' ]*$/, A3 = /^[-A-Za-z0-9._~!$*,;=@?/(): ]+$/, g3 = /^-?\d+(?:\.\d+)?(?:[eE][-+]?\d+)?$/, E4 = /[(),:]|%2[04]|%3B/gi, b2 = { "%20": "+", "%24": "$", "(": "%28", ")": "%29", ",": "%2C", ":": "%3A", "%3B": ";" }, S2 = /[!(),:]|%2[01489C]|%3[AB]/gi, v3 = { "%20": "+", "%21": "!!", "!": "!!", "%24": "$", "%28": "!(", "(": "!(", "%29": "!)", ")": "!)", "+": "!+", "%2C": "!,", ",": "!,", "%3A": "!:", ":": "!:", "%3B": ";" }, L3 = 40, U2 = 41, V2 = 44, C2 = 58, D2 = 38, j2 = 48, R = 65, N4 = 97, P4 = new Array(111);
        P4[33] = "!", P4[40] = "(", P4[41] = ")", P4[43] = "+", P4[44] = ",", P4[45] = ",", P4[48] = "0", P4[49] = "1", P4[50] = "2", P4[51] = "3", P4[52] = "4", P4[53] = "5", P4[54] = "6", P4[55] = "7", P4[56] = "8", P4[57] = "9", P4[58] = ":", P4[116] = "t", P4[102] = "f", P4[110] = "n";
        const J3 = "", F4 = " ";
        function T4(e4, t8) {
          const r7 = t8 ? S2 : E4, s8 = t8 ? v3 : b2;
          return encodeURIComponent(e4).replace(r7, function(e5) {
            const t9 = s8[e5];
            return void 0 === t9 ? e5 : t9;
          });
        }
        function I4(e4, t8) {
          switch (t8) {
            case j2:
              return 0;
            case 49:
              return 1;
            case 50:
              return 2;
            case 51:
              return 3;
            case 52:
              return 4;
            case 53:
              return 5;
            case 54:
              return 6;
            case 55:
              return 7;
            case 56:
              return 8;
            case 57:
              return 9;
            case R:
            case N4:
              return 10;
            case 66:
            case 98:
              return 11;
            case 67:
            case 99:
              return 12;
            case 68:
            case 100:
              return 13;
            case 69:
            case 101:
              return 14;
            case 70:
            case 102:
              return 15;
            default:
              throw new SyntaxError(p3(o10, e4));
          }
        }
        function k(e4) {
          if (e4.coerceNullToEmptyString) return M3(e4, false);
          if (e4.impliedStringLiterals) throw new SyntaxError("JSON->URL: can not represent null with implied strings");
          return "null";
        }
        function M3(e4, t8) {
          if (t8 ? e4.allowEmptyUnquotedKeys : e4.allowEmptyUnquotedValues) return J3;
          if (e4.AQF) return "!e";
          if (e4.impliedStringLiterals) throw new SyntaxError(i5);
          return "''";
        }
        !function(e4) {
          let { toJsonURLText_Array: t8, toJsonURLText_Boolean: r7, toJsonURLText_Number: s8, toJsonURLText_Object: i6, toJsonURLText_String: n3 } = e4;
          Object.defineProperty(Array.prototype, "toJsonURLText", { value: t8 }), Object.defineProperty(Boolean.prototype, "toJsonURLText", { value: r7 }), Object.defineProperty(Number.prototype, "toJsonURLText", { value: s8 }), Object.defineProperty(Object.prototype, "toJsonURLText", { value: i6 }), Object.defineProperty(String.prototype, "toJsonURLText", { value: n3 });
        }({ toJsonURLText_Array: function() {
          let e4, t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r7 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          return this.forEach(function(s8) {
            if ("function" == typeof s8) {
              if (!t8.callFunctions) return;
              for (; "function" == typeof s8; ) s8 = s8();
            }
            if (void 0 === s8) {
              if (t8.ignoreUndefinedArrayMembers) return;
              s8 = k(t8);
            } else if (null === s8) {
              if (t8.ignoreNullArrayMembers) return;
              s8 = k(t8);
            } else s8 = m5(s8, t8, r7 + 1);
            void 0 === e4 ? e4 = s8 : !t8.wwwFormUrlEncoded || r7 > 0 ? e4 += "," + s8 : e4 += "&" + s8;
          }), !t8.isImplied || r7 > 0 ? void 0 === e4 ? "()" : "(" + e4 + ")" : void 0 === e4 ? J3 : e4;
        }, toJsonURLText_Boolean: function() {
          return true === this ? "true" : "false";
        }, toJsonURLText_Number: function(e4) {
          const t8 = String(this);
          return e4.impliedStringLiterals && -1 !== t8.indexOf("+") ? T4(t8, e4) : t8;
        }, toJsonURLText_Object: function() {
          let e4, t8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r7 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          const s8 = Object.keys(this), i6 = this;
          return s8.forEach(function(s9) {
            if (null == s9) return;
            let n3 = i6[s9];
            if ("function" == typeof n3) {
              if (!t8.callFunctions) return;
              for (; "function" == typeof n3; ) n3 = n3();
            }
            if (void 0 === n3) {
              if (t8.ignoreUndefinedObjectMembers) return;
              n3 = k(t8);
            } else if (null === n3) {
              if (t8.ignoreNullObjectMembers) return;
              n3 = k(t8);
            } else n3 = m5(n3, t8, r7 + 1);
            const o11 = m5(s9, t8, r7, true);
            void 0 === e4 ? e4 = !t8.wwwFormUrlEncoded || r7 > 0 ? o11 + ":" + n3 : o11 + "=" + n3 : !t8.wwwFormUrlEncoded || r7 > 0 ? e4 += "," + o11 + ":" + n3 : e4 += "&" + o11 + "=" + n3;
          }), !t8.isImplied || r7 > 0 ? (t8.noEmptyComposite && void 0 === e4 && (e4 = ":"), void 0 === e4 ? "()" : "(" + e4 + ")") : void 0 === e4 ? J3 : e4;
        }, toJsonURLText_String: function(e4, t8, r7) {
          if (0 === this.length) return M3(e4, r7);
          if (e4.impliedStringLiterals) return T4(this, e4.AQF);
          if ("true" === (s8 = this) || "false" === s8 || "null" === s8 || g3.test(s8)) return true === r7 ? this : e4.AQF ? -1 == this.indexOf("+") ? "!" + this : this.replace("+", "!+") : -1 == this.indexOf("+") ? "'" + this + "'" : encodeURIComponent(this);
          var s8;
          if (e4.AQF) return T4(this, true);
          if (O3.test(this)) return -1 == this.indexOf(F4) ? this : this.replace(y2, "+");
          if (A3.test(this)) return -1 == this.indexOf(F4) ? "'" + this + "'" : "'" + this.replace(y2, "+") + "'";
          let i6 = T4(this);
          return 39 == i6.charCodeAt(0) ? "%27" + i6.substring(1) : i6;
        } });
        class _2 {
          constructor(e4, t8, r7, s8) {
            this.text = e4, this.pos = this.markPos = t8, this.end = r7, this.options = s8;
          }
          skipAmps() {
            let e4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            const t8 = this.text, r7 = this.end;
            let s8 = this.pos;
            if (e4) for (; s8 < r7 && t8.charCodeAt(s8) === D2; ) s8++;
            else if (s8 < r7 && t8.charCodeAt(s8) === D2) {
              for (s8++; s8 < r7 && t8.charCodeAt(s8) === D2; s8++) ;
              s8 !== r7 && s8--;
            }
            this.pos = s8;
          }
          structChar() {
            let e4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (this.options.wwwFormUrlEncoded) {
              const t9 = this.text.charCodeAt(this.pos);
              switch (t9) {
                case D2:
                case 61:
                  if (e4) return;
                  return this.pos++, t9;
              }
            }
            const t8 = this.pos, r7 = this.ordinal();
            switch (r7) {
              case V2:
              case C2:
                if (e4) return void (this.pos = t8);
              case L3:
              case U2:
                return r7;
              default:
                return void (this.pos = t8);
            }
          }
          ordinal(e4) {
            return void 0 !== e4 ? this.text.charCodeAt(e4) : this.text.charCodeAt(this.pos++);
          }
          accept(e4) {
            const t8 = this.pos;
            return this.ordinal() === e4 || (this.pos = t8, false);
          }
          acceptPlus() {
            return 43 == this.text.charCodeAt(this.pos) && (this.pos++, true);
          }
          done() {
            return this.end <= this.pos;
          }
          validateLiteral(e4, r7) {
            const s8 = this.text, i6 = this.end;
            for (; e4 < i6; e4++) {
              switch (l6(s8.charCodeAt(e4)) & r7) {
                case 0:
                  throw new SyntaxError(p3(t7, e4));
                case u4:
                  return e4;
                case 8:
                  return e4 + 1;
                default:
                  continue;
              }
            }
          }
          findLiteralEnd() {
            const e4 = this.text, t8 = this.end;
            let r7 = this.pos;
            const s8 = 39 === e4.charCodeAt(r7);
            s8 && r7++;
            const i6 = s8 ? 28 : 18;
            if (r7 = this.validateLiteral(r7, i6), void 0 !== r7) return r7;
            if (s8) throw new SyntaxError(p3("JSON->URL: quoted string still open", r7));
            return t8;
          }
          isEmptyObject() {
            if (this.options.noEmptyComposite) {
              const e4 = this.pos;
              if (!this.accept(C2)) return false;
              const t8 = this.pos, r7 = this.accept(U2);
              return this.pos = r7 ? t8 : e4, r7;
            }
            return false;
          }
          parseLiteral(e4) {
            const t8 = this.pos, r7 = this.options, s8 = this.findLiteralEnd();
            if (void 0 === e4 && (e4 = this.ordinal(s8) == C2), s8 <= t8) {
              return function(e5, t9) {
                if (t9) return J3;
                throw new SyntaxError(p3(i5, e5));
              }(t8, e4 ? this.options.allowEmptyUnquotedKeys : this.options.allowEmptyUnquotedValues);
            }
            if (true === r7.impliedStringLiterals) return this.parseStringLiteral(s8, true);
            const n3 = this.parseTrueFalseNull(s8, e4);
            if (void 0 !== n3) return n3;
            const o11 = this.parseNumberLiteral(s8, e4);
            return void 0 !== o11 ? o11 : this.parseStringLiteral(s8, false);
          }
          parseDigits(e4) {
            let t8, r7 = false;
            for (; this.pos < e4; ) switch (this.ordinal()) {
              case j2:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                t8 = this.pos, r7 = true;
                continue;
              default:
                return this.pos = t8, r7;
            }
            return this.pos = t8, r7;
          }
          parseExponentValue(e4) {
            return !(e4 <= this.pos) && (this.acceptPlus() || this.accept(45), this.parseDigits(e4));
          }
          parseExponent(e4) {
            const t8 = this.pos;
            switch (this.ordinal()) {
              case 69:
              case 101:
                if (this.parseExponentValue(e4)) return true;
            }
            return this.pos = t8, false;
          }
          parseFraction(e4) {
            const t8 = this.pos;
            return !(e4 <= t8) && (!(!this.accept(46) || !this.parseDigits(e4)) || (this.pos = t8, false));
          }
          parseInteger(e4) {
            return !(e4 <= this.pos) && (!!this.accept(j2) || this.parseDigits(e4));
          }
          parseNumberLiteral(e4, t8) {
            const r7 = this.text, s8 = this.pos;
            if (this.accept(45), this.parseInteger(e4) && (this.parseFraction(e4), this.parseExponent(e4), this.pos === e4)) {
              const i6 = decodeURIComponent(r7.substring(s8, e4));
              return t8 ? i6 : Number(i6);
            }
            this.pos = s8;
          }
          parseStringLiteral(e4, t8) {
            const r7 = this.text, s8 = this.pos;
            let i6 = t8 || 39 !== r7.charCodeAt(s8) ? r7.substring(s8, e4) : r7.substring(s8 + 1, e4 - 1);
            return i6 = decodeURIComponent(i6.replace(w3, F4)), this.pos = e4, i6;
          }
          parseTrueFalseNull(e4, t8) {
            const r7 = this.text, s8 = this.pos;
            let i6, n3, o11, a4, p4;
            switch (e4 - s8) {
              case 4:
                if (i6 = r7.charCodeAt(s8), n3 = r7.charCodeAt(s8 + 1), o11 = r7.charCodeAt(s8 + 2), a4 = r7.charCodeAt(s8 + 3), 116 === i6 && 114 === n3 && 117 === o11 && 101 === a4) return this.pos = e4, !t8 || "true";
                if (110 === i6 && 117 === n3 && 108 === o11 && 108 === a4) return this.pos = e4, t8 ? "null" : this.newNullValue();
                break;
              case 5:
                if (i6 = r7.charCodeAt(s8), n3 = r7.charCodeAt(s8 + 1), o11 = r7.charCodeAt(s8 + 2), a4 = r7.charCodeAt(s8 + 3), p4 = r7.charCodeAt(s8 + 4), 102 === i6 && n3 === N4 && 108 === o11 && 115 === a4 && 101 === p4) return this.pos = e4, !!t8 && "false";
            }
          }
          newEmptyValue() {
            const e4 = this.options;
            if (e4.noEmptyComposite) return [];
            const t8 = e4.emptyValue;
            return "function" == typeof t8 ? t8() : t8;
          }
          newNullValue() {
            const e4 = this.options;
            let t8 = e4.nullValue;
            return "function" == typeof t8 && (t8 = t8()), null == t8 && e4.coerceNullToEmptyString && (t8 = J3), t8;
          }
        }
        class q3 extends _2 {
          constructor(e4, t8, r7, s8) {
            super(e4, t8, r7, s8);
          }
          ordinal(e4) {
            const t8 = e4 || this.pos, r7 = this.text.charCodeAt(t8);
            let s8, i6;
            return 37 === r7 ? (s8 = function(e5, t9, r8) {
              if (r8 <= t9 + 1) throw new SyntaxError(p3(o10, t9));
              return I4(t9, e5.charCodeAt(t9)) << 4 | I4(t9, e5.charCodeAt(t9 + 1));
            }(this.text, t8 + 1, this.end), i6 = 3) : (s8 = r7, i6 = 1), void 0 === e4 && (this.pos += i6), s8;
          }
          acceptPlus() {
            return this.accept(43);
          }
          findLiteralEnd() {
            const e4 = this.end, r7 = this.pos, s8 = this.text;
            let i6 = r7;
            for (; ; ) {
              if (e4 <= this.pos) return this.pos = r7, e4;
              switch (50 & l6(s8.charCodeAt(this.pos))) {
                case 48:
                  if (this.options.wwwFormUrlEncoded) return i6 = this.pos, this.pos = r7, i6;
                case 0:
                  throw new SyntaxError(p3(t7, i6));
              }
              switch (this.ordinal()) {
                case L3:
                case U2:
                case C2:
                case V2:
                  return this.pos = r7, i6;
                case 33:
                  if (this.pos === e4) throw new SyntaxError(p3(n2, i6));
                  this.ordinal(), i6 = this.pos;
                  break;
                default:
                  i6 = this.pos;
              }
            }
          }
          parseStringLiteral(e4) {
            const t8 = this.text, r7 = this.pos, s8 = decodeURIComponent(t8.substring(r7, e4).replace(w3, F4));
            return this.pos = e4, "!e" === s8 ? J3 : s8.replace(x3, function(e5, t9, s9) {
              if (2 === e5.length) {
                const t10 = e5.charCodeAt(1), r8 = P4[t10];
                if (void 0 !== r8) return r8;
              }
              throw new SyntaxError(p3(n2, r7 + s9));
            });
          }
        }
        class $ extends Array {
          constructor(e4) {
            super(), this.limits = e4, this.parseDepth = 0;
          }
          replaceAndPush(e4, t8, r7) {
            if (this[this.parseDepth] = t8, ++this.parseDepth >= this.limits.maxParseDepth) throw new Error(p3("JSON->URL: MaxParseDepth exceeded", e4));
            this.push(r7);
          }
          replace(e4) {
            this[this.parseDepth] = e4;
          }
          depth() {
            return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && (this.parseDepth--, this.pop()), this.parseDepth;
          }
        }
        class B extends Array {
          constructor(e4) {
            super(), this.limits = e4, this.numValues = 0;
          }
          popObjectValue(e4) {
            let t8 = this.pop(), r7 = this.pop(), s8 = this[this.length - 1];
            return null === t8 && e4.isPresentAndTrue("ignoreNullObjectMembers") || (s8[r7] = t8), s8;
          }
          popArrayValue(e4) {
            let t8 = this.pop(), r7 = this[this.length - 1];
            return null === t8 && e4.isPresentAndTrue("ignoreNullArrayMembers") || r7.push(t8), r7;
          }
          checkValueLimit(e4) {
            let t8 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            if (this.numValues += t8, this.numValues > this.limits.maxParseValues + 1) throw new Error(p3("JSON->URL: MaxParseValues exceeded", e4));
          }
          appendArrayValue(e4, t8) {
            let r7 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            this.checkValueLimit(e4, r7), this.push(t8);
          }
        }
        function Q2(e4) {
          for (; "function" == typeof e4; ) e4 = e4();
          return e4;
        }
        function K2(e4, t8, r7, s8) {
          return "number" == typeof e4 ? "number" != typeof t8 && (r7 = t8) : r7 = e4, (r7 = Q2(r7)) instanceof d5 || (r7 = new d5(r7, s8)), r7;
        }
        function z2(e4, t8, r7, s8) {
          return s8.AQF ? new q3(e4, t8, r7, s8) : new _2(e4, t8, r7, s8);
        }
        function Z(e4, t8) {
          return "number" == typeof e4 ? e4 : t8;
        }
        function G2(i6, n3, o11, u5, c4) {
          if (void 0 === i6) return;
          u5 = K2(n3, o11, u5, c4), i6 = String(i6);
          const l7 = Z(n3, 0), h4 = Z(o11, i6.length);
          if (h4 <= l7) {
            if (void 0 !== u5.impliedArray) return u5.impliedArray;
            if (void 0 !== u5.impliedObject) return u5.impliedObject;
            throw new SyntaxError(p3("JSON->URL: expected value", 0));
          }
          if (h4 > u5.maxParseChars) throw new Error("JSON->URL: MaxParseChars exceeded");
          const d6 = u5.wwwFormUrlEncoded && (u5.impliedObject || u5.impliedArray), f6 = new B(u5), m6 = new $(u5), w4 = z2(i6, l7, h4, u5);
          if (void 0 !== u5.impliedObject) f6.push(u5.impliedObject), m6.push(6);
          else if (void 0 !== u5.impliedArray) f6.push(u5.impliedArray), m6.push(2);
          else {
            if (w4.structChar(true) !== L3) {
              const t8 = w4.parseLiteral(false);
              if (w4.done()) return t8;
              throw new SyntaxError(p3(e3, 0));
            }
            m6.push(1);
          }
          for (d6 && w4.skipAmps(true); ; ) {
            if (w4.done()) throw new SyntaxError(p3(r6, w4.pos));
            let i7, n4, o12;
            switch (m6[m6.depth()]) {
              case 1:
                switch (w4.structChar(true)) {
                  case L3:
                    f6.appendArrayValue(w4.pos, []), m6.replaceAndPush(w4.pos, 3, 1);
                    continue;
                  case U2:
                    if (-1 === m6.depth(true)) {
                      if (w4.done()) return w4.newEmptyValue();
                      throw new SyntaxError(p3(s7, w4.pos));
                    }
                    if (f6.appendArrayValue(w4.pos, w4.newEmptyValue()), 0 === m6.depth() && (d6 && w4.skipAmps(), w4.done())) {
                      if (u5.impliedArray) return f6.popArrayValue(u5);
                      if (u5.impliedObject) return f6.popObjectValue(u5);
                      throw new SyntaxError(p3(r6, w4.pos));
                    }
                    continue;
                }
                switch (f6.checkValueLimit(w4.pos), n4 = w4.isEmptyObject(), i7 = n4 ? {} : w4.parseLiteral(), o12 = w4.pos, w4.structChar()) {
                  case D2:
                    if (!u5.wwwFormUrlEncoded || m6.depth() > 0) throw new SyntaxError(p3(t7, o12));
                  case V2:
                    m6.replace(2), f6.appendArrayValue(o12, []), f6.push(i7), f6.popArrayValue(u5);
                    continue;
                  case U2:
                    switch (n4 ? f6.push({}) : f6.appendArrayValue(o12, [i7]), m6.depth(true)) {
                      case -1:
                        if (w4.pos === h4) return f6[0];
                        throw new SyntaxError(p3(s7, o12));
                      case 0:
                        if (d6 && w4.skipAmps(), w4.done()) {
                          if (u5.impliedArray) return f6.popArrayValue(u5);
                          if (u5.impliedObject) return f6.popObjectValue(u5);
                          throw new SyntaxError(p3(r6, o12));
                        }
                    }
                    continue;
                  case 61:
                    if (!u5.wwwFormUrlEncoded || m6.depth() > 0) throw new SyntaxError(p3(t7, o12));
                  case C2:
                    m6.replace(4), f6.push({}, i7);
                    continue;
                  default:
                    throw new SyntaxError(p3(e3, o12));
                }
              case 2:
                if (w4.accept(L3)) {
                  m6.replaceAndPush(w4.pos, 3, 1);
                  continue;
                }
                if (f6.checkValueLimit(w4.pos), i7 = w4.parseLiteral(false), d6 && w4.skipAmps(), w4.done()) {
                  if (0 === m6.depth() && u5.impliedArray) return f6.push(i7), f6.popArrayValue(u5);
                  throw new SyntaxError(p3(r6, h4));
                }
                m6.replace(3), f6.push(i7);
                continue;
              case 3:
                switch (f6.popArrayValue(u5), w4.structChar()) {
                  case D2:
                    if (!u5.wwwFormUrlEncoded || m6.depth() > 0) throw new SyntaxError(p3(t7, w4.pos));
                  case V2:
                    m6.replace(2);
                    continue;
                  case U2:
                    switch (m6.depth(true)) {
                      case -1:
                        if (w4.done() && !u5.impliedArray) return f6[0];
                        throw new SyntaxError(p3(s7, w4.pos));
                      case 0:
                        if (d6 && w4.skipAmps(), w4.done()) {
                          if (u5.impliedArray) return f6.popArrayValue(u5);
                          if (u5.impliedObject) return f6.popObjectValue(u5);
                          throw new SyntaxError(p3(r6, w4.pos));
                        }
                    }
                    continue;
                }
                throw new SyntaxError(p3("JSON->URL: expected comma or close paren", w4.pos));
              case 4:
                if (w4.accept(L3)) {
                  m6.replaceAndPush(w4.pos, 5, 1);
                  continue;
                }
                if (f6.checkValueLimit(w4.pos), i7 = w4.parseLiteral(false), d6 && w4.skipAmps(), w4.done()) {
                  if (0 === m6.depth() && u5.impliedObject) return f6.push(i7), f6.popObjectValue(u5);
                  throw new SyntaxError(p3(r6, h4));
                }
                m6.replace(5), f6.push(i7);
                continue;
              case 5:
                switch (f6.popObjectValue(u5), o12 = w4.pos, w4.structChar()) {
                  case D2:
                    if (!u5.wwwFormUrlEncoded || m6.depth() > 0) throw new SyntaxError(p3(t7, o12));
                  case V2:
                    m6.replace(6);
                    continue;
                  case U2:
                    switch (m6.depth(true)) {
                      case -1:
                        if (w4.done() && !u5.impliedObject) return f6[0];
                        throw new SyntaxError(p3(s7, w4.pos));
                      case 0:
                        if (d6 && w4.skipAmps(), w4.done()) {
                          if (u5.impliedArray) return f6.popArrayValue(u5);
                          if (u5.impliedObject) return f6.popObjectValue(u5);
                          throw new SyntaxError(p3(s7, w4.pos));
                        }
                    }
                    continue;
                }
                throw new SyntaxError(p3("JSON->URL: expected comma, open paren, or close paren", w4.pos));
              case 6:
                if (i7 = w4.parseLiteral(true), d6 && w4.skipAmps(), w4.done()) {
                  if (u5.impliedObject && 0 == m6.depth()) return f6.push(i7, u5.getMissingValue(i7)), f6.popObjectValue(u5);
                  throw new SyntaxError(p3(r6, h4));
                }
                switch (w4.structChar()) {
                  case 61:
                    if (!u5.wwwFormUrlEncoded || m6.depth() > 0) throw new SyntaxError(p3(t7, w4.pos));
                  case C2:
                    break;
                  case D2:
                    if (!u5.wwwFormUrlEncoded || m6.depth() > 0) throw new SyntaxError(p3(t7, w4.pos));
                  case V2:
                    if (u5.impliedObject && 0 == m6.depth()) {
                      f6.push(i7, u5.getMissingValue(i7)), f6.popObjectValue(u5);
                      continue;
                    }
                  default:
                    throw new SyntaxError(p3(a3, w4.pos));
                }
                m6.replace(4), f6.push(i7);
                continue;
              default:
                throw new SyntaxError(p3("JSON->URL: internal error", w4.pos));
            }
          }
        }
        return class {
          constructor(e4) {
            for (; "function" == typeof e4; ) e4 = e4();
            void 0 === e4 && (e4 = {}), this.maxParseDepth = "number" == typeof e4.maxParseDepth ? parseInt(e4.maxParseDepth) : 32, this.maxParseValues = "number" == typeof e4.maxParseValues ? parseInt(e4.maxParseValues) : 4096, this.maxParseChars = "number" == typeof e4.maxParseChars ? parseInt(e4.maxParseChars) : 32768, this.emptyValue = void 0 === e4.emptyValue ? {} : e4.emptyValue, this.nullValue = void 0 === e4.nullValue ? null : e4.nullValue;
          }
          parseLiteral(e4) {
            let t8 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r7 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, s8 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], i6 = arguments.length > 4 ? arguments[4] : void 0;
            void 0 !== e4 && (e4 = String(e4)), void 0 === r7 && (r7 = e4.length);
            return z2(e4, t8, r7, K2(i6)).parseLiteral(s8);
          }
          static parse(e4, t8, r7, s8) {
            return G2(e4, t8, r7, s8, void 0);
          }
          parse(e4, t8, r7, s8) {
            return G2(e4, t8, r7, s8, this);
          }
          static stringify(e4, t8) {
            if (void 0 !== e4) return t8 = new f5(Q2(t8)), null === e4 ? k(t8) : m5(e4, t8, 0);
          }
        };
      });
    }
  });

  // node_modules/classnames/index.js
  var require_classnames = __commonJS({
    "node_modules/classnames/index.js"(exports, module) {
      (function() {
        "use strict";
        var hasOwn = {}.hasOwnProperty;
        function classNames16() {
          var classes = [];
          for (var i5 = 0; i5 < arguments.length; i5++) {
            var arg = arguments[i5];
            if (!arg) continue;
            var argType = typeof arg;
            if (argType === "string" || argType === "number") {
              classes.push(arg);
            } else if (Array.isArray(arg)) {
              if (arg.length) {
                var inner = classNames16.apply(null, arg);
                if (inner) {
                  classes.push(inner);
                }
              }
            } else if (argType === "object") {
              if (arg.toString === Object.prototype.toString) {
                for (var key in arg) {
                  if (hasOwn.call(arg, key) && arg[key]) {
                    classes.push(key);
                  }
                }
              } else {
                classes.push(arg.toString());
              }
            }
          }
          return classes.join(" ");
        }
        if (typeof module !== "undefined" && module.exports) {
          classNames16.default = classNames16;
          module.exports = classNames16;
        } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
          define("classnames", [], function() {
            return classNames16;
          });
        } else {
          window.classNames = classNames16;
        }
      })();
    }
  });

  // node_modules/react-fast-compare/index.js
  var require_react_fast_compare = __commonJS({
    "node_modules/react-fast-compare/index.js"(exports, module) {
      var hasElementType = typeof Element !== "undefined";
      var hasMap = typeof Map === "function";
      var hasSet = typeof Set === "function";
      var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
      function equal(a3, b2) {
        if (a3 === b2) return true;
        if (a3 && b2 && typeof a3 == "object" && typeof b2 == "object") {
          if (a3.constructor !== b2.constructor) return false;
          var length, i5, keys;
          if (Array.isArray(a3)) {
            length = a3.length;
            if (length != b2.length) return false;
            for (i5 = length; i5-- !== 0; )
              if (!equal(a3[i5], b2[i5])) return false;
            return true;
          }
          var it;
          if (hasMap && a3 instanceof Map && b2 instanceof Map) {
            if (a3.size !== b2.size) return false;
            it = a3.entries();
            while (!(i5 = it.next()).done)
              if (!b2.has(i5.value[0])) return false;
            it = a3.entries();
            while (!(i5 = it.next()).done)
              if (!equal(i5.value[1], b2.get(i5.value[0]))) return false;
            return true;
          }
          if (hasSet && a3 instanceof Set && b2 instanceof Set) {
            if (a3.size !== b2.size) return false;
            it = a3.entries();
            while (!(i5 = it.next()).done)
              if (!b2.has(i5.value[0])) return false;
            return true;
          }
          if (hasArrayBuffer && ArrayBuffer.isView(a3) && ArrayBuffer.isView(b2)) {
            length = a3.length;
            if (length != b2.length) return false;
            for (i5 = length; i5-- !== 0; )
              if (a3[i5] !== b2[i5]) return false;
            return true;
          }
          if (a3.constructor === RegExp) return a3.source === b2.source && a3.flags === b2.flags;
          if (a3.valueOf !== Object.prototype.valueOf) return a3.valueOf() === b2.valueOf();
          if (a3.toString !== Object.prototype.toString) return a3.toString() === b2.toString();
          keys = Object.keys(a3);
          length = keys.length;
          if (length !== Object.keys(b2).length) return false;
          for (i5 = length; i5-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b2, keys[i5])) return false;
          if (hasElementType && a3 instanceof Element) return false;
          for (i5 = length; i5-- !== 0; ) {
            if ((keys[i5] === "_owner" || keys[i5] === "__v" || keys[i5] === "__o") && a3.$$typeof) {
              continue;
            }
            if (!equal(a3[keys[i5]], b2[keys[i5]])) return false;
          }
          return true;
        }
        return a3 !== a3 && b2 !== b2;
      }
      module.exports = function isEqual2(a3, b2) {
        try {
          return equal(a3, b2);
        } catch (error) {
          if ((error.message || "").match(/stack|recursion/i)) {
            console.warn("react-fast-compare cannot handle circular refs");
            return false;
          }
          throw error;
        }
      };
    }
  });

  // node_modules/d3/d3.js
  var require_d3 = __commonJS({
    "node_modules/d3/d3.js"(exports, module) {
      !function() {
        var d33 = {
          version: "3.5.17"
        };
        var d3_arraySlice = [].slice, d3_array = function(list) {
          return d3_arraySlice.call(list);
        };
        var d3_document = this.document;
        function d3_documentElement(node) {
          return node && (node.ownerDocument || node.document || node).documentElement;
        }
        function d3_window(node) {
          return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
        }
        if (d3_document) {
          try {
            d3_array(d3_document.documentElement.childNodes)[0].nodeType;
          } catch (e3) {
            d3_array = function(list) {
              var i5 = list.length, array = new Array(i5);
              while (i5--) array[i5] = list[i5];
              return array;
            };
          }
        }
        if (!Date.now) Date.now = function() {
          return +/* @__PURE__ */ new Date();
        };
        if (d3_document) {
          try {
            d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
          } catch (error) {
            var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
            d3_element_prototype.setAttribute = function(name, value) {
              d3_element_setAttribute.call(this, name, value + "");
            };
            d3_element_prototype.setAttributeNS = function(space, local, value) {
              d3_element_setAttributeNS.call(this, space, local, value + "");
            };
            d3_style_prototype.setProperty = function(name, value, priority) {
              d3_style_setProperty.call(this, name, value + "", priority);
            };
          }
        }
        d33.ascending = d3_ascending;
        function d3_ascending(a3, b2) {
          return a3 < b2 ? -1 : a3 > b2 ? 1 : a3 >= b2 ? 0 : NaN;
        }
        d33.descending = function(a3, b2) {
          return b2 < a3 ? -1 : b2 > a3 ? 1 : b2 >= a3 ? 0 : NaN;
        };
        d33.min = function(array, f5) {
          var i5 = -1, n2 = array.length, a3, b2;
          if (arguments.length === 1) {
            while (++i5 < n2) if ((b2 = array[i5]) != null && b2 >= b2) {
              a3 = b2;
              break;
            }
            while (++i5 < n2) if ((b2 = array[i5]) != null && a3 > b2) a3 = b2;
          } else {
            while (++i5 < n2) if ((b2 = f5.call(array, array[i5], i5)) != null && b2 >= b2) {
              a3 = b2;
              break;
            }
            while (++i5 < n2) if ((b2 = f5.call(array, array[i5], i5)) != null && a3 > b2) a3 = b2;
          }
          return a3;
        };
        d33.max = function(array, f5) {
          var i5 = -1, n2 = array.length, a3, b2;
          if (arguments.length === 1) {
            while (++i5 < n2) if ((b2 = array[i5]) != null && b2 >= b2) {
              a3 = b2;
              break;
            }
            while (++i5 < n2) if ((b2 = array[i5]) != null && b2 > a3) a3 = b2;
          } else {
            while (++i5 < n2) if ((b2 = f5.call(array, array[i5], i5)) != null && b2 >= b2) {
              a3 = b2;
              break;
            }
            while (++i5 < n2) if ((b2 = f5.call(array, array[i5], i5)) != null && b2 > a3) a3 = b2;
          }
          return a3;
        };
        d33.extent = function(array, f5) {
          var i5 = -1, n2 = array.length, a3, b2, c3;
          if (arguments.length === 1) {
            while (++i5 < n2) if ((b2 = array[i5]) != null && b2 >= b2) {
              a3 = c3 = b2;
              break;
            }
            while (++i5 < n2) if ((b2 = array[i5]) != null) {
              if (a3 > b2) a3 = b2;
              if (c3 < b2) c3 = b2;
            }
          } else {
            while (++i5 < n2) if ((b2 = f5.call(array, array[i5], i5)) != null && b2 >= b2) {
              a3 = c3 = b2;
              break;
            }
            while (++i5 < n2) if ((b2 = f5.call(array, array[i5], i5)) != null) {
              if (a3 > b2) a3 = b2;
              if (c3 < b2) c3 = b2;
            }
          }
          return [a3, c3];
        };
        function d3_number(x3) {
          return x3 === null ? NaN : +x3;
        }
        function d3_numeric(x3) {
          return !isNaN(x3);
        }
        d33.sum = function(array, f5) {
          var s7 = 0, n2 = array.length, a3, i5 = -1;
          if (arguments.length === 1) {
            while (++i5 < n2) if (d3_numeric(a3 = +array[i5])) s7 += a3;
          } else {
            while (++i5 < n2) if (d3_numeric(a3 = +f5.call(array, array[i5], i5))) s7 += a3;
          }
          return s7;
        };
        d33.mean = function(array, f5) {
          var s7 = 0, n2 = array.length, a3, i5 = -1, j2 = n2;
          if (arguments.length === 1) {
            while (++i5 < n2) if (d3_numeric(a3 = d3_number(array[i5]))) s7 += a3;
            else --j2;
          } else {
            while (++i5 < n2) if (d3_numeric(a3 = d3_number(f5.call(array, array[i5], i5)))) s7 += a3;
            else --j2;
          }
          if (j2) return s7 / j2;
        };
        d33.quantile = function(values, p3) {
          var H4 = (values.length - 1) * p3 + 1, h3 = Math.floor(H4), v3 = +values[h3 - 1], e3 = H4 - h3;
          return e3 ? v3 + e3 * (values[h3] - v3) : v3;
        };
        d33.median = function(array, f5) {
          var numbers2 = [], n2 = array.length, a3, i5 = -1;
          if (arguments.length === 1) {
            while (++i5 < n2) if (d3_numeric(a3 = d3_number(array[i5]))) numbers2.push(a3);
          } else {
            while (++i5 < n2) if (d3_numeric(a3 = d3_number(f5.call(array, array[i5], i5)))) numbers2.push(a3);
          }
          if (numbers2.length) return d33.quantile(numbers2.sort(d3_ascending), 0.5);
        };
        d33.variance = function(array, f5) {
          var n2 = array.length, m5 = 0, a3, d5, s7 = 0, i5 = -1, j2 = 0;
          if (arguments.length === 1) {
            while (++i5 < n2) {
              if (d3_numeric(a3 = d3_number(array[i5]))) {
                d5 = a3 - m5;
                m5 += d5 / ++j2;
                s7 += d5 * (a3 - m5);
              }
            }
          } else {
            while (++i5 < n2) {
              if (d3_numeric(a3 = d3_number(f5.call(array, array[i5], i5)))) {
                d5 = a3 - m5;
                m5 += d5 / ++j2;
                s7 += d5 * (a3 - m5);
              }
            }
          }
          if (j2 > 1) return s7 / (j2 - 1);
        };
        d33.deviation = function() {
          var v3 = d33.variance.apply(this, arguments);
          return v3 ? Math.sqrt(v3) : v3;
        };
        function d3_bisector(compare) {
          return {
            left: function(a3, x3, lo, hi) {
              if (arguments.length < 3) lo = 0;
              if (arguments.length < 4) hi = a3.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (compare(a3[mid], x3) < 0) lo = mid + 1;
                else hi = mid;
              }
              return lo;
            },
            right: function(a3, x3, lo, hi) {
              if (arguments.length < 3) lo = 0;
              if (arguments.length < 4) hi = a3.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (compare(a3[mid], x3) > 0) hi = mid;
                else lo = mid + 1;
              }
              return lo;
            }
          };
        }
        var d3_bisect = d3_bisector(d3_ascending);
        d33.bisectLeft = d3_bisect.left;
        d33.bisect = d33.bisectRight = d3_bisect.right;
        d33.bisector = function(f5) {
          return d3_bisector(f5.length === 1 ? function(d5, x3) {
            return d3_ascending(f5(d5), x3);
          } : f5);
        };
        d33.shuffle = function(array, i0, i1) {
          if ((m5 = arguments.length) < 3) {
            i1 = array.length;
            if (m5 < 2) i0 = 0;
          }
          var m5 = i1 - i0, t7, i5;
          while (m5) {
            i5 = Math.random() * m5-- | 0;
            t7 = array[m5 + i0], array[m5 + i0] = array[i5 + i0], array[i5 + i0] = t7;
          }
          return array;
        };
        d33.permute = function(array, indexes) {
          var i5 = indexes.length, permutes = new Array(i5);
          while (i5--) permutes[i5] = array[indexes[i5]];
          return permutes;
        };
        d33.pairs = function(array) {
          var i5 = 0, n2 = array.length - 1, p0, p1 = array[0], pairs = new Array(n2 < 0 ? 0 : n2);
          while (i5 < n2) pairs[i5] = [p0 = p1, p1 = array[++i5]];
          return pairs;
        };
        d33.transpose = function(matrix) {
          if (!(n2 = matrix.length)) return [];
          for (var i5 = -1, m5 = d33.min(matrix, d3_transposeLength), transpose = new Array(m5); ++i5 < m5; ) {
            for (var j2 = -1, n2, row = transpose[i5] = new Array(n2); ++j2 < n2; ) {
              row[j2] = matrix[j2][i5];
            }
          }
          return transpose;
        };
        function d3_transposeLength(d5) {
          return d5.length;
        }
        d33.zip = function() {
          return d33.transpose(arguments);
        };
        d33.keys = function(map3) {
          var keys = [];
          for (var key in map3) keys.push(key);
          return keys;
        };
        d33.values = function(map3) {
          var values = [];
          for (var key in map3) values.push(map3[key]);
          return values;
        };
        d33.entries = function(map3) {
          var entries = [];
          for (var key in map3) entries.push({
            key,
            value: map3[key]
          });
          return entries;
        };
        d33.merge = function(arrays) {
          var n2 = arrays.length, m5, i5 = -1, j2 = 0, merged, array;
          while (++i5 < n2) j2 += arrays[i5].length;
          merged = new Array(j2);
          while (--n2 >= 0) {
            array = arrays[n2];
            m5 = array.length;
            while (--m5 >= 0) {
              merged[--j2] = array[m5];
            }
          }
          return merged;
        };
        var abs = Math.abs;
        d33.range = function(start3, stop, step) {
          if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
              stop = start3;
              start3 = 0;
            }
          }
          if ((stop - start3) / step === Infinity) throw new Error("infinite range");
          var range = [], k = d3_range_integerScale(abs(step)), i5 = -1, j2;
          start3 *= k, stop *= k, step *= k;
          if (step < 0) while ((j2 = start3 + step * ++i5) > stop) range.push(j2 / k);
          else while ((j2 = start3 + step * ++i5) < stop) range.push(j2 / k);
          return range;
        };
        function d3_range_integerScale(x3) {
          var k = 1;
          while (x3 * k % 1) k *= 10;
          return k;
        }
        function d3_class(ctor, properties) {
          for (var key in properties) {
            Object.defineProperty(ctor.prototype, key, {
              value: properties[key],
              enumerable: false
            });
          }
        }
        d33.map = function(object, f5) {
          var map3 = new d3_Map();
          if (object instanceof d3_Map) {
            object.forEach(function(key2, value) {
              map3.set(key2, value);
            });
          } else if (Array.isArray(object)) {
            var i5 = -1, n2 = object.length, o10;
            if (arguments.length === 1) while (++i5 < n2) map3.set(i5, object[i5]);
            else while (++i5 < n2) map3.set(f5.call(object, o10 = object[i5], i5), o10);
          } else {
            for (var key in object) map3.set(key, object[key]);
          }
          return map3;
        };
        function d3_Map() {
          this._ = /* @__PURE__ */ Object.create(null);
        }
        var d3_map_proto = "__proto__", d3_map_zero = "\0";
        d3_class(d3_Map, {
          has: d3_map_has,
          get: function(key) {
            return this._[d3_map_escape(key)];
          },
          set: function(key, value) {
            return this._[d3_map_escape(key)] = value;
          },
          remove: d3_map_remove,
          keys: d3_map_keys,
          values: function() {
            var values = [];
            for (var key in this._) values.push(this._[key]);
            return values;
          },
          entries: function() {
            var entries = [];
            for (var key in this._) entries.push({
              key: d3_map_unescape(key),
              value: this._[key]
            });
            return entries;
          },
          size: d3_map_size,
          empty: d3_map_empty,
          forEach: function(f5) {
            for (var key in this._) f5.call(this, d3_map_unescape(key), this._[key]);
          }
        });
        function d3_map_escape(key) {
          return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
        }
        function d3_map_unescape(key) {
          return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
        }
        function d3_map_has(key) {
          return d3_map_escape(key) in this._;
        }
        function d3_map_remove(key) {
          return (key = d3_map_escape(key)) in this._ && delete this._[key];
        }
        function d3_map_keys() {
          var keys = [];
          for (var key in this._) keys.push(d3_map_unescape(key));
          return keys;
        }
        function d3_map_size() {
          var size = 0;
          for (var key in this._) ++size;
          return size;
        }
        function d3_map_empty() {
          for (var key in this._) return false;
          return true;
        }
        d33.nest = function() {
          var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
          function map3(mapType, array, depth) {
            if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i5 = -1, n2 = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i5 < n2) {
              if (values = valuesByKey.get(keyValue = key(object = array[i5]))) {
                values.push(object);
              } else {
                valuesByKey.set(keyValue, [object]);
              }
            }
            if (mapType) {
              object = mapType();
              setter = function(keyValue2, values2) {
                object.set(keyValue2, map3(mapType, values2, depth));
              };
            } else {
              object = {};
              setter = function(keyValue2, values2) {
                object[keyValue2] = map3(mapType, values2, depth);
              };
            }
            valuesByKey.forEach(setter);
            return object;
          }
          function entries(map4, depth) {
            if (depth >= keys.length) return map4;
            var array = [], sortKey = sortKeys[depth++];
            map4.forEach(function(key, keyMap) {
              array.push({
                key,
                values: entries(keyMap, depth)
              });
            });
            return sortKey ? array.sort(function(a3, b2) {
              return sortKey(a3.key, b2.key);
            }) : array;
          }
          nest.map = function(array, mapType) {
            return map3(mapType, array, 0);
          };
          nest.entries = function(array) {
            return entries(map3(d33.map, array, 0), 0);
          };
          nest.key = function(d5) {
            keys.push(d5);
            return nest;
          };
          nest.sortKeys = function(order2) {
            sortKeys[keys.length - 1] = order2;
            return nest;
          };
          nest.sortValues = function(order2) {
            sortValues = order2;
            return nest;
          };
          nest.rollup = function(f5) {
            rollup = f5;
            return nest;
          };
          return nest;
        };
        d33.set = function(array) {
          var set2 = new d3_Set();
          if (array) for (var i5 = 0, n2 = array.length; i5 < n2; ++i5) set2.add(array[i5]);
          return set2;
        };
        function d3_Set() {
          this._ = /* @__PURE__ */ Object.create(null);
        }
        d3_class(d3_Set, {
          has: d3_map_has,
          add: function(key) {
            this._[d3_map_escape(key += "")] = true;
            return key;
          },
          remove: d3_map_remove,
          values: d3_map_keys,
          size: d3_map_size,
          empty: d3_map_empty,
          forEach: function(f5) {
            for (var key in this._) f5.call(this, d3_map_unescape(key));
          }
        });
        d33.behavior = {};
        function d3_identity(d5) {
          return d5;
        }
        d33.rebind = function(target, source) {
          var i5 = 1, n2 = arguments.length, method;
          while (++i5 < n2) target[method = arguments[i5]] = d3_rebind(target, source, source[method]);
          return target;
        };
        function d3_rebind(target, source, method) {
          return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
          };
        }
        function d3_vendorSymbol(object, name) {
          if (name in object) return name;
          name = name.charAt(0).toUpperCase() + name.slice(1);
          for (var i5 = 0, n2 = d3_vendorPrefixes.length; i5 < n2; ++i5) {
            var prefixName = d3_vendorPrefixes[i5] + name;
            if (prefixName in object) return prefixName;
          }
        }
        var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
        function d3_noop() {
        }
        d33.dispatch = function() {
          var dispatch = new d3_dispatch(), i5 = -1, n2 = arguments.length;
          while (++i5 < n2) dispatch[arguments[i5]] = d3_dispatch_event(dispatch);
          return dispatch;
        };
        function d3_dispatch() {
        }
        d3_dispatch.prototype.on = function(type, listener) {
          var i5 = type.indexOf("."), name = "";
          if (i5 >= 0) {
            name = type.slice(i5 + 1);
            type = type.slice(0, i5);
          }
          if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
          if (arguments.length === 2) {
            if (listener == null) for (type in this) {
              if (this.hasOwnProperty(type)) this[type].on(name, null);
            }
            return this;
          }
        };
        function d3_dispatch_event(dispatch) {
          var listeners = [], listenerByName = new d3_Map();
          function event() {
            var z2 = listeners, i5 = -1, n2 = z2.length, l6;
            while (++i5 < n2) if (l6 = z2[i5].on) l6.apply(this, arguments);
            return dispatch;
          }
          event.on = function(name, listener) {
            var l6 = listenerByName.get(name), i5;
            if (arguments.length < 2) return l6 && l6.on;
            if (l6) {
              l6.on = null;
              listeners = listeners.slice(0, i5 = listeners.indexOf(l6)).concat(listeners.slice(i5 + 1));
              listenerByName.remove(name);
            }
            if (listener) listeners.push(listenerByName.set(name, {
              on: listener
            }));
            return dispatch;
          };
          return event;
        }
        d33.event = null;
        function d3_eventPreventDefault() {
          d33.event.preventDefault();
        }
        function d3_eventSource() {
          var e3 = d33.event, s7;
          while (s7 = e3.sourceEvent) e3 = s7;
          return e3;
        }
        function d3_eventDispatch(target) {
          var dispatch = new d3_dispatch(), i5 = 0, n2 = arguments.length;
          while (++i5 < n2) dispatch[arguments[i5]] = d3_dispatch_event(dispatch);
          dispatch.of = function(thiz, argumentz) {
            return function(e1) {
              try {
                var e0 = e1.sourceEvent = d33.event;
                e1.target = target;
                d33.event = e1;
                dispatch[e1.type].apply(thiz, argumentz);
              } finally {
                d33.event = e0;
              }
            };
          };
          return dispatch;
        }
        d33.requote = function(s7) {
          return s7.replace(d3_requote_re, "\\$&");
        };
        var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
        var d3_subclass = {}.__proto__ ? function(object, prototype) {
          object.__proto__ = prototype;
        } : function(object, prototype) {
          for (var property in prototype) object[property] = prototype[property];
        };
        function d3_selection(groups) {
          d3_subclass(groups, d3_selectionPrototype);
          return groups;
        }
        var d3_select = function(s7, n2) {
          return n2.querySelector(s7);
        }, d3_selectAll = function(s7, n2) {
          return n2.querySelectorAll(s7);
        }, d3_selectMatches = function(n2, s7) {
          var d3_selectMatcher = n2.matches || n2[d3_vendorSymbol(n2, "matchesSelector")];
          d3_selectMatches = function(n3, s8) {
            return d3_selectMatcher.call(n3, s8);
          };
          return d3_selectMatches(n2, s7);
        };
        if (typeof Sizzle === "function") {
          d3_select = function(s7, n2) {
            return Sizzle(s7, n2)[0] || null;
          };
          d3_selectAll = Sizzle;
          d3_selectMatches = Sizzle.matchesSelector;
        }
        d33.selection = function() {
          return d33.select(d3_document.documentElement);
        };
        var d3_selectionPrototype = d33.selection.prototype = [];
        d3_selectionPrototype.select = function(selector) {
          var subgroups = [], subgroup, subnode, group, node;
          selector = d3_selection_selector(selector);
          for (var j2 = -1, m5 = this.length; ++j2 < m5; ) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j2]).parentNode;
            for (var i5 = -1, n2 = group.length; ++i5 < n2; ) {
              if (node = group[i5]) {
                subgroup.push(subnode = selector.call(node, node.__data__, i5, j2));
                if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
              } else {
                subgroup.push(null);
              }
            }
          }
          return d3_selection(subgroups);
        };
        function d3_selection_selector(selector) {
          return typeof selector === "function" ? selector : function() {
            return d3_select(selector, this);
          };
        }
        d3_selectionPrototype.selectAll = function(selector) {
          var subgroups = [], subgroup, node;
          selector = d3_selection_selectorAll(selector);
          for (var j2 = -1, m5 = this.length; ++j2 < m5; ) {
            for (var group = this[j2], i5 = -1, n2 = group.length; ++i5 < n2; ) {
              if (node = group[i5]) {
                subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i5, j2)));
                subgroup.parentNode = node;
              }
            }
          }
          return d3_selection(subgroups);
        };
        function d3_selection_selectorAll(selector) {
          return typeof selector === "function" ? selector : function() {
            return d3_selectAll(selector, this);
          };
        }
        var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
        var d3_nsPrefix = {
          svg: "http://www.w3.org/2000/svg",
          xhtml: d3_nsXhtml,
          xlink: "http://www.w3.org/1999/xlink",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/"
        };
        d33.ns = {
          prefix: d3_nsPrefix,
          qualify: function(name) {
            var i5 = name.indexOf(":"), prefix2 = name;
            if (i5 >= 0 && (prefix2 = name.slice(0, i5)) !== "xmlns") name = name.slice(i5 + 1);
            return d3_nsPrefix.hasOwnProperty(prefix2) ? {
              space: d3_nsPrefix[prefix2],
              local: name
            } : name;
          }
        };
        d3_selectionPrototype.attr = function(name, value) {
          if (arguments.length < 2) {
            if (typeof name === "string") {
              var node = this.node();
              name = d33.ns.qualify(name);
              return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name) this.each(d3_selection_attr(value, name[value]));
            return this;
          }
          return this.each(d3_selection_attr(name, value));
        };
        function d3_selection_attr(name, value) {
          name = d33.ns.qualify(name);
          function attrNull() {
            this.removeAttribute(name);
          }
          function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
          }
          function attrConstant() {
            this.setAttribute(name, value);
          }
          function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
          }
          function attrFunction() {
            var x3 = value.apply(this, arguments);
            if (x3 == null) this.removeAttribute(name);
            else this.setAttribute(name, x3);
          }
          function attrFunctionNS() {
            var x3 = value.apply(this, arguments);
            if (x3 == null) this.removeAttributeNS(name.space, name.local);
            else this.setAttributeNS(name.space, name.local, x3);
          }
          return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
        }
        function d3_collapse(s7) {
          return s7.trim().replace(/\s+/g, " ");
        }
        d3_selectionPrototype.classed = function(name, value) {
          if (arguments.length < 2) {
            if (typeof name === "string") {
              var node = this.node(), n2 = (name = d3_selection_classes(name)).length, i5 = -1;
              if (value = node.classList) {
                while (++i5 < n2) if (!value.contains(name[i5])) return false;
              } else {
                value = node.getAttribute("class");
                while (++i5 < n2) if (!d3_selection_classedRe(name[i5]).test(value)) return false;
              }
              return true;
            }
            for (value in name) this.each(d3_selection_classed(value, name[value]));
            return this;
          }
          return this.each(d3_selection_classed(name, value));
        };
        function d3_selection_classedRe(name) {
          return new RegExp("(?:^|\\s+)" + d33.requote(name) + "(?:\\s+|$)", "g");
        }
        function d3_selection_classes(name) {
          return (name + "").trim().split(/^|\s+/);
        }
        function d3_selection_classed(name, value) {
          name = d3_selection_classes(name).map(d3_selection_classedName);
          var n2 = name.length;
          function classedConstant() {
            var i5 = -1;
            while (++i5 < n2) name[i5](this, value);
          }
          function classedFunction() {
            var i5 = -1, x3 = value.apply(this, arguments);
            while (++i5 < n2) name[i5](this, x3);
          }
          return typeof value === "function" ? classedFunction : classedConstant;
        }
        function d3_selection_classedName(name) {
          var re2 = d3_selection_classedRe(name);
          return function(node, value) {
            if (c3 = node.classList) return value ? c3.add(name) : c3.remove(name);
            var c3 = node.getAttribute("class") || "";
            if (value) {
              re2.lastIndex = 0;
              if (!re2.test(c3)) node.setAttribute("class", d3_collapse(c3 + " " + name));
            } else {
              node.setAttribute("class", d3_collapse(c3.replace(re2, " ")));
            }
          };
        }
        d3_selectionPrototype.style = function(name, value, priority) {
          var n2 = arguments.length;
          if (n2 < 3) {
            if (typeof name !== "string") {
              if (n2 < 2) value = "";
              for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
              return this;
            }
            if (n2 < 2) {
              var node = this.node();
              return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
            }
            priority = "";
          }
          return this.each(d3_selection_style(name, value, priority));
        };
        function d3_selection_style(name, value, priority) {
          function styleNull() {
            this.style.removeProperty(name);
          }
          function styleConstant() {
            this.style.setProperty(name, value, priority);
          }
          function styleFunction() {
            var x3 = value.apply(this, arguments);
            if (x3 == null) this.style.removeProperty(name);
            else this.style.setProperty(name, x3, priority);
          }
          return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
        }
        d3_selectionPrototype.property = function(name, value) {
          if (arguments.length < 2) {
            if (typeof name === "string") return this.node()[name];
            for (value in name) this.each(d3_selection_property(value, name[value]));
            return this;
          }
          return this.each(d3_selection_property(name, value));
        };
        function d3_selection_property(name, value) {
          function propertyNull() {
            delete this[name];
          }
          function propertyConstant() {
            this[name] = value;
          }
          function propertyFunction() {
            var x3 = value.apply(this, arguments);
            if (x3 == null) delete this[name];
            else this[name] = x3;
          }
          return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
        }
        d3_selectionPrototype.text = function(value) {
          return arguments.length ? this.each(typeof value === "function" ? function() {
            var v3 = value.apply(this, arguments);
            this.textContent = v3 == null ? "" : v3;
          } : value == null ? function() {
            this.textContent = "";
          } : function() {
            this.textContent = value;
          }) : this.node().textContent;
        };
        d3_selectionPrototype.html = function(value) {
          return arguments.length ? this.each(typeof value === "function" ? function() {
            var v3 = value.apply(this, arguments);
            this.innerHTML = v3 == null ? "" : v3;
          } : value == null ? function() {
            this.innerHTML = "";
          } : function() {
            this.innerHTML = value;
          }) : this.node().innerHTML;
        };
        d3_selectionPrototype.append = function(name) {
          name = d3_selection_creator(name);
          return this.select(function() {
            return this.appendChild(name.apply(this, arguments));
          });
        };
        function d3_selection_creator(name) {
          function create() {
            var document2 = this.ownerDocument, namespace = this.namespaceURI;
            return namespace === d3_nsXhtml && document2.documentElement.namespaceURI === d3_nsXhtml ? document2.createElement(name) : document2.createElementNS(namespace, name);
          }
          function createNS() {
            return this.ownerDocument.createElementNS(name.space, name.local);
          }
          return typeof name === "function" ? name : (name = d33.ns.qualify(name)).local ? createNS : create;
        }
        d3_selectionPrototype.insert = function(name, before) {
          name = d3_selection_creator(name);
          before = d3_selection_selector(before);
          return this.select(function() {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
          });
        };
        d3_selectionPrototype.remove = function() {
          return this.each(d3_selectionRemove);
        };
        function d3_selectionRemove() {
          var parent = this.parentNode;
          if (parent) parent.removeChild(this);
        }
        d3_selectionPrototype.data = function(value, key) {
          var i5 = -1, n2 = this.length, group, node;
          if (!arguments.length) {
            value = new Array(n2 = (group = this[0]).length);
            while (++i5 < n2) {
              if (node = group[i5]) {
                value[i5] = node.__data__;
              }
            }
            return value;
          }
          function bind(group2, groupData) {
            var i6, n3 = group2.length, m5 = groupData.length, n0 = Math.min(n3, m5), updateNodes = new Array(m5), enterNodes = new Array(m5), exitNodes = new Array(n3), node2, nodeData;
            if (key) {
              var nodeByKeyValue = new d3_Map(), keyValues = new Array(n3), keyValue;
              for (i6 = -1; ++i6 < n3; ) {
                if (node2 = group2[i6]) {
                  if (nodeByKeyValue.has(keyValue = key.call(node2, node2.__data__, i6))) {
                    exitNodes[i6] = node2;
                  } else {
                    nodeByKeyValue.set(keyValue, node2);
                  }
                  keyValues[i6] = keyValue;
                }
              }
              for (i6 = -1; ++i6 < m5; ) {
                if (!(node2 = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i6], i6)))) {
                  enterNodes[i6] = d3_selection_dataNode(nodeData);
                } else if (node2 !== true) {
                  updateNodes[i6] = node2;
                  node2.__data__ = nodeData;
                }
                nodeByKeyValue.set(keyValue, true);
              }
              for (i6 = -1; ++i6 < n3; ) {
                if (i6 in keyValues && nodeByKeyValue.get(keyValues[i6]) !== true) {
                  exitNodes[i6] = group2[i6];
                }
              }
            } else {
              for (i6 = -1; ++i6 < n0; ) {
                node2 = group2[i6];
                nodeData = groupData[i6];
                if (node2) {
                  node2.__data__ = nodeData;
                  updateNodes[i6] = node2;
                } else {
                  enterNodes[i6] = d3_selection_dataNode(nodeData);
                }
              }
              for (; i6 < m5; ++i6) {
                enterNodes[i6] = d3_selection_dataNode(groupData[i6]);
              }
              for (; i6 < n3; ++i6) {
                exitNodes[i6] = group2[i6];
              }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group2.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
          }
          var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
          if (typeof value === "function") {
            while (++i5 < n2) {
              bind(group = this[i5], value.call(group, group.parentNode.__data__, i5));
            }
          } else {
            while (++i5 < n2) {
              bind(group = this[i5], value);
            }
          }
          update.enter = function() {
            return enter;
          };
          update.exit = function() {
            return exit;
          };
          return update;
        };
        function d3_selection_dataNode(data) {
          return {
            __data__: data
          };
        }
        d3_selectionPrototype.datum = function(value) {
          return arguments.length ? this.property("__data__", value) : this.property("__data__");
        };
        d3_selectionPrototype.filter = function(filter) {
          var subgroups = [], subgroup, group, node;
          if (typeof filter !== "function") filter = d3_selection_filter(filter);
          for (var j2 = 0, m5 = this.length; j2 < m5; j2++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j2]).parentNode;
            for (var i5 = 0, n2 = group.length; i5 < n2; i5++) {
              if ((node = group[i5]) && filter.call(node, node.__data__, i5, j2)) {
                subgroup.push(node);
              }
            }
          }
          return d3_selection(subgroups);
        };
        function d3_selection_filter(selector) {
          return function() {
            return d3_selectMatches(this, selector);
          };
        }
        d3_selectionPrototype.order = function() {
          for (var j2 = -1, m5 = this.length; ++j2 < m5; ) {
            for (var group = this[j2], i5 = group.length - 1, next = group[i5], node; --i5 >= 0; ) {
              if (node = group[i5]) {
                if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
                next = node;
              }
            }
          }
          return this;
        };
        d3_selectionPrototype.sort = function(comparator) {
          comparator = d3_selection_sortComparator.apply(this, arguments);
          for (var j2 = -1, m5 = this.length; ++j2 < m5; ) this[j2].sort(comparator);
          return this.order();
        };
        function d3_selection_sortComparator(comparator) {
          if (!arguments.length) comparator = d3_ascending;
          return function(a3, b2) {
            return a3 && b2 ? comparator(a3.__data__, b2.__data__) : !a3 - !b2;
          };
        }
        d3_selectionPrototype.each = function(callback2) {
          return d3_selection_each(this, function(node, i5, j2) {
            callback2.call(node, node.__data__, i5, j2);
          });
        };
        function d3_selection_each(groups, callback2) {
          for (var j2 = 0, m5 = groups.length; j2 < m5; j2++) {
            for (var group = groups[j2], i5 = 0, n2 = group.length, node; i5 < n2; i5++) {
              if (node = group[i5]) callback2(node, i5, j2);
            }
          }
          return groups;
        }
        d3_selectionPrototype.call = function(callback2) {
          var args = d3_array(arguments);
          callback2.apply(args[0] = this, args);
          return this;
        };
        d3_selectionPrototype.empty = function() {
          return !this.node();
        };
        d3_selectionPrototype.node = function() {
          for (var j2 = 0, m5 = this.length; j2 < m5; j2++) {
            for (var group = this[j2], i5 = 0, n2 = group.length; i5 < n2; i5++) {
              var node = group[i5];
              if (node) return node;
            }
          }
          return null;
        };
        d3_selectionPrototype.size = function() {
          var n2 = 0;
          d3_selection_each(this, function() {
            ++n2;
          });
          return n2;
        };
        function d3_selection_enter(selection) {
          d3_subclass(selection, d3_selection_enterPrototype);
          return selection;
        }
        var d3_selection_enterPrototype = [];
        d33.selection.enter = d3_selection_enter;
        d33.selection.enter.prototype = d3_selection_enterPrototype;
        d3_selection_enterPrototype.append = d3_selectionPrototype.append;
        d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
        d3_selection_enterPrototype.node = d3_selectionPrototype.node;
        d3_selection_enterPrototype.call = d3_selectionPrototype.call;
        d3_selection_enterPrototype.size = d3_selectionPrototype.size;
        d3_selection_enterPrototype.select = function(selector) {
          var subgroups = [], subgroup, subnode, upgroup, group, node;
          for (var j2 = -1, m5 = this.length; ++j2 < m5; ) {
            upgroup = (group = this[j2]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i5 = -1, n2 = group.length; ++i5 < n2; ) {
              if (node = group[i5]) {
                subgroup.push(upgroup[i5] = subnode = selector.call(group.parentNode, node.__data__, i5, j2));
                subnode.__data__ = node.__data__;
              } else {
                subgroup.push(null);
              }
            }
          }
          return d3_selection(subgroups);
        };
        d3_selection_enterPrototype.insert = function(name, before) {
          if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
          return d3_selectionPrototype.insert.call(this, name, before);
        };
        function d3_selection_enterInsertBefore(enter) {
          var i0, j0;
          return function(d5, i5, j2) {
            var group = enter[j2].update, n2 = group.length, node;
            if (j2 != j0) j0 = j2, i0 = 0;
            if (i5 >= i0) i0 = i5 + 1;
            while (!(node = group[i0]) && ++i0 < n2) ;
            return node;
          };
        }
        d33.select = function(node) {
          var group;
          if (typeof node === "string") {
            group = [d3_select(node, d3_document)];
            group.parentNode = d3_document.documentElement;
          } else {
            group = [node];
            group.parentNode = d3_documentElement(node);
          }
          return d3_selection([group]);
        };
        d33.selectAll = function(nodes) {
          var group;
          if (typeof nodes === "string") {
            group = d3_array(d3_selectAll(nodes, d3_document));
            group.parentNode = d3_document.documentElement;
          } else {
            group = d3_array(nodes);
            group.parentNode = null;
          }
          return d3_selection([group]);
        };
        d3_selectionPrototype.on = function(type, listener, capture) {
          var n2 = arguments.length;
          if (n2 < 3) {
            if (typeof type !== "string") {
              if (n2 < 2) listener = false;
              for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
              return this;
            }
            if (n2 < 2) return (n2 = this.node()["__on" + type]) && n2._;
            capture = false;
          }
          return this.each(d3_selection_on(type, listener, capture));
        };
        function d3_selection_on(type, listener, capture) {
          var name = "__on" + type, i5 = type.indexOf("."), wrap = d3_selection_onListener;
          if (i5 > 0) type = type.slice(0, i5);
          var filter = d3_selection_onFilters.get(type);
          if (filter) type = filter, wrap = d3_selection_onFilter;
          function onRemove() {
            var l6 = this[name];
            if (l6) {
              this.removeEventListener(type, l6, l6.$);
              delete this[name];
            }
          }
          function onAdd() {
            var l6 = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l6, l6.$ = capture);
            l6._ = listener;
          }
          function removeAll() {
            var re2 = new RegExp("^__on([^.]+)" + d33.requote(type) + "$"), match;
            for (var name2 in this) {
              if (match = name2.match(re2)) {
                var l6 = this[name2];
                this.removeEventListener(match[1], l6, l6.$);
                delete this[name2];
              }
            }
          }
          return i5 ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
        }
        var d3_selection_onFilters = d33.map({
          mouseenter: "mouseover",
          mouseleave: "mouseout"
        });
        if (d3_document) {
          d3_selection_onFilters.forEach(function(k) {
            if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
          });
        }
        function d3_selection_onListener(listener, argumentz) {
          return function(e3) {
            var o10 = d33.event;
            d33.event = e3;
            argumentz[0] = this.__data__;
            try {
              listener.apply(this, argumentz);
            } finally {
              d33.event = o10;
            }
          };
        }
        function d3_selection_onFilter(listener, argumentz) {
          var l6 = d3_selection_onListener(listener, argumentz);
          return function(e3) {
            var target = this, related = e3.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
              l6.call(target, e3);
            }
          };
        }
        var d3_event_dragSelect, d3_event_dragId = 0;
        function d3_event_dragSuppress(node) {
          var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w3 = d33.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
          if (d3_event_dragSelect == null) {
            d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
          }
          if (d3_event_dragSelect) {
            var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = "none";
          }
          return function(suppressClick) {
            w3.on(name, null);
            if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
            if (suppressClick) {
              var off = function() {
                w3.on(click, null);
              };
              w3.on(click, function() {
                d3_eventPreventDefault();
                off();
              }, true);
              setTimeout(off, 0);
            }
          };
        }
        d33.mouse = function(container2) {
          return d3_mousePoint(container2, d3_eventSource());
        };
        var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
        function d3_mousePoint(container2, e3) {
          if (e3.changedTouches) e3 = e3.changedTouches[0];
          var svg = container2.ownerSVGElement || container2;
          if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0) {
              var window2 = d3_window(container2);
              if (window2.scrollX || window2.scrollY) {
                svg = d33.select("body").append("svg").style({
                  position: "absolute",
                  top: 0,
                  left: 0,
                  margin: 0,
                  padding: 0,
                  border: "none"
                }, "important");
                var ctm = svg[0][0].getScreenCTM();
                d3_mouse_bug44083 = !(ctm.f || ctm.e);
                svg.remove();
              }
            }
            if (d3_mouse_bug44083) point.x = e3.pageX, point.y = e3.pageY;
            else point.x = e3.clientX, point.y = e3.clientY;
            point = point.matrixTransform(container2.getScreenCTM().inverse());
            return [point.x, point.y];
          }
          var rect = container2.getBoundingClientRect();
          return [e3.clientX - rect.left - container2.clientLeft, e3.clientY - rect.top - container2.clientTop];
        }
        d33.touch = function(container2, touches, identifier) {
          if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
          if (touches) for (var i5 = 0, n2 = touches.length, touch; i5 < n2; ++i5) {
            if ((touch = touches[i5]).identifier === identifier) {
              return d3_mousePoint(container2, touch);
            }
          }
        };
        d33.behavior.drag = function() {
          var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d33.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d33.touch, d3_identity, "touchmove", "touchend");
          function drag() {
            this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
          }
          function dragstart(id, position, subject, move, end2) {
            return function() {
              var that = this, target = d33.event.target.correspondingElement || d33.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d33.select(subject(target)).on(move + dragName, moved).on(end2 + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
              if (origin) {
                dragOffset = origin.apply(that, arguments);
                dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];
              } else {
                dragOffset = [0, 0];
              }
              dispatch({
                type: "dragstart"
              });
              function moved() {
                var position1 = position(parent, dragId), dx, dy;
                if (!position1) return;
                dx = position1[0] - position0[0];
                dy = position1[1] - position0[1];
                dragged |= dx | dy;
                position0 = position1;
                dispatch({
                  type: "drag",
                  x: position1[0] + dragOffset[0],
                  y: position1[1] + dragOffset[1],
                  dx,
                  dy
                });
              }
              function ended() {
                if (!position(parent, dragId)) return;
                dragSubject.on(move + dragName, null).on(end2 + dragName, null);
                dragRestore(dragged);
                dispatch({
                  type: "dragend"
                });
              }
            };
          }
          drag.origin = function(x3) {
            if (!arguments.length) return origin;
            origin = x3;
            return drag;
          };
          return d33.rebind(drag, event, "on");
        };
        function d3_behavior_dragTouchId() {
          return d33.event.changedTouches[0].identifier;
        }
        d33.touches = function(container2, touches) {
          if (arguments.length < 2) touches = d3_eventSource().touches;
          return touches ? d3_array(touches).map(function(touch) {
            var point = d3_mousePoint(container2, touch);
            point.identifier = touch.identifier;
            return point;
          }) : [];
        };
        var \u03B5 = 1e-6, \u03B52 = \u03B5 * \u03B5, \u03C0 = Math.PI, \u03C4 = 2 * \u03C0, \u03C4\u03B5 = \u03C4 - \u03B5, half\u03C0 = \u03C0 / 2, d3_radians = \u03C0 / 180, d3_degrees = 180 / \u03C0;
        function d3_sgn(x3) {
          return x3 > 0 ? 1 : x3 < 0 ? -1 : 0;
        }
        function d3_cross2d(a3, b2, c3) {
          return (b2[0] - a3[0]) * (c3[1] - a3[1]) - (b2[1] - a3[1]) * (c3[0] - a3[0]);
        }
        function d3_acos(x3) {
          return x3 > 1 ? 0 : x3 < -1 ? \u03C0 : Math.acos(x3);
        }
        function d3_asin(x3) {
          return x3 > 1 ? half\u03C0 : x3 < -1 ? -half\u03C0 : Math.asin(x3);
        }
        function d3_sinh(x3) {
          return ((x3 = Math.exp(x3)) - 1 / x3) / 2;
        }
        function d3_cosh(x3) {
          return ((x3 = Math.exp(x3)) + 1 / x3) / 2;
        }
        function d3_tanh(x3) {
          return ((x3 = Math.exp(2 * x3)) - 1) / (x3 + 1);
        }
        function d3_haversin(x3) {
          return (x3 = Math.sin(x3 / 2)) * x3;
        }
        var \u03C1 = Math.SQRT2, \u03C12 = 2, \u03C14 = 4;
        d33.interpolateZoom = function(p0, p1) {
          var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d22 = dx * dx + dy * dy, i5, S2;
          if (d22 < \u03B52) {
            S2 = Math.log(w1 / w0) / \u03C1;
            i5 = function(t7) {
              return [ux0 + t7 * dx, uy0 + t7 * dy, w0 * Math.exp(\u03C1 * t7 * S2)];
            };
          } else {
            var d1 = Math.sqrt(d22), b0 = (w1 * w1 - w0 * w0 + \u03C14 * d22) / (2 * w0 * \u03C12 * d1), b1 = (w1 * w1 - w0 * w0 - \u03C14 * d22) / (2 * w1 * \u03C12 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S2 = (r1 - r0) / \u03C1;
            i5 = function(t7) {
              var s7 = t7 * S2, coshr0 = d3_cosh(r0), u4 = w0 / (\u03C12 * d1) * (coshr0 * d3_tanh(\u03C1 * s7 + r0) - d3_sinh(r0));
              return [ux0 + u4 * dx, uy0 + u4 * dy, w0 * coshr0 / d3_cosh(\u03C1 * s7 + r0)];
            };
          }
          i5.duration = S2 * 1e3;
          return i5;
        };
        d33.behavior.zoom = function() {
          var view = {
            x: 0,
            y: 0,
            k: 1
          }, translate0, center0, center, size = [960, 500], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
          if (!d3_behavior_zoomWheel) {
            d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
              return -d33.event.deltaY * (d33.event.deltaMode ? 120 : 1);
            }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
              return d33.event.wheelDelta;
            }, "mousewheel") : (d3_behavior_zoomDelta = function() {
              return -d33.event.detail;
            }, "MozMousePixelScroll");
          }
          function zoom(g3) {
            g3.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
          }
          zoom.event = function(g3) {
            g3.each(function() {
              var dispatch = event.of(this, arguments), view1 = view;
              if (d3_transitionInheritId) {
                d33.select(this).transition().each("start.zoom", function() {
                  view = this.__chart__ || {
                    x: 0,
                    y: 0,
                    k: 1
                  };
                  zoomstarted(dispatch);
                }).tween("zoom:zoom", function() {
                  var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i5 = d33.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                  return function(t7) {
                    var l6 = i5(t7), k = dx / l6[2];
                    this.__chart__ = view = {
                      x: cx - l6[0] * k,
                      y: cy - l6[1] * k,
                      k
                    };
                    zoomed(dispatch);
                  };
                }).each("interrupt.zoom", function() {
                  zoomended(dispatch);
                }).each("end.zoom", function() {
                  zoomended(dispatch);
                });
              } else {
                this.__chart__ = view;
                zoomstarted(dispatch);
                zoomed(dispatch);
                zoomended(dispatch);
              }
            });
          };
          zoom.translate = function(_2) {
            if (!arguments.length) return [view.x, view.y];
            view = {
              x: +_2[0],
              y: +_2[1],
              k: view.k
            };
            rescale();
            return zoom;
          };
          zoom.scale = function(_2) {
            if (!arguments.length) return view.k;
            view = {
              x: view.x,
              y: view.y,
              k: null
            };
            scaleTo(+_2);
            rescale();
            return zoom;
          };
          zoom.scaleExtent = function(_2) {
            if (!arguments.length) return scaleExtent;
            scaleExtent = _2 == null ? d3_behavior_zoomInfinity : [+_2[0], +_2[1]];
            return zoom;
          };
          zoom.center = function(_2) {
            if (!arguments.length) return center;
            center = _2 && [+_2[0], +_2[1]];
            return zoom;
          };
          zoom.size = function(_2) {
            if (!arguments.length) return size;
            size = _2 && [+_2[0], +_2[1]];
            return zoom;
          };
          zoom.duration = function(_2) {
            if (!arguments.length) return duration;
            duration = +_2;
            return zoom;
          };
          zoom.x = function(z2) {
            if (!arguments.length) return x1;
            x1 = z2;
            x0 = z2.copy();
            view = {
              x: 0,
              y: 0,
              k: 1
            };
            return zoom;
          };
          zoom.y = function(z2) {
            if (!arguments.length) return y1;
            y1 = z2;
            y0 = z2.copy();
            view = {
              x: 0,
              y: 0,
              k: 1
            };
            return zoom;
          };
          function location(p3) {
            return [(p3[0] - view.x) / view.k, (p3[1] - view.y) / view.k];
          }
          function point(l6) {
            return [l6[0] * view.k + view.x, l6[1] * view.k + view.y];
          }
          function scaleTo(s7) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s7));
          }
          function translateTo(p3, l6) {
            l6 = point(l6);
            view.x += p3[0] - l6[0];
            view.y += p3[1] - l6[1];
          }
          function zoomTo(that, p3, l6, k) {
            that.__chart__ = {
              x: view.x,
              y: view.y,
              k: view.k
            };
            scaleTo(Math.pow(2, k));
            translateTo(center0 = p3, l6);
            that = d33.select(that);
            if (duration > 0) that = that.transition().duration(duration);
            that.call(zoom.event);
          }
          function rescale() {
            if (x1) x1.domain(x0.range().map(function(x3) {
              return (x3 - view.x) / view.k;
            }).map(x0.invert));
            if (y1) y1.domain(y0.range().map(function(y2) {
              return (y2 - view.y) / view.k;
            }).map(y0.invert));
          }
          function zoomstarted(dispatch) {
            if (!zooming++) dispatch({
              type: "zoomstart"
            });
          }
          function zoomed(dispatch) {
            rescale();
            dispatch({
              type: "zoom",
              scale: view.k,
              translate: [view.x, view.y]
            });
          }
          function zoomended(dispatch) {
            if (!--zooming) dispatch({
              type: "zoomend"
            }), center0 = null;
          }
          function mousedowned() {
            var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d33.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d33.mouse(that)), dragRestore = d3_event_dragSuppress(that);
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
              dragged = 1;
              translateTo(d33.mouse(that), location0);
              zoomed(dispatch);
            }
            function ended() {
              subject.on(mousemove, null).on(mouseup, null);
              dragRestore(dragged);
              zoomended(dispatch);
            }
          }
          function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d33.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d33.select(that), dragRestore = d3_event_dragSuppress(that);
            started();
            zoomstarted(dispatch);
            subject.on(mousedown, null).on(touchstart, started);
            function relocate() {
              var touches = d33.touches(that);
              scale0 = view.k;
              touches.forEach(function(t7) {
                if (t7.identifier in locations0) locations0[t7.identifier] = location(t7);
              });
              return touches;
            }
            function started() {
              var target = d33.event.target;
              d33.select(target).on(touchmove, moved).on(touchend, ended);
              targets.push(target);
              var changed = d33.event.changedTouches;
              for (var i5 = 0, n2 = changed.length; i5 < n2; ++i5) {
                locations0[changed[i5].identifier] = null;
              }
              var touches = relocate(), now = Date.now();
              if (touches.length === 1) {
                if (now - touchtime < 500) {
                  var p3 = touches[0];
                  zoomTo(that, p3, locations0[p3.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                  d3_eventPreventDefault();
                }
                touchtime = now;
              } else if (touches.length > 1) {
                var p3 = touches[0], q3 = touches[1], dx = p3[0] - q3[0], dy = p3[1] - q3[1];
                distance0 = dx * dx + dy * dy;
              }
            }
            function moved() {
              var touches = d33.touches(that), p0, l0, p1, l1;
              d3_selection_interrupt.call(that);
              for (var i5 = 0, n2 = touches.length; i5 < n2; ++i5, l1 = null) {
                p1 = touches[i5];
                if (l1 = locations0[p1.identifier]) {
                  if (l0) break;
                  p0 = p1, l0 = l1;
                }
              }
              if (l1) {
                var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
                l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
                scaleTo(scale1 * scale0);
              }
              touchtime = null;
              translateTo(p0, l0);
              zoomed(dispatch);
            }
            function ended() {
              if (d33.event.touches.length) {
                var changed = d33.event.changedTouches;
                for (var i5 = 0, n2 = changed.length; i5 < n2; ++i5) {
                  delete locations0[changed[i5].identifier];
                }
                for (var identifier in locations0) {
                  return void relocate();
                }
              }
              d33.selectAll(targets).on(zoomName, null);
              subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
              dragRestore();
              zoomended(dispatch);
            }
          }
          function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer) clearTimeout(mousewheelTimer);
            else d3_selection_interrupt.call(this), translate0 = location(center0 = center || d33.mouse(this)), zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function() {
              mousewheelTimer = null;
              zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * 2e-3) * view.k);
            translateTo(center0, translate0);
            zoomed(dispatch);
          }
          function dblclicked() {
            var p3 = d33.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p3, location(p3), d33.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
          }
          return d33.rebind(zoom, event, "on");
        };
        var d3_behavior_zoomInfinity = [0, Infinity], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
        d33.color = d3_color;
        function d3_color() {
        }
        d3_color.prototype.toString = function() {
          return this.rgb() + "";
        };
        d33.hsl = d3_hsl;
        function d3_hsl(h3, s7, l6) {
          return this instanceof d3_hsl ? void (this.h = +h3, this.s = +s7, this.l = +l6) : arguments.length < 2 ? h3 instanceof d3_hsl ? new d3_hsl(h3.h, h3.s, h3.l) : d3_rgb_parse("" + h3, d3_rgb_hsl, d3_hsl) : new d3_hsl(h3, s7, l6);
        }
        var d3_hslPrototype = d3_hsl.prototype = new d3_color();
        d3_hslPrototype.brighter = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          return new d3_hsl(this.h, this.s, this.l / k);
        };
        d3_hslPrototype.darker = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          return new d3_hsl(this.h, this.s, k * this.l);
        };
        d3_hslPrototype.rgb = function() {
          return d3_hsl_rgb(this.h, this.s, this.l);
        };
        function d3_hsl_rgb(h3, s7, l6) {
          var m1, m22;
          h3 = isNaN(h3) ? 0 : (h3 %= 360) < 0 ? h3 + 360 : h3;
          s7 = isNaN(s7) ? 0 : s7 < 0 ? 0 : s7 > 1 ? 1 : s7;
          l6 = l6 < 0 ? 0 : l6 > 1 ? 1 : l6;
          m22 = l6 <= 0.5 ? l6 * (1 + s7) : l6 + s7 - l6 * s7;
          m1 = 2 * l6 - m22;
          function v3(h4) {
            if (h4 > 360) h4 -= 360;
            else if (h4 < 0) h4 += 360;
            if (h4 < 60) return m1 + (m22 - m1) * h4 / 60;
            if (h4 < 180) return m22;
            if (h4 < 240) return m1 + (m22 - m1) * (240 - h4) / 60;
            return m1;
          }
          function vv(h4) {
            return Math.round(v3(h4) * 255);
          }
          return new d3_rgb(vv(h3 + 120), vv(h3), vv(h3 - 120));
        }
        d33.hcl = d3_hcl;
        function d3_hcl(h3, c3, l6) {
          return this instanceof d3_hcl ? void (this.h = +h3, this.c = +c3, this.l = +l6) : arguments.length < 2 ? h3 instanceof d3_hcl ? new d3_hcl(h3.h, h3.c, h3.l) : h3 instanceof d3_lab ? d3_lab_hcl(h3.l, h3.a, h3.b) : d3_lab_hcl((h3 = d3_rgb_lab((h3 = d33.rgb(h3)).r, h3.g, h3.b)).l, h3.a, h3.b) : new d3_hcl(h3, c3, l6);
        }
        var d3_hclPrototype = d3_hcl.prototype = new d3_color();
        d3_hclPrototype.brighter = function(k) {
          return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
        };
        d3_hclPrototype.darker = function(k) {
          return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
        };
        d3_hclPrototype.rgb = function() {
          return d3_hcl_lab(this.h, this.c, this.l).rgb();
        };
        function d3_hcl_lab(h3, c3, l6) {
          if (isNaN(h3)) h3 = 0;
          if (isNaN(c3)) c3 = 0;
          return new d3_lab(l6, Math.cos(h3 *= d3_radians) * c3, Math.sin(h3) * c3);
        }
        d33.lab = d3_lab;
        function d3_lab(l6, a3, b2) {
          return this instanceof d3_lab ? void (this.l = +l6, this.a = +a3, this.b = +b2) : arguments.length < 2 ? l6 instanceof d3_lab ? new d3_lab(l6.l, l6.a, l6.b) : l6 instanceof d3_hcl ? d3_hcl_lab(l6.h, l6.c, l6.l) : d3_rgb_lab((l6 = d3_rgb(l6)).r, l6.g, l6.b) : new d3_lab(l6, a3, b2);
        }
        var d3_lab_K = 18;
        var d3_lab_X = 0.95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
        var d3_labPrototype = d3_lab.prototype = new d3_color();
        d3_labPrototype.brighter = function(k) {
          return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
        };
        d3_labPrototype.darker = function(k) {
          return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
        };
        d3_labPrototype.rgb = function() {
          return d3_lab_rgb(this.l, this.a, this.b);
        };
        function d3_lab_rgb(l6, a3, b2) {
          var y2 = (l6 + 16) / 116, x3 = y2 + a3 / 500, z2 = y2 - b2 / 200;
          x3 = d3_lab_xyz(x3) * d3_lab_X;
          y2 = d3_lab_xyz(y2) * d3_lab_Y;
          z2 = d3_lab_xyz(z2) * d3_lab_Z;
          return new d3_rgb(d3_xyz_rgb(3.2404542 * x3 - 1.5371385 * y2 - 0.4985314 * z2), d3_xyz_rgb(-0.969266 * x3 + 1.8760108 * y2 + 0.041556 * z2), d3_xyz_rgb(0.0556434 * x3 - 0.2040259 * y2 + 1.0572252 * z2));
        }
        function d3_lab_hcl(l6, a3, b2) {
          return l6 > 0 ? new d3_hcl(Math.atan2(b2, a3) * d3_degrees, Math.sqrt(a3 * a3 + b2 * b2), l6) : new d3_hcl(NaN, NaN, l6);
        }
        function d3_lab_xyz(x3) {
          return x3 > 0.206893034 ? x3 * x3 * x3 : (x3 - 4 / 29) / 7.787037;
        }
        function d3_xyz_lab(x3) {
          return x3 > 8856e-6 ? Math.pow(x3, 1 / 3) : 7.787037 * x3 + 4 / 29;
        }
        function d3_xyz_rgb(r6) {
          return Math.round(255 * (r6 <= 304e-5 ? 12.92 * r6 : 1.055 * Math.pow(r6, 1 / 2.4) - 0.055));
        }
        d33.rgb = d3_rgb;
        function d3_rgb(r6, g3, b2) {
          return this instanceof d3_rgb ? void (this.r = ~~r6, this.g = ~~g3, this.b = ~~b2) : arguments.length < 2 ? r6 instanceof d3_rgb ? new d3_rgb(r6.r, r6.g, r6.b) : d3_rgb_parse("" + r6, d3_rgb, d3_hsl_rgb) : new d3_rgb(r6, g3, b2);
        }
        function d3_rgbNumber(value) {
          return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
        }
        function d3_rgbString(value) {
          return d3_rgbNumber(value) + "";
        }
        var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
        d3_rgbPrototype.brighter = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          var r6 = this.r, g3 = this.g, b2 = this.b, i5 = 30;
          if (!r6 && !g3 && !b2) return new d3_rgb(i5, i5, i5);
          if (r6 && r6 < i5) r6 = i5;
          if (g3 && g3 < i5) g3 = i5;
          if (b2 && b2 < i5) b2 = i5;
          return new d3_rgb(Math.min(255, r6 / k), Math.min(255, g3 / k), Math.min(255, b2 / k));
        };
        d3_rgbPrototype.darker = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          return new d3_rgb(k * this.r, k * this.g, k * this.b);
        };
        d3_rgbPrototype.hsl = function() {
          return d3_rgb_hsl(this.r, this.g, this.b);
        };
        d3_rgbPrototype.toString = function() {
          return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
        };
        function d3_rgb_hex(v3) {
          return v3 < 16 ? "0" + Math.max(0, v3).toString(16) : Math.min(255, v3).toString(16);
        }
        function d3_rgb_parse(format2, rgb, hsl) {
          var r6 = 0, g3 = 0, b2 = 0, m1, m22, color2;
          m1 = /([a-z]+)\((.*)\)/.exec(format2 = format2.toLowerCase());
          if (m1) {
            m22 = m1[2].split(",");
            switch (m1[1]) {
              case "hsl": {
                return hsl(parseFloat(m22[0]), parseFloat(m22[1]) / 100, parseFloat(m22[2]) / 100);
              }
              case "rgb": {
                return rgb(d3_rgb_parseNumber(m22[0]), d3_rgb_parseNumber(m22[1]), d3_rgb_parseNumber(m22[2]));
              }
            }
          }
          if (color2 = d3_rgb_names.get(format2)) {
            return rgb(color2.r, color2.g, color2.b);
          }
          if (format2 != null && format2.charAt(0) === "#" && !isNaN(color2 = parseInt(format2.slice(1), 16))) {
            if (format2.length === 4) {
              r6 = (color2 & 3840) >> 4;
              r6 = r6 >> 4 | r6;
              g3 = color2 & 240;
              g3 = g3 >> 4 | g3;
              b2 = color2 & 15;
              b2 = b2 << 4 | b2;
            } else if (format2.length === 7) {
              r6 = (color2 & 16711680) >> 16;
              g3 = (color2 & 65280) >> 8;
              b2 = color2 & 255;
            }
          }
          return rgb(r6, g3, b2);
        }
        function d3_rgb_hsl(r6, g3, b2) {
          var min2 = Math.min(r6 /= 255, g3 /= 255, b2 /= 255), max2 = Math.max(r6, g3, b2), d5 = max2 - min2, h3, s7, l6 = (max2 + min2) / 2;
          if (d5) {
            s7 = l6 < 0.5 ? d5 / (max2 + min2) : d5 / (2 - max2 - min2);
            if (r6 == max2) h3 = (g3 - b2) / d5 + (g3 < b2 ? 6 : 0);
            else if (g3 == max2) h3 = (b2 - r6) / d5 + 2;
            else h3 = (r6 - g3) / d5 + 4;
            h3 *= 60;
          } else {
            h3 = NaN;
            s7 = l6 > 0 && l6 < 1 ? 0 : h3;
          }
          return new d3_hsl(h3, s7, l6);
        }
        function d3_rgb_lab(r6, g3, b2) {
          r6 = d3_rgb_xyz(r6);
          g3 = d3_rgb_xyz(g3);
          b2 = d3_rgb_xyz(b2);
          var x3 = d3_xyz_lab((0.4124564 * r6 + 0.3575761 * g3 + 0.1804375 * b2) / d3_lab_X), y2 = d3_xyz_lab((0.2126729 * r6 + 0.7151522 * g3 + 0.072175 * b2) / d3_lab_Y), z2 = d3_xyz_lab((0.0193339 * r6 + 0.119192 * g3 + 0.9503041 * b2) / d3_lab_Z);
          return d3_lab(116 * y2 - 16, 500 * (x3 - y2), 200 * (y2 - z2));
        }
        function d3_rgb_xyz(r6) {
          return (r6 /= 255) <= 0.04045 ? r6 / 12.92 : Math.pow((r6 + 0.055) / 1.055, 2.4);
        }
        function d3_rgb_parseNumber(c3) {
          var f5 = parseFloat(c3);
          return c3.charAt(c3.length - 1) === "%" ? Math.round(f5 * 2.55) : f5;
        }
        var d3_rgb_names = d33.map({
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074
        });
        d3_rgb_names.forEach(function(key, value) {
          d3_rgb_names.set(key, d3_rgbNumber(value));
        });
        function d3_functor(v3) {
          return typeof v3 === "function" ? v3 : function() {
            return v3;
          };
        }
        d33.functor = d3_functor;
        d33.xhr = d3_xhrType(d3_identity);
        function d3_xhrType(response) {
          return function(url, mimeType, callback2) {
            if (arguments.length === 2 && typeof mimeType === "function") callback2 = mimeType, mimeType = null;
            return d3_xhr(url, mimeType, response, callback2);
          };
        }
        function d3_xhr(url, mimeType, response, callback2) {
          var xhr = {}, dispatch = d33.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
          if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
          "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
            request.readyState > 3 && respond();
          };
          function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
              try {
                result = response.call(xhr, request);
              } catch (e3) {
                dispatch.error.call(xhr, e3);
                return;
              }
              dispatch.load.call(xhr, result);
            } else {
              dispatch.error.call(xhr, request);
            }
          }
          request.onprogress = function(event) {
            var o10 = d33.event;
            d33.event = event;
            try {
              dispatch.progress.call(xhr, request);
            } finally {
              d33.event = o10;
            }
          };
          xhr.header = function(name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2) return headers[name];
            if (value == null) delete headers[name];
            else headers[name] = value + "";
            return xhr;
          };
          xhr.mimeType = function(value) {
            if (!arguments.length) return mimeType;
            mimeType = value == null ? null : value + "";
            return xhr;
          };
          xhr.responseType = function(value) {
            if (!arguments.length) return responseType;
            responseType = value;
            return xhr;
          };
          xhr.response = function(value) {
            response = value;
            return xhr;
          };
          ["get", "post"].forEach(function(method) {
            xhr[method] = function() {
              return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
            };
          });
          xhr.send = function(method, data, callback3) {
            if (arguments.length === 2 && typeof data === "function") callback3 = data, data = null;
            request.open(method, url, true);
            if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
            if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
            if (responseType != null) request.responseType = responseType;
            if (callback3 != null) xhr.on("error", callback3).on("load", function(request2) {
              callback3(null, request2);
            });
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
          };
          xhr.abort = function() {
            request.abort();
            return xhr;
          };
          d33.rebind(xhr, dispatch, "on");
          return callback2 == null ? xhr : xhr.get(d3_xhr_fixCallback(callback2));
        }
        function d3_xhr_fixCallback(callback2) {
          return callback2.length === 1 ? function(error, request) {
            callback2(error == null ? request : null);
          } : callback2;
        }
        function d3_xhrHasResponse(request) {
          var type = request.responseType;
          return type && type !== "text" ? request.response : request.responseText;
        }
        d33.dsv = function(delimiter, mimeType) {
          var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
          function dsv(url, row, callback2) {
            if (arguments.length < 3) callback2 = row, row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback2);
            xhr.row = function(_2) {
              return arguments.length ? xhr.response((row = _2) == null ? response : typedResponse(_2)) : row;
            };
            return xhr;
          }
          function response(request) {
            return dsv.parse(request.responseText);
          }
          function typedResponse(f5) {
            return function(request) {
              return dsv.parse(request.responseText, f5);
            };
          }
          dsv.parse = function(text, f5) {
            var o10;
            return dsv.parseRows(text, function(row, i5) {
              if (o10) return o10(row, i5 - 1);
              var a3 = new Function("d", "return {" + row.map(function(name, i6) {
                return JSON.stringify(name) + ": d[" + i6 + "]";
              }).join(",") + "}");
              o10 = f5 ? function(row2, i6) {
                return f5(a3(row2), i6);
              } : a3;
            });
          };
          dsv.parseRows = function(text, f5) {
            var EOL = {}, EOF = {}, rows = [], N4 = text.length, I4 = 0, n2 = 0, t7, eol;
            function token() {
              if (I4 >= N4) return EOF;
              if (eol) return eol = false, EOL;
              var j2 = I4;
              if (text.charCodeAt(j2) === 34) {
                var i5 = j2;
                while (i5++ < N4) {
                  if (text.charCodeAt(i5) === 34) {
                    if (text.charCodeAt(i5 + 1) !== 34) break;
                    ++i5;
                  }
                }
                I4 = i5 + 2;
                var c3 = text.charCodeAt(i5 + 1);
                if (c3 === 13) {
                  eol = true;
                  if (text.charCodeAt(i5 + 2) === 10) ++I4;
                } else if (c3 === 10) {
                  eol = true;
                }
                return text.slice(j2 + 1, i5).replace(/""/g, '"');
              }
              while (I4 < N4) {
                var c3 = text.charCodeAt(I4++), k = 1;
                if (c3 === 10) eol = true;
                else if (c3 === 13) {
                  eol = true;
                  if (text.charCodeAt(I4) === 10) ++I4, ++k;
                } else if (c3 !== delimiterCode) continue;
                return text.slice(j2, I4 - k);
              }
              return text.slice(j2);
            }
            while ((t7 = token()) !== EOF) {
              var a3 = [];
              while (t7 !== EOL && t7 !== EOF) {
                a3.push(t7);
                t7 = token();
              }
              if (f5 && (a3 = f5(a3, n2++)) == null) continue;
              rows.push(a3);
            }
            return rows;
          };
          dsv.format = function(rows) {
            if (Array.isArray(rows[0])) return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function(row) {
              for (var field in row) {
                if (!fieldSet.has(field)) {
                  fields.push(fieldSet.add(field));
                }
              }
            });
            return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
              return fields.map(function(field) {
                return formatValue(row[field]);
              }).join(delimiter);
            })).join("\n");
          };
          dsv.formatRows = function(rows) {
            return rows.map(formatRow).join("\n");
          };
          function formatRow(row) {
            return row.map(formatValue).join(delimiter);
          }
          function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
          }
          return dsv;
        };
        d33.csv = d33.dsv(",", "text/csv");
        d33.tsv = d33.dsv("	", "text/tab-separated-values");
        var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback2) {
          setTimeout(callback2, 17);
        };
        d33.timer = function() {
          d3_timer.apply(this, arguments);
        };
        function d3_timer(callback2, delay, then) {
          var n2 = arguments.length;
          if (n2 < 2) delay = 0;
          if (n2 < 3) then = Date.now();
          var time = then + delay, timer = {
            c: callback2,
            t: time,
            n: null
          };
          if (d3_timer_queueTail) d3_timer_queueTail.n = timer;
          else d3_timer_queueHead = timer;
          d3_timer_queueTail = timer;
          if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
          }
          return timer;
        }
        function d3_timer_step() {
          var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
          if (delay > 24) {
            if (isFinite(delay)) {
              clearTimeout(d3_timer_timeout);
              d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
          } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
          }
        }
        d33.timer.flush = function() {
          d3_timer_mark();
          d3_timer_sweep();
        };
        function d3_timer_mark() {
          var now = Date.now(), timer = d3_timer_queueHead;
          while (timer) {
            if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
            timer = timer.n;
          }
          return now;
        }
        function d3_timer_sweep() {
          var t0, t1 = d3_timer_queueHead, time = Infinity;
          while (t1) {
            if (t1.c) {
              if (t1.t < time) time = t1.t;
              t1 = (t0 = t1).n;
            } else {
              t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            }
          }
          d3_timer_queueTail = t0;
          return time;
        }
        function d3_format_precision(x3, p3) {
          return p3 - (x3 ? Math.ceil(Math.log(x3) / Math.LN10) : 1);
        }
        d33.round = function(x3, n2) {
          return n2 ? Math.round(x3 * (n2 = Math.pow(10, n2))) / n2 : Math.round(x3);
        };
        var d3_formatPrefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(d3_formatPrefix);
        d33.formatPrefix = function(value, precision) {
          var i5 = 0;
          if (value = +value) {
            if (value < 0) value *= -1;
            if (precision) value = d33.round(value, d3_format_precision(value, precision));
            i5 = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
            i5 = Math.max(-24, Math.min(24, Math.floor((i5 - 1) / 3) * 3));
          }
          return d3_formatPrefixes[8 + i5 / 3];
        };
        function d3_formatPrefix(d5, i5) {
          var k = Math.pow(10, abs(8 - i5) * 3);
          return {
            scale: i5 > 8 ? function(d6) {
              return d6 / k;
            } : function(d6) {
              return d6 * k;
            },
            symbol: d5
          };
        }
        function d3_locale_numberFormat(locale) {
          var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
            var i5 = value.length, t7 = [], j2 = 0, g3 = locale_grouping[0], length = 0;
            while (i5 > 0 && g3 > 0) {
              if (length + g3 + 1 > width) g3 = Math.max(1, width - length);
              t7.push(value.substring(i5 -= g3, i5 + g3));
              if ((length += g3 + 1) > width) break;
              g3 = locale_grouping[j2 = (j2 + 1) % locale_grouping.length];
            }
            return t7.reverse().join(locale_thousands);
          } : d3_identity;
          return function(specifier) {
            var match = d3_format_re.exec(specifier), fill2 = match[1] || " ", align = match[2] || ">", sign2 = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale2 = 1, prefix2 = "", suffix = "", integer = false, exponent = true;
            if (precision) precision = +precision.substring(1);
            if (zfill || fill2 === "0" && align === "=") {
              zfill = fill2 = "0";
              align = "=";
            }
            switch (type) {
              case "n":
                comma = true;
                type = "g";
                break;
              case "%":
                scale2 = 100;
                suffix = "%";
                type = "f";
                break;
              case "p":
                scale2 = 100;
                suffix = "%";
                type = "r";
                break;
              case "b":
              case "o":
              case "x":
              case "X":
                if (symbol === "#") prefix2 = "0" + type.toLowerCase();
              case "c":
                exponent = false;
              case "d":
                integer = true;
                precision = 0;
                break;
              case "s":
                scale2 = -1;
                type = "r";
                break;
            }
            if (symbol === "$") prefix2 = locale_currency[0], suffix = locale_currency[1];
            if (type == "r" && !precision) type = "g";
            if (precision != null) {
              if (type == "g") precision = Math.max(1, Math.min(21, precision));
              else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
            }
            type = d3_format_types.get(type) || d3_format_typeDefault;
            var zcomma = zfill && comma;
            return function(value) {
              var fullSuffix = suffix;
              if (integer && value % 1) return "";
              var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign2 === "-" ? "" : sign2;
              if (scale2 < 0) {
                var unit = d33.formatPrefix(value, precision);
                value = unit.scale(value);
                fullSuffix = unit.symbol + suffix;
              } else {
                value *= scale2;
              }
              value = type(value, precision);
              var i5 = value.lastIndexOf("."), before, after;
              if (i5 < 0) {
                var j2 = exponent ? value.lastIndexOf("e") : -1;
                if (j2 < 0) before = value, after = "";
                else before = value.substring(0, j2), after = value.substring(j2);
              } else {
                before = value.substring(0, i5);
                after = locale_decimal + value.substring(i5 + 1);
              }
              if (!zfill && comma) before = formatGroup(before, Infinity);
              var length = prefix2.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill2) : "";
              if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
              negative += prefix2;
              value = before + after;
              return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
            };
          };
        }
        var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
        var d3_format_types = d33.map({
          b: function(x3) {
            return x3.toString(2);
          },
          c: function(x3) {
            return String.fromCharCode(x3);
          },
          o: function(x3) {
            return x3.toString(8);
          },
          x: function(x3) {
            return x3.toString(16);
          },
          X: function(x3) {
            return x3.toString(16).toUpperCase();
          },
          g: function(x3, p3) {
            return x3.toPrecision(p3);
          },
          e: function(x3, p3) {
            return x3.toExponential(p3);
          },
          f: function(x3, p3) {
            return x3.toFixed(p3);
          },
          r: function(x3, p3) {
            return (x3 = d33.round(x3, d3_format_precision(x3, p3))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x3 * (1 + 1e-15), p3))));
          }
        });
        function d3_format_typeDefault(x3) {
          return x3 + "";
        }
        var d3_time = d33.time = {}, d3_date = Date;
        function d3_date_utc() {
          this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
        }
        d3_date_utc.prototype = {
          getDate: function() {
            return this._.getUTCDate();
          },
          getDay: function() {
            return this._.getUTCDay();
          },
          getFullYear: function() {
            return this._.getUTCFullYear();
          },
          getHours: function() {
            return this._.getUTCHours();
          },
          getMilliseconds: function() {
            return this._.getUTCMilliseconds();
          },
          getMinutes: function() {
            return this._.getUTCMinutes();
          },
          getMonth: function() {
            return this._.getUTCMonth();
          },
          getSeconds: function() {
            return this._.getUTCSeconds();
          },
          getTime: function() {
            return this._.getTime();
          },
          getTimezoneOffset: function() {
            return 0;
          },
          valueOf: function() {
            return this._.valueOf();
          },
          setDate: function() {
            d3_time_prototype.setUTCDate.apply(this._, arguments);
          },
          setDay: function() {
            d3_time_prototype.setUTCDay.apply(this._, arguments);
          },
          setFullYear: function() {
            d3_time_prototype.setUTCFullYear.apply(this._, arguments);
          },
          setHours: function() {
            d3_time_prototype.setUTCHours.apply(this._, arguments);
          },
          setMilliseconds: function() {
            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
          },
          setMinutes: function() {
            d3_time_prototype.setUTCMinutes.apply(this._, arguments);
          },
          setMonth: function() {
            d3_time_prototype.setUTCMonth.apply(this._, arguments);
          },
          setSeconds: function() {
            d3_time_prototype.setUTCSeconds.apply(this._, arguments);
          },
          setTime: function() {
            d3_time_prototype.setTime.apply(this._, arguments);
          }
        };
        var d3_time_prototype = Date.prototype;
        function d3_time_interval(local, step, number) {
          function round3(date) {
            var d0 = local(date), d1 = offset2(d0, 1);
            return date - d0 < d1 - date ? d0 : d1;
          }
          function ceil(date) {
            step(date = local(new d3_date(date - 1)), 1);
            return date;
          }
          function offset2(date, k) {
            step(date = new d3_date(+date), k);
            return date;
          }
          function range(t0, t1, dt) {
            var time = ceil(t0), times = [];
            if (dt > 1) {
              while (time < t1) {
                if (!(number(time) % dt)) times.push(/* @__PURE__ */ new Date(+time));
                step(time, 1);
              }
            } else {
              while (time < t1) times.push(/* @__PURE__ */ new Date(+time)), step(time, 1);
            }
            return times;
          }
          function range_utc(t0, t1, dt) {
            try {
              d3_date = d3_date_utc;
              var utc4 = new d3_date_utc();
              utc4._ = t0;
              return range(utc4, t1, dt);
            } finally {
              d3_date = Date;
            }
          }
          local.floor = local;
          local.round = round3;
          local.ceil = ceil;
          local.offset = offset2;
          local.range = range;
          var utc3 = local.utc = d3_time_interval_utc(local);
          utc3.floor = utc3;
          utc3.round = d3_time_interval_utc(round3);
          utc3.ceil = d3_time_interval_utc(ceil);
          utc3.offset = d3_time_interval_utc(offset2);
          utc3.range = range_utc;
          return local;
        }
        function d3_time_interval_utc(method) {
          return function(date, k) {
            try {
              d3_date = d3_date_utc;
              var utc3 = new d3_date_utc();
              utc3._ = date;
              return method(utc3, k)._;
            } finally {
              d3_date = Date;
            }
          };
        }
        d3_time.year = d3_time_interval(function(date) {
          date = d3_time.day(date);
          date.setMonth(0, 1);
          return date;
        }, function(date, offset2) {
          date.setFullYear(date.getFullYear() + offset2);
        }, function(date) {
          return date.getFullYear();
        });
        d3_time.years = d3_time.year.range;
        d3_time.years.utc = d3_time.year.utc.range;
        d3_time.day = d3_time_interval(function(date) {
          var day = new d3_date(2e3, 0);
          day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
          return day;
        }, function(date, offset2) {
          date.setDate(date.getDate() + offset2);
        }, function(date) {
          return date.getDate() - 1;
        });
        d3_time.days = d3_time.day.range;
        d3_time.days.utc = d3_time.day.utc.range;
        d3_time.dayOfYear = function(date) {
          var year = d3_time.year(date);
          return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
        };
        ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function(day, i5) {
          i5 = 7 - i5;
          var interval = d3_time[day] = d3_time_interval(function(date) {
            (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i5) % 7);
            return date;
          }, function(date, offset2) {
            date.setDate(date.getDate() + Math.floor(offset2) * 7);
          }, function(date) {
            var day2 = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day2 + i5) % 7) / 7) - (day2 !== i5);
          });
          d3_time[day + "s"] = interval.range;
          d3_time[day + "s"].utc = interval.utc.range;
          d3_time[day + "OfYear"] = function(date) {
            var day2 = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day2 + i5) % 7) / 7);
          };
        });
        d3_time.week = d3_time.sunday;
        d3_time.weeks = d3_time.sunday.range;
        d3_time.weeks.utc = d3_time.sunday.utc.range;
        d3_time.weekOfYear = d3_time.sundayOfYear;
        function d3_locale_timeFormat(locale) {
          var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
          function d3_time_format2(template) {
            var n2 = template.length;
            function format2(date) {
              var string = [], i5 = -1, j2 = 0, c3, p3, f5;
              while (++i5 < n2) {
                if (template.charCodeAt(i5) === 37) {
                  string.push(template.slice(j2, i5));
                  if ((p3 = d3_time_formatPads[c3 = template.charAt(++i5)]) != null) c3 = template.charAt(++i5);
                  if (f5 = d3_time_formats[c3]) c3 = f5(date, p3 == null ? c3 === "e" ? " " : "0" : p3);
                  string.push(c3);
                  j2 = i5 + 1;
                }
              }
              string.push(template.slice(j2, i5));
              return string.join("");
            }
            format2.parse = function(string) {
              var d5 = {
                y: 1900,
                m: 0,
                d: 1,
                H: 0,
                M: 0,
                S: 0,
                L: 0,
                Z: null
              }, i5 = d3_time_parse(d5, template, string, 0);
              if (i5 != string.length) return null;
              if ("p" in d5) d5.H = d5.H % 12 + d5.p * 12;
              var localZ = d5.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
              if ("j" in d5) date.setFullYear(d5.y, 0, d5.j);
              else if ("W" in d5 || "U" in d5) {
                if (!("w" in d5)) d5.w = "W" in d5 ? 1 : 0;
                date.setFullYear(d5.y, 0, 1);
                date.setFullYear(d5.y, 0, "W" in d5 ? (d5.w + 6) % 7 + d5.W * 7 - (date.getDay() + 5) % 7 : d5.w + d5.U * 7 - (date.getDay() + 6) % 7);
              } else date.setFullYear(d5.y, d5.m, d5.d);
              date.setHours(d5.H + (d5.Z / 100 | 0), d5.M + d5.Z % 100, d5.S, d5.L);
              return localZ ? date._ : date;
            };
            format2.toString = function() {
              return template;
            };
            return format2;
          }
          function d3_time_parse(date, template, string, j2) {
            var c3, p3, t7, i5 = 0, n2 = template.length, m5 = string.length;
            while (i5 < n2) {
              if (j2 >= m5) return -1;
              c3 = template.charCodeAt(i5++);
              if (c3 === 37) {
                t7 = template.charAt(i5++);
                p3 = d3_time_parsers[t7 in d3_time_formatPads ? template.charAt(i5++) : t7];
                if (!p3 || (j2 = p3(date, string, j2)) < 0) return -1;
              } else if (c3 != string.charCodeAt(j2++)) {
                return -1;
              }
            }
            return j2;
          }
          d3_time_format2.utc = function(template) {
            var local = d3_time_format2(template);
            function format2(date) {
              try {
                d3_date = d3_date_utc;
                var utc3 = new d3_date();
                utc3._ = date;
                return local(utc3);
              } finally {
                d3_date = Date;
              }
            }
            format2.parse = function(string) {
              try {
                d3_date = d3_date_utc;
                var date = local.parse(string);
                return date && date._;
              } finally {
                d3_date = Date;
              }
            };
            format2.toString = local.toString;
            return format2;
          };
          d3_time_format2.multi = d3_time_format2.utc.multi = d3_time_formatMulti;
          var d3_time_periodLookup = d33.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
          locale_periods.forEach(function(p3, i5) {
            d3_time_periodLookup.set(p3.toLowerCase(), i5);
          });
          var d3_time_formats = {
            a: function(d5) {
              return locale_shortDays[d5.getDay()];
            },
            A: function(d5) {
              return locale_days[d5.getDay()];
            },
            b: function(d5) {
              return locale_shortMonths[d5.getMonth()];
            },
            B: function(d5) {
              return locale_months[d5.getMonth()];
            },
            c: d3_time_format2(locale_dateTime),
            d: function(d5, p3) {
              return d3_time_formatPad(d5.getDate(), p3, 2);
            },
            e: function(d5, p3) {
              return d3_time_formatPad(d5.getDate(), p3, 2);
            },
            H: function(d5, p3) {
              return d3_time_formatPad(d5.getHours(), p3, 2);
            },
            I: function(d5, p3) {
              return d3_time_formatPad(d5.getHours() % 12 || 12, p3, 2);
            },
            j: function(d5, p3) {
              return d3_time_formatPad(1 + d3_time.dayOfYear(d5), p3, 3);
            },
            L: function(d5, p3) {
              return d3_time_formatPad(d5.getMilliseconds(), p3, 3);
            },
            m: function(d5, p3) {
              return d3_time_formatPad(d5.getMonth() + 1, p3, 2);
            },
            M: function(d5, p3) {
              return d3_time_formatPad(d5.getMinutes(), p3, 2);
            },
            p: function(d5) {
              return locale_periods[+(d5.getHours() >= 12)];
            },
            S: function(d5, p3) {
              return d3_time_formatPad(d5.getSeconds(), p3, 2);
            },
            U: function(d5, p3) {
              return d3_time_formatPad(d3_time.sundayOfYear(d5), p3, 2);
            },
            w: function(d5) {
              return d5.getDay();
            },
            W: function(d5, p3) {
              return d3_time_formatPad(d3_time.mondayOfYear(d5), p3, 2);
            },
            x: d3_time_format2(locale_date),
            X: d3_time_format2(locale_time),
            y: function(d5, p3) {
              return d3_time_formatPad(d5.getFullYear() % 100, p3, 2);
            },
            Y: function(d5, p3) {
              return d3_time_formatPad(d5.getFullYear() % 1e4, p3, 4);
            },
            Z: d3_time_zone,
            "%": function() {
              return "%";
            }
          };
          var d3_time_parsers = {
            a: d3_time_parseWeekdayAbbrev,
            A: d3_time_parseWeekday,
            b: d3_time_parseMonthAbbrev,
            B: d3_time_parseMonth,
            c: d3_time_parseLocaleFull,
            d: d3_time_parseDay,
            e: d3_time_parseDay,
            H: d3_time_parseHour24,
            I: d3_time_parseHour24,
            j: d3_time_parseDayOfYear,
            L: d3_time_parseMilliseconds,
            m: d3_time_parseMonthNumber,
            M: d3_time_parseMinutes,
            p: d3_time_parseAmPm,
            S: d3_time_parseSeconds,
            U: d3_time_parseWeekNumberSunday,
            w: d3_time_parseWeekdayNumber,
            W: d3_time_parseWeekNumberMonday,
            x: d3_time_parseLocaleDate,
            X: d3_time_parseLocaleTime,
            y: d3_time_parseYear,
            Y: d3_time_parseFullYear,
            Z: d3_time_parseZone,
            "%": d3_time_parseLiteralPercent
          };
          function d3_time_parseWeekdayAbbrev(date, string, i5) {
            d3_time_dayAbbrevRe.lastIndex = 0;
            var n2 = d3_time_dayAbbrevRe.exec(string.slice(i5));
            return n2 ? (date.w = d3_time_dayAbbrevLookup.get(n2[0].toLowerCase()), i5 + n2[0].length) : -1;
          }
          function d3_time_parseWeekday(date, string, i5) {
            d3_time_dayRe.lastIndex = 0;
            var n2 = d3_time_dayRe.exec(string.slice(i5));
            return n2 ? (date.w = d3_time_dayLookup.get(n2[0].toLowerCase()), i5 + n2[0].length) : -1;
          }
          function d3_time_parseMonthAbbrev(date, string, i5) {
            d3_time_monthAbbrevRe.lastIndex = 0;
            var n2 = d3_time_monthAbbrevRe.exec(string.slice(i5));
            return n2 ? (date.m = d3_time_monthAbbrevLookup.get(n2[0].toLowerCase()), i5 + n2[0].length) : -1;
          }
          function d3_time_parseMonth(date, string, i5) {
            d3_time_monthRe.lastIndex = 0;
            var n2 = d3_time_monthRe.exec(string.slice(i5));
            return n2 ? (date.m = d3_time_monthLookup.get(n2[0].toLowerCase()), i5 + n2[0].length) : -1;
          }
          function d3_time_parseLocaleFull(date, string, i5) {
            return d3_time_parse(date, d3_time_formats.c.toString(), string, i5);
          }
          function d3_time_parseLocaleDate(date, string, i5) {
            return d3_time_parse(date, d3_time_formats.x.toString(), string, i5);
          }
          function d3_time_parseLocaleTime(date, string, i5) {
            return d3_time_parse(date, d3_time_formats.X.toString(), string, i5);
          }
          function d3_time_parseAmPm(date, string, i5) {
            var n2 = d3_time_periodLookup.get(string.slice(i5, i5 += 2).toLowerCase());
            return n2 == null ? -1 : (date.p = n2, i5);
          }
          return d3_time_format2;
        }
        var d3_time_formatPads = {
          "-": "",
          _: " ",
          "0": "0"
        }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
        function d3_time_formatPad(value, fill2, width) {
          var sign2 = value < 0 ? "-" : "", string = (sign2 ? -value : value) + "", length = string.length;
          return sign2 + (length < width ? new Array(width - length + 1).join(fill2) + string : string);
        }
        function d3_time_formatRe(names2) {
          return new RegExp("^(?:" + names2.map(d33.requote).join("|") + ")", "i");
        }
        function d3_time_formatLookup(names2) {
          var map3 = new d3_Map(), i5 = -1, n2 = names2.length;
          while (++i5 < n2) map3.set(names2[i5].toLowerCase(), i5);
          return map3;
        }
        function d3_time_parseWeekdayNumber(date, string, i5) {
          d3_time_numberRe.lastIndex = 0;
          var n2 = d3_time_numberRe.exec(string.slice(i5, i5 + 1));
          return n2 ? (date.w = +n2[0], i5 + n2[0].length) : -1;
        }
        function d3_time_parseWeekNumberSunday(date, string, i5) {
          d3_time_numberRe.lastIndex = 0;
          var n2 = d3_time_numberRe.exec(string.slice(i5));
          return n2 ? (date.U = +n2[0], i5 + n2[0].length) : -1;
        }
        function d3_time_parseWeekNumberMonday(date, string, i5) {
          d3_time_numberRe.lastIndex = 0;
          var n2 = d3_time_numberRe.exec(string.slice(i5));
          return n2 ? (date.W = +n2[0], i5 + n2[0].length) : -1;
        }
        function d3_time_parseFullYear(date, string, i5) {
          d3_time_numberRe.lastIndex = 0;
          var n2 = d3_time_numberRe.exec(string.slice(i5, i5 + 4));
          return n2 ? (date.y = +n2[0], i5 + n2[0].length) : -1;
        }
        function d3_time_parseYear(date, string, i5) {
          d3_time_numberRe.lastIndex = 0;
          var n2 = d3_time_numberRe.exec(string.slice(i5, i5 + 2));
          return n2 ? (date.y = d3_time_expandYear(+n2[0]), i5 + n2[0].length) : -1;
        }
        function d3_time_parseZone(date, string, i5) {
          return /^[+-]\d{4}$/.test(string = string.slice(i5, i5 + 5)) ? (date.Z = -string, i5 + 5) : -1;
        }
        function d3_time_expandYear(d5) {
          return d5 + (d5 > 68 ? 1900 : 2e3);
        }
        function d3_time_parseMonthNumber(date, string, i5) {
          d3_time_numberRe.lastIndex = 0;
          var n2 = d3_time_numberRe.exec(string.slice(i5, i5 + 2));
          return n2 ? (date.m = n2[0] - 1, i5 + n2[0].length) : -1;
        }
        function d3_time_parseDay(date, string, i5) {
          d3_time_numberRe.lastIndex = 0;
          var n2 = d3_time_numberRe.exec(string.slice(i5, i5 + 2));
          return n2 ? (date.d = +n2[0], i5 + n2[0].length) : -1;
        }
        function d3_time_parseDayOfYear(date, string, i5) {
          d3_time_numberRe.lastIndex = 0;
          var n2 = d3_time_numberRe.exec(string.slice(i5, i5 + 3));
          return n2 ? (date.j = +n2[0], i5 + n2[0].length) : -1;
        }
        function d3_time_parseHour24(date, string, i5) {
          d3_time_numberRe.lastIndex = 0;
          var n2 = d3_time_numberRe.exec(string.slice(i5, i5 + 2));
          return n2 ? (date.H = +n2[0], i5 + n2[0].length) : -1;
        }
        function d3_time_parseMinutes(date, string, i5) {
          d3_time_numberRe.lastIndex = 0;
          var n2 = d3_time_numberRe.exec(string.slice(i5, i5 + 2));
          return n2 ? (date.M = +n2[0], i5 + n2[0].length) : -1;
        }
        function d3_time_parseSeconds(date, string, i5) {
          d3_time_numberRe.lastIndex = 0;
          var n2 = d3_time_numberRe.exec(string.slice(i5, i5 + 2));
          return n2 ? (date.S = +n2[0], i5 + n2[0].length) : -1;
        }
        function d3_time_parseMilliseconds(date, string, i5) {
          d3_time_numberRe.lastIndex = 0;
          var n2 = d3_time_numberRe.exec(string.slice(i5, i5 + 3));
          return n2 ? (date.L = +n2[0], i5 + n2[0].length) : -1;
        }
        function d3_time_zone(d5) {
          var z2 = d5.getTimezoneOffset(), zs = z2 > 0 ? "-" : "+", zh = abs(z2) / 60 | 0, zm = abs(z2) % 60;
          return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
        }
        function d3_time_parseLiteralPercent(date, string, i5) {
          d3_time_percentRe.lastIndex = 0;
          var n2 = d3_time_percentRe.exec(string.slice(i5, i5 + 1));
          return n2 ? i5 + n2[0].length : -1;
        }
        function d3_time_formatMulti(formats) {
          var n2 = formats.length, i5 = -1;
          while (++i5 < n2) formats[i5][0] = this(formats[i5][0]);
          return function(date) {
            var i6 = 0, f5 = formats[i6];
            while (!f5[1](date)) f5 = formats[++i6];
            return f5[0](date);
          };
        }
        d33.locale = function(locale) {
          return {
            numberFormat: d3_locale_numberFormat(locale),
            timeFormat: d3_locale_timeFormat(locale)
          };
        };
        var d3_locale_enUS = d33.locale({
          decimal: ".",
          thousands: ",",
          grouping: [3],
          currency: ["$", ""],
          dateTime: "%a %b %e %X %Y",
          date: "%m/%d/%Y",
          time: "%H:%M:%S",
          periods: ["AM", "PM"],
          days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        });
        d33.format = d3_locale_enUS.numberFormat;
        d33.geo = {};
        function d3_adder() {
        }
        d3_adder.prototype = {
          s: 0,
          t: 0,
          add: function(y2) {
            d3_adderSum(y2, this.t, d3_adderTemp);
            d3_adderSum(d3_adderTemp.s, this.s, this);
            if (this.s) this.t += d3_adderTemp.t;
            else this.s = d3_adderTemp.t;
          },
          reset: function() {
            this.s = this.t = 0;
          },
          valueOf: function() {
            return this.s;
          }
        };
        var d3_adderTemp = new d3_adder();
        function d3_adderSum(a3, b2, o10) {
          var x3 = o10.s = a3 + b2, bv = x3 - a3, av = x3 - bv;
          o10.t = a3 - av + (b2 - bv);
        }
        d33.geo.stream = function(object, listener) {
          if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, listener);
          } else {
            d3_geo_streamGeometry(object, listener);
          }
        };
        function d3_geo_streamGeometry(geometry, listener) {
          if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, listener);
          }
        }
        var d3_geo_streamObjectType = {
          Feature: function(feature, listener) {
            d3_geo_streamGeometry(feature.geometry, listener);
          },
          FeatureCollection: function(object, listener) {
            var features = object.features, i5 = -1, n2 = features.length;
            while (++i5 < n2) d3_geo_streamGeometry(features[i5].geometry, listener);
          }
        };
        var d3_geo_streamGeometryType = {
          Sphere: function(object, listener) {
            listener.sphere();
          },
          Point: function(object, listener) {
            object = object.coordinates;
            listener.point(object[0], object[1], object[2]);
          },
          MultiPoint: function(object, listener) {
            var coordinates = object.coordinates, i5 = -1, n2 = coordinates.length;
            while (++i5 < n2) object = coordinates[i5], listener.point(object[0], object[1], object[2]);
          },
          LineString: function(object, listener) {
            d3_geo_streamLine(object.coordinates, listener, 0);
          },
          MultiLineString: function(object, listener) {
            var coordinates = object.coordinates, i5 = -1, n2 = coordinates.length;
            while (++i5 < n2) d3_geo_streamLine(coordinates[i5], listener, 0);
          },
          Polygon: function(object, listener) {
            d3_geo_streamPolygon(object.coordinates, listener);
          },
          MultiPolygon: function(object, listener) {
            var coordinates = object.coordinates, i5 = -1, n2 = coordinates.length;
            while (++i5 < n2) d3_geo_streamPolygon(coordinates[i5], listener);
          },
          GeometryCollection: function(object, listener) {
            var geometries = object.geometries, i5 = -1, n2 = geometries.length;
            while (++i5 < n2) d3_geo_streamGeometry(geometries[i5], listener);
          }
        };
        function d3_geo_streamLine(coordinates, listener, closed) {
          var i5 = -1, n2 = coordinates.length - closed, coordinate;
          listener.lineStart();
          while (++i5 < n2) coordinate = coordinates[i5], listener.point(coordinate[0], coordinate[1], coordinate[2]);
          listener.lineEnd();
        }
        function d3_geo_streamPolygon(coordinates, listener) {
          var i5 = -1, n2 = coordinates.length;
          listener.polygonStart();
          while (++i5 < n2) d3_geo_streamLine(coordinates[i5], listener, 1);
          listener.polygonEnd();
        }
        d33.geo.area = function(object) {
          d3_geo_areaSum = 0;
          d33.geo.stream(object, d3_geo_area);
          return d3_geo_areaSum;
        };
        var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
        var d3_geo_area = {
          sphere: function() {
            d3_geo_areaSum += 4 * \u03C0;
          },
          point: d3_noop,
          lineStart: d3_noop,
          lineEnd: d3_noop,
          polygonStart: function() {
            d3_geo_areaRingSum.reset();
            d3_geo_area.lineStart = d3_geo_areaRingStart;
          },
          polygonEnd: function() {
            var area = 2 * d3_geo_areaRingSum;
            d3_geo_areaSum += area < 0 ? 4 * \u03C0 + area : area;
            d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
          }
        };
        function d3_geo_areaRingStart() {
          var \u03BB00, \u03C600, \u03BB0, cos\u03C60, sin\u03C60;
          d3_geo_area.point = function(\u03BB, \u03C6) {
            d3_geo_area.point = nextPoint;
            \u03BB0 = (\u03BB00 = \u03BB) * d3_radians, cos\u03C60 = Math.cos(\u03C6 = (\u03C600 = \u03C6) * d3_radians / 2 + \u03C0 / 4), sin\u03C60 = Math.sin(\u03C6);
          };
          function nextPoint(\u03BB, \u03C6) {
            \u03BB *= d3_radians;
            \u03C6 = \u03C6 * d3_radians / 2 + \u03C0 / 4;
            var d\u03BB = \u03BB - \u03BB0, sd\u03BB = d\u03BB >= 0 ? 1 : -1, ad\u03BB = sd\u03BB * d\u03BB, cos\u03C6 = Math.cos(\u03C6), sin\u03C6 = Math.sin(\u03C6), k = sin\u03C60 * sin\u03C6, u4 = cos\u03C60 * cos\u03C6 + k * Math.cos(ad\u03BB), v3 = k * sd\u03BB * Math.sin(ad\u03BB);
            d3_geo_areaRingSum.add(Math.atan2(v3, u4));
            \u03BB0 = \u03BB, cos\u03C60 = cos\u03C6, sin\u03C60 = sin\u03C6;
          }
          d3_geo_area.lineEnd = function() {
            nextPoint(\u03BB00, \u03C600);
          };
        }
        function d3_geo_cartesian(spherical) {
          var \u03BB = spherical[0], \u03C6 = spherical[1], cos\u03C6 = Math.cos(\u03C6);
          return [cos\u03C6 * Math.cos(\u03BB), cos\u03C6 * Math.sin(\u03BB), Math.sin(\u03C6)];
        }
        function d3_geo_cartesianDot(a3, b2) {
          return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
        }
        function d3_geo_cartesianCross(a3, b2) {
          return [a3[1] * b2[2] - a3[2] * b2[1], a3[2] * b2[0] - a3[0] * b2[2], a3[0] * b2[1] - a3[1] * b2[0]];
        }
        function d3_geo_cartesianAdd(a3, b2) {
          a3[0] += b2[0];
          a3[1] += b2[1];
          a3[2] += b2[2];
        }
        function d3_geo_cartesianScale(vector, k) {
          return [vector[0] * k, vector[1] * k, vector[2] * k];
        }
        function d3_geo_cartesianNormalize(d5) {
          var l6 = Math.sqrt(d5[0] * d5[0] + d5[1] * d5[1] + d5[2] * d5[2]);
          d5[0] /= l6;
          d5[1] /= l6;
          d5[2] /= l6;
        }
        function d3_geo_spherical(cartesian) {
          return [Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])];
        }
        function d3_geo_sphericalEqual(a3, b2) {
          return abs(a3[0] - b2[0]) < \u03B5 && abs(a3[1] - b2[1]) < \u03B5;
        }
        d33.geo.bounds = /* @__PURE__ */ function() {
          var \u03BB0, \u03C60, \u03BB1, \u03C61, \u03BB_, \u03BB__, \u03C6__, p0, d\u03BBSum, ranges, range;
          var bound = {
            point,
            lineStart,
            lineEnd,
            polygonStart: function() {
              bound.point = ringPoint;
              bound.lineStart = ringStart;
              bound.lineEnd = ringEnd;
              d\u03BBSum = 0;
              d3_geo_area.polygonStart();
            },
            polygonEnd: function() {
              d3_geo_area.polygonEnd();
              bound.point = point;
              bound.lineStart = lineStart;
              bound.lineEnd = lineEnd;
              if (d3_geo_areaRingSum < 0) \u03BB0 = -(\u03BB1 = 180), \u03C60 = -(\u03C61 = 90);
              else if (d\u03BBSum > \u03B5) \u03C61 = 90;
              else if (d\u03BBSum < -\u03B5) \u03C60 = -90;
              range[0] = \u03BB0, range[1] = \u03BB1;
            }
          };
          function point(\u03BB, \u03C6) {
            ranges.push(range = [\u03BB0 = \u03BB, \u03BB1 = \u03BB]);
            if (\u03C6 < \u03C60) \u03C60 = \u03C6;
            if (\u03C6 > \u03C61) \u03C61 = \u03C6;
          }
          function linePoint(\u03BB, \u03C6) {
            var p3 = d3_geo_cartesian([\u03BB * d3_radians, \u03C6 * d3_radians]);
            if (p0) {
              var normal = d3_geo_cartesianCross(p0, p3), equatorial = [normal[1], -normal[0], 0], inflection = d3_geo_cartesianCross(equatorial, normal);
              d3_geo_cartesianNormalize(inflection);
              inflection = d3_geo_spherical(inflection);
              var d\u03BB = \u03BB - \u03BB_, s7 = d\u03BB > 0 ? 1 : -1, \u03BBi = inflection[0] * d3_degrees * s7, antimeridian = abs(d\u03BB) > 180;
              if (antimeridian ^ (s7 * \u03BB_ < \u03BBi && \u03BBi < s7 * \u03BB)) {
                var \u03C6i = inflection[1] * d3_degrees;
                if (\u03C6i > \u03C61) \u03C61 = \u03C6i;
              } else if (\u03BBi = (\u03BBi + 360) % 360 - 180, antimeridian ^ (s7 * \u03BB_ < \u03BBi && \u03BBi < s7 * \u03BB)) {
                var \u03C6i = -inflection[1] * d3_degrees;
                if (\u03C6i < \u03C60) \u03C60 = \u03C6i;
              } else {
                if (\u03C6 < \u03C60) \u03C60 = \u03C6;
                if (\u03C6 > \u03C61) \u03C61 = \u03C6;
              }
              if (antimeridian) {
                if (\u03BB < \u03BB_) {
                  if (angle(\u03BB0, \u03BB) > angle(\u03BB0, \u03BB1)) \u03BB1 = \u03BB;
                } else {
                  if (angle(\u03BB, \u03BB1) > angle(\u03BB0, \u03BB1)) \u03BB0 = \u03BB;
                }
              } else {
                if (\u03BB1 >= \u03BB0) {
                  if (\u03BB < \u03BB0) \u03BB0 = \u03BB;
                  if (\u03BB > \u03BB1) \u03BB1 = \u03BB;
                } else {
                  if (\u03BB > \u03BB_) {
                    if (angle(\u03BB0, \u03BB) > angle(\u03BB0, \u03BB1)) \u03BB1 = \u03BB;
                  } else {
                    if (angle(\u03BB, \u03BB1) > angle(\u03BB0, \u03BB1)) \u03BB0 = \u03BB;
                  }
                }
              }
            } else {
              point(\u03BB, \u03C6);
            }
            p0 = p3, \u03BB_ = \u03BB;
          }
          function lineStart() {
            bound.point = linePoint;
          }
          function lineEnd() {
            range[0] = \u03BB0, range[1] = \u03BB1;
            bound.point = point;
            p0 = null;
          }
          function ringPoint(\u03BB, \u03C6) {
            if (p0) {
              var d\u03BB = \u03BB - \u03BB_;
              d\u03BBSum += abs(d\u03BB) > 180 ? d\u03BB + (d\u03BB > 0 ? 360 : -360) : d\u03BB;
            } else \u03BB__ = \u03BB, \u03C6__ = \u03C6;
            d3_geo_area.point(\u03BB, \u03C6);
            linePoint(\u03BB, \u03C6);
          }
          function ringStart() {
            d3_geo_area.lineStart();
          }
          function ringEnd() {
            ringPoint(\u03BB__, \u03C6__);
            d3_geo_area.lineEnd();
            if (abs(d\u03BBSum) > \u03B5) \u03BB0 = -(\u03BB1 = 180);
            range[0] = \u03BB0, range[1] = \u03BB1;
            p0 = null;
          }
          function angle(\u03BB02, \u03BB12) {
            return (\u03BB12 -= \u03BB02) < 0 ? \u03BB12 + 360 : \u03BB12;
          }
          function compareRanges(a3, b2) {
            return a3[0] - b2[0];
          }
          function withinRange(x3, range2) {
            return range2[0] <= range2[1] ? range2[0] <= x3 && x3 <= range2[1] : x3 < range2[0] || range2[1] < x3;
          }
          return function(feature) {
            \u03C61 = \u03BB1 = -(\u03BB0 = \u03C60 = Infinity);
            ranges = [];
            d33.geo.stream(feature, bound);
            var n2 = ranges.length;
            if (n2) {
              ranges.sort(compareRanges);
              for (var i5 = 1, a3 = ranges[0], b2, merged = [a3]; i5 < n2; ++i5) {
                b2 = ranges[i5];
                if (withinRange(b2[0], a3) || withinRange(b2[1], a3)) {
                  if (angle(a3[0], b2[1]) > angle(a3[0], a3[1])) a3[1] = b2[1];
                  if (angle(b2[0], a3[1]) > angle(a3[0], a3[1])) a3[0] = b2[0];
                } else {
                  merged.push(a3 = b2);
                }
              }
              var best = -Infinity, d\u03BB;
              for (var n2 = merged.length - 1, i5 = 0, a3 = merged[n2], b2; i5 <= n2; a3 = b2, ++i5) {
                b2 = merged[i5];
                if ((d\u03BB = angle(a3[1], b2[0])) > best) best = d\u03BB, \u03BB0 = b2[0], \u03BB1 = a3[1];
              }
            }
            ranges = range = null;
            return \u03BB0 === Infinity || \u03C60 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[\u03BB0, \u03C60], [\u03BB1, \u03C61]];
          };
        }();
        d33.geo.centroid = function(object) {
          d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
          d33.geo.stream(object, d3_geo_centroid);
          var x3 = d3_geo_centroidX2, y2 = d3_geo_centroidY2, z2 = d3_geo_centroidZ2, m5 = x3 * x3 + y2 * y2 + z2 * z2;
          if (m5 < \u03B52) {
            x3 = d3_geo_centroidX1, y2 = d3_geo_centroidY1, z2 = d3_geo_centroidZ1;
            if (d3_geo_centroidW1 < \u03B5) x3 = d3_geo_centroidX0, y2 = d3_geo_centroidY0, z2 = d3_geo_centroidZ0;
            m5 = x3 * x3 + y2 * y2 + z2 * z2;
            if (m5 < \u03B52) return [NaN, NaN];
          }
          return [Math.atan2(y2, x3) * d3_degrees, d3_asin(z2 / Math.sqrt(m5)) * d3_degrees];
        };
        var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
        var d3_geo_centroid = {
          sphere: d3_noop,
          point: d3_geo_centroidPoint,
          lineStart: d3_geo_centroidLineStart,
          lineEnd: d3_geo_centroidLineEnd,
          polygonStart: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
          },
          polygonEnd: function() {
            d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
          }
        };
        function d3_geo_centroidPoint(\u03BB, \u03C6) {
          \u03BB *= d3_radians;
          var cos\u03C6 = Math.cos(\u03C6 *= d3_radians);
          d3_geo_centroidPointXYZ(cos\u03C6 * Math.cos(\u03BB), cos\u03C6 * Math.sin(\u03BB), Math.sin(\u03C6));
        }
        function d3_geo_centroidPointXYZ(x3, y2, z2) {
          ++d3_geo_centroidW0;
          d3_geo_centroidX0 += (x3 - d3_geo_centroidX0) / d3_geo_centroidW0;
          d3_geo_centroidY0 += (y2 - d3_geo_centroidY0) / d3_geo_centroidW0;
          d3_geo_centroidZ0 += (z2 - d3_geo_centroidZ0) / d3_geo_centroidW0;
        }
        function d3_geo_centroidLineStart() {
          var x0, y0, z0;
          d3_geo_centroid.point = function(\u03BB, \u03C6) {
            \u03BB *= d3_radians;
            var cos\u03C6 = Math.cos(\u03C6 *= d3_radians);
            x0 = cos\u03C6 * Math.cos(\u03BB);
            y0 = cos\u03C6 * Math.sin(\u03BB);
            z0 = Math.sin(\u03C6);
            d3_geo_centroid.point = nextPoint;
            d3_geo_centroidPointXYZ(x0, y0, z0);
          };
          function nextPoint(\u03BB, \u03C6) {
            \u03BB *= d3_radians;
            var cos\u03C6 = Math.cos(\u03C6 *= d3_radians), x3 = cos\u03C6 * Math.cos(\u03BB), y2 = cos\u03C6 * Math.sin(\u03BB), z2 = Math.sin(\u03C6), w3 = Math.atan2(Math.sqrt((w3 = y0 * z2 - z0 * y2) * w3 + (w3 = z0 * x3 - x0 * z2) * w3 + (w3 = x0 * y2 - y0 * x3) * w3), x0 * x3 + y0 * y2 + z0 * z2);
            d3_geo_centroidW1 += w3;
            d3_geo_centroidX1 += w3 * (x0 + (x0 = x3));
            d3_geo_centroidY1 += w3 * (y0 + (y0 = y2));
            d3_geo_centroidZ1 += w3 * (z0 + (z0 = z2));
            d3_geo_centroidPointXYZ(x0, y0, z0);
          }
        }
        function d3_geo_centroidLineEnd() {
          d3_geo_centroid.point = d3_geo_centroidPoint;
        }
        function d3_geo_centroidRingStart() {
          var \u03BB00, \u03C600, x0, y0, z0;
          d3_geo_centroid.point = function(\u03BB, \u03C6) {
            \u03BB00 = \u03BB, \u03C600 = \u03C6;
            d3_geo_centroid.point = nextPoint;
            \u03BB *= d3_radians;
            var cos\u03C6 = Math.cos(\u03C6 *= d3_radians);
            x0 = cos\u03C6 * Math.cos(\u03BB);
            y0 = cos\u03C6 * Math.sin(\u03BB);
            z0 = Math.sin(\u03C6);
            d3_geo_centroidPointXYZ(x0, y0, z0);
          };
          d3_geo_centroid.lineEnd = function() {
            nextPoint(\u03BB00, \u03C600);
            d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
            d3_geo_centroid.point = d3_geo_centroidPoint;
          };
          function nextPoint(\u03BB, \u03C6) {
            \u03BB *= d3_radians;
            var cos\u03C6 = Math.cos(\u03C6 *= d3_radians), x3 = cos\u03C6 * Math.cos(\u03BB), y2 = cos\u03C6 * Math.sin(\u03BB), z2 = Math.sin(\u03C6), cx = y0 * z2 - z0 * y2, cy = z0 * x3 - x0 * z2, cz = x0 * y2 - y0 * x3, m5 = Math.sqrt(cx * cx + cy * cy + cz * cz), u4 = x0 * x3 + y0 * y2 + z0 * z2, v3 = m5 && -d3_acos(u4) / m5, w3 = Math.atan2(m5, u4);
            d3_geo_centroidX2 += v3 * cx;
            d3_geo_centroidY2 += v3 * cy;
            d3_geo_centroidZ2 += v3 * cz;
            d3_geo_centroidW1 += w3;
            d3_geo_centroidX1 += w3 * (x0 + (x0 = x3));
            d3_geo_centroidY1 += w3 * (y0 + (y0 = y2));
            d3_geo_centroidZ1 += w3 * (z0 + (z0 = z2));
            d3_geo_centroidPointXYZ(x0, y0, z0);
          }
        }
        function d3_geo_compose(a3, b2) {
          function compose(x3, y2) {
            return x3 = a3(x3, y2), b2(x3[0], x3[1]);
          }
          if (a3.invert && b2.invert) compose.invert = function(x3, y2) {
            return x3 = b2.invert(x3, y2), x3 && a3.invert(x3[0], x3[1]);
          };
          return compose;
        }
        function d3_true() {
          return true;
        }
        function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate3, listener) {
          var subject = [], clip = [];
          segments.forEach(function(segment) {
            if ((n3 = segment.length - 1) <= 0) return;
            var n3, p0 = segment[0], p1 = segment[n3];
            if (d3_geo_sphericalEqual(p0, p1)) {
              listener.lineStart();
              for (var i6 = 0; i6 < n3; ++i6) listener.point((p0 = segment[i6])[0], p0[1]);
              listener.lineEnd();
              return;
            }
            var a3 = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b2 = new d3_geo_clipPolygonIntersection(p0, null, a3, false);
            a3.o = b2;
            subject.push(a3);
            clip.push(b2);
            a3 = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
            b2 = new d3_geo_clipPolygonIntersection(p1, null, a3, true);
            a3.o = b2;
            subject.push(a3);
            clip.push(b2);
          });
          clip.sort(compare);
          d3_geo_clipPolygonLinkCircular(subject);
          d3_geo_clipPolygonLinkCircular(clip);
          if (!subject.length) return;
          for (var i5 = 0, entry = clipStartInside, n2 = clip.length; i5 < n2; ++i5) {
            clip[i5].e = entry = !entry;
          }
          var start3 = subject[0], points, point;
          while (1) {
            var current = start3, isSubject = true;
            while (current.v) if ((current = current.n) === start3) return;
            points = current.z;
            listener.lineStart();
            do {
              current.v = current.o.v = true;
              if (current.e) {
                if (isSubject) {
                  for (var i5 = 0, n2 = points.length; i5 < n2; ++i5) listener.point((point = points[i5])[0], point[1]);
                } else {
                  interpolate3(current.x, current.n.x, 1, listener);
                }
                current = current.n;
              } else {
                if (isSubject) {
                  points = current.p.z;
                  for (var i5 = points.length - 1; i5 >= 0; --i5) listener.point((point = points[i5])[0], point[1]);
                } else {
                  interpolate3(current.x, current.p.x, -1, listener);
                }
                current = current.p;
              }
              current = current.o;
              points = current.z;
              isSubject = !isSubject;
            } while (!current.v);
            listener.lineEnd();
          }
        }
        function d3_geo_clipPolygonLinkCircular(array) {
          if (!(n2 = array.length)) return;
          var n2, i5 = 0, a3 = array[0], b2;
          while (++i5 < n2) {
            a3.n = b2 = array[i5];
            b2.p = a3;
            a3 = b2;
          }
          a3.n = b2 = array[0];
          b2.p = a3;
        }
        function d3_geo_clipPolygonIntersection(point, points, other, entry) {
          this.x = point;
          this.z = points;
          this.o = other;
          this.e = entry;
          this.v = false;
          this.n = this.p = null;
        }
        function d3_geo_clip(pointVisible, clipLine, interpolate3, clipStart) {
          return function(rotate2, listener) {
            var line = clipLine(listener), rotatedClipStart = rotate2.invert(clipStart[0], clipStart[1]);
            var clip = {
              point,
              lineStart,
              lineEnd,
              polygonStart: function() {
                clip.point = pointRing;
                clip.lineStart = ringStart;
                clip.lineEnd = ringEnd;
                segments = [];
                polygon = [];
              },
              polygonEnd: function() {
                clip.point = point;
                clip.lineStart = lineStart;
                clip.lineEnd = lineEnd;
                segments = d33.merge(segments);
                var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                if (segments.length) {
                  if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                  d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate3, listener);
                } else if (clipStartInside) {
                  if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                  listener.lineStart();
                  interpolate3(null, null, 1, listener);
                  listener.lineEnd();
                }
                if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
                segments = polygon = null;
              },
              sphere: function() {
                listener.polygonStart();
                listener.lineStart();
                interpolate3(null, null, 1, listener);
                listener.lineEnd();
                listener.polygonEnd();
              }
            };
            function point(\u03BB, \u03C6) {
              var point2 = rotate2(\u03BB, \u03C6);
              if (pointVisible(\u03BB = point2[0], \u03C6 = point2[1])) listener.point(\u03BB, \u03C6);
            }
            function pointLine(\u03BB, \u03C6) {
              var point2 = rotate2(\u03BB, \u03C6);
              line.point(point2[0], point2[1]);
            }
            function lineStart() {
              clip.point = pointLine;
              line.lineStart();
            }
            function lineEnd() {
              clip.point = point;
              line.lineEnd();
            }
            var segments;
            var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
            function pointRing(\u03BB, \u03C6) {
              ring.push([\u03BB, \u03C6]);
              var point2 = rotate2(\u03BB, \u03C6);
              ringListener.point(point2[0], point2[1]);
            }
            function ringStart() {
              ringListener.lineStart();
              ring = [];
            }
            function ringEnd() {
              pointRing(ring[0][0], ring[0][1]);
              ringListener.lineEnd();
              var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n2 = ringSegments.length;
              ring.pop();
              polygon.push(ring);
              ring = null;
              if (!n2) return;
              if (clean & 1) {
                segment = ringSegments[0];
                var n2 = segment.length - 1, i5 = -1, point2;
                if (n2 > 0) {
                  if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                  listener.lineStart();
                  while (++i5 < n2) listener.point((point2 = segment[i5])[0], point2[1]);
                  listener.lineEnd();
                }
                return;
              }
              if (n2 > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
              segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
            }
            return clip;
          };
        }
        function d3_geo_clipSegmentLength1(segment) {
          return segment.length > 1;
        }
        function d3_geo_clipBufferListener() {
          var lines = [], line;
          return {
            lineStart: function() {
              lines.push(line = []);
            },
            point: function(\u03BB, \u03C6) {
              line.push([\u03BB, \u03C6]);
            },
            lineEnd: d3_noop,
            buffer: function() {
              var buffer = lines;
              lines = [];
              line = null;
              return buffer;
            },
            rejoin: function() {
              if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
            }
          };
        }
        function d3_geo_clipSort(a3, b2) {
          return ((a3 = a3.x)[0] < 0 ? a3[1] - half\u03C0 - \u03B5 : half\u03C0 - a3[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - half\u03C0 - \u03B5 : half\u03C0 - b2[1]);
        }
        var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [-\u03C0, -\u03C0 / 2]);
        function d3_geo_clipAntimeridianLine(listener) {
          var \u03BB0 = NaN, \u03C60 = NaN, s\u03BB0 = NaN, clean;
          return {
            lineStart: function() {
              listener.lineStart();
              clean = 1;
            },
            point: function(\u03BB1, \u03C61) {
              var s\u03BB1 = \u03BB1 > 0 ? \u03C0 : -\u03C0, d\u03BB = abs(\u03BB1 - \u03BB0);
              if (abs(d\u03BB - \u03C0) < \u03B5) {
                listener.point(\u03BB0, \u03C60 = (\u03C60 + \u03C61) / 2 > 0 ? half\u03C0 : -half\u03C0);
                listener.point(s\u03BB0, \u03C60);
                listener.lineEnd();
                listener.lineStart();
                listener.point(s\u03BB1, \u03C60);
                listener.point(\u03BB1, \u03C60);
                clean = 0;
              } else if (s\u03BB0 !== s\u03BB1 && d\u03BB >= \u03C0) {
                if (abs(\u03BB0 - s\u03BB0) < \u03B5) \u03BB0 -= s\u03BB0 * \u03B5;
                if (abs(\u03BB1 - s\u03BB1) < \u03B5) \u03BB1 -= s\u03BB1 * \u03B5;
                \u03C60 = d3_geo_clipAntimeridianIntersect(\u03BB0, \u03C60, \u03BB1, \u03C61);
                listener.point(s\u03BB0, \u03C60);
                listener.lineEnd();
                listener.lineStart();
                listener.point(s\u03BB1, \u03C60);
                clean = 0;
              }
              listener.point(\u03BB0 = \u03BB1, \u03C60 = \u03C61);
              s\u03BB0 = s\u03BB1;
            },
            lineEnd: function() {
              listener.lineEnd();
              \u03BB0 = \u03C60 = NaN;
            },
            clean: function() {
              return 2 - clean;
            }
          };
        }
        function d3_geo_clipAntimeridianIntersect(\u03BB0, \u03C60, \u03BB1, \u03C61) {
          var cos\u03C60, cos\u03C61, sin\u03BB0_\u03BB1 = Math.sin(\u03BB0 - \u03BB1);
          return abs(sin\u03BB0_\u03BB1) > \u03B5 ? Math.atan((Math.sin(\u03C60) * (cos\u03C61 = Math.cos(\u03C61)) * Math.sin(\u03BB1) - Math.sin(\u03C61) * (cos\u03C60 = Math.cos(\u03C60)) * Math.sin(\u03BB0)) / (cos\u03C60 * cos\u03C61 * sin\u03BB0_\u03BB1)) : (\u03C60 + \u03C61) / 2;
        }
        function d3_geo_clipAntimeridianInterpolate(from2, to2, direction, listener) {
          var \u03C6;
          if (from2 == null) {
            \u03C6 = direction * half\u03C0;
            listener.point(-\u03C0, \u03C6);
            listener.point(0, \u03C6);
            listener.point(\u03C0, \u03C6);
            listener.point(\u03C0, 0);
            listener.point(\u03C0, -\u03C6);
            listener.point(0, -\u03C6);
            listener.point(-\u03C0, -\u03C6);
            listener.point(-\u03C0, 0);
            listener.point(-\u03C0, \u03C6);
          } else if (abs(from2[0] - to2[0]) > \u03B5) {
            var s7 = from2[0] < to2[0] ? \u03C0 : -\u03C0;
            \u03C6 = direction * s7 / 2;
            listener.point(-s7, \u03C6);
            listener.point(0, \u03C6);
            listener.point(s7, \u03C6);
          } else {
            listener.point(to2[0], to2[1]);
          }
        }
        function d3_geo_pointInPolygon(point, polygon) {
          var meridian = point[0], parallel = point[1], meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0], polarAngle = 0, winding = 0;
          d3_geo_areaRingSum.reset();
          for (var i5 = 0, n2 = polygon.length; i5 < n2; ++i5) {
            var ring = polygon[i5], m5 = ring.length;
            if (!m5) continue;
            var point0 = ring[0], \u03BB0 = point0[0], \u03C60 = point0[1] / 2 + \u03C0 / 4, sin\u03C60 = Math.sin(\u03C60), cos\u03C60 = Math.cos(\u03C60), j2 = 1;
            while (true) {
              if (j2 === m5) j2 = 0;
              point = ring[j2];
              var \u03BB = point[0], \u03C6 = point[1] / 2 + \u03C0 / 4, sin\u03C6 = Math.sin(\u03C6), cos\u03C6 = Math.cos(\u03C6), d\u03BB = \u03BB - \u03BB0, sd\u03BB = d\u03BB >= 0 ? 1 : -1, ad\u03BB = sd\u03BB * d\u03BB, antimeridian = ad\u03BB > \u03C0, k = sin\u03C60 * sin\u03C6;
              d3_geo_areaRingSum.add(Math.atan2(k * sd\u03BB * Math.sin(ad\u03BB), cos\u03C60 * cos\u03C6 + k * Math.cos(ad\u03BB)));
              polarAngle += antimeridian ? d\u03BB + sd\u03BB * \u03C4 : d\u03BB;
              if (antimeridian ^ \u03BB0 >= meridian ^ \u03BB >= meridian) {
                var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                d3_geo_cartesianNormalize(arc);
                var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                d3_geo_cartesianNormalize(intersection);
                var \u03C6arc = (antimeridian ^ d\u03BB >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                if (parallel > \u03C6arc || parallel === \u03C6arc && (arc[0] || arc[1])) {
                  winding += antimeridian ^ d\u03BB >= 0 ? 1 : -1;
                }
              }
              if (!j2++) break;
              \u03BB0 = \u03BB, sin\u03C60 = sin\u03C6, cos\u03C60 = cos\u03C6, point0 = point;
            }
          }
          return (polarAngle < -\u03B5 || polarAngle < \u03B5 && d3_geo_areaRingSum < -\u03B5) ^ winding & 1;
        }
        function d3_geo_clipCircle(radius) {
          var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > \u03B5, interpolate3 = d3_geo_circleInterpolate(radius, 6 * d3_radians);
          return d3_geo_clip(visible, clipLine, interpolate3, smallRadius ? [0, -radius] : [-\u03C0, radius - \u03C0]);
          function visible(\u03BB, \u03C6) {
            return Math.cos(\u03BB) * Math.cos(\u03C6) > cr;
          }
          function clipLine(listener) {
            var point0, c0, v0, v00, clean;
            return {
              lineStart: function() {
                v00 = v0 = false;
                clean = 1;
              },
              point: function(\u03BB, \u03C6) {
                var point1 = [\u03BB, \u03C6], point2, v3 = visible(\u03BB, \u03C6), c3 = smallRadius ? v3 ? 0 : code(\u03BB, \u03C6) : v3 ? code(\u03BB + (\u03BB < 0 ? \u03C0 : -\u03C0), \u03C6) : 0;
                if (!point0 && (v00 = v0 = v3)) listener.lineStart();
                if (v3 !== v0) {
                  point2 = intersect(point0, point1);
                  if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                    point1[0] += \u03B5;
                    point1[1] += \u03B5;
                    v3 = visible(point1[0], point1[1]);
                  }
                }
                if (v3 !== v0) {
                  clean = 0;
                  if (v3) {
                    listener.lineStart();
                    point2 = intersect(point1, point0);
                    listener.point(point2[0], point2[1]);
                  } else {
                    point2 = intersect(point0, point1);
                    listener.point(point2[0], point2[1]);
                    listener.lineEnd();
                  }
                  point0 = point2;
                } else if (notHemisphere && point0 && smallRadius ^ v3) {
                  var t7;
                  if (!(c3 & c0) && (t7 = intersect(point1, point0, true))) {
                    clean = 0;
                    if (smallRadius) {
                      listener.lineStart();
                      listener.point(t7[0][0], t7[0][1]);
                      listener.point(t7[1][0], t7[1][1]);
                      listener.lineEnd();
                    } else {
                      listener.point(t7[1][0], t7[1][1]);
                      listener.lineEnd();
                      listener.lineStart();
                      listener.point(t7[0][0], t7[0][1]);
                    }
                  }
                }
                if (v3 && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                  listener.point(point1[0], point1[1]);
                }
                point0 = point1, v0 = v3, c0 = c3;
              },
              lineEnd: function() {
                if (v0) listener.lineEnd();
                point0 = null;
              },
              clean: function() {
                return clean | (v00 && v0) << 1;
              }
            };
          }
          function intersect(a3, b2, two) {
            var pa = d3_geo_cartesian(a3), pb = d3_geo_cartesian(b2);
            var n1 = [1, 0, 0], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant) return !two && a3;
            var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A3 = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c22);
            d3_geo_cartesianAdd(A3, B);
            var u4 = n1xn2, w3 = d3_geo_cartesianDot(A3, u4), uu = d3_geo_cartesianDot(u4, u4), t22 = w3 * w3 - uu * (d3_geo_cartesianDot(A3, A3) - 1);
            if (t22 < 0) return;
            var t7 = Math.sqrt(t22), q3 = d3_geo_cartesianScale(u4, (-w3 - t7) / uu);
            d3_geo_cartesianAdd(q3, A3);
            q3 = d3_geo_spherical(q3);
            if (!two) return q3;
            var \u03BB0 = a3[0], \u03BB1 = b2[0], \u03C60 = a3[1], \u03C61 = b2[1], z2;
            if (\u03BB1 < \u03BB0) z2 = \u03BB0, \u03BB0 = \u03BB1, \u03BB1 = z2;
            var \u03B4\u03BB = \u03BB1 - \u03BB0, polar = abs(\u03B4\u03BB - \u03C0) < \u03B5, meridian = polar || \u03B4\u03BB < \u03B5;
            if (!polar && \u03C61 < \u03C60) z2 = \u03C60, \u03C60 = \u03C61, \u03C61 = z2;
            if (meridian ? polar ? \u03C60 + \u03C61 > 0 ^ q3[1] < (abs(q3[0] - \u03BB0) < \u03B5 ? \u03C60 : \u03C61) : \u03C60 <= q3[1] && q3[1] <= \u03C61 : \u03B4\u03BB > \u03C0 ^ (\u03BB0 <= q3[0] && q3[0] <= \u03BB1)) {
              var q1 = d3_geo_cartesianScale(u4, (-w3 + t7) / uu);
              d3_geo_cartesianAdd(q1, A3);
              return [q3, d3_geo_spherical(q1)];
            }
          }
          function code(\u03BB, \u03C6) {
            var r6 = smallRadius ? radius : \u03C0 - radius, code2 = 0;
            if (\u03BB < -r6) code2 |= 1;
            else if (\u03BB > r6) code2 |= 2;
            if (\u03C6 < -r6) code2 |= 4;
            else if (\u03C6 > r6) code2 |= 8;
            return code2;
          }
        }
        function d3_geom_clipLine(x0, y0, x1, y1) {
          return function(line) {
            var a3 = line.a, b2 = line.b, ax = a3.x, ay = a3.y, bx = b2.x, by = b2.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r6;
            r6 = x0 - ax;
            if (!dx && r6 > 0) return;
            r6 /= dx;
            if (dx < 0) {
              if (r6 < t0) return;
              if (r6 < t1) t1 = r6;
            } else if (dx > 0) {
              if (r6 > t1) return;
              if (r6 > t0) t0 = r6;
            }
            r6 = x1 - ax;
            if (!dx && r6 < 0) return;
            r6 /= dx;
            if (dx < 0) {
              if (r6 > t1) return;
              if (r6 > t0) t0 = r6;
            } else if (dx > 0) {
              if (r6 < t0) return;
              if (r6 < t1) t1 = r6;
            }
            r6 = y0 - ay;
            if (!dy && r6 > 0) return;
            r6 /= dy;
            if (dy < 0) {
              if (r6 < t0) return;
              if (r6 < t1) t1 = r6;
            } else if (dy > 0) {
              if (r6 > t1) return;
              if (r6 > t0) t0 = r6;
            }
            r6 = y1 - ay;
            if (!dy && r6 < 0) return;
            r6 /= dy;
            if (dy < 0) {
              if (r6 > t1) return;
              if (r6 > t0) t0 = r6;
            } else if (dy > 0) {
              if (r6 < t0) return;
              if (r6 < t1) t1 = r6;
            }
            if (t0 > 0) line.a = {
              x: ax + t0 * dx,
              y: ay + t0 * dy
            };
            if (t1 < 1) line.b = {
              x: ax + t1 * dx,
              y: ay + t1 * dy
            };
            return line;
          };
        }
        var d3_geo_clipExtentMAX = 1e9;
        d33.geo.clipExtent = function() {
          var x0, y0, x1, y1, stream, clip, clipExtent = {
            stream: function(output) {
              if (stream) stream.valid = false;
              stream = clip(output);
              stream.valid = true;
              return stream;
            },
            extent: function(_2) {
              if (!arguments.length) return [[x0, y0], [x1, y1]];
              clip = d3_geo_clipExtent(x0 = +_2[0][0], y0 = +_2[0][1], x1 = +_2[1][0], y1 = +_2[1][1]);
              if (stream) stream.valid = false, stream = null;
              return clipExtent;
            }
          };
          return clipExtent.extent([[0, 0], [960, 500]]);
        };
        function d3_geo_clipExtent(x0, y0, x1, y1) {
          return function(listener) {
            var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
            var clip = {
              point,
              lineStart,
              lineEnd,
              polygonStart: function() {
                listener = bufferListener;
                segments = [];
                polygon = [];
                clean = true;
              },
              polygonEnd: function() {
                listener = listener_;
                segments = d33.merge(segments);
                var clipStartInside = insidePolygon([x0, y1]), inside = clean && clipStartInside, visible = segments.length;
                if (inside || visible) {
                  listener.polygonStart();
                  if (inside) {
                    listener.lineStart();
                    interpolate3(null, null, 1, listener);
                    listener.lineEnd();
                  }
                  if (visible) {
                    d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate3, listener);
                  }
                  listener.polygonEnd();
                }
                segments = polygon = ring = null;
              }
            };
            function insidePolygon(p3) {
              var wn = 0, n2 = polygon.length, y2 = p3[1];
              for (var i5 = 0; i5 < n2; ++i5) {
                for (var j2 = 1, v3 = polygon[i5], m5 = v3.length, a3 = v3[0], b2; j2 < m5; ++j2) {
                  b2 = v3[j2];
                  if (a3[1] <= y2) {
                    if (b2[1] > y2 && d3_cross2d(a3, b2, p3) > 0) ++wn;
                  } else {
                    if (b2[1] <= y2 && d3_cross2d(a3, b2, p3) < 0) --wn;
                  }
                  a3 = b2;
                }
              }
              return wn !== 0;
            }
            function interpolate3(from2, to2, direction, listener2) {
              var a3 = 0, a1 = 0;
              if (from2 == null || (a3 = corner(from2, direction)) !== (a1 = corner(to2, direction)) || comparePoints(from2, to2) < 0 ^ direction > 0) {
                do {
                  listener2.point(a3 === 0 || a3 === 3 ? x0 : x1, a3 > 1 ? y1 : y0);
                } while ((a3 = (a3 + direction + 4) % 4) !== a1);
              } else {
                listener2.point(to2[0], to2[1]);
              }
            }
            function pointVisible(x3, y2) {
              return x0 <= x3 && x3 <= x1 && y0 <= y2 && y2 <= y1;
            }
            function point(x3, y2) {
              if (pointVisible(x3, y2)) listener.point(x3, y2);
            }
            var x__, y__, v__, x_, y_, v_, first, clean;
            function lineStart() {
              clip.point = linePoint;
              if (polygon) polygon.push(ring = []);
              first = true;
              v_ = false;
              x_ = y_ = NaN;
            }
            function lineEnd() {
              if (segments) {
                linePoint(x__, y__);
                if (v__ && v_) bufferListener.rejoin();
                segments.push(bufferListener.buffer());
              }
              clip.point = point;
              if (v_) listener.lineEnd();
            }
            function linePoint(x3, y2) {
              x3 = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x3));
              y2 = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y2));
              var v3 = pointVisible(x3, y2);
              if (polygon) ring.push([x3, y2]);
              if (first) {
                x__ = x3, y__ = y2, v__ = v3;
                first = false;
                if (v3) {
                  listener.lineStart();
                  listener.point(x3, y2);
                }
              } else {
                if (v3 && v_) listener.point(x3, y2);
                else {
                  var l6 = {
                    a: {
                      x: x_,
                      y: y_
                    },
                    b: {
                      x: x3,
                      y: y2
                    }
                  };
                  if (clipLine(l6)) {
                    if (!v_) {
                      listener.lineStart();
                      listener.point(l6.a.x, l6.a.y);
                    }
                    listener.point(l6.b.x, l6.b.y);
                    if (!v3) listener.lineEnd();
                    clean = false;
                  } else if (v3) {
                    listener.lineStart();
                    listener.point(x3, y2);
                    clean = false;
                  }
                }
              }
              x_ = x3, y_ = y2, v_ = v3;
            }
            return clip;
          };
          function corner(p3, direction) {
            return abs(p3[0] - x0) < \u03B5 ? direction > 0 ? 0 : 3 : abs(p3[0] - x1) < \u03B5 ? direction > 0 ? 2 : 1 : abs(p3[1] - y0) < \u03B5 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
          }
          function compare(a3, b2) {
            return comparePoints(a3.x, b2.x);
          }
          function comparePoints(a3, b2) {
            var ca = corner(a3, 1), cb = corner(b2, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b2[1] - a3[1] : ca === 1 ? a3[0] - b2[0] : ca === 2 ? a3[1] - b2[1] : b2[0] - a3[0];
          }
        }
        function d3_geo_conic(projectAt) {
          var \u03C60 = 0, \u03C61 = \u03C0 / 3, m5 = d3_geo_projectionMutator(projectAt), p3 = m5(\u03C60, \u03C61);
          p3.parallels = function(_2) {
            if (!arguments.length) return [\u03C60 / \u03C0 * 180, \u03C61 / \u03C0 * 180];
            return m5(\u03C60 = _2[0] * \u03C0 / 180, \u03C61 = _2[1] * \u03C0 / 180);
          };
          return p3;
        }
        function d3_geo_conicEqualArea(\u03C60, \u03C61) {
          var sin\u03C60 = Math.sin(\u03C60), n2 = (sin\u03C60 + Math.sin(\u03C61)) / 2, C2 = 1 + sin\u03C60 * (2 * n2 - sin\u03C60), \u03C10 = Math.sqrt(C2) / n2;
          function forward(\u03BB, \u03C6) {
            var \u03C13 = Math.sqrt(C2 - 2 * n2 * Math.sin(\u03C6)) / n2;
            return [\u03C13 * Math.sin(\u03BB *= n2), \u03C10 - \u03C13 * Math.cos(\u03BB)];
          }
          forward.invert = function(x3, y2) {
            var \u03C10_y = \u03C10 - y2;
            return [Math.atan2(x3, \u03C10_y) / n2, d3_asin((C2 - (x3 * x3 + \u03C10_y * \u03C10_y) * n2 * n2) / (2 * n2))];
          };
          return forward;
        }
        (d33.geo.conicEqualArea = function() {
          return d3_geo_conic(d3_geo_conicEqualArea);
        }).raw = d3_geo_conicEqualArea;
        d33.geo.albers = function() {
          return d33.geo.conicEqualArea().rotate([96, 0]).center([-0.6, 38.7]).parallels([29.5, 45.5]).scale(1070);
        };
        d33.geo.albersUsa = function() {
          var lower48 = d33.geo.albers();
          var alaska = d33.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]);
          var hawaii = d33.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]);
          var point, pointStream = {
            point: function(x3, y2) {
              point = [x3, y2];
            }
          }, lower48Point, alaskaPoint, hawaiiPoint;
          function albersUsa(coordinates) {
            var x3 = coordinates[0], y2 = coordinates[1];
            point = null;
            (lower48Point(x3, y2), point) || (alaskaPoint(x3, y2), point) || hawaiiPoint(x3, y2);
            return point;
          }
          albersUsa.invert = function(coordinates) {
            var k = lower48.scale(), t7 = lower48.translate(), x3 = (coordinates[0] - t7[0]) / k, y2 = (coordinates[1] - t7[1]) / k;
            return (y2 >= 0.12 && y2 < 0.234 && x3 >= -0.425 && x3 < -0.214 ? alaska : y2 >= 0.166 && y2 < 0.234 && x3 >= -0.214 && x3 < -0.115 ? hawaii : lower48).invert(coordinates);
          };
          albersUsa.stream = function(stream) {
            var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
            return {
              point: function(x3, y2) {
                lower48Stream.point(x3, y2);
                alaskaStream.point(x3, y2);
                hawaiiStream.point(x3, y2);
              },
              sphere: function() {
                lower48Stream.sphere();
                alaskaStream.sphere();
                hawaiiStream.sphere();
              },
              lineStart: function() {
                lower48Stream.lineStart();
                alaskaStream.lineStart();
                hawaiiStream.lineStart();
              },
              lineEnd: function() {
                lower48Stream.lineEnd();
                alaskaStream.lineEnd();
                hawaiiStream.lineEnd();
              },
              polygonStart: function() {
                lower48Stream.polygonStart();
                alaskaStream.polygonStart();
                hawaiiStream.polygonStart();
              },
              polygonEnd: function() {
                lower48Stream.polygonEnd();
                alaskaStream.polygonEnd();
                hawaiiStream.polygonEnd();
              }
            };
          };
          albersUsa.precision = function(_2) {
            if (!arguments.length) return lower48.precision();
            lower48.precision(_2);
            alaska.precision(_2);
            hawaii.precision(_2);
            return albersUsa;
          };
          albersUsa.scale = function(_2) {
            if (!arguments.length) return lower48.scale();
            lower48.scale(_2);
            alaska.scale(_2 * 0.35);
            hawaii.scale(_2);
            return albersUsa.translate(lower48.translate());
          };
          albersUsa.translate = function(_2) {
            if (!arguments.length) return lower48.translate();
            var k = lower48.scale(), x3 = +_2[0], y2 = +_2[1];
            lower48Point = lower48.translate(_2).clipExtent([[x3 - 0.455 * k, y2 - 0.238 * k], [x3 + 0.455 * k, y2 + 0.238 * k]]).stream(pointStream).point;
            alaskaPoint = alaska.translate([x3 - 0.307 * k, y2 + 0.201 * k]).clipExtent([[x3 - 0.425 * k + \u03B5, y2 + 0.12 * k + \u03B5], [x3 - 0.214 * k - \u03B5, y2 + 0.234 * k - \u03B5]]).stream(pointStream).point;
            hawaiiPoint = hawaii.translate([x3 - 0.205 * k, y2 + 0.212 * k]).clipExtent([[x3 - 0.214 * k + \u03B5, y2 + 0.166 * k + \u03B5], [x3 - 0.115 * k - \u03B5, y2 + 0.234 * k - \u03B5]]).stream(pointStream).point;
            return albersUsa;
          };
          return albersUsa.scale(1070);
        };
        var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
          point: d3_noop,
          lineStart: d3_noop,
          lineEnd: d3_noop,
          polygonStart: function() {
            d3_geo_pathAreaPolygon = 0;
            d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
          },
          polygonEnd: function() {
            d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
            d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
          }
        };
        function d3_geo_pathAreaRingStart() {
          var x00, y00, x0, y0;
          d3_geo_pathArea.point = function(x3, y2) {
            d3_geo_pathArea.point = nextPoint;
            x00 = x0 = x3, y00 = y0 = y2;
          };
          function nextPoint(x3, y2) {
            d3_geo_pathAreaPolygon += y0 * x3 - x0 * y2;
            x0 = x3, y0 = y2;
          }
          d3_geo_pathArea.lineEnd = function() {
            nextPoint(x00, y00);
          };
        }
        var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
        var d3_geo_pathBounds = {
          point: d3_geo_pathBoundsPoint,
          lineStart: d3_noop,
          lineEnd: d3_noop,
          polygonStart: d3_noop,
          polygonEnd: d3_noop
        };
        function d3_geo_pathBoundsPoint(x3, y2) {
          if (x3 < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x3;
          if (x3 > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x3;
          if (y2 < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y2;
          if (y2 > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y2;
        }
        function d3_geo_pathBuffer() {
          var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
          var stream = {
            point,
            lineStart: function() {
              stream.point = pointLineStart;
            },
            lineEnd,
            polygonStart: function() {
              stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
              stream.lineEnd = lineEnd;
              stream.point = point;
            },
            pointRadius: function(_2) {
              pointCircle = d3_geo_pathBufferCircle(_2);
              return stream;
            },
            result: function() {
              if (buffer.length) {
                var result = buffer.join("");
                buffer = [];
                return result;
              }
            }
          };
          function point(x3, y2) {
            buffer.push("M", x3, ",", y2, pointCircle);
          }
          function pointLineStart(x3, y2) {
            buffer.push("M", x3, ",", y2);
            stream.point = pointLine;
          }
          function pointLine(x3, y2) {
            buffer.push("L", x3, ",", y2);
          }
          function lineEnd() {
            stream.point = point;
          }
          function lineEndPolygon() {
            buffer.push("Z");
          }
          return stream;
        }
        function d3_geo_pathBufferCircle(radius) {
          return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
        }
        var d3_geo_pathCentroid = {
          point: d3_geo_pathCentroidPoint,
          lineStart: d3_geo_pathCentroidLineStart,
          lineEnd: d3_geo_pathCentroidLineEnd,
          polygonStart: function() {
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
          },
          polygonEnd: function() {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
            d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
          }
        };
        function d3_geo_pathCentroidPoint(x3, y2) {
          d3_geo_centroidX0 += x3;
          d3_geo_centroidY0 += y2;
          ++d3_geo_centroidZ0;
        }
        function d3_geo_pathCentroidLineStart() {
          var x0, y0;
          d3_geo_pathCentroid.point = function(x3, y2) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x0 = x3, y0 = y2);
          };
          function nextPoint(x3, y2) {
            var dx = x3 - x0, dy = y2 - y0, z2 = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z2 * (x0 + x3) / 2;
            d3_geo_centroidY1 += z2 * (y0 + y2) / 2;
            d3_geo_centroidZ1 += z2;
            d3_geo_pathCentroidPoint(x0 = x3, y0 = y2);
          }
        }
        function d3_geo_pathCentroidLineEnd() {
          d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
        }
        function d3_geo_pathCentroidRingStart() {
          var x00, y00, x0, y0;
          d3_geo_pathCentroid.point = function(x3, y2) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x00 = x0 = x3, y00 = y0 = y2);
          };
          function nextPoint(x3, y2) {
            var dx = x3 - x0, dy = y2 - y0, z2 = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z2 * (x0 + x3) / 2;
            d3_geo_centroidY1 += z2 * (y0 + y2) / 2;
            d3_geo_centroidZ1 += z2;
            z2 = y0 * x3 - x0 * y2;
            d3_geo_centroidX2 += z2 * (x0 + x3);
            d3_geo_centroidY2 += z2 * (y0 + y2);
            d3_geo_centroidZ2 += z2 * 3;
            d3_geo_pathCentroidPoint(x0 = x3, y0 = y2);
          }
          d3_geo_pathCentroid.lineEnd = function() {
            nextPoint(x00, y00);
          };
        }
        function d3_geo_pathContext(context) {
          var pointRadius = 4.5;
          var stream = {
            point,
            lineStart: function() {
              stream.point = pointLineStart;
            },
            lineEnd,
            polygonStart: function() {
              stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function() {
              stream.lineEnd = lineEnd;
              stream.point = point;
            },
            pointRadius: function(_2) {
              pointRadius = _2;
              return stream;
            },
            result: d3_noop
          };
          function point(x3, y2) {
            context.moveTo(x3 + pointRadius, y2);
            context.arc(x3, y2, pointRadius, 0, \u03C4);
          }
          function pointLineStart(x3, y2) {
            context.moveTo(x3, y2);
            stream.point = pointLine;
          }
          function pointLine(x3, y2) {
            context.lineTo(x3, y2);
          }
          function lineEnd() {
            stream.point = point;
          }
          function lineEndPolygon() {
            context.closePath();
          }
          return stream;
        }
        function d3_geo_resample(project) {
          var \u03B42 = 0.5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
          function resample(stream) {
            return (maxDepth ? resampleRecursive : resampleNone)(stream);
          }
          function resampleNone(stream) {
            return d3_geo_transformPoint(stream, function(x3, y2) {
              x3 = project(x3, y2);
              stream.point(x3[0], x3[1]);
            });
          }
          function resampleRecursive(stream) {
            var \u03BB00, \u03C600, x00, y00, a00, b00, c00, \u03BB0, x0, y0, a0, b0, c0;
            var resample2 = {
              point,
              lineStart,
              lineEnd,
              polygonStart: function() {
                stream.polygonStart();
                resample2.lineStart = ringStart;
              },
              polygonEnd: function() {
                stream.polygonEnd();
                resample2.lineStart = lineStart;
              }
            };
            function point(x3, y2) {
              x3 = project(x3, y2);
              stream.point(x3[0], x3[1]);
            }
            function lineStart() {
              x0 = NaN;
              resample2.point = linePoint;
              stream.lineStart();
            }
            function linePoint(\u03BB, \u03C6) {
              var c3 = d3_geo_cartesian([\u03BB, \u03C6]), p3 = project(\u03BB, \u03C6);
              resampleLineTo(x0, y0, \u03BB0, a0, b0, c0, x0 = p3[0], y0 = p3[1], \u03BB0 = \u03BB, a0 = c3[0], b0 = c3[1], c0 = c3[2], maxDepth, stream);
              stream.point(x0, y0);
            }
            function lineEnd() {
              resample2.point = point;
              stream.lineEnd();
            }
            function ringStart() {
              lineStart();
              resample2.point = ringPoint;
              resample2.lineEnd = ringEnd;
            }
            function ringPoint(\u03BB, \u03C6) {
              linePoint(\u03BB00 = \u03BB, \u03C600 = \u03C6), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
              resample2.point = linePoint;
            }
            function ringEnd() {
              resampleLineTo(x0, y0, \u03BB0, a0, b0, c0, x00, y00, \u03BB00, a00, b00, c00, maxDepth, stream);
              resample2.lineEnd = lineEnd;
              lineEnd();
            }
            return resample2;
          }
          function resampleLineTo(x0, y0, \u03BB0, a0, b0, c0, x1, y1, \u03BB1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d22 = dx * dx + dy * dy;
            if (d22 > 4 * \u03B42 && depth--) {
              var a3 = a0 + a1, b2 = b0 + b1, c3 = c0 + c1, m5 = Math.sqrt(a3 * a3 + b2 * b2 + c3 * c3), \u03C62 = Math.asin(c3 /= m5), \u03BB2 = abs(abs(c3) - 1) < \u03B5 || abs(\u03BB0 - \u03BB1) < \u03B5 ? (\u03BB0 + \u03BB1) / 2 : Math.atan2(b2, a3), p3 = project(\u03BB2, \u03C62), x22 = p3[0], y2 = p3[1], dx2 = x22 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
              if (dz * dz / d22 > \u03B42 || abs((dx * dx2 + dy * dy2) / d22 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                resampleLineTo(x0, y0, \u03BB0, a0, b0, c0, x22, y2, \u03BB2, a3 /= m5, b2 /= m5, c3, depth, stream);
                stream.point(x22, y2);
                resampleLineTo(x22, y2, \u03BB2, a3, b2, c3, x1, y1, \u03BB1, a1, b1, c1, depth, stream);
              }
            }
          }
          resample.precision = function(_2) {
            if (!arguments.length) return Math.sqrt(\u03B42);
            maxDepth = (\u03B42 = _2 * _2) > 0 && 16;
            return resample;
          };
          return resample;
        }
        d33.geo.path = function() {
          var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
          function path(object) {
            if (object) {
              if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
              if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
              d33.geo.stream(object, cacheStream);
            }
            return contextStream.result();
          }
          path.area = function(object) {
            d3_geo_pathAreaSum = 0;
            d33.geo.stream(object, projectStream(d3_geo_pathArea));
            return d3_geo_pathAreaSum;
          };
          path.centroid = function(object) {
            d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
            d33.geo.stream(object, projectStream(d3_geo_pathCentroid));
            return d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [NaN, NaN];
          };
          path.bounds = function(object) {
            d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
            d33.geo.stream(object, projectStream(d3_geo_pathBounds));
            return [[d3_geo_pathBoundsX0, d3_geo_pathBoundsY0], [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]];
          };
          path.projection = function(_2) {
            if (!arguments.length) return projection;
            projectStream = (projection = _2) ? _2.stream || d3_geo_pathProjectStream(_2) : d3_identity;
            return reset();
          };
          path.context = function(_2) {
            if (!arguments.length) return context;
            contextStream = (context = _2) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_2);
            if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
            return reset();
          };
          path.pointRadius = function(_2) {
            if (!arguments.length) return pointRadius;
            pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
            return path;
          };
          function reset() {
            cacheStream = null;
            return path;
          }
          return path.projection(d33.geo.albersUsa()).context(null);
        };
        function d3_geo_pathProjectStream(project) {
          var resample = d3_geo_resample(function(x3, y2) {
            return project([x3 * d3_degrees, y2 * d3_degrees]);
          });
          return function(stream) {
            return d3_geo_projectionRadians(resample(stream));
          };
        }
        d33.geo.transform = function(methods) {
          return {
            stream: function(stream) {
              var transform = new d3_geo_transform(stream);
              for (var k in methods) transform[k] = methods[k];
              return transform;
            }
          };
        };
        function d3_geo_transform(stream) {
          this.stream = stream;
        }
        d3_geo_transform.prototype = {
          point: function(x3, y2) {
            this.stream.point(x3, y2);
          },
          sphere: function() {
            this.stream.sphere();
          },
          lineStart: function() {
            this.stream.lineStart();
          },
          lineEnd: function() {
            this.stream.lineEnd();
          },
          polygonStart: function() {
            this.stream.polygonStart();
          },
          polygonEnd: function() {
            this.stream.polygonEnd();
          }
        };
        function d3_geo_transformPoint(stream, point) {
          return {
            point,
            sphere: function() {
              stream.sphere();
            },
            lineStart: function() {
              stream.lineStart();
            },
            lineEnd: function() {
              stream.lineEnd();
            },
            polygonStart: function() {
              stream.polygonStart();
            },
            polygonEnd: function() {
              stream.polygonEnd();
            }
          };
        }
        d33.geo.projection = d3_geo_projection;
        d33.geo.projectionMutator = d3_geo_projectionMutator;
        function d3_geo_projection(project) {
          return d3_geo_projectionMutator(function() {
            return project;
          })();
        }
        function d3_geo_projectionMutator(projectAt) {
          var project, rotate2, projectRotate, projectResample = d3_geo_resample(function(x4, y3) {
            x4 = project(x4, y3);
            return [x4[0] * k + \u03B4x, \u03B4y - x4[1] * k];
          }), k = 150, x3 = 480, y2 = 250, \u03BB = 0, \u03C6 = 0, \u03B4\u03BB = 0, \u03B4\u03C6 = 0, \u03B4\u03B3 = 0, \u03B4x, \u03B4y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
          function projection(point) {
            point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
            return [point[0] * k + \u03B4x, \u03B4y - point[1] * k];
          }
          function invert(point) {
            point = projectRotate.invert((point[0] - \u03B4x) / k, (\u03B4y - point[1]) / k);
            return point && [point[0] * d3_degrees, point[1] * d3_degrees];
          }
          projection.stream = function(output) {
            if (stream) stream.valid = false;
            stream = d3_geo_projectionRadians(preclip(rotate2, projectResample(postclip(output))));
            stream.valid = true;
            return stream;
          };
          projection.clipAngle = function(_2) {
            if (!arguments.length) return clipAngle;
            preclip = _2 == null ? (clipAngle = _2, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_2) * d3_radians);
            return invalidate();
          };
          projection.clipExtent = function(_2) {
            if (!arguments.length) return clipExtent;
            clipExtent = _2;
            postclip = _2 ? d3_geo_clipExtent(_2[0][0], _2[0][1], _2[1][0], _2[1][1]) : d3_identity;
            return invalidate();
          };
          projection.scale = function(_2) {
            if (!arguments.length) return k;
            k = +_2;
            return reset();
          };
          projection.translate = function(_2) {
            if (!arguments.length) return [x3, y2];
            x3 = +_2[0];
            y2 = +_2[1];
            return reset();
          };
          projection.center = function(_2) {
            if (!arguments.length) return [\u03BB * d3_degrees, \u03C6 * d3_degrees];
            \u03BB = _2[0] % 360 * d3_radians;
            \u03C6 = _2[1] % 360 * d3_radians;
            return reset();
          };
          projection.rotate = function(_2) {
            if (!arguments.length) return [\u03B4\u03BB * d3_degrees, \u03B4\u03C6 * d3_degrees, \u03B4\u03B3 * d3_degrees];
            \u03B4\u03BB = _2[0] % 360 * d3_radians;
            \u03B4\u03C6 = _2[1] % 360 * d3_radians;
            \u03B4\u03B3 = _2.length > 2 ? _2[2] % 360 * d3_radians : 0;
            return reset();
          };
          d33.rebind(projection, projectResample, "precision");
          function reset() {
            projectRotate = d3_geo_compose(rotate2 = d3_geo_rotation(\u03B4\u03BB, \u03B4\u03C6, \u03B4\u03B3), project);
            var center = project(\u03BB, \u03C6);
            \u03B4x = x3 - center[0] * k;
            \u03B4y = y2 + center[1] * k;
            return invalidate();
          }
          function invalidate() {
            if (stream) stream.valid = false, stream = null;
            return projection;
          }
          return function() {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return reset();
          };
        }
        function d3_geo_projectionRadians(stream) {
          return d3_geo_transformPoint(stream, function(x3, y2) {
            stream.point(x3 * d3_radians, y2 * d3_radians);
          });
        }
        function d3_geo_equirectangular(\u03BB, \u03C6) {
          return [\u03BB, \u03C6];
        }
        (d33.geo.equirectangular = function() {
          return d3_geo_projection(d3_geo_equirectangular);
        }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
        d33.geo.rotation = function(rotate2) {
          rotate2 = d3_geo_rotation(rotate2[0] % 360 * d3_radians, rotate2[1] * d3_radians, rotate2.length > 2 ? rotate2[2] * d3_radians : 0);
          function forward(coordinates) {
            coordinates = rotate2(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
          }
          forward.invert = function(coordinates) {
            coordinates = rotate2.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
          };
          return forward;
        };
        function d3_geo_identityRotation(\u03BB, \u03C6) {
          return [\u03BB > \u03C0 ? \u03BB - \u03C4 : \u03BB < -\u03C0 ? \u03BB + \u03C4 : \u03BB, \u03C6];
        }
        d3_geo_identityRotation.invert = d3_geo_equirectangular;
        function d3_geo_rotation(\u03B4\u03BB, \u03B4\u03C6, \u03B4\u03B3) {
          return \u03B4\u03BB ? \u03B4\u03C6 || \u03B4\u03B3 ? d3_geo_compose(d3_geo_rotation\u03BB(\u03B4\u03BB), d3_geo_rotation\u03C6\u03B3(\u03B4\u03C6, \u03B4\u03B3)) : d3_geo_rotation\u03BB(\u03B4\u03BB) : \u03B4\u03C6 || \u03B4\u03B3 ? d3_geo_rotation\u03C6\u03B3(\u03B4\u03C6, \u03B4\u03B3) : d3_geo_identityRotation;
        }
        function d3_geo_forwardRotation\u03BB(\u03B4\u03BB) {
          return function(\u03BB, \u03C6) {
            return \u03BB += \u03B4\u03BB, [\u03BB > \u03C0 ? \u03BB - \u03C4 : \u03BB < -\u03C0 ? \u03BB + \u03C4 : \u03BB, \u03C6];
          };
        }
        function d3_geo_rotation\u03BB(\u03B4\u03BB) {
          var rotation = d3_geo_forwardRotation\u03BB(\u03B4\u03BB);
          rotation.invert = d3_geo_forwardRotation\u03BB(-\u03B4\u03BB);
          return rotation;
        }
        function d3_geo_rotation\u03C6\u03B3(\u03B4\u03C6, \u03B4\u03B3) {
          var cos\u03B4\u03C6 = Math.cos(\u03B4\u03C6), sin\u03B4\u03C6 = Math.sin(\u03B4\u03C6), cos\u03B4\u03B3 = Math.cos(\u03B4\u03B3), sin\u03B4\u03B3 = Math.sin(\u03B4\u03B3);
          function rotation(\u03BB, \u03C6) {
            var cos\u03C6 = Math.cos(\u03C6), x3 = Math.cos(\u03BB) * cos\u03C6, y2 = Math.sin(\u03BB) * cos\u03C6, z2 = Math.sin(\u03C6), k = z2 * cos\u03B4\u03C6 + x3 * sin\u03B4\u03C6;
            return [Math.atan2(y2 * cos\u03B4\u03B3 - k * sin\u03B4\u03B3, x3 * cos\u03B4\u03C6 - z2 * sin\u03B4\u03C6), d3_asin(k * cos\u03B4\u03B3 + y2 * sin\u03B4\u03B3)];
          }
          rotation.invert = function(\u03BB, \u03C6) {
            var cos\u03C6 = Math.cos(\u03C6), x3 = Math.cos(\u03BB) * cos\u03C6, y2 = Math.sin(\u03BB) * cos\u03C6, z2 = Math.sin(\u03C6), k = z2 * cos\u03B4\u03B3 - y2 * sin\u03B4\u03B3;
            return [Math.atan2(y2 * cos\u03B4\u03B3 + z2 * sin\u03B4\u03B3, x3 * cos\u03B4\u03C6 + k * sin\u03B4\u03C6), d3_asin(k * cos\u03B4\u03C6 - x3 * sin\u03B4\u03C6)];
          };
          return rotation;
        }
        d33.geo.circle = function() {
          var origin = [0, 0], angle, precision = 6, interpolate3;
          function circle() {
            var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate2 = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
            interpolate3(null, null, 1, {
              point: function(x3, y2) {
                ring.push(x3 = rotate2(x3, y2));
                x3[0] *= d3_degrees, x3[1] *= d3_degrees;
              }
            });
            return {
              type: "Polygon",
              coordinates: [ring]
            };
          }
          circle.origin = function(x3) {
            if (!arguments.length) return origin;
            origin = x3;
            return circle;
          };
          circle.angle = function(x3) {
            if (!arguments.length) return angle;
            interpolate3 = d3_geo_circleInterpolate((angle = +x3) * d3_radians, precision * d3_radians);
            return circle;
          };
          circle.precision = function(_2) {
            if (!arguments.length) return precision;
            interpolate3 = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_2) * d3_radians);
            return circle;
          };
          return circle.angle(90);
        };
        function d3_geo_circleInterpolate(radius, precision) {
          var cr = Math.cos(radius), sr = Math.sin(radius);
          return function(from2, to2, direction, listener) {
            var step = direction * precision;
            if (from2 != null) {
              from2 = d3_geo_circleAngle(cr, from2);
              to2 = d3_geo_circleAngle(cr, to2);
              if (direction > 0 ? from2 < to2 : from2 > to2) from2 += direction * \u03C4;
            } else {
              from2 = radius + direction * \u03C4;
              to2 = radius - 0.5 * step;
            }
            for (var point, t7 = from2; direction > 0 ? t7 > to2 : t7 < to2; t7 -= step) {
              listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t7), -sr * Math.sin(t7)]))[0], point[1]);
            }
          };
        }
        function d3_geo_circleAngle(cr, point) {
          var a3 = d3_geo_cartesian(point);
          a3[0] -= cr;
          d3_geo_cartesianNormalize(a3);
          var angle = d3_acos(-a3[1]);
          return ((-a3[2] < 0 ? -angle : angle) + 2 * Math.PI - \u03B5) % (2 * Math.PI);
        }
        d33.geo.distance = function(a3, b2) {
          var \u0394\u03BB = (b2[0] - a3[0]) * d3_radians, \u03C60 = a3[1] * d3_radians, \u03C61 = b2[1] * d3_radians, sin\u0394\u03BB = Math.sin(\u0394\u03BB), cos\u0394\u03BB = Math.cos(\u0394\u03BB), sin\u03C60 = Math.sin(\u03C60), cos\u03C60 = Math.cos(\u03C60), sin\u03C61 = Math.sin(\u03C61), cos\u03C61 = Math.cos(\u03C61), t7;
          return Math.atan2(Math.sqrt((t7 = cos\u03C61 * sin\u0394\u03BB) * t7 + (t7 = cos\u03C60 * sin\u03C61 - sin\u03C60 * cos\u03C61 * cos\u0394\u03BB) * t7), sin\u03C60 * sin\u03C61 + cos\u03C60 * cos\u03C61 * cos\u0394\u03BB);
        };
        d33.geo.graticule = function() {
          var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x3, y2, X4, Y2, precision = 2.5;
          function graticule() {
            return {
              type: "MultiLineString",
              coordinates: lines()
            };
          }
          function lines() {
            return d33.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X4).concat(d33.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y2)).concat(d33.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x4) {
              return abs(x4 % DX) > \u03B5;
            }).map(x3)).concat(d33.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y3) {
              return abs(y3 % DY) > \u03B5;
            }).map(y2));
          }
          graticule.lines = function() {
            return lines().map(function(coordinates) {
              return {
                type: "LineString",
                coordinates
              };
            });
          };
          graticule.outline = function() {
            return {
              type: "Polygon",
              coordinates: [X4(X0).concat(Y2(Y1).slice(1), X4(X1).reverse().slice(1), Y2(Y0).reverse().slice(1))]
            };
          };
          graticule.extent = function(_2) {
            if (!arguments.length) return graticule.minorExtent();
            return graticule.majorExtent(_2).minorExtent(_2);
          };
          graticule.majorExtent = function(_2) {
            if (!arguments.length) return [[X0, Y0], [X1, Y1]];
            X0 = +_2[0][0], X1 = +_2[1][0];
            Y0 = +_2[0][1], Y1 = +_2[1][1];
            if (X0 > X1) _2 = X0, X0 = X1, X1 = _2;
            if (Y0 > Y1) _2 = Y0, Y0 = Y1, Y1 = _2;
            return graticule.precision(precision);
          };
          graticule.minorExtent = function(_2) {
            if (!arguments.length) return [[x0, y0], [x1, y1]];
            x0 = +_2[0][0], x1 = +_2[1][0];
            y0 = +_2[0][1], y1 = +_2[1][1];
            if (x0 > x1) _2 = x0, x0 = x1, x1 = _2;
            if (y0 > y1) _2 = y0, y0 = y1, y1 = _2;
            return graticule.precision(precision);
          };
          graticule.step = function(_2) {
            if (!arguments.length) return graticule.minorStep();
            return graticule.majorStep(_2).minorStep(_2);
          };
          graticule.majorStep = function(_2) {
            if (!arguments.length) return [DX, DY];
            DX = +_2[0], DY = +_2[1];
            return graticule;
          };
          graticule.minorStep = function(_2) {
            if (!arguments.length) return [dx, dy];
            dx = +_2[0], dy = +_2[1];
            return graticule;
          };
          graticule.precision = function(_2) {
            if (!arguments.length) return precision;
            precision = +_2;
            x3 = d3_geo_graticuleX(y0, y1, 90);
            y2 = d3_geo_graticuleY(x0, x1, precision);
            X4 = d3_geo_graticuleX(Y0, Y1, 90);
            Y2 = d3_geo_graticuleY(X0, X1, precision);
            return graticule;
          };
          return graticule.majorExtent([[-180, -90 + \u03B5], [180, 90 - \u03B5]]).minorExtent([[-180, -80 - \u03B5], [180, 80 + \u03B5]]);
        };
        function d3_geo_graticuleX(y0, y1, dy) {
          var y2 = d33.range(y0, y1 - \u03B5, dy).concat(y1);
          return function(x3) {
            return y2.map(function(y3) {
              return [x3, y3];
            });
          };
        }
        function d3_geo_graticuleY(x0, x1, dx) {
          var x3 = d33.range(x0, x1 - \u03B5, dx).concat(x1);
          return function(y2) {
            return x3.map(function(x4) {
              return [x4, y2];
            });
          };
        }
        function d3_source(d5) {
          return d5.source;
        }
        function d3_target(d5) {
          return d5.target;
        }
        d33.geo.greatArc = function() {
          var source = d3_source, source_, target = d3_target, target_;
          function greatArc() {
            return {
              type: "LineString",
              coordinates: [source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)]
            };
          }
          greatArc.distance = function() {
            return d33.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
          };
          greatArc.source = function(_2) {
            if (!arguments.length) return source;
            source = _2, source_ = typeof _2 === "function" ? null : _2;
            return greatArc;
          };
          greatArc.target = function(_2) {
            if (!arguments.length) return target;
            target = _2, target_ = typeof _2 === "function" ? null : _2;
            return greatArc;
          };
          greatArc.precision = function() {
            return arguments.length ? greatArc : 0;
          };
          return greatArc;
        };
        d33.geo.interpolate = function(source, target) {
          return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
        };
        function d3_geo_interpolate(x0, y0, x1, y1) {
          var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d5 = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d5);
          var interpolate3 = d5 ? function(t7) {
            var B = Math.sin(t7 *= d5) * k, A3 = Math.sin(d5 - t7) * k, x3 = A3 * kx0 + B * kx1, y2 = A3 * ky0 + B * ky1, z2 = A3 * sy0 + B * sy1;
            return [Math.atan2(y2, x3) * d3_degrees, Math.atan2(z2, Math.sqrt(x3 * x3 + y2 * y2)) * d3_degrees];
          } : function() {
            return [x0 * d3_degrees, y0 * d3_degrees];
          };
          interpolate3.distance = d5;
          return interpolate3;
        }
        d33.geo.length = function(object) {
          d3_geo_lengthSum = 0;
          d33.geo.stream(object, d3_geo_length);
          return d3_geo_lengthSum;
        };
        var d3_geo_lengthSum;
        var d3_geo_length = {
          sphere: d3_noop,
          point: d3_noop,
          lineStart: d3_geo_lengthLineStart,
          lineEnd: d3_noop,
          polygonStart: d3_noop,
          polygonEnd: d3_noop
        };
        function d3_geo_lengthLineStart() {
          var \u03BB0, sin\u03C60, cos\u03C60;
          d3_geo_length.point = function(\u03BB, \u03C6) {
            \u03BB0 = \u03BB * d3_radians, sin\u03C60 = Math.sin(\u03C6 *= d3_radians), cos\u03C60 = Math.cos(\u03C6);
            d3_geo_length.point = nextPoint;
          };
          d3_geo_length.lineEnd = function() {
            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
          };
          function nextPoint(\u03BB, \u03C6) {
            var sin\u03C6 = Math.sin(\u03C6 *= d3_radians), cos\u03C6 = Math.cos(\u03C6), t7 = abs((\u03BB *= d3_radians) - \u03BB0), cos\u0394\u03BB = Math.cos(t7);
            d3_geo_lengthSum += Math.atan2(Math.sqrt((t7 = cos\u03C6 * Math.sin(t7)) * t7 + (t7 = cos\u03C60 * sin\u03C6 - sin\u03C60 * cos\u03C6 * cos\u0394\u03BB) * t7), sin\u03C60 * sin\u03C6 + cos\u03C60 * cos\u03C6 * cos\u0394\u03BB);
            \u03BB0 = \u03BB, sin\u03C60 = sin\u03C6, cos\u03C60 = cos\u03C6;
          }
        }
        function d3_geo_azimuthal(scale2, angle) {
          function azimuthal(\u03BB, \u03C6) {
            var cos\u03BB = Math.cos(\u03BB), cos\u03C6 = Math.cos(\u03C6), k = scale2(cos\u03BB * cos\u03C6);
            return [k * cos\u03C6 * Math.sin(\u03BB), k * Math.sin(\u03C6)];
          }
          azimuthal.invert = function(x3, y2) {
            var \u03C13 = Math.sqrt(x3 * x3 + y2 * y2), c3 = angle(\u03C13), sinc = Math.sin(c3), cosc = Math.cos(c3);
            return [Math.atan2(x3 * sinc, \u03C13 * cosc), Math.asin(\u03C13 && y2 * sinc / \u03C13)];
          };
          return azimuthal;
        }
        var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cos\u03BBcos\u03C6) {
          return Math.sqrt(2 / (1 + cos\u03BBcos\u03C6));
        }, function(\u03C13) {
          return 2 * Math.asin(\u03C13 / 2);
        });
        (d33.geo.azimuthalEqualArea = function() {
          return d3_geo_projection(d3_geo_azimuthalEqualArea);
        }).raw = d3_geo_azimuthalEqualArea;
        var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cos\u03BBcos\u03C6) {
          var c3 = Math.acos(cos\u03BBcos\u03C6);
          return c3 && c3 / Math.sin(c3);
        }, d3_identity);
        (d33.geo.azimuthalEquidistant = function() {
          return d3_geo_projection(d3_geo_azimuthalEquidistant);
        }).raw = d3_geo_azimuthalEquidistant;
        function d3_geo_conicConformal(\u03C60, \u03C61) {
          var cos\u03C60 = Math.cos(\u03C60), t7 = function(\u03C6) {
            return Math.tan(\u03C0 / 4 + \u03C6 / 2);
          }, n2 = \u03C60 === \u03C61 ? Math.sin(\u03C60) : Math.log(cos\u03C60 / Math.cos(\u03C61)) / Math.log(t7(\u03C61) / t7(\u03C60)), F4 = cos\u03C60 * Math.pow(t7(\u03C60), n2) / n2;
          if (!n2) return d3_geo_mercator;
          function forward(\u03BB, \u03C6) {
            if (F4 > 0) {
              if (\u03C6 < -half\u03C0 + \u03B5) \u03C6 = -half\u03C0 + \u03B5;
            } else {
              if (\u03C6 > half\u03C0 - \u03B5) \u03C6 = half\u03C0 - \u03B5;
            }
            var \u03C13 = F4 / Math.pow(t7(\u03C6), n2);
            return [\u03C13 * Math.sin(n2 * \u03BB), F4 - \u03C13 * Math.cos(n2 * \u03BB)];
          }
          forward.invert = function(x3, y2) {
            var \u03C10_y = F4 - y2, \u03C13 = d3_sgn(n2) * Math.sqrt(x3 * x3 + \u03C10_y * \u03C10_y);
            return [Math.atan2(x3, \u03C10_y) / n2, 2 * Math.atan(Math.pow(F4 / \u03C13, 1 / n2)) - half\u03C0];
          };
          return forward;
        }
        (d33.geo.conicConformal = function() {
          return d3_geo_conic(d3_geo_conicConformal);
        }).raw = d3_geo_conicConformal;
        function d3_geo_conicEquidistant(\u03C60, \u03C61) {
          var cos\u03C60 = Math.cos(\u03C60), n2 = \u03C60 === \u03C61 ? Math.sin(\u03C60) : (cos\u03C60 - Math.cos(\u03C61)) / (\u03C61 - \u03C60), G2 = cos\u03C60 / n2 + \u03C60;
          if (abs(n2) < \u03B5) return d3_geo_equirectangular;
          function forward(\u03BB, \u03C6) {
            var \u03C13 = G2 - \u03C6;
            return [\u03C13 * Math.sin(n2 * \u03BB), G2 - \u03C13 * Math.cos(n2 * \u03BB)];
          }
          forward.invert = function(x3, y2) {
            var \u03C10_y = G2 - y2;
            return [Math.atan2(x3, \u03C10_y) / n2, G2 - d3_sgn(n2) * Math.sqrt(x3 * x3 + \u03C10_y * \u03C10_y)];
          };
          return forward;
        }
        (d33.geo.conicEquidistant = function() {
          return d3_geo_conic(d3_geo_conicEquidistant);
        }).raw = d3_geo_conicEquidistant;
        var d3_geo_gnomonic = d3_geo_azimuthal(function(cos\u03BBcos\u03C6) {
          return 1 / cos\u03BBcos\u03C6;
        }, Math.atan);
        (d33.geo.gnomonic = function() {
          return d3_geo_projection(d3_geo_gnomonic);
        }).raw = d3_geo_gnomonic;
        function d3_geo_mercator(\u03BB, \u03C6) {
          return [\u03BB, Math.log(Math.tan(\u03C0 / 4 + \u03C6 / 2))];
        }
        d3_geo_mercator.invert = function(x3, y2) {
          return [x3, 2 * Math.atan(Math.exp(y2)) - half\u03C0];
        };
        function d3_geo_mercatorProjection(project) {
          var m5 = d3_geo_projection(project), scale2 = m5.scale, translate = m5.translate, clipExtent = m5.clipExtent, clipAuto;
          m5.scale = function() {
            var v3 = scale2.apply(m5, arguments);
            return v3 === m5 ? clipAuto ? m5.clipExtent(null) : m5 : v3;
          };
          m5.translate = function() {
            var v3 = translate.apply(m5, arguments);
            return v3 === m5 ? clipAuto ? m5.clipExtent(null) : m5 : v3;
          };
          m5.clipExtent = function(_2) {
            var v3 = clipExtent.apply(m5, arguments);
            if (v3 === m5) {
              if (clipAuto = _2 == null) {
                var k = \u03C0 * scale2(), t7 = translate();
                clipExtent([[t7[0] - k, t7[1] - k], [t7[0] + k, t7[1] + k]]);
              }
            } else if (clipAuto) {
              v3 = null;
            }
            return v3;
          };
          return m5.clipExtent(null);
        }
        (d33.geo.mercator = function() {
          return d3_geo_mercatorProjection(d3_geo_mercator);
        }).raw = d3_geo_mercator;
        var d3_geo_orthographic = d3_geo_azimuthal(function() {
          return 1;
        }, Math.asin);
        (d33.geo.orthographic = function() {
          return d3_geo_projection(d3_geo_orthographic);
        }).raw = d3_geo_orthographic;
        var d3_geo_stereographic = d3_geo_azimuthal(function(cos\u03BBcos\u03C6) {
          return 1 / (1 + cos\u03BBcos\u03C6);
        }, function(\u03C13) {
          return 2 * Math.atan(\u03C13);
        });
        (d33.geo.stereographic = function() {
          return d3_geo_projection(d3_geo_stereographic);
        }).raw = d3_geo_stereographic;
        function d3_geo_transverseMercator(\u03BB, \u03C6) {
          return [Math.log(Math.tan(\u03C0 / 4 + \u03C6 / 2)), -\u03BB];
        }
        d3_geo_transverseMercator.invert = function(x3, y2) {
          return [-y2, 2 * Math.atan(Math.exp(x3)) - half\u03C0];
        };
        (d33.geo.transverseMercator = function() {
          var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate2 = projection.rotate;
          projection.center = function(_2) {
            return _2 ? center([-_2[1], _2[0]]) : (_2 = center(), [_2[1], -_2[0]]);
          };
          projection.rotate = function(_2) {
            return _2 ? rotate2([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate2(), [_2[0], _2[1], _2[2] - 90]);
          };
          return rotate2([0, 0, 90]);
        }).raw = d3_geo_transverseMercator;
        d33.geom = {};
        function d3_geom_pointX(d5) {
          return d5[0];
        }
        function d3_geom_pointY(d5) {
          return d5[1];
        }
        d33.geom.hull = function(vertices) {
          var x3 = d3_geom_pointX, y2 = d3_geom_pointY;
          if (arguments.length) return hull(vertices);
          function hull(data) {
            if (data.length < 3) return [];
            var fx = d3_functor(x3), fy = d3_functor(y2), i5, n2 = data.length, points = [], flippedPoints = [];
            for (i5 = 0; i5 < n2; i5++) {
              points.push([+fx.call(this, data[i5], i5), +fy.call(this, data[i5], i5), i5]);
            }
            points.sort(d3_geom_hullOrder);
            for (i5 = 0; i5 < n2; i5++) flippedPoints.push([points[i5][0], -points[i5][1]]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for (i5 = upper.length - 1; i5 >= 0; --i5) polygon.push(data[points[upper[i5]][2]]);
            for (i5 = +skipLeft; i5 < lower.length - skipRight; ++i5) polygon.push(data[points[lower[i5]][2]]);
            return polygon;
          }
          hull.x = function(_2) {
            return arguments.length ? (x3 = _2, hull) : x3;
          };
          hull.y = function(_2) {
            return arguments.length ? (y2 = _2, hull) : y2;
          };
          return hull;
        };
        function d3_geom_hullUpper(points) {
          var n2 = points.length, hull = [0, 1], hs = 2;
          for (var i5 = 2; i5 < n2; i5++) {
            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i5]) <= 0) --hs;
            hull[hs++] = i5;
          }
          return hull.slice(0, hs);
        }
        function d3_geom_hullOrder(a3, b2) {
          return a3[0] - b2[0] || a3[1] - b2[1];
        }
        d33.geom.polygon = function(coordinates) {
          d3_subclass(coordinates, d3_geom_polygonPrototype);
          return coordinates;
        };
        var d3_geom_polygonPrototype = d33.geom.polygon.prototype = [];
        d3_geom_polygonPrototype.area = function() {
          var i5 = -1, n2 = this.length, a3, b2 = this[n2 - 1], area = 0;
          while (++i5 < n2) {
            a3 = b2;
            b2 = this[i5];
            area += a3[1] * b2[0] - a3[0] * b2[1];
          }
          return area * 0.5;
        };
        d3_geom_polygonPrototype.centroid = function(k) {
          var i5 = -1, n2 = this.length, x3 = 0, y2 = 0, a3, b2 = this[n2 - 1], c3;
          if (!arguments.length) k = -1 / (6 * this.area());
          while (++i5 < n2) {
            a3 = b2;
            b2 = this[i5];
            c3 = a3[0] * b2[1] - b2[0] * a3[1];
            x3 += (a3[0] + b2[0]) * c3;
            y2 += (a3[1] + b2[1]) * c3;
          }
          return [x3 * k, y2 * k];
        };
        d3_geom_polygonPrototype.clip = function(subject) {
          var input, closed = d3_geom_polygonClosed(subject), i5 = -1, n2 = this.length - d3_geom_polygonClosed(this), j2, m5, a3 = this[n2 - 1], b2, c3, d5;
          while (++i5 < n2) {
            input = subject.slice();
            subject.length = 0;
            b2 = this[i5];
            c3 = input[(m5 = input.length - closed) - 1];
            j2 = -1;
            while (++j2 < m5) {
              d5 = input[j2];
              if (d3_geom_polygonInside(d5, a3, b2)) {
                if (!d3_geom_polygonInside(c3, a3, b2)) {
                  subject.push(d3_geom_polygonIntersect(c3, d5, a3, b2));
                }
                subject.push(d5);
              } else if (d3_geom_polygonInside(c3, a3, b2)) {
                subject.push(d3_geom_polygonIntersect(c3, d5, a3, b2));
              }
              c3 = d5;
            }
            if (closed) subject.push(subject[0]);
            a3 = b2;
          }
          return subject;
        };
        function d3_geom_polygonInside(p3, a3, b2) {
          return (b2[0] - a3[0]) * (p3[1] - a3[1]) < (b2[1] - a3[1]) * (p3[0] - a3[0]);
        }
        function d3_geom_polygonIntersect(c3, d5, a3, b2) {
          var x1 = c3[0], x3 = a3[0], x21 = d5[0] - x1, x43 = b2[0] - x3, y1 = c3[1], y3 = a3[1], y21 = d5[1] - y1, y43 = b2[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
          return [x1 + ua * x21, y1 + ua * y21];
        }
        function d3_geom_polygonClosed(coordinates) {
          var a3 = coordinates[0], b2 = coordinates[coordinates.length - 1];
          return !(a3[0] - b2[0] || a3[1] - b2[1]);
        }
        var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
        function d3_geom_voronoiBeach() {
          d3_geom_voronoiRedBlackNode(this);
          this.edge = this.site = this.circle = null;
        }
        function d3_geom_voronoiCreateBeach(site) {
          var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
          beach.site = site;
          return beach;
        }
        function d3_geom_voronoiDetachBeach(beach) {
          d3_geom_voronoiDetachCircle(beach);
          d3_geom_voronoiBeaches.remove(beach);
          d3_geom_voronoiBeachPool.push(beach);
          d3_geom_voronoiRedBlackNode(beach);
        }
        function d3_geom_voronoiRemoveBeach(beach) {
          var circle = beach.circle, x3 = circle.x, y2 = circle.cy, vertex = {
            x: x3,
            y: y2
          }, previous = beach.P, next = beach.N, disappearing = [beach];
          d3_geom_voronoiDetachBeach(beach);
          var lArc = previous;
          while (lArc.circle && abs(x3 - lArc.circle.x) < \u03B5 && abs(y2 - lArc.circle.cy) < \u03B5) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
          }
          disappearing.unshift(lArc);
          d3_geom_voronoiDetachCircle(lArc);
          var rArc = next;
          while (rArc.circle && abs(x3 - rArc.circle.x) < \u03B5 && abs(y2 - rArc.circle.cy) < \u03B5) {
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
          }
          disappearing.push(rArc);
          d3_geom_voronoiDetachCircle(rArc);
          var nArcs = disappearing.length, iArc;
          for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
          }
          lArc = disappearing[0];
          rArc = disappearing[nArcs - 1];
          rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
        }
        function d3_geom_voronoiAddBeach(site) {
          var x3 = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
          while (node) {
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x3;
            if (dxl > \u03B5) node = node.L;
            else {
              dxr = x3 - d3_geom_voronoiRightBreakPoint(node, directrix);
              if (dxr > \u03B5) {
                if (!node.R) {
                  lArc = node;
                  break;
                }
                node = node.R;
              } else {
                if (dxl > -\u03B5) {
                  lArc = node.P;
                  rArc = node;
                } else if (dxr > -\u03B5) {
                  lArc = node;
                  rArc = node.N;
                } else {
                  lArc = rArc = node;
                }
                break;
              }
            }
          }
          var newArc = d3_geom_voronoiCreateBeach(site);
          d3_geom_voronoiBeaches.insert(lArc, newArc);
          if (!lArc && !rArc) return;
          if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
          }
          if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
          }
          d3_geom_voronoiDetachCircle(lArc);
          d3_geom_voronoiDetachCircle(rArc);
          var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d5 = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
            x: (cy * hb - by * hc) / d5 + ax,
            y: (bx * hc - cx * hb) / d5 + ay
          };
          d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
          newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
          rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
        }
        function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
          var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
          if (!pby2) return rfocx;
          var lArc = arc.P;
          if (!lArc) return -Infinity;
          site = lArc.site;
          var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
          if (!plby2) return lfocx;
          var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b2 = hl / plby2;
          if (aby2) return (-b2 + Math.sqrt(b2 * b2 - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
          return (rfocx + lfocx) / 2;
        }
        function d3_geom_voronoiRightBreakPoint(arc, directrix) {
          var rArc = arc.N;
          if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
          var site = arc.site;
          return site.y === directrix ? site.x : Infinity;
        }
        function d3_geom_voronoiCell(site) {
          this.site = site;
          this.edges = [];
        }
        d3_geom_voronoiCell.prototype.prepare = function() {
          var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
          while (iHalfEdge--) {
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
          }
          halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
          return halfEdges.length;
        };
        function d3_geom_voronoiCloseCells(extent) {
          var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x22, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start3, end2;
          while (iCell--) {
            cell = cells[iCell];
            if (!cell || !cell.prepare()) continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while (iHalfEdge < nHalfEdges) {
              end2 = halfEdges[iHalfEdge].end(), x3 = end2.x, y3 = end2.y;
              start3 = halfEdges[++iHalfEdge % nHalfEdges].start(), x22 = start3.x, y2 = start3.y;
              if (abs(x3 - x22) > \u03B5 || abs(y3 - y2) > \u03B5) {
                halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end2, abs(x3 - x0) < \u03B5 && y1 - y3 > \u03B5 ? {
                  x: x0,
                  y: abs(x22 - x0) < \u03B5 ? y2 : y1
                } : abs(y3 - y1) < \u03B5 && x1 - x3 > \u03B5 ? {
                  x: abs(y2 - y1) < \u03B5 ? x22 : x1,
                  y: y1
                } : abs(x3 - x1) < \u03B5 && y3 - y0 > \u03B5 ? {
                  x: x1,
                  y: abs(x22 - x1) < \u03B5 ? y2 : y0
                } : abs(y3 - y0) < \u03B5 && x3 - x0 > \u03B5 ? {
                  x: abs(y2 - y0) < \u03B5 ? x22 : x0,
                  y: y0
                } : null), cell.site, null));
                ++nHalfEdges;
              }
            }
          }
        }
        function d3_geom_voronoiHalfEdgeOrder(a3, b2) {
          return b2.angle - a3.angle;
        }
        function d3_geom_voronoiCircle() {
          d3_geom_voronoiRedBlackNode(this);
          this.x = this.y = this.arc = this.site = this.cy = null;
        }
        function d3_geom_voronoiAttachCircle(arc) {
          var lArc = arc.P, rArc = arc.N;
          if (!lArc || !rArc) return;
          var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
          if (lSite === rSite) return;
          var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
          var d5 = 2 * (ax * cy - ay * cx);
          if (d5 >= -\u03B52) return;
          var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x3 = (cy * ha - ay * hc) / d5, y2 = (ax * hc - cx * ha) / d5, cy = y2 + by;
          var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
          circle.arc = arc;
          circle.site = cSite;
          circle.x = x3 + bx;
          circle.y = cy + Math.sqrt(x3 * x3 + y2 * y2);
          circle.cy = cy;
          arc.circle = circle;
          var before = null, node = d3_geom_voronoiCircles._;
          while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
              if (node.L) node = node.L;
              else {
                before = node.P;
                break;
              }
            } else {
              if (node.R) node = node.R;
              else {
                before = node;
                break;
              }
            }
          }
          d3_geom_voronoiCircles.insert(before, circle);
          if (!before) d3_geom_voronoiFirstCircle = circle;
        }
        function d3_geom_voronoiDetachCircle(arc) {
          var circle = arc.circle;
          if (circle) {
            if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
          }
        }
        function d3_geom_voronoiClipEdges(extent) {
          var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i5 = edges.length, e3;
          while (i5--) {
            e3 = edges[i5];
            if (!d3_geom_voronoiConnectEdge(e3, extent) || !clip(e3) || abs(e3.a.x - e3.b.x) < \u03B5 && abs(e3.a.y - e3.b.y) < \u03B5) {
              e3.a = e3.b = null;
              edges.splice(i5, 1);
            }
          }
        }
        function d3_geom_voronoiConnectEdge(edge, extent) {
          var vb = edge.b;
          if (vb) return true;
          var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
          if (ry === ly) {
            if (fx < x0 || fx >= x1) return;
            if (lx > rx) {
              if (!va) va = {
                x: fx,
                y: y0
              };
              else if (va.y >= y1) return;
              vb = {
                x: fx,
                y: y1
              };
            } else {
              if (!va) va = {
                x: fx,
                y: y1
              };
              else if (va.y < y0) return;
              vb = {
                x: fx,
                y: y0
              };
            }
          } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
              if (lx > rx) {
                if (!va) va = {
                  x: (y0 - fb) / fm,
                  y: y0
                };
                else if (va.y >= y1) return;
                vb = {
                  x: (y1 - fb) / fm,
                  y: y1
                };
              } else {
                if (!va) va = {
                  x: (y1 - fb) / fm,
                  y: y1
                };
                else if (va.y < y0) return;
                vb = {
                  x: (y0 - fb) / fm,
                  y: y0
                };
              }
            } else {
              if (ly < ry) {
                if (!va) va = {
                  x: x0,
                  y: fm * x0 + fb
                };
                else if (va.x >= x1) return;
                vb = {
                  x: x1,
                  y: fm * x1 + fb
                };
              } else {
                if (!va) va = {
                  x: x1,
                  y: fm * x1 + fb
                };
                else if (va.x < x0) return;
                vb = {
                  x: x0,
                  y: fm * x0 + fb
                };
              }
            }
          }
          edge.a = va;
          edge.b = vb;
          return true;
        }
        function d3_geom_voronoiEdge(lSite, rSite) {
          this.l = lSite;
          this.r = rSite;
          this.a = this.b = null;
        }
        function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
          var edge = new d3_geom_voronoiEdge(lSite, rSite);
          d3_geom_voronoiEdges.push(edge);
          if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
          if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
          d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
          d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
          return edge;
        }
        function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
          var edge = new d3_geom_voronoiEdge(lSite, null);
          edge.a = va;
          edge.b = vb;
          d3_geom_voronoiEdges.push(edge);
          return edge;
        }
        function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
          if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
          } else if (edge.l === rSite) {
            edge.b = vertex;
          } else {
            edge.a = vertex;
          }
        }
        function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
          var va = edge.a, vb = edge.b;
          this.edge = edge;
          this.site = lSite;
          this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
        }
        d3_geom_voronoiHalfEdge.prototype = {
          start: function() {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
          },
          end: function() {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
          }
        };
        function d3_geom_voronoiRedBlackTree() {
          this._ = null;
        }
        function d3_geom_voronoiRedBlackNode(node) {
          node.U = node.C = node.L = node.R = node.P = node.N = null;
        }
        d3_geom_voronoiRedBlackTree.prototype = {
          insert: function(after, node) {
            var parent, grandpa, uncle;
            if (after) {
              node.P = after;
              node.N = after.N;
              if (after.N) after.N.P = node;
              after.N = node;
              if (after.R) {
                after = after.R;
                while (after.L) after = after.L;
                after.L = node;
              } else {
                after.R = node;
              }
              parent = after;
            } else if (this._) {
              after = d3_geom_voronoiRedBlackFirst(this._);
              node.P = null;
              node.N = after;
              after.P = after.L = node;
              parent = after;
            } else {
              node.P = node.N = null;
              this._ = node;
              parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
              grandpa = parent.U;
              if (parent === grandpa.L) {
                uncle = grandpa.R;
                if (uncle && uncle.C) {
                  parent.C = uncle.C = false;
                  grandpa.C = true;
                  after = grandpa;
                } else {
                  if (after === parent.R) {
                    d3_geom_voronoiRedBlackRotateLeft(this, parent);
                    after = parent;
                    parent = after.U;
                  }
                  parent.C = false;
                  grandpa.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                }
              } else {
                uncle = grandpa.L;
                if (uncle && uncle.C) {
                  parent.C = uncle.C = false;
                  grandpa.C = true;
                  after = grandpa;
                } else {
                  if (after === parent.L) {
                    d3_geom_voronoiRedBlackRotateRight(this, parent);
                    after = parent;
                    parent = after.U;
                  }
                  parent.C = false;
                  grandpa.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                }
              }
              parent = after.U;
            }
            this._.C = false;
          },
          remove: function(node) {
            if (node.N) node.N.P = node.P;
            if (node.P) node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left2 = node.L, right2 = node.R, next, red;
            if (!left2) next = right2;
            else if (!right2) next = left2;
            else next = d3_geom_voronoiRedBlackFirst(right2);
            if (parent) {
              if (parent.L === node) parent.L = next;
              else parent.R = next;
            } else {
              this._ = next;
            }
            if (left2 && right2) {
              red = next.C;
              next.C = node.C;
              next.L = left2;
              left2.U = next;
              if (next !== right2) {
                parent = next.U;
                next.U = node.U;
                node = next.R;
                parent.L = node;
                next.R = right2;
                right2.U = next;
              } else {
                next.U = parent;
                parent = next;
                node = next.R;
              }
            } else {
              red = node.C;
              node = next;
            }
            if (node) node.U = parent;
            if (red) return;
            if (node && node.C) {
              node.C = false;
              return;
            }
            do {
              if (node === this._) break;
              if (node === parent.L) {
                sibling = parent.R;
                if (sibling.C) {
                  sibling.C = false;
                  parent.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  sibling = parent.R;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                  if (!sibling.R || !sibling.R.C) {
                    sibling.L.C = false;
                    sibling.C = true;
                    d3_geom_voronoiRedBlackRotateRight(this, sibling);
                    sibling = parent.R;
                  }
                  sibling.C = parent.C;
                  parent.C = sibling.R.C = false;
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  node = this._;
                  break;
                }
              } else {
                sibling = parent.L;
                if (sibling.C) {
                  sibling.C = false;
                  parent.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  sibling = parent.L;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                  if (!sibling.L || !sibling.L.C) {
                    sibling.R.C = false;
                    sibling.C = true;
                    d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                    sibling = parent.L;
                  }
                  sibling.C = parent.C;
                  parent.C = sibling.L.C = false;
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  node = this._;
                  break;
                }
              }
              sibling.C = true;
              node = parent;
              parent = parent.U;
            } while (!node.C);
            if (node) node.C = false;
          }
        };
        function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
          var p3 = node, q3 = node.R, parent = p3.U;
          if (parent) {
            if (parent.L === p3) parent.L = q3;
            else parent.R = q3;
          } else {
            tree._ = q3;
          }
          q3.U = parent;
          p3.U = q3;
          p3.R = q3.L;
          if (p3.R) p3.R.U = p3;
          q3.L = p3;
        }
        function d3_geom_voronoiRedBlackRotateRight(tree, node) {
          var p3 = node, q3 = node.L, parent = p3.U;
          if (parent) {
            if (parent.L === p3) parent.L = q3;
            else parent.R = q3;
          } else {
            tree._ = q3;
          }
          q3.U = parent;
          p3.U = q3;
          p3.L = q3.R;
          if (p3.L) p3.L.U = p3;
          q3.R = p3;
        }
        function d3_geom_voronoiRedBlackFirst(node) {
          while (node.L) node = node.L;
          return node;
        }
        function d3_geom_voronoi(sites, bbox) {
          var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
          d3_geom_voronoiEdges = [];
          d3_geom_voronoiCells = new Array(sites.length);
          d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
          d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
          while (true) {
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
              if (site.x !== x0 || site.y !== y0) {
                d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                d3_geom_voronoiAddBeach(site);
                x0 = site.x, y0 = site.y;
              }
              site = sites.pop();
            } else if (circle) {
              d3_geom_voronoiRemoveBeach(circle.arc);
            } else {
              break;
            }
          }
          if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
          var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
          };
          d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
          return diagram;
        }
        function d3_geom_voronoiVertexOrder(a3, b2) {
          return b2.y - a3.y || b2.x - a3.x;
        }
        d33.geom.voronoi = function(points) {
          var x3 = d3_geom_pointX, y2 = d3_geom_pointY, fx = x3, fy = y2, clipExtent = d3_geom_voronoiClipExtent;
          if (points) return voronoi(points);
          function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i5) {
              var edges = cell.edges, site = cell.site, polygon = polygons[i5] = edges.length ? edges.map(function(e3) {
                var s7 = e3.start();
                return [s7.x, s7.y];
              }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
              polygon.point = data[i5];
            });
            return polygons;
          }
          function sites(data) {
            return data.map(function(d5, i5) {
              return {
                x: Math.round(fx(d5, i5) / \u03B5) * \u03B5,
                y: Math.round(fy(d5, i5) / \u03B5) * \u03B5,
                i: i5
              };
            });
          }
          voronoi.links = function(data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
              return edge.l && edge.r;
            }).map(function(edge) {
              return {
                source: data[edge.l.i],
                target: data[edge.r.i]
              };
            });
          };
          voronoi.triangles = function(data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i5) {
              var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j2 = -1, m5 = edges.length, e0, s0, e1 = edges[m5 - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
              while (++j2 < m5) {
                e0 = e1;
                s0 = s1;
                e1 = edges[j2].edge;
                s1 = e1.l === site ? e1.r : e1.l;
                if (i5 < s0.i && i5 < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                  triangles.push([data[i5], data[s0.i], data[s1.i]]);
                }
              }
            });
            return triangles;
          };
          voronoi.x = function(_2) {
            return arguments.length ? (fx = d3_functor(x3 = _2), voronoi) : x3;
          };
          voronoi.y = function(_2) {
            return arguments.length ? (fy = d3_functor(y2 = _2), voronoi) : y2;
          };
          voronoi.clipExtent = function(_2) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _2 == null ? d3_geom_voronoiClipExtent : _2;
            return voronoi;
          };
          voronoi.size = function(_2) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_2 && [[0, 0], _2]);
          };
          return voronoi;
        };
        var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
        function d3_geom_voronoiTriangleArea(a3, b2, c3) {
          return (a3.x - c3.x) * (b2.y - a3.y) - (a3.x - b2.x) * (c3.y - a3.y);
        }
        d33.geom.delaunay = function(vertices) {
          return d33.geom.voronoi().triangles(vertices);
        };
        d33.geom.quadtree = function(points, x1, y1, x22, y2) {
          var x3 = d3_geom_pointX, y3 = d3_geom_pointY, compat;
          if (compat = arguments.length) {
            x3 = d3_geom_quadtreeCompatX;
            y3 = d3_geom_quadtreeCompatY;
            if (compat === 3) {
              y2 = y1;
              x22 = x1;
              y1 = x1 = 0;
            }
            return quadtree(points);
          }
          function quadtree(data) {
            var d5, fx = d3_functor(x3), fy = d3_functor(y3), xs, ys, i5, n2, x1_, y1_, x2_, y2_;
            if (x1 != null) {
              x1_ = x1, y1_ = y1, x2_ = x22, y2_ = y2;
            } else {
              x2_ = y2_ = -(x1_ = y1_ = Infinity);
              xs = [], ys = [];
              n2 = data.length;
              if (compat) for (i5 = 0; i5 < n2; ++i5) {
                d5 = data[i5];
                if (d5.x < x1_) x1_ = d5.x;
                if (d5.y < y1_) y1_ = d5.y;
                if (d5.x > x2_) x2_ = d5.x;
                if (d5.y > y2_) y2_ = d5.y;
                xs.push(d5.x);
                ys.push(d5.y);
              }
              else for (i5 = 0; i5 < n2; ++i5) {
                var x_ = +fx(d5 = data[i5], i5), y_ = +fy(d5, i5);
                if (x_ < x1_) x1_ = x_;
                if (y_ < y1_) y1_ = y_;
                if (x_ > x2_) x2_ = x_;
                if (y_ > y2_) y2_ = y_;
                xs.push(x_);
                ys.push(y_);
              }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy) y2_ = y1_ + dx;
            else x2_ = x1_ + dy;
            function insert(n3, d6, x4, y4, x12, y12, x23, y22) {
              if (isNaN(x4) || isNaN(y4)) return;
              if (n3.leaf) {
                var nx = n3.x, ny = n3.y;
                if (nx != null) {
                  if (abs(nx - x4) + abs(ny - y4) < 0.01) {
                    insertChild(n3, d6, x4, y4, x12, y12, x23, y22);
                  } else {
                    var nPoint = n3.point;
                    n3.x = n3.y = n3.point = null;
                    insertChild(n3, nPoint, nx, ny, x12, y12, x23, y22);
                    insertChild(n3, d6, x4, y4, x12, y12, x23, y22);
                  }
                } else {
                  n3.x = x4, n3.y = y4, n3.point = d6;
                }
              } else {
                insertChild(n3, d6, x4, y4, x12, y12, x23, y22);
              }
            }
            function insertChild(n3, d6, x4, y4, x12, y12, x23, y22) {
              var xm = (x12 + x23) * 0.5, ym = (y12 + y22) * 0.5, right2 = x4 >= xm, below = y4 >= ym, i6 = below << 1 | right2;
              n3.leaf = false;
              n3 = n3.nodes[i6] || (n3.nodes[i6] = d3_geom_quadtreeNode());
              if (right2) x12 = xm;
              else x23 = xm;
              if (below) y12 = ym;
              else y22 = ym;
              insert(n3, d6, x4, y4, x12, y12, x23, y22);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function(d6) {
              insert(root, d6, +fx(d6, ++i5), +fy(d6, i5), x1_, y1_, x2_, y2_);
            };
            root.visit = function(f5) {
              d3_geom_quadtreeVisit(f5, root, x1_, y1_, x2_, y2_);
            };
            root.find = function(point) {
              return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i5 = -1;
            if (x1 == null) {
              while (++i5 < n2) {
                insert(root, data[i5], xs[i5], ys[i5], x1_, y1_, x2_, y2_);
              }
              --i5;
            } else data.forEach(root.add);
            xs = ys = data = d5 = null;
            return root;
          }
          quadtree.x = function(_2) {
            return arguments.length ? (x3 = _2, quadtree) : x3;
          };
          quadtree.y = function(_2) {
            return arguments.length ? (y3 = _2, quadtree) : y3;
          };
          quadtree.extent = function(_2) {
            if (!arguments.length) return x1 == null ? null : [[x1, y1], [x22, y2]];
            if (_2 == null) x1 = y1 = x22 = y2 = null;
            else x1 = +_2[0][0], y1 = +_2[0][1], x22 = +_2[1][0], y2 = +_2[1][1];
            return quadtree;
          };
          quadtree.size = function(_2) {
            if (!arguments.length) return x1 == null ? null : [x22 - x1, y2 - y1];
            if (_2 == null) x1 = y1 = x22 = y2 = null;
            else x1 = y1 = 0, x22 = +_2[0], y2 = +_2[1];
            return quadtree;
          };
          return quadtree;
        };
        function d3_geom_quadtreeCompatX(d5) {
          return d5.x;
        }
        function d3_geom_quadtreeCompatY(d5) {
          return d5.y;
        }
        function d3_geom_quadtreeNode() {
          return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
          };
        }
        function d3_geom_quadtreeVisit(f5, node, x1, y1, x22, y2) {
          if (!f5(node, x1, y1, x22, y2)) {
            var sx = (x1 + x22) * 0.5, sy = (y1 + y2) * 0.5, children = node.nodes;
            if (children[0]) d3_geom_quadtreeVisit(f5, children[0], x1, y1, sx, sy);
            if (children[1]) d3_geom_quadtreeVisit(f5, children[1], sx, y1, x22, sy);
            if (children[2]) d3_geom_quadtreeVisit(f5, children[2], x1, sy, sx, y2);
            if (children[3]) d3_geom_quadtreeVisit(f5, children[3], sx, sy, x22, y2);
          }
        }
        function d3_geom_quadtreeFind(root, x3, y2, x0, y0, x32, y3) {
          var minDistance2 = Infinity, closestPoint;
          (function find3(node, x1, y1, x22, y22) {
            if (x1 > x32 || y1 > y3 || x22 < x0 || y22 < y0) return;
            if (point = node.point) {
              var point, dx = x3 - node.x, dy = y2 - node.y, distance2 = dx * dx + dy * dy;
              if (distance2 < minDistance2) {
                var distance = Math.sqrt(minDistance2 = distance2);
                x0 = x3 - distance, y0 = y2 - distance;
                x32 = x3 + distance, y3 = y2 + distance;
                closestPoint = point;
              }
            }
            var children = node.nodes, xm = (x1 + x22) * 0.5, ym = (y1 + y22) * 0.5, right2 = x3 >= xm, below = y2 >= ym;
            for (var i5 = below << 1 | right2, j2 = i5 + 4; i5 < j2; ++i5) {
              if (node = children[i5 & 3]) switch (i5 & 3) {
                case 0:
                  find3(node, x1, y1, xm, ym);
                  break;
                case 1:
                  find3(node, xm, y1, x22, ym);
                  break;
                case 2:
                  find3(node, x1, ym, xm, y22);
                  break;
                case 3:
                  find3(node, xm, ym, x22, y22);
                  break;
              }
            }
          })(root, x0, y0, x32, y3);
          return closestPoint;
        }
        d33.interpolateRgb = d3_interpolateRgb;
        function d3_interpolateRgb(a3, b2) {
          a3 = d33.rgb(a3);
          b2 = d33.rgb(b2);
          var ar = a3.r, ag = a3.g, ab = a3.b, br = b2.r - ar, bg = b2.g - ag, bb = b2.b - ab;
          return function(t7) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t7)) + d3_rgb_hex(Math.round(ag + bg * t7)) + d3_rgb_hex(Math.round(ab + bb * t7));
          };
        }
        d33.interpolateObject = d3_interpolateObject;
        function d3_interpolateObject(a3, b2) {
          var i5 = {}, c3 = {}, k;
          for (k in a3) {
            if (k in b2) {
              i5[k] = d3_interpolate(a3[k], b2[k]);
            } else {
              c3[k] = a3[k];
            }
          }
          for (k in b2) {
            if (!(k in a3)) {
              c3[k] = b2[k];
            }
          }
          return function(t7) {
            for (k in i5) c3[k] = i5[k](t7);
            return c3;
          };
        }
        d33.interpolateNumber = d3_interpolateNumber;
        function d3_interpolateNumber(a3, b2) {
          a3 = +a3, b2 = +b2;
          return function(t7) {
            return a3 * (1 - t7) + b2 * t7;
          };
        }
        d33.interpolateString = d3_interpolateString;
        function d3_interpolateString(a3, b2) {
          var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i5 = -1, s7 = [], q3 = [];
          a3 = a3 + "", b2 = b2 + "";
          while ((am = d3_interpolate_numberA.exec(a3)) && (bm = d3_interpolate_numberB.exec(b2))) {
            if ((bs = bm.index) > bi) {
              bs = b2.slice(bi, bs);
              if (s7[i5]) s7[i5] += bs;
              else s7[++i5] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
              if (s7[i5]) s7[i5] += bm;
              else s7[++i5] = bm;
            } else {
              s7[++i5] = null;
              q3.push({
                i: i5,
                x: d3_interpolateNumber(am, bm)
              });
            }
            bi = d3_interpolate_numberB.lastIndex;
          }
          if (bi < b2.length) {
            bs = b2.slice(bi);
            if (s7[i5]) s7[i5] += bs;
            else s7[++i5] = bs;
          }
          return s7.length < 2 ? q3[0] ? (b2 = q3[0].x, function(t7) {
            return b2(t7) + "";
          }) : function() {
            return b2;
          } : (b2 = q3.length, function(t7) {
            for (var i6 = 0, o10; i6 < b2; ++i6) s7[(o10 = q3[i6]).i] = o10.x(t7);
            return s7.join("");
          });
        }
        var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
        d33.interpolate = d3_interpolate;
        function d3_interpolate(a3, b2) {
          var i5 = d33.interpolators.length, f5;
          while (--i5 >= 0 && !(f5 = d33.interpolators[i5](a3, b2))) ;
          return f5;
        }
        d33.interpolators = [function(a3, b2) {
          var t7 = typeof b2;
          return (t7 === "string" ? d3_rgb_names.has(b2.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b2) ? d3_interpolateRgb : d3_interpolateString : b2 instanceof d3_color ? d3_interpolateRgb : Array.isArray(b2) ? d3_interpolateArray : t7 === "object" && isNaN(b2) ? d3_interpolateObject : d3_interpolateNumber)(a3, b2);
        }];
        d33.interpolateArray = d3_interpolateArray;
        function d3_interpolateArray(a3, b2) {
          var x3 = [], c3 = [], na = a3.length, nb = b2.length, n0 = Math.min(a3.length, b2.length), i5;
          for (i5 = 0; i5 < n0; ++i5) x3.push(d3_interpolate(a3[i5], b2[i5]));
          for (; i5 < na; ++i5) c3[i5] = a3[i5];
          for (; i5 < nb; ++i5) c3[i5] = b2[i5];
          return function(t7) {
            for (i5 = 0; i5 < n0; ++i5) c3[i5] = x3[i5](t7);
            return c3;
          };
        }
        var d3_ease_default = function() {
          return d3_identity;
        };
        var d3_ease = d33.map({
          linear: d3_ease_default,
          poly: d3_ease_poly,
          quad: function() {
            return d3_ease_quad;
          },
          cubic: function() {
            return d3_ease_cubic;
          },
          sin: function() {
            return d3_ease_sin;
          },
          exp: function() {
            return d3_ease_exp;
          },
          circle: function() {
            return d3_ease_circle;
          },
          elastic: d3_ease_elastic,
          back: d3_ease_back,
          bounce: function() {
            return d3_ease_bounce;
          }
        });
        var d3_ease_mode = d33.map({
          "in": d3_identity,
          out: d3_ease_reverse,
          "in-out": d3_ease_reflect,
          "out-in": function(f5) {
            return d3_ease_reflect(d3_ease_reverse(f5));
          }
        });
        d33.ease = function(name) {
          var i5 = name.indexOf("-"), t7 = i5 >= 0 ? name.slice(0, i5) : name, m5 = i5 >= 0 ? name.slice(i5 + 1) : "in";
          t7 = d3_ease.get(t7) || d3_ease_default;
          m5 = d3_ease_mode.get(m5) || d3_identity;
          return d3_ease_clamp(m5(t7.apply(null, d3_arraySlice.call(arguments, 1))));
        };
        function d3_ease_clamp(f5) {
          return function(t7) {
            return t7 <= 0 ? 0 : t7 >= 1 ? 1 : f5(t7);
          };
        }
        function d3_ease_reverse(f5) {
          return function(t7) {
            return 1 - f5(1 - t7);
          };
        }
        function d3_ease_reflect(f5) {
          return function(t7) {
            return 0.5 * (t7 < 0.5 ? f5(2 * t7) : 2 - f5(2 - 2 * t7));
          };
        }
        function d3_ease_quad(t7) {
          return t7 * t7;
        }
        function d3_ease_cubic(t7) {
          return t7 * t7 * t7;
        }
        function d3_ease_cubicInOut(t7) {
          if (t7 <= 0) return 0;
          if (t7 >= 1) return 1;
          var t22 = t7 * t7, t32 = t22 * t7;
          return 4 * (t7 < 0.5 ? t32 : 3 * (t7 - t22) + t32 - 0.75);
        }
        function d3_ease_poly(e3) {
          return function(t7) {
            return Math.pow(t7, e3);
          };
        }
        function d3_ease_sin(t7) {
          return 1 - Math.cos(t7 * half\u03C0);
        }
        function d3_ease_exp(t7) {
          return Math.pow(2, 10 * (t7 - 1));
        }
        function d3_ease_circle(t7) {
          return 1 - Math.sqrt(1 - t7 * t7);
        }
        function d3_ease_elastic(a3, p3) {
          var s7;
          if (arguments.length < 2) p3 = 0.45;
          if (arguments.length) s7 = p3 / \u03C4 * Math.asin(1 / a3);
          else a3 = 1, s7 = p3 / 4;
          return function(t7) {
            return 1 + a3 * Math.pow(2, -10 * t7) * Math.sin((t7 - s7) * \u03C4 / p3);
          };
        }
        function d3_ease_back(s7) {
          if (!s7) s7 = 1.70158;
          return function(t7) {
            return t7 * t7 * ((s7 + 1) * t7 - s7);
          };
        }
        function d3_ease_bounce(t7) {
          return t7 < 1 / 2.75 ? 7.5625 * t7 * t7 : t7 < 2 / 2.75 ? 7.5625 * (t7 -= 1.5 / 2.75) * t7 + 0.75 : t7 < 2.5 / 2.75 ? 7.5625 * (t7 -= 2.25 / 2.75) * t7 + 0.9375 : 7.5625 * (t7 -= 2.625 / 2.75) * t7 + 0.984375;
        }
        d33.interpolateHcl = d3_interpolateHcl;
        function d3_interpolateHcl(a3, b2) {
          a3 = d33.hcl(a3);
          b2 = d33.hcl(b2);
          var ah = a3.h, ac = a3.c, al = a3.l, bh = b2.h - ah, bc = b2.c - ac, bl = b2.l - al;
          if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b2.c : ac;
          if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b2.h : ah;
          else if (bh > 180) bh -= 360;
          else if (bh < -180) bh += 360;
          return function(t7) {
            return d3_hcl_lab(ah + bh * t7, ac + bc * t7, al + bl * t7) + "";
          };
        }
        d33.interpolateHsl = d3_interpolateHsl;
        function d3_interpolateHsl(a3, b2) {
          a3 = d33.hsl(a3);
          b2 = d33.hsl(b2);
          var ah = a3.h, as = a3.s, al = a3.l, bh = b2.h - ah, bs = b2.s - as, bl = b2.l - al;
          if (isNaN(bs)) bs = 0, as = isNaN(as) ? b2.s : as;
          if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b2.h : ah;
          else if (bh > 180) bh -= 360;
          else if (bh < -180) bh += 360;
          return function(t7) {
            return d3_hsl_rgb(ah + bh * t7, as + bs * t7, al + bl * t7) + "";
          };
        }
        d33.interpolateLab = d3_interpolateLab;
        function d3_interpolateLab(a3, b2) {
          a3 = d33.lab(a3);
          b2 = d33.lab(b2);
          var al = a3.l, aa = a3.a, ab = a3.b, bl = b2.l - al, ba = b2.a - aa, bb = b2.b - ab;
          return function(t7) {
            return d3_lab_rgb(al + bl * t7, aa + ba * t7, ab + bb * t7) + "";
          };
        }
        d33.interpolateRound = d3_interpolateRound;
        function d3_interpolateRound(a3, b2) {
          b2 -= a3;
          return function(t7) {
            return Math.round(a3 + b2 * t7);
          };
        }
        d33.transform = function(string) {
          var g3 = d3_document.createElementNS(d33.ns.prefix.svg, "g");
          return (d33.transform = function(string2) {
            if (string2 != null) {
              g3.setAttribute("transform", string2);
              var t7 = g3.transform.baseVal.consolidate();
            }
            return new d3_transform(t7 ? t7.matrix : d3_transformIdentity);
          })(string);
        };
        function d3_transform(m5) {
          var r0 = [m5.a, m5.b], r1 = [m5.c, m5.d], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
          if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
          }
          this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
          this.translate = [m5.e, m5.f];
          this.scale = [kx, ky];
          this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
        }
        d3_transform.prototype.toString = function() {
          return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
        };
        function d3_transformDot(a3, b2) {
          return a3[0] * b2[0] + a3[1] * b2[1];
        }
        function d3_transformNormalize(a3) {
          var k = Math.sqrt(d3_transformDot(a3, a3));
          if (k) {
            a3[0] /= k;
            a3[1] /= k;
          }
          return k;
        }
        function d3_transformCombine(a3, b2, k) {
          a3[0] += k * b2[0];
          a3[1] += k * b2[1];
          return a3;
        }
        var d3_transformIdentity = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: 0,
          f: 0
        };
        d33.interpolateTransform = d3_interpolateTransform;
        function d3_interpolateTransformPop(s7) {
          return s7.length ? s7.pop() + "," : "";
        }
        function d3_interpolateTranslate(ta, tb, s7, q3) {
          if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
            var i5 = s7.push("translate(", null, ",", null, ")");
            q3.push({
              i: i5 - 4,
              x: d3_interpolateNumber(ta[0], tb[0])
            }, {
              i: i5 - 2,
              x: d3_interpolateNumber(ta[1], tb[1])
            });
          } else if (tb[0] || tb[1]) {
            s7.push("translate(" + tb + ")");
          }
        }
        function d3_interpolateRotate(ra, rb, s7, q3) {
          if (ra !== rb) {
            if (ra - rb > 180) rb += 360;
            else if (rb - ra > 180) ra += 360;
            q3.push({
              i: s7.push(d3_interpolateTransformPop(s7) + "rotate(", null, ")") - 2,
              x: d3_interpolateNumber(ra, rb)
            });
          } else if (rb) {
            s7.push(d3_interpolateTransformPop(s7) + "rotate(" + rb + ")");
          }
        }
        function d3_interpolateSkew(wa, wb, s7, q3) {
          if (wa !== wb) {
            q3.push({
              i: s7.push(d3_interpolateTransformPop(s7) + "skewX(", null, ")") - 2,
              x: d3_interpolateNumber(wa, wb)
            });
          } else if (wb) {
            s7.push(d3_interpolateTransformPop(s7) + "skewX(" + wb + ")");
          }
        }
        function d3_interpolateScale(ka, kb, s7, q3) {
          if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
            var i5 = s7.push(d3_interpolateTransformPop(s7) + "scale(", null, ",", null, ")");
            q3.push({
              i: i5 - 4,
              x: d3_interpolateNumber(ka[0], kb[0])
            }, {
              i: i5 - 2,
              x: d3_interpolateNumber(ka[1], kb[1])
            });
          } else if (kb[0] !== 1 || kb[1] !== 1) {
            s7.push(d3_interpolateTransformPop(s7) + "scale(" + kb + ")");
          }
        }
        function d3_interpolateTransform(a3, b2) {
          var s7 = [], q3 = [];
          a3 = d33.transform(a3), b2 = d33.transform(b2);
          d3_interpolateTranslate(a3.translate, b2.translate, s7, q3);
          d3_interpolateRotate(a3.rotate, b2.rotate, s7, q3);
          d3_interpolateSkew(a3.skew, b2.skew, s7, q3);
          d3_interpolateScale(a3.scale, b2.scale, s7, q3);
          a3 = b2 = null;
          return function(t7) {
            var i5 = -1, n2 = q3.length, o10;
            while (++i5 < n2) s7[(o10 = q3[i5]).i] = o10.x(t7);
            return s7.join("");
          };
        }
        function d3_uninterpolateNumber(a3, b2) {
          b2 = (b2 -= a3 = +a3) || 1 / b2;
          return function(x3) {
            return (x3 - a3) / b2;
          };
        }
        function d3_uninterpolateClamp(a3, b2) {
          b2 = (b2 -= a3 = +a3) || 1 / b2;
          return function(x3) {
            return Math.max(0, Math.min(1, (x3 - a3) / b2));
          };
        }
        d33.layout = {};
        d33.layout.bundle = function() {
          return function(links) {
            var paths = [], i5 = -1, n2 = links.length;
            while (++i5 < n2) paths.push(d3_layout_bundlePath(links[i5]));
            return paths;
          };
        };
        function d3_layout_bundlePath(link) {
          var start3 = link.source, end2 = link.target, lca = d3_layout_bundleLeastCommonAncestor(start3, end2), points = [start3];
          while (start3 !== lca) {
            start3 = start3.parent;
            points.push(start3);
          }
          var k = points.length;
          while (end2 !== lca) {
            points.splice(k, 0, end2);
            end2 = end2.parent;
          }
          return points;
        }
        function d3_layout_bundleAncestors(node) {
          var ancestors = [], parent = node.parent;
          while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
          }
          ancestors.push(node);
          return ancestors;
        }
        function d3_layout_bundleLeastCommonAncestor(a3, b2) {
          if (a3 === b2) return a3;
          var aNodes = d3_layout_bundleAncestors(a3), bNodes = d3_layout_bundleAncestors(b2), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
          while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
          }
          return sharedNode;
        }
        d33.layout.chord = function() {
          var chord = {}, chords, groups, matrix, n2, padding = 0, sortGroups, sortSubgroups, sortChords;
          function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d33.range(n2), subgroupIndex = [], k, x3, x0, i5, j2;
            chords = [];
            groups = [];
            k = 0, i5 = -1;
            while (++i5 < n2) {
              x3 = 0, j2 = -1;
              while (++j2 < n2) {
                x3 += matrix[i5][j2];
              }
              groupSums.push(x3);
              subgroupIndex.push(d33.range(n2));
              k += x3;
            }
            if (sortGroups) {
              groupIndex.sort(function(a3, b2) {
                return sortGroups(groupSums[a3], groupSums[b2]);
              });
            }
            if (sortSubgroups) {
              subgroupIndex.forEach(function(d5, i6) {
                d5.sort(function(a3, b2) {
                  return sortSubgroups(matrix[i6][a3], matrix[i6][b2]);
                });
              });
            }
            k = (\u03C4 - padding * n2) / k;
            x3 = 0, i5 = -1;
            while (++i5 < n2) {
              x0 = x3, j2 = -1;
              while (++j2 < n2) {
                var di = groupIndex[i5], dj = subgroupIndex[di][j2], v3 = matrix[di][dj], a0 = x3, a1 = x3 += v3 * k;
                subgroups[di + "-" + dj] = {
                  index: di,
                  subindex: dj,
                  startAngle: a0,
                  endAngle: a1,
                  value: v3
                };
              }
              groups[di] = {
                index: di,
                startAngle: x0,
                endAngle: x3,
                value: groupSums[di]
              };
              x3 += padding;
            }
            i5 = -1;
            while (++i5 < n2) {
              j2 = i5 - 1;
              while (++j2 < n2) {
                var source = subgroups[i5 + "-" + j2], target = subgroups[j2 + "-" + i5];
                if (source.value || target.value) {
                  chords.push(source.value < target.value ? {
                    source: target,
                    target: source
                  } : {
                    source,
                    target
                  });
                }
              }
            }
            if (sortChords) resort();
          }
          function resort() {
            chords.sort(function(a3, b2) {
              return sortChords((a3.source.value + a3.target.value) / 2, (b2.source.value + b2.target.value) / 2);
            });
          }
          chord.matrix = function(x3) {
            if (!arguments.length) return matrix;
            n2 = (matrix = x3) && matrix.length;
            chords = groups = null;
            return chord;
          };
          chord.padding = function(x3) {
            if (!arguments.length) return padding;
            padding = x3;
            chords = groups = null;
            return chord;
          };
          chord.sortGroups = function(x3) {
            if (!arguments.length) return sortGroups;
            sortGroups = x3;
            chords = groups = null;
            return chord;
          };
          chord.sortSubgroups = function(x3) {
            if (!arguments.length) return sortSubgroups;
            sortSubgroups = x3;
            chords = null;
            return chord;
          };
          chord.sortChords = function(x3) {
            if (!arguments.length) return sortChords;
            sortChords = x3;
            if (chords) resort();
            return chord;
          };
          chord.chords = function() {
            if (!chords) relayout();
            return chords;
          };
          chord.groups = function() {
            if (!groups) relayout();
            return groups;
          };
          return chord;
        };
        d33.layout.force = function() {
          var force = {}, event = d33.dispatch("start", "tick", "end"), timer, size = [1, 1], drag, alpha2, friction = 0.9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = 0.1, theta2 = 0.64, nodes = [], links = [], distances, strengths, charges;
          function repulse(node) {
            return function(quad, x1, _2, x22) {
              if (quad.point !== node) {
                var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x22 - x1, dn = dx * dx + dy * dy;
                if (dw * dw / theta2 < dn) {
                  if (dn < chargeDistance2) {
                    var k = quad.charge / dn;
                    node.px -= dx * k;
                    node.py -= dy * k;
                  }
                  return true;
                }
                if (quad.point && dn && dn < chargeDistance2) {
                  var k = quad.pointCharge / dn;
                  node.px -= dx * k;
                  node.py -= dy * k;
                }
              }
              return !quad.charge;
            };
          }
          force.tick = function() {
            if ((alpha2 *= 0.99) < 5e-3) {
              timer = null;
              event.end({
                type: "end",
                alpha: alpha2 = 0
              });
              return true;
            }
            var n2 = nodes.length, m5 = links.length, q3, i5, o10, s7, t7, l6, k, x3, y2;
            for (i5 = 0; i5 < m5; ++i5) {
              o10 = links[i5];
              s7 = o10.source;
              t7 = o10.target;
              x3 = t7.x - s7.x;
              y2 = t7.y - s7.y;
              if (l6 = x3 * x3 + y2 * y2) {
                l6 = alpha2 * strengths[i5] * ((l6 = Math.sqrt(l6)) - distances[i5]) / l6;
                x3 *= l6;
                y2 *= l6;
                t7.x -= x3 * (k = s7.weight + t7.weight ? s7.weight / (s7.weight + t7.weight) : 0.5);
                t7.y -= y2 * k;
                s7.x += x3 * (k = 1 - k);
                s7.y += y2 * k;
              }
            }
            if (k = alpha2 * gravity) {
              x3 = size[0] / 2;
              y2 = size[1] / 2;
              i5 = -1;
              if (k) while (++i5 < n2) {
                o10 = nodes[i5];
                o10.x += (x3 - o10.x) * k;
                o10.y += (y2 - o10.y) * k;
              }
            }
            if (charge) {
              d3_layout_forceAccumulate(q3 = d33.geom.quadtree(nodes), alpha2, charges);
              i5 = -1;
              while (++i5 < n2) {
                if (!(o10 = nodes[i5]).fixed) {
                  q3.visit(repulse(o10));
                }
              }
            }
            i5 = -1;
            while (++i5 < n2) {
              o10 = nodes[i5];
              if (o10.fixed) {
                o10.x = o10.px;
                o10.y = o10.py;
              } else {
                o10.x -= (o10.px - (o10.px = o10.x)) * friction;
                o10.y -= (o10.py - (o10.py = o10.y)) * friction;
              }
            }
            event.tick({
              type: "tick",
              alpha: alpha2
            });
          };
          force.nodes = function(x3) {
            if (!arguments.length) return nodes;
            nodes = x3;
            return force;
          };
          force.links = function(x3) {
            if (!arguments.length) return links;
            links = x3;
            return force;
          };
          force.size = function(x3) {
            if (!arguments.length) return size;
            size = x3;
            return force;
          };
          force.linkDistance = function(x3) {
            if (!arguments.length) return linkDistance;
            linkDistance = typeof x3 === "function" ? x3 : +x3;
            return force;
          };
          force.distance = force.linkDistance;
          force.linkStrength = function(x3) {
            if (!arguments.length) return linkStrength;
            linkStrength = typeof x3 === "function" ? x3 : +x3;
            return force;
          };
          force.friction = function(x3) {
            if (!arguments.length) return friction;
            friction = +x3;
            return force;
          };
          force.charge = function(x3) {
            if (!arguments.length) return charge;
            charge = typeof x3 === "function" ? x3 : +x3;
            return force;
          };
          force.chargeDistance = function(x3) {
            if (!arguments.length) return Math.sqrt(chargeDistance2);
            chargeDistance2 = x3 * x3;
            return force;
          };
          force.gravity = function(x3) {
            if (!arguments.length) return gravity;
            gravity = +x3;
            return force;
          };
          force.theta = function(x3) {
            if (!arguments.length) return Math.sqrt(theta2);
            theta2 = x3 * x3;
            return force;
          };
          force.alpha = function(x3) {
            if (!arguments.length) return alpha2;
            x3 = +x3;
            if (alpha2) {
              if (x3 > 0) {
                alpha2 = x3;
              } else {
                timer.c = null, timer.t = NaN, timer = null;
                event.end({
                  type: "end",
                  alpha: alpha2 = 0
                });
              }
            } else if (x3 > 0) {
              event.start({
                type: "start",
                alpha: alpha2 = x3
              });
              timer = d3_timer(force.tick);
            }
            return force;
          };
          force.start = function() {
            var i5, n2 = nodes.length, m5 = links.length, w3 = size[0], h3 = size[1], neighbors, o10;
            for (i5 = 0; i5 < n2; ++i5) {
              (o10 = nodes[i5]).index = i5;
              o10.weight = 0;
            }
            for (i5 = 0; i5 < m5; ++i5) {
              o10 = links[i5];
              if (typeof o10.source == "number") o10.source = nodes[o10.source];
              if (typeof o10.target == "number") o10.target = nodes[o10.target];
              ++o10.source.weight;
              ++o10.target.weight;
            }
            for (i5 = 0; i5 < n2; ++i5) {
              o10 = nodes[i5];
              if (isNaN(o10.x)) o10.x = position("x", w3);
              if (isNaN(o10.y)) o10.y = position("y", h3);
              if (isNaN(o10.px)) o10.px = o10.x;
              if (isNaN(o10.py)) o10.py = o10.y;
            }
            distances = [];
            if (typeof linkDistance === "function") for (i5 = 0; i5 < m5; ++i5) distances[i5] = +linkDistance.call(this, links[i5], i5);
            else for (i5 = 0; i5 < m5; ++i5) distances[i5] = linkDistance;
            strengths = [];
            if (typeof linkStrength === "function") for (i5 = 0; i5 < m5; ++i5) strengths[i5] = +linkStrength.call(this, links[i5], i5);
            else for (i5 = 0; i5 < m5; ++i5) strengths[i5] = linkStrength;
            charges = [];
            if (typeof charge === "function") for (i5 = 0; i5 < n2; ++i5) charges[i5] = +charge.call(this, nodes[i5], i5);
            else for (i5 = 0; i5 < n2; ++i5) charges[i5] = charge;
            function position(dimension, size2) {
              if (!neighbors) {
                neighbors = new Array(n2);
                for (j2 = 0; j2 < n2; ++j2) {
                  neighbors[j2] = [];
                }
                for (j2 = 0; j2 < m5; ++j2) {
                  var o11 = links[j2];
                  neighbors[o11.source.index].push(o11.target);
                  neighbors[o11.target.index].push(o11.source);
                }
              }
              var candidates = neighbors[i5], j2 = -1, l6 = candidates.length, x3;
              while (++j2 < l6) if (!isNaN(x3 = candidates[j2][dimension])) return x3;
              return Math.random() * size2;
            }
            return force.resume();
          };
          force.resume = function() {
            return force.alpha(0.1);
          };
          force.stop = function() {
            return force.alpha(0);
          };
          force.drag = function() {
            if (!drag) drag = d33.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
            if (!arguments.length) return drag;
            this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
          };
          function dragmove(d5) {
            d5.px = d33.event.x, d5.py = d33.event.y;
            force.resume();
          }
          return d33.rebind(force, event, "on");
        };
        function d3_layout_forceDragstart(d5) {
          d5.fixed |= 2;
        }
        function d3_layout_forceDragend(d5) {
          d5.fixed &= ~6;
        }
        function d3_layout_forceMouseover(d5) {
          d5.fixed |= 4;
          d5.px = d5.x, d5.py = d5.y;
        }
        function d3_layout_forceMouseout(d5) {
          d5.fixed &= ~4;
        }
        function d3_layout_forceAccumulate(quad, alpha2, charges) {
          var cx = 0, cy = 0;
          quad.charge = 0;
          if (!quad.leaf) {
            var nodes = quad.nodes, n2 = nodes.length, i5 = -1, c3;
            while (++i5 < n2) {
              c3 = nodes[i5];
              if (c3 == null) continue;
              d3_layout_forceAccumulate(c3, alpha2, charges);
              quad.charge += c3.charge;
              cx += c3.charge * c3.cx;
              cy += c3.charge * c3.cy;
            }
          }
          if (quad.point) {
            if (!quad.leaf) {
              quad.point.x += Math.random() - 0.5;
              quad.point.y += Math.random() - 0.5;
            }
            var k = alpha2 * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
          }
          quad.cx = cx / quad.charge;
          quad.cy = cy / quad.charge;
        }
        var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
        d33.layout.hierarchy = function() {
          var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
          function hierarchy(root) {
            var stack = [root], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
              nodes.push(node);
              if ((childs = children.call(hierarchy, node, node.depth)) && (n2 = childs.length)) {
                var n2, childs, child;
                while (--n2 >= 0) {
                  stack.push(child = childs[n2]);
                  child.parent = node;
                  child.depth = node.depth + 1;
                }
                if (value) node.value = 0;
                node.children = childs;
              } else {
                if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
                delete node.children;
              }
            }
            d3_layout_hierarchyVisitAfter(root, function(node2) {
              var childs2, parent;
              if (sort && (childs2 = node2.children)) childs2.sort(sort);
              if (value && (parent = node2.parent)) parent.value += node2.value;
            });
            return nodes;
          }
          hierarchy.sort = function(x3) {
            if (!arguments.length) return sort;
            sort = x3;
            return hierarchy;
          };
          hierarchy.children = function(x3) {
            if (!arguments.length) return children;
            children = x3;
            return hierarchy;
          };
          hierarchy.value = function(x3) {
            if (!arguments.length) return value;
            value = x3;
            return hierarchy;
          };
          hierarchy.revalue = function(root) {
            if (value) {
              d3_layout_hierarchyVisitBefore(root, function(node) {
                if (node.children) node.value = 0;
              });
              d3_layout_hierarchyVisitAfter(root, function(node) {
                var parent;
                if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
                if (parent = node.parent) parent.value += node.value;
              });
            }
            return root;
          };
          return hierarchy;
        };
        function d3_layout_hierarchyRebind(object, hierarchy) {
          d33.rebind(object, hierarchy, "sort", "children", "value");
          object.nodes = object;
          object.links = d3_layout_hierarchyLinks;
          return object;
        }
        function d3_layout_hierarchyVisitBefore(node, callback2) {
          var nodes = [node];
          while ((node = nodes.pop()) != null) {
            callback2(node);
            if ((children = node.children) && (n2 = children.length)) {
              var n2, children;
              while (--n2 >= 0) nodes.push(children[n2]);
            }
          }
        }
        function d3_layout_hierarchyVisitAfter(node, callback2) {
          var nodes = [node], nodes2 = [];
          while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n2 = children.length)) {
              var i5 = -1, n2, children;
              while (++i5 < n2) nodes.push(children[i5]);
            }
          }
          while ((node = nodes2.pop()) != null) {
            callback2(node);
          }
        }
        function d3_layout_hierarchyChildren(d5) {
          return d5.children;
        }
        function d3_layout_hierarchyValue(d5) {
          return d5.value;
        }
        function d3_layout_hierarchySort(a3, b2) {
          return b2.value - a3.value;
        }
        function d3_layout_hierarchyLinks(nodes) {
          return d33.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
              return {
                source: parent,
                target: child
              };
            });
          }));
        }
        d33.layout.partition = function() {
          var hierarchy = d33.layout.hierarchy(), size = [1, 1];
          function position(node, x3, dx, dy) {
            var children = node.children;
            node.x = x3;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n2 = children.length)) {
              var i5 = -1, n2, c3, d5;
              dx = node.value ? dx / node.value : 0;
              while (++i5 < n2) {
                position(c3 = children[i5], x3, d5 = c3.value * dx, dy);
                x3 += d5;
              }
            }
          }
          function depth(node) {
            var children = node.children, d5 = 0;
            if (children && (n2 = children.length)) {
              var i5 = -1, n2;
              while (++i5 < n2) d5 = Math.max(d5, depth(children[i5]));
            }
            return 1 + d5;
          }
          function partition(d5, i5) {
            var nodes = hierarchy.call(this, d5, i5);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
          }
          partition.size = function(x3) {
            if (!arguments.length) return size;
            size = x3;
            return partition;
          };
          return d3_layout_hierarchyRebind(partition, hierarchy);
        };
        d33.layout.pie = function() {
          var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = \u03C4, padAngle = 0;
          function pie(data) {
            var n2 = data.length, values = data.map(function(d5, i5) {
              return +value.call(pie, d5, i5);
            }), a3 = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a3, p3 = Math.min(Math.abs(da) / n2, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p3 * (da < 0 ? -1 : 1), sum = d33.sum(values), k = sum ? (da - n2 * pa) / sum : 0, index2 = d33.range(n2), arcs = [], v3;
            if (sort != null) index2.sort(sort === d3_layout_pieSortByValue ? function(i5, j2) {
              return values[j2] - values[i5];
            } : function(i5, j2) {
              return sort(data[i5], data[j2]);
            });
            index2.forEach(function(i5) {
              arcs[i5] = {
                data: data[i5],
                value: v3 = values[i5],
                startAngle: a3,
                endAngle: a3 += v3 * k + pa,
                padAngle: p3
              };
            });
            return arcs;
          }
          pie.value = function(_2) {
            if (!arguments.length) return value;
            value = _2;
            return pie;
          };
          pie.sort = function(_2) {
            if (!arguments.length) return sort;
            sort = _2;
            return pie;
          };
          pie.startAngle = function(_2) {
            if (!arguments.length) return startAngle;
            startAngle = _2;
            return pie;
          };
          pie.endAngle = function(_2) {
            if (!arguments.length) return endAngle;
            endAngle = _2;
            return pie;
          };
          pie.padAngle = function(_2) {
            if (!arguments.length) return padAngle;
            padAngle = _2;
            return pie;
          };
          return pie;
        };
        var d3_layout_pieSortByValue = {};
        d33.layout.stack = function() {
          var values = d3_identity, order2 = d3_layout_stackOrderDefault, offset2 = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x3 = d3_layout_stackX, y2 = d3_layout_stackY;
          function stack(data, index2) {
            if (!(n2 = data.length)) return data;
            var series = data.map(function(d5, i6) {
              return values.call(stack, d5, i6);
            });
            var points = series.map(function(d5) {
              return d5.map(function(v3, i6) {
                return [x3.call(stack, v3, i6), y2.call(stack, v3, i6)];
              });
            });
            var orders = order2.call(stack, points, index2);
            series = d33.permute(series, orders);
            points = d33.permute(points, orders);
            var offsets = offset2.call(stack, points, index2);
            var m5 = series[0].length, n2, i5, j2, o10;
            for (j2 = 0; j2 < m5; ++j2) {
              out.call(stack, series[0][j2], o10 = offsets[j2], points[0][j2][1]);
              for (i5 = 1; i5 < n2; ++i5) {
                out.call(stack, series[i5][j2], o10 += points[i5 - 1][j2][1], points[i5][j2][1]);
              }
            }
            return data;
          }
          stack.values = function(x4) {
            if (!arguments.length) return values;
            values = x4;
            return stack;
          };
          stack.order = function(x4) {
            if (!arguments.length) return order2;
            order2 = typeof x4 === "function" ? x4 : d3_layout_stackOrders.get(x4) || d3_layout_stackOrderDefault;
            return stack;
          };
          stack.offset = function(x4) {
            if (!arguments.length) return offset2;
            offset2 = typeof x4 === "function" ? x4 : d3_layout_stackOffsets.get(x4) || d3_layout_stackOffsetZero;
            return stack;
          };
          stack.x = function(z2) {
            if (!arguments.length) return x3;
            x3 = z2;
            return stack;
          };
          stack.y = function(z2) {
            if (!arguments.length) return y2;
            y2 = z2;
            return stack;
          };
          stack.out = function(z2) {
            if (!arguments.length) return out;
            out = z2;
            return stack;
          };
          return stack;
        };
        function d3_layout_stackX(d5) {
          return d5.x;
        }
        function d3_layout_stackY(d5) {
          return d5.y;
        }
        function d3_layout_stackOut(d5, y0, y2) {
          d5.y0 = y0;
          d5.y = y2;
        }
        var d3_layout_stackOrders = d33.map({
          "inside-out": function(data) {
            var n2 = data.length, i5, j2, max2 = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index2 = d33.range(n2).sort(function(a3, b2) {
              return max2[a3] - max2[b2];
            }), top2 = 0, bottom2 = 0, tops = [], bottoms = [];
            for (i5 = 0; i5 < n2; ++i5) {
              j2 = index2[i5];
              if (top2 < bottom2) {
                top2 += sums[j2];
                tops.push(j2);
              } else {
                bottom2 += sums[j2];
                bottoms.push(j2);
              }
            }
            return bottoms.reverse().concat(tops);
          },
          reverse: function(data) {
            return d33.range(data.length).reverse();
          },
          "default": d3_layout_stackOrderDefault
        });
        var d3_layout_stackOffsets = d33.map({
          silhouette: function(data) {
            var n2 = data.length, m5 = data[0].length, sums = [], max2 = 0, i5, j2, o10, y0 = [];
            for (j2 = 0; j2 < m5; ++j2) {
              for (i5 = 0, o10 = 0; i5 < n2; i5++) o10 += data[i5][j2][1];
              if (o10 > max2) max2 = o10;
              sums.push(o10);
            }
            for (j2 = 0; j2 < m5; ++j2) {
              y0[j2] = (max2 - sums[j2]) / 2;
            }
            return y0;
          },
          wiggle: function(data) {
            var n2 = data.length, x3 = data[0], m5 = x3.length, i5, j2, k, s1, s22, s32, dx, o10, o0, y0 = [];
            y0[0] = o10 = o0 = 0;
            for (j2 = 1; j2 < m5; ++j2) {
              for (i5 = 0, s1 = 0; i5 < n2; ++i5) s1 += data[i5][j2][1];
              for (i5 = 0, s22 = 0, dx = x3[j2][0] - x3[j2 - 1][0]; i5 < n2; ++i5) {
                for (k = 0, s32 = (data[i5][j2][1] - data[i5][j2 - 1][1]) / (2 * dx); k < i5; ++k) {
                  s32 += (data[k][j2][1] - data[k][j2 - 1][1]) / dx;
                }
                s22 += s32 * data[i5][j2][1];
              }
              y0[j2] = o10 -= s1 ? s22 / s1 * dx : 0;
              if (o10 < o0) o0 = o10;
            }
            for (j2 = 0; j2 < m5; ++j2) y0[j2] -= o0;
            return y0;
          },
          expand: function(data) {
            var n2 = data.length, m5 = data[0].length, k = 1 / n2, i5, j2, o10, y0 = [];
            for (j2 = 0; j2 < m5; ++j2) {
              for (i5 = 0, o10 = 0; i5 < n2; i5++) o10 += data[i5][j2][1];
              if (o10) for (i5 = 0; i5 < n2; i5++) data[i5][j2][1] /= o10;
              else for (i5 = 0; i5 < n2; i5++) data[i5][j2][1] = k;
            }
            for (j2 = 0; j2 < m5; ++j2) y0[j2] = 0;
            return y0;
          },
          zero: d3_layout_stackOffsetZero
        });
        function d3_layout_stackOrderDefault(data) {
          return d33.range(data.length);
        }
        function d3_layout_stackOffsetZero(data) {
          var j2 = -1, m5 = data[0].length, y0 = [];
          while (++j2 < m5) y0[j2] = 0;
          return y0;
        }
        function d3_layout_stackMaxIndex(array) {
          var i5 = 1, j2 = 0, v3 = array[0][1], k, n2 = array.length;
          for (; i5 < n2; ++i5) {
            if ((k = array[i5][1]) > v3) {
              j2 = i5;
              v3 = k;
            }
          }
          return j2;
        }
        function d3_layout_stackReduceSum(d5) {
          return d5.reduce(d3_layout_stackSum, 0);
        }
        function d3_layout_stackSum(p3, d5) {
          return p3 + d5[1];
        }
        d33.layout.histogram = function() {
          var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
          function histogram(data, i5) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i5), thresholds = binner.call(this, range, values, i5), bin, i5 = -1, n2 = values.length, m5 = thresholds.length - 1, k = frequency ? 1 : 1 / n2, x3;
            while (++i5 < m5) {
              bin = bins[i5] = [];
              bin.dx = thresholds[i5 + 1] - (bin.x = thresholds[i5]);
              bin.y = 0;
            }
            if (m5 > 0) {
              i5 = -1;
              while (++i5 < n2) {
                x3 = values[i5];
                if (x3 >= range[0] && x3 <= range[1]) {
                  bin = bins[d33.bisect(thresholds, x3, 1, m5) - 1];
                  bin.y += k;
                  bin.push(data[i5]);
                }
              }
            }
            return bins;
          }
          histogram.value = function(x3) {
            if (!arguments.length) return valuer;
            valuer = x3;
            return histogram;
          };
          histogram.range = function(x3) {
            if (!arguments.length) return ranger;
            ranger = d3_functor(x3);
            return histogram;
          };
          histogram.bins = function(x3) {
            if (!arguments.length) return binner;
            binner = typeof x3 === "number" ? function(range) {
              return d3_layout_histogramBinFixed(range, x3);
            } : d3_functor(x3);
            return histogram;
          };
          histogram.frequency = function(x3) {
            if (!arguments.length) return frequency;
            frequency = !!x3;
            return histogram;
          };
          return histogram;
        };
        function d3_layout_histogramBinSturges(range, values) {
          return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
        }
        function d3_layout_histogramBinFixed(range, n2) {
          var x3 = -1, b2 = +range[0], m5 = (range[1] - b2) / n2, f5 = [];
          while (++x3 <= n2) f5[x3] = m5 * x3 + b2;
          return f5;
        }
        function d3_layout_histogramRange(values) {
          return [d33.min(values), d33.max(values)];
        }
        d33.layout.pack = function() {
          var hierarchy = d33.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [1, 1], radius;
          function pack(d5, i5) {
            var nodes = hierarchy.call(this, d5, i5), root = nodes[0], w3 = size[0], h3 = size[1], r6 = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
              return radius;
            };
            root.x = root.y = 0;
            d3_layout_hierarchyVisitAfter(root, function(d6) {
              d6.r = +r6(d6.value);
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
              var dr = padding * (radius ? 1 : Math.max(2 * root.r / w3, 2 * root.r / h3)) / 2;
              d3_layout_hierarchyVisitAfter(root, function(d6) {
                d6.r += dr;
              });
              d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
              d3_layout_hierarchyVisitAfter(root, function(d6) {
                d6.r -= dr;
              });
            }
            d3_layout_packTransform(root, w3 / 2, h3 / 2, radius ? 1 : 1 / Math.max(2 * root.r / w3, 2 * root.r / h3));
            return nodes;
          }
          pack.size = function(_2) {
            if (!arguments.length) return size;
            size = _2;
            return pack;
          };
          pack.radius = function(_2) {
            if (!arguments.length) return radius;
            radius = _2 == null || typeof _2 === "function" ? _2 : +_2;
            return pack;
          };
          pack.padding = function(_2) {
            if (!arguments.length) return padding;
            padding = +_2;
            return pack;
          };
          return d3_layout_hierarchyRebind(pack, hierarchy);
        };
        function d3_layout_packSort(a3, b2) {
          return a3.value - b2.value;
        }
        function d3_layout_packInsert(a3, b2) {
          var c3 = a3._pack_next;
          a3._pack_next = b2;
          b2._pack_prev = a3;
          b2._pack_next = c3;
          c3._pack_prev = b2;
        }
        function d3_layout_packSplice(a3, b2) {
          a3._pack_next = b2;
          b2._pack_prev = a3;
        }
        function d3_layout_packIntersects(a3, b2) {
          var dx = b2.x - a3.x, dy = b2.y - a3.y, dr = a3.r + b2.r;
          return 0.999 * dr * dr > dx * dx + dy * dy;
        }
        function d3_layout_packSiblings(node) {
          if (!(nodes = node.children) || !(n2 = nodes.length)) return;
          var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a3, b2, c3, i5, j2, k, n2;
          function bound(node2) {
            xMin = Math.min(node2.x - node2.r, xMin);
            xMax = Math.max(node2.x + node2.r, xMax);
            yMin = Math.min(node2.y - node2.r, yMin);
            yMax = Math.max(node2.y + node2.r, yMax);
          }
          nodes.forEach(d3_layout_packLink);
          a3 = nodes[0];
          a3.x = -a3.r;
          a3.y = 0;
          bound(a3);
          if (n2 > 1) {
            b2 = nodes[1];
            b2.x = b2.r;
            b2.y = 0;
            bound(b2);
            if (n2 > 2) {
              c3 = nodes[2];
              d3_layout_packPlace(a3, b2, c3);
              bound(c3);
              d3_layout_packInsert(a3, c3);
              a3._pack_prev = c3;
              d3_layout_packInsert(c3, b2);
              b2 = a3._pack_next;
              for (i5 = 3; i5 < n2; i5++) {
                d3_layout_packPlace(a3, b2, c3 = nodes[i5]);
                var isect = 0, s1 = 1, s22 = 1;
                for (j2 = b2._pack_next; j2 !== b2; j2 = j2._pack_next, s1++) {
                  if (d3_layout_packIntersects(j2, c3)) {
                    isect = 1;
                    break;
                  }
                }
                if (isect == 1) {
                  for (k = a3._pack_prev; k !== j2._pack_prev; k = k._pack_prev, s22++) {
                    if (d3_layout_packIntersects(k, c3)) {
                      break;
                    }
                  }
                }
                if (isect) {
                  if (s1 < s22 || s1 == s22 && b2.r < a3.r) d3_layout_packSplice(a3, b2 = j2);
                  else d3_layout_packSplice(a3 = k, b2);
                  i5--;
                } else {
                  d3_layout_packInsert(a3, c3);
                  b2 = c3;
                  bound(c3);
                }
              }
            }
          }
          var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
          for (i5 = 0; i5 < n2; i5++) {
            c3 = nodes[i5];
            c3.x -= cx;
            c3.y -= cy;
            cr = Math.max(cr, c3.r + Math.sqrt(c3.x * c3.x + c3.y * c3.y));
          }
          node.r = cr;
          nodes.forEach(d3_layout_packUnlink);
        }
        function d3_layout_packLink(node) {
          node._pack_next = node._pack_prev = node;
        }
        function d3_layout_packUnlink(node) {
          delete node._pack_next;
          delete node._pack_prev;
        }
        function d3_layout_packTransform(node, x3, y2, k) {
          var children = node.children;
          node.x = x3 += k * node.x;
          node.y = y2 += k * node.y;
          node.r *= k;
          if (children) {
            var i5 = -1, n2 = children.length;
            while (++i5 < n2) d3_layout_packTransform(children[i5], x3, y2, k);
          }
        }
        function d3_layout_packPlace(a3, b2, c3) {
          var db = a3.r + c3.r, dx = b2.x - a3.x, dy = b2.y - a3.y;
          if (db && (dx || dy)) {
            var da = b2.r + c3.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x3 = 0.5 + (db - da) / (2 * dc), y2 = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c3.x = a3.x + x3 * dx + y2 * dy;
            c3.y = a3.y + x3 * dy - y2 * dx;
          } else {
            c3.x = a3.x + db;
            c3.y = a3.y;
          }
        }
        d33.layout.tree = function() {
          var hierarchy = d33.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [1, 1], nodeSize = null;
          function tree(d5, i5) {
            var nodes = hierarchy.call(this, d5, i5), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode);
            else {
              var left2 = root0, right2 = root0, bottom2 = root0;
              d3_layout_hierarchyVisitBefore(root0, function(node) {
                if (node.x < left2.x) left2 = node;
                if (node.x > right2.x) right2 = node;
                if (node.depth > bottom2.depth) bottom2 = node;
              });
              var tx = separation(left2, right2) / 2 - left2.x, kx = size[0] / (right2.x + separation(right2, left2) / 2 + tx), ky = size[1] / (bottom2.depth || 1);
              d3_layout_hierarchyVisitBefore(root0, function(node) {
                node.x = (node.x + tx) * kx;
                node.y = node.depth * ky;
              });
            }
            return nodes;
          }
          function wrapTree(root0) {
            var root1 = {
              A: null,
              children: [root0]
            }, queue = [root1], node1;
            while ((node1 = queue.pop()) != null) {
              for (var children = node1.children, child, i5 = 0, n2 = children.length; i5 < n2; ++i5) {
                queue.push((children[i5] = child = {
                  _: children[i5],
                  parent: node1,
                  children: (child = children[i5].children) && child.slice() || [],
                  A: null,
                  a: null,
                  z: 0,
                  m: 0,
                  c: 0,
                  s: 0,
                  t: null,
                  i: i5
                }).a = child);
              }
            }
            return root1.children[0];
          }
          function firstWalk(v3) {
            var children = v3.children, siblings = v3.parent.children, w3 = v3.i ? siblings[v3.i - 1] : null;
            if (children.length) {
              d3_layout_treeShift(v3);
              var midpoint = (children[0].z + children[children.length - 1].z) / 2;
              if (w3) {
                v3.z = w3.z + separation(v3._, w3._);
                v3.m = v3.z - midpoint;
              } else {
                v3.z = midpoint;
              }
            } else if (w3) {
              v3.z = w3.z + separation(v3._, w3._);
            }
            v3.parent.A = apportion(v3, w3, v3.parent.A || siblings[0]);
          }
          function secondWalk(v3) {
            v3._.x = v3.z + v3.parent.m;
            v3.m += v3.parent.m;
          }
          function apportion(v3, w3, ancestor) {
            if (w3) {
              var vip = v3, vop = v3, vim = w3, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
              while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                vom = d3_layout_treeLeft(vom);
                vop = d3_layout_treeRight(vop);
                vop.a = v3;
                shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                if (shift > 0) {
                  d3_layout_treeMove(d3_layout_treeAncestor(vim, v3, ancestor), v3, shift);
                  sip += shift;
                  sop += shift;
                }
                sim += vim.m;
                sip += vip.m;
                som += vom.m;
                sop += vop.m;
              }
              if (vim && !d3_layout_treeRight(vop)) {
                vop.t = vim;
                vop.m += sim - sop;
              }
              if (vip && !d3_layout_treeLeft(vom)) {
                vom.t = vip;
                vom.m += sip - som;
                ancestor = v3;
              }
            }
            return ancestor;
          }
          function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
          }
          tree.separation = function(x3) {
            if (!arguments.length) return separation;
            separation = x3;
            return tree;
          };
          tree.size = function(x3) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x3) == null ? sizeNode : null;
            return tree;
          };
          tree.nodeSize = function(x3) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x3) == null ? null : sizeNode;
            return tree;
          };
          return d3_layout_hierarchyRebind(tree, hierarchy);
        };
        function d3_layout_treeSeparation(a3, b2) {
          return a3.parent == b2.parent ? 1 : 2;
        }
        function d3_layout_treeLeft(v3) {
          var children = v3.children;
          return children.length ? children[0] : v3.t;
        }
        function d3_layout_treeRight(v3) {
          var children = v3.children, n2;
          return (n2 = children.length) ? children[n2 - 1] : v3.t;
        }
        function d3_layout_treeMove(wm, wp, shift) {
          var change = shift / (wp.i - wm.i);
          wp.c -= change;
          wp.s += shift;
          wm.c += change;
          wp.z += shift;
          wp.m += shift;
        }
        function d3_layout_treeShift(v3) {
          var shift = 0, change = 0, children = v3.children, i5 = children.length, w3;
          while (--i5 >= 0) {
            w3 = children[i5];
            w3.z += shift;
            w3.m += shift;
            shift += w3.s + (change += w3.c);
          }
        }
        function d3_layout_treeAncestor(vim, v3, ancestor) {
          return vim.a.parent === v3.parent ? vim.a : ancestor;
        }
        d33.layout.cluster = function() {
          var hierarchy = d33.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [1, 1], nodeSize = false;
          function cluster(d5, i5) {
            var nodes = hierarchy.call(this, d5, i5), root = nodes[0], previousNode, x3 = 0;
            d3_layout_hierarchyVisitAfter(root, function(node) {
              var children = node.children;
              if (children && children.length) {
                node.x = d3_layout_clusterX(children);
                node.y = d3_layout_clusterY(children);
              } else {
                node.x = previousNode ? x3 += separation(node, previousNode) : 0;
                node.y = 0;
                previousNode = node;
              }
            });
            var left2 = d3_layout_clusterLeft(root), right2 = d3_layout_clusterRight(root), x0 = left2.x - separation(left2, right2) / 2, x1 = right2.x + separation(right2, left2) / 2;
            d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
              node.x = (node.x - root.x) * size[0];
              node.y = (root.y - node.y) * size[1];
            } : function(node) {
              node.x = (node.x - x0) / (x1 - x0) * size[0];
              node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
          }
          cluster.separation = function(x3) {
            if (!arguments.length) return separation;
            separation = x3;
            return cluster;
          };
          cluster.size = function(x3) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x3) == null;
            return cluster;
          };
          cluster.nodeSize = function(x3) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x3) != null;
            return cluster;
          };
          return d3_layout_hierarchyRebind(cluster, hierarchy);
        };
        function d3_layout_clusterY(children) {
          return 1 + d33.max(children, function(child) {
            return child.y;
          });
        }
        function d3_layout_clusterX(children) {
          return children.reduce(function(x3, child) {
            return x3 + child.x;
          }, 0) / children.length;
        }
        function d3_layout_clusterLeft(node) {
          var children = node.children;
          return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
        }
        function d3_layout_clusterRight(node) {
          var children = node.children, n2;
          return children && (n2 = children.length) ? d3_layout_clusterRight(children[n2 - 1]) : node;
        }
        d33.layout.treemap = function() {
          var hierarchy = d33.layout.hierarchy(), round3 = Math.round, size = [1, 1], padding = null, pad2 = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = 0.5 * (1 + Math.sqrt(5));
          function scale2(children, k) {
            var i5 = -1, n2 = children.length, child, area;
            while (++i5 < n2) {
              area = (child = children[i5]).value * (k < 0 ? 0 : k);
              child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
          }
          function squarify(node) {
            var children = node.children;
            if (children && children.length) {
              var rect = pad2(node), row = [], remaining = children.slice(), child, best = Infinity, score, u4 = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n2;
              scale2(remaining, rect.dx * rect.dy / node.value);
              row.area = 0;
              while ((n2 = remaining.length) > 0) {
                row.push(child = remaining[n2 - 1]);
                row.area += child.area;
                if (mode !== "squarify" || (score = worst(row, u4)) <= best) {
                  remaining.pop();
                  best = score;
                } else {
                  row.area -= row.pop().area;
                  position(row, u4, rect, false);
                  u4 = Math.min(rect.dx, rect.dy);
                  row.length = row.area = 0;
                  best = Infinity;
                }
              }
              if (row.length) {
                position(row, u4, rect, true);
                row.length = row.area = 0;
              }
              children.forEach(squarify);
            }
          }
          function stickify(node) {
            var children = node.children;
            if (children && children.length) {
              var rect = pad2(node), remaining = children.slice(), child, row = [];
              scale2(remaining, rect.dx * rect.dy / node.value);
              row.area = 0;
              while (child = remaining.pop()) {
                row.push(child);
                row.area += child.area;
                if (child.z != null) {
                  position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                  row.length = row.area = 0;
                }
              }
              children.forEach(stickify);
            }
          }
          function worst(row, u4) {
            var s7 = row.area, r6, rmax = 0, rmin = Infinity, i5 = -1, n2 = row.length;
            while (++i5 < n2) {
              if (!(r6 = row[i5].area)) continue;
              if (r6 < rmin) rmin = r6;
              if (r6 > rmax) rmax = r6;
            }
            s7 *= s7;
            u4 *= u4;
            return s7 ? Math.max(u4 * rmax * ratio / s7, s7 / (u4 * rmin * ratio)) : Infinity;
          }
          function position(row, u4, rect, flush) {
            var i5 = -1, n2 = row.length, x3 = rect.x, y2 = rect.y, v3 = u4 ? round3(row.area / u4) : 0, o10;
            if (u4 == rect.dx) {
              if (flush || v3 > rect.dy) v3 = rect.dy;
              while (++i5 < n2) {
                o10 = row[i5];
                o10.x = x3;
                o10.y = y2;
                o10.dy = v3;
                x3 += o10.dx = Math.min(rect.x + rect.dx - x3, v3 ? round3(o10.area / v3) : 0);
              }
              o10.z = true;
              o10.dx += rect.x + rect.dx - x3;
              rect.y += v3;
              rect.dy -= v3;
            } else {
              if (flush || v3 > rect.dx) v3 = rect.dx;
              while (++i5 < n2) {
                o10 = row[i5];
                o10.x = x3;
                o10.y = y2;
                o10.dx = v3;
                y2 += o10.dy = Math.min(rect.y + rect.dy - y2, v3 ? round3(o10.area / v3) : 0);
              }
              o10.z = false;
              o10.dy += rect.y + rect.dy - y2;
              rect.x += v3;
              rect.dx -= v3;
            }
          }
          function treemap(d5) {
            var nodes = stickies || hierarchy(d5), root = nodes[0];
            root.x = root.y = 0;
            if (root.value) root.dx = size[0], root.dy = size[1];
            else root.dx = root.dy = 0;
            if (stickies) hierarchy.revalue(root);
            scale2([root], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky) stickies = nodes;
            return nodes;
          }
          treemap.size = function(x3) {
            if (!arguments.length) return size;
            size = x3;
            return treemap;
          };
          treemap.padding = function(x3) {
            if (!arguments.length) return padding;
            function padFunction(node) {
              var p3 = x3.call(treemap, node, node.depth);
              return p3 == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p3 === "number" ? [p3, p3, p3, p3] : p3);
            }
            function padConstant(node) {
              return d3_layout_treemapPad(node, x3);
            }
            var type;
            pad2 = (padding = x3) == null ? d3_layout_treemapPadNull : (type = typeof x3) === "function" ? padFunction : type === "number" ? (x3 = [x3, x3, x3, x3], padConstant) : padConstant;
            return treemap;
          };
          treemap.round = function(x3) {
            if (!arguments.length) return round3 != Number;
            round3 = x3 ? Math.round : Number;
            return treemap;
          };
          treemap.sticky = function(x3) {
            if (!arguments.length) return sticky;
            sticky = x3;
            stickies = null;
            return treemap;
          };
          treemap.ratio = function(x3) {
            if (!arguments.length) return ratio;
            ratio = x3;
            return treemap;
          };
          treemap.mode = function(x3) {
            if (!arguments.length) return mode;
            mode = x3 + "";
            return treemap;
          };
          return d3_layout_hierarchyRebind(treemap, hierarchy);
        };
        function d3_layout_treemapPadNull(node) {
          return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
          };
        }
        function d3_layout_treemapPad(node, padding) {
          var x3 = node.x + padding[3], y2 = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
          if (dx < 0) {
            x3 += dx / 2;
            dx = 0;
          }
          if (dy < 0) {
            y2 += dy / 2;
            dy = 0;
          }
          return {
            x: x3,
            y: y2,
            dx,
            dy
          };
        }
        d33.random = {
          normal: function(\u00B5, \u03C3) {
            var n2 = arguments.length;
            if (n2 < 2) \u03C3 = 1;
            if (n2 < 1) \u00B5 = 0;
            return function() {
              var x3, y2, r6;
              do {
                x3 = Math.random() * 2 - 1;
                y2 = Math.random() * 2 - 1;
                r6 = x3 * x3 + y2 * y2;
              } while (!r6 || r6 > 1);
              return \u00B5 + \u03C3 * x3 * Math.sqrt(-2 * Math.log(r6) / r6);
            };
          },
          logNormal: function() {
            var random = d33.random.normal.apply(d33, arguments);
            return function() {
              return Math.exp(random());
            };
          },
          bates: function(m5) {
            var random = d33.random.irwinHall(m5);
            return function() {
              return random() / m5;
            };
          },
          irwinHall: function(m5) {
            return function() {
              for (var s7 = 0, j2 = 0; j2 < m5; j2++) s7 += Math.random();
              return s7;
            };
          }
        };
        d33.scale = {};
        function d3_scaleExtent(domain) {
          var start3 = domain[0], stop = domain[domain.length - 1];
          return start3 < stop ? [start3, stop] : [stop, start3];
        }
        function d3_scaleRange(scale2) {
          return scale2.rangeExtent ? scale2.rangeExtent() : d3_scaleExtent(scale2.range());
        }
        function d3_scale_bilinear(domain, range, uninterpolate, interpolate3) {
          var u4 = uninterpolate(domain[0], domain[1]), i5 = interpolate3(range[0], range[1]);
          return function(x3) {
            return i5(u4(x3));
          };
        }
        function d3_scale_nice(domain, nice) {
          var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
          if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
          }
          domain[i0] = nice.floor(x0);
          domain[i1] = nice.ceil(x1);
          return domain;
        }
        function d3_scale_niceStep(step) {
          return step ? {
            floor: function(x3) {
              return Math.floor(x3 / step) * step;
            },
            ceil: function(x3) {
              return Math.ceil(x3 / step) * step;
            }
          } : d3_scale_niceIdentity;
        }
        var d3_scale_niceIdentity = {
          floor: d3_identity,
          ceil: d3_identity
        };
        function d3_scale_polylinear(domain, range, uninterpolate, interpolate3) {
          var u4 = [], i5 = [], j2 = 0, k = Math.min(domain.length, range.length) - 1;
          if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
          }
          while (++j2 <= k) {
            u4.push(uninterpolate(domain[j2 - 1], domain[j2]));
            i5.push(interpolate3(range[j2 - 1], range[j2]));
          }
          return function(x3) {
            var j3 = d33.bisect(domain, x3, 1, k) - 1;
            return i5[j3](u4[j3](x3));
          };
        }
        d33.scale.linear = function() {
          return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);
        };
        function d3_scale_linear(domain, range, interpolate3, clamp) {
          var output, input;
          function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate3);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale2;
          }
          function scale2(x3) {
            return output(x3);
          }
          scale2.invert = function(y2) {
            return input(y2);
          };
          scale2.domain = function(x3) {
            if (!arguments.length) return domain;
            domain = x3.map(Number);
            return rescale();
          };
          scale2.range = function(x3) {
            if (!arguments.length) return range;
            range = x3;
            return rescale();
          };
          scale2.rangeRound = function(x3) {
            return scale2.range(x3).interpolate(d3_interpolateRound);
          };
          scale2.clamp = function(x3) {
            if (!arguments.length) return clamp;
            clamp = x3;
            return rescale();
          };
          scale2.interpolate = function(x3) {
            if (!arguments.length) return interpolate3;
            interpolate3 = x3;
            return rescale();
          };
          scale2.ticks = function(m5) {
            return d3_scale_linearTicks(domain, m5);
          };
          scale2.tickFormat = function(m5, format2) {
            return d3_scale_linearTickFormat(domain, m5, format2);
          };
          scale2.nice = function(m5) {
            d3_scale_linearNice(domain, m5);
            return rescale();
          };
          scale2.copy = function() {
            return d3_scale_linear(domain, range, interpolate3, clamp);
          };
          return rescale();
        }
        function d3_scale_linearRebind(scale2, linear) {
          return d33.rebind(scale2, linear, "range", "rangeRound", "interpolate", "clamp");
        }
        function d3_scale_linearNice(domain, m5) {
          d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m5)[2]));
          d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m5)[2]));
          return domain;
        }
        function d3_scale_linearTickRange(domain, m5) {
          if (m5 == null) m5 = 10;
          var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m5) / Math.LN10)), err = m5 / span * step;
          if (err <= 0.15) step *= 10;
          else if (err <= 0.35) step *= 5;
          else if (err <= 0.75) step *= 2;
          extent[0] = Math.ceil(extent[0] / step) * step;
          extent[1] = Math.floor(extent[1] / step) * step + step * 0.5;
          extent[2] = step;
          return extent;
        }
        function d3_scale_linearTicks(domain, m5) {
          return d33.range.apply(d33, d3_scale_linearTickRange(domain, m5));
        }
        function d3_scale_linearTickFormat(domain, m5, format2) {
          var range = d3_scale_linearTickRange(domain, m5);
          if (format2) {
            var match = d3_format_re.exec(format2);
            match.shift();
            if (match[8] === "s") {
              var prefix2 = d33.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
              if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix2.scale(range[2]));
              match[8] = "f";
              format2 = d33.format(match.join(""));
              return function(d5) {
                return format2(prefix2.scale(d5)) + prefix2.symbol;
              };
            }
            if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
            format2 = match.join("");
          } else {
            format2 = ",." + d3_scale_linearPrecision(range[2]) + "f";
          }
          return d33.format(format2);
        }
        var d3_scale_linearFormatSignificant = {
          s: 1,
          g: 1,
          p: 1,
          r: 1,
          e: 1
        };
        function d3_scale_linearPrecision(value) {
          return -Math.floor(Math.log(value) / Math.LN10 + 0.01);
        }
        function d3_scale_linearFormatPrecision(type, range) {
          var p3 = d3_scale_linearPrecision(range[2]);
          return type in d3_scale_linearFormatSignificant ? Math.abs(p3 - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p3 - (type === "%") * 2;
        }
        d33.scale.log = function() {
          return d3_scale_log(d33.scale.linear().domain([0, 1]), 10, true, [1, 10]);
        };
        function d3_scale_log(linear, base, positive, domain) {
          function log(x3) {
            return (positive ? Math.log(x3 < 0 ? 0 : x3) : -Math.log(x3 > 0 ? 0 : -x3)) / Math.log(base);
          }
          function pow(x3) {
            return positive ? Math.pow(base, x3) : -Math.pow(base, -x3);
          }
          function scale2(x3) {
            return linear(log(x3));
          }
          scale2.invert = function(x3) {
            return pow(linear.invert(x3));
          };
          scale2.domain = function(x3) {
            if (!arguments.length) return domain;
            positive = x3[0] >= 0;
            linear.domain((domain = x3.map(Number)).map(log));
            return scale2;
          };
          scale2.base = function(_2) {
            if (!arguments.length) return base;
            base = +_2;
            linear.domain(domain.map(log));
            return scale2;
          };
          scale2.nice = function() {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale2;
          };
          scale2.ticks = function() {
            var extent = d3_scaleExtent(domain), ticks = [], u4 = extent[0], v3 = extent[1], i5 = Math.floor(log(u4)), j2 = Math.ceil(log(v3)), n2 = base % 1 ? 2 : base;
            if (isFinite(j2 - i5)) {
              if (positive) {
                for (; i5 < j2; i5++) for (var k = 1; k < n2; k++) ticks.push(pow(i5) * k);
                ticks.push(pow(i5));
              } else {
                ticks.push(pow(i5));
                for (; i5++ < j2; ) for (var k = n2 - 1; k > 0; k--) ticks.push(pow(i5) * k);
              }
              for (i5 = 0; ticks[i5] < u4; i5++) {
              }
              for (j2 = ticks.length; ticks[j2 - 1] > v3; j2--) {
              }
              ticks = ticks.slice(i5, j2);
            }
            return ticks;
          };
          scale2.tickFormat = function(n2, format2) {
            if (!arguments.length) return d3_scale_logFormat;
            if (arguments.length < 2) format2 = d3_scale_logFormat;
            else if (typeof format2 !== "function") format2 = d33.format(format2);
            var k = Math.max(1, base * n2 / scale2.ticks().length);
            return function(d5) {
              var i5 = d5 / pow(Math.round(log(d5)));
              if (i5 * base < base - 0.5) i5 *= base;
              return i5 <= k ? format2(d5) : "";
            };
          };
          scale2.copy = function() {
            return d3_scale_log(linear.copy(), base, positive, domain);
          };
          return d3_scale_linearRebind(scale2, linear);
        }
        var d3_scale_logFormat = d33.format(".0e"), d3_scale_logNiceNegative = {
          floor: function(x3) {
            return -Math.ceil(-x3);
          },
          ceil: function(x3) {
            return -Math.floor(-x3);
          }
        };
        d33.scale.pow = function() {
          return d3_scale_pow(d33.scale.linear(), 1, [0, 1]);
        };
        function d3_scale_pow(linear, exponent, domain) {
          var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
          function scale2(x3) {
            return linear(powp(x3));
          }
          scale2.invert = function(x3) {
            return powb(linear.invert(x3));
          };
          scale2.domain = function(x3) {
            if (!arguments.length) return domain;
            linear.domain((domain = x3.map(Number)).map(powp));
            return scale2;
          };
          scale2.ticks = function(m5) {
            return d3_scale_linearTicks(domain, m5);
          };
          scale2.tickFormat = function(m5, format2) {
            return d3_scale_linearTickFormat(domain, m5, format2);
          };
          scale2.nice = function(m5) {
            return scale2.domain(d3_scale_linearNice(domain, m5));
          };
          scale2.exponent = function(x3) {
            if (!arguments.length) return exponent;
            powp = d3_scale_powPow(exponent = x3);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale2;
          };
          scale2.copy = function() {
            return d3_scale_pow(linear.copy(), exponent, domain);
          };
          return d3_scale_linearRebind(scale2, linear);
        }
        function d3_scale_powPow(e3) {
          return function(x3) {
            return x3 < 0 ? -Math.pow(-x3, e3) : Math.pow(x3, e3);
          };
        }
        d33.scale.sqrt = function() {
          return d33.scale.pow().exponent(0.5);
        };
        d33.scale.ordinal = function() {
          return d3_scale_ordinal([], {
            t: "range",
            a: [[]]
          });
        };
        function d3_scale_ordinal(domain, ranger) {
          var index2, range, rangeBand;
          function scale2(x3) {
            return range[((index2.get(x3) || (ranger.t === "range" ? index2.set(x3, domain.push(x3)) : NaN)) - 1) % range.length];
          }
          function steps(start3, step) {
            return d33.range(domain.length).map(function(i5) {
              return start3 + step * i5;
            });
          }
          scale2.domain = function(x3) {
            if (!arguments.length) return domain;
            domain = [];
            index2 = new d3_Map();
            var i5 = -1, n2 = x3.length, xi;
            while (++i5 < n2) if (!index2.has(xi = x3[i5])) index2.set(xi, domain.push(xi));
            return scale2[ranger.t].apply(scale2, ranger.a);
          };
          scale2.range = function(x3) {
            if (!arguments.length) return range;
            range = x3;
            rangeBand = 0;
            ranger = {
              t: "range",
              a: arguments
            };
            return scale2;
          };
          scale2.rangePoints = function(x3, padding) {
            if (arguments.length < 2) padding = 0;
            var start3 = x3[0], stop = x3[1], step = domain.length < 2 ? (start3 = (start3 + stop) / 2, 0) : (stop - start3) / (domain.length - 1 + padding);
            range = steps(start3 + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
              t: "rangePoints",
              a: arguments
            };
            return scale2;
          };
          scale2.rangeRoundPoints = function(x3, padding) {
            if (arguments.length < 2) padding = 0;
            var start3 = x3[0], stop = x3[1], step = domain.length < 2 ? (start3 = stop = Math.round((start3 + stop) / 2), 0) : (stop - start3) / (domain.length - 1 + padding) | 0;
            range = steps(start3 + Math.round(step * padding / 2 + (stop - start3 - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
              t: "rangeRoundPoints",
              a: arguments
            };
            return scale2;
          };
          scale2.rangeBands = function(x3, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x3[1] < x3[0], start3 = x3[reverse - 0], stop = x3[1 - reverse], step = (stop - start3) / (domain.length - padding + 2 * outerPadding);
            range = steps(start3 + step * outerPadding, step);
            if (reverse) range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
              t: "rangeBands",
              a: arguments
            };
            return scale2;
          };
          scale2.rangeRoundBands = function(x3, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x3[1] < x3[0], start3 = x3[reverse - 0], stop = x3[1 - reverse], step = Math.floor((stop - start3) / (domain.length - padding + 2 * outerPadding));
            range = steps(start3 + Math.round((stop - start3 - (domain.length - padding) * step) / 2), step);
            if (reverse) range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
              t: "rangeRoundBands",
              a: arguments
            };
            return scale2;
          };
          scale2.rangeBand = function() {
            return rangeBand;
          };
          scale2.rangeExtent = function() {
            return d3_scaleExtent(ranger.a[0]);
          };
          scale2.copy = function() {
            return d3_scale_ordinal(domain, ranger);
          };
          return scale2.domain(domain);
        }
        d33.scale.category10 = function() {
          return d33.scale.ordinal().range(d3_category10);
        };
        d33.scale.category20 = function() {
          return d33.scale.ordinal().range(d3_category20);
        };
        d33.scale.category20b = function() {
          return d33.scale.ordinal().range(d3_category20b);
        };
        d33.scale.category20c = function() {
          return d33.scale.ordinal().range(d3_category20c);
        };
        var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);
        var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);
        var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);
        var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
        d33.scale.quantile = function() {
          return d3_scale_quantile([], []);
        };
        function d3_scale_quantile(domain, range) {
          var thresholds;
          function rescale() {
            var k = 0, q3 = range.length;
            thresholds = [];
            while (++k < q3) thresholds[k - 1] = d33.quantile(domain, k / q3);
            return scale2;
          }
          function scale2(x3) {
            if (!isNaN(x3 = +x3)) return range[d33.bisect(thresholds, x3)];
          }
          scale2.domain = function(x3) {
            if (!arguments.length) return domain;
            domain = x3.map(d3_number).filter(d3_numeric).sort(d3_ascending);
            return rescale();
          };
          scale2.range = function(x3) {
            if (!arguments.length) return range;
            range = x3;
            return rescale();
          };
          scale2.quantiles = function() {
            return thresholds;
          };
          scale2.invertExtent = function(y2) {
            y2 = range.indexOf(y2);
            return y2 < 0 ? [NaN, NaN] : [y2 > 0 ? thresholds[y2 - 1] : domain[0], y2 < thresholds.length ? thresholds[y2] : domain[domain.length - 1]];
          };
          scale2.copy = function() {
            return d3_scale_quantile(domain, range);
          };
          return rescale();
        }
        d33.scale.quantize = function() {
          return d3_scale_quantize(0, 1, [0, 1]);
        };
        function d3_scale_quantize(x0, x1, range) {
          var kx, i5;
          function scale2(x3) {
            return range[Math.max(0, Math.min(i5, Math.floor(kx * (x3 - x0))))];
          }
          function rescale() {
            kx = range.length / (x1 - x0);
            i5 = range.length - 1;
            return scale2;
          }
          scale2.domain = function(x3) {
            if (!arguments.length) return [x0, x1];
            x0 = +x3[0];
            x1 = +x3[x3.length - 1];
            return rescale();
          };
          scale2.range = function(x3) {
            if (!arguments.length) return range;
            range = x3;
            return rescale();
          };
          scale2.invertExtent = function(y2) {
            y2 = range.indexOf(y2);
            y2 = y2 < 0 ? NaN : y2 / kx + x0;
            return [y2, y2 + 1 / kx];
          };
          scale2.copy = function() {
            return d3_scale_quantize(x0, x1, range);
          };
          return rescale();
        }
        d33.scale.threshold = function() {
          return d3_scale_threshold([0.5], [0, 1]);
        };
        function d3_scale_threshold(domain, range) {
          function scale2(x3) {
            if (x3 <= x3) return range[d33.bisect(domain, x3)];
          }
          scale2.domain = function(_2) {
            if (!arguments.length) return domain;
            domain = _2;
            return scale2;
          };
          scale2.range = function(_2) {
            if (!arguments.length) return range;
            range = _2;
            return scale2;
          };
          scale2.invertExtent = function(y2) {
            y2 = range.indexOf(y2);
            return [domain[y2 - 1], domain[y2]];
          };
          scale2.copy = function() {
            return d3_scale_threshold(domain, range);
          };
          return scale2;
        }
        d33.scale.identity = function() {
          return d3_scale_identity([0, 1]);
        };
        function d3_scale_identity(domain) {
          function identity(x3) {
            return +x3;
          }
          identity.invert = identity;
          identity.domain = identity.range = function(x3) {
            if (!arguments.length) return domain;
            domain = x3.map(identity);
            return identity;
          };
          identity.ticks = function(m5) {
            return d3_scale_linearTicks(domain, m5);
          };
          identity.tickFormat = function(m5, format2) {
            return d3_scale_linearTickFormat(domain, m5, format2);
          };
          identity.copy = function() {
            return d3_scale_identity(domain);
          };
          return identity;
        }
        d33.svg = {};
        function d3_zero() {
          return 0;
        }
        d33.svg.arc = function() {
          var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
          function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half\u03C0, a1 = endAngle.apply(this, arguments) - half\u03C0, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
            if (da >= \u03C4\u03B5) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x22, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
              rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
              if (!cw) p1 *= -1;
              if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
              if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
            }
            if (r1) {
              x0 = r1 * Math.cos(a0 + p1);
              y0 = r1 * Math.sin(a0 + p1);
              x1 = r1 * Math.cos(a1 - p1);
              y1 = r1 * Math.sin(a1 - p1);
              var l1 = Math.abs(a1 - a0 - 2 * p1) <= \u03C0 ? 0 : 1;
              if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                var h12 = (a0 + a1) / 2;
                x0 = r1 * Math.cos(h12);
                y0 = r1 * Math.sin(h12);
                x1 = y1 = null;
              }
            } else {
              x0 = y0 = 0;
            }
            if (r0) {
              x22 = r0 * Math.cos(a1 - p0);
              y2 = r0 * Math.sin(a1 - p0);
              x3 = r0 * Math.cos(a0 + p0);
              y3 = r0 * Math.sin(a0 + p0);
              var l0 = Math.abs(a0 - a1 + 2 * p0) <= \u03C0 ? 0 : 1;
              if (p0 && d3_svg_arcSweep(x22, y2, x3, y3) === 1 - cw ^ l0) {
                var h0 = (a0 + a1) / 2;
                x22 = r0 * Math.cos(h0);
                y2 = r0 * Math.sin(h0);
                x3 = y3 = null;
              }
            } else {
              x22 = y2 = 0;
            }
            if (da > \u03B5 && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > 1e-3) {
              cr = r0 < r1 ^ cw ? 0 : 1;
              var rc1 = rc, rc0 = rc;
              if (da < \u03C0) {
                var oc = x3 == null ? [x22, y2] : x1 == null ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x22, y2]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
                rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
              }
              if (x1 != null) {
                var t30 = d3_svg_arcCornerTangents(x3 == null ? [x22, y2] : [x3, y3], [x0, y0], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([x1, y1], [x22, y2], r1, rc1, cw);
                if (rc === rc1) {
                  path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                } else {
                  path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                }
              } else {
                path.push("M", x0, ",", y0);
              }
              if (x3 != null) {
                var t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([x22, y2], x1 == null ? [x0, y0] : [x1, y1], r0, -rc0, cw);
                if (rc === rc0) {
                  path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                } else {
                  path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                }
              } else {
                path.push("L", x22, ",", y2);
              }
            } else {
              path.push("M", x0, ",", y0);
              if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
              path.push("L", x22, ",", y2);
              if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
            }
            path.push("Z");
            return path.join("");
          }
          function circleSegment(r1, cw) {
            return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
          }
          arc.innerRadius = function(v3) {
            if (!arguments.length) return innerRadius;
            innerRadius = d3_functor(v3);
            return arc;
          };
          arc.outerRadius = function(v3) {
            if (!arguments.length) return outerRadius;
            outerRadius = d3_functor(v3);
            return arc;
          };
          arc.cornerRadius = function(v3) {
            if (!arguments.length) return cornerRadius;
            cornerRadius = d3_functor(v3);
            return arc;
          };
          arc.padRadius = function(v3) {
            if (!arguments.length) return padRadius;
            padRadius = v3 == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v3);
            return arc;
          };
          arc.startAngle = function(v3) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v3);
            return arc;
          };
          arc.endAngle = function(v3) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v3);
            return arc;
          };
          arc.padAngle = function(v3) {
            if (!arguments.length) return padAngle;
            padAngle = d3_functor(v3);
            return arc;
          };
          arc.centroid = function() {
            var r6 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a3 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half\u03C0;
            return [Math.cos(a3) * r6, Math.sin(a3) * r6];
          };
          return arc;
        };
        var d3_svg_arcAuto = "auto";
        function d3_svg_arcInnerRadius(d5) {
          return d5.innerRadius;
        }
        function d3_svg_arcOuterRadius(d5) {
          return d5.outerRadius;
        }
        function d3_svg_arcStartAngle(d5) {
          return d5.startAngle;
        }
        function d3_svg_arcEndAngle(d5) {
          return d5.endAngle;
        }
        function d3_svg_arcPadAngle(d5) {
          return d5 && d5.padAngle;
        }
        function d3_svg_arcSweep(x0, y0, x1, y1) {
          return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
        }
        function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
          var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x22 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x22) / 2, y3 = (y1 + y2) / 2, dx = x22 - x1, dy = y2 - y1, d22 = dx * dx + dy * dy, r6 = r1 - rc, D2 = x1 * y2 - x22 * y1, d5 = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r6 * r6 * d22 - D2 * D2)), cx0 = (D2 * dy - dx * d5) / d22, cy0 = (-D2 * dx - dy * d5) / d22, cx1 = (D2 * dy + dx * d5) / d22, cy1 = (-D2 * dx + dy * d5) / d22, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
          if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
          return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r6, cy0 * r1 / r6]];
        }
        function d3_svg_line(projection) {
          var x3 = d3_geom_pointX, y2 = d3_geom_pointY, defined2 = d3_true, interpolate3 = d3_svg_lineLinear, interpolateKey = interpolate3.key, tension = 0.7;
          function line(data) {
            var segments = [], points = [], i5 = -1, n2 = data.length, d5, fx = d3_functor(x3), fy = d3_functor(y2);
            function segment() {
              segments.push("M", interpolate3(projection(points), tension));
            }
            while (++i5 < n2) {
              if (defined2.call(this, d5 = data[i5], i5)) {
                points.push([+fx.call(this, d5, i5), +fy.call(this, d5, i5)]);
              } else if (points.length) {
                segment();
                points = [];
              }
            }
            if (points.length) segment();
            return segments.length ? segments.join("") : null;
          }
          line.x = function(_2) {
            if (!arguments.length) return x3;
            x3 = _2;
            return line;
          };
          line.y = function(_2) {
            if (!arguments.length) return y2;
            y2 = _2;
            return line;
          };
          line.defined = function(_2) {
            if (!arguments.length) return defined2;
            defined2 = _2;
            return line;
          };
          line.interpolate = function(_2) {
            if (!arguments.length) return interpolateKey;
            if (typeof _2 === "function") interpolateKey = interpolate3 = _2;
            else interpolateKey = (interpolate3 = d3_svg_lineInterpolators.get(_2) || d3_svg_lineLinear).key;
            return line;
          };
          line.tension = function(_2) {
            if (!arguments.length) return tension;
            tension = _2;
            return line;
          };
          return line;
        }
        d33.svg.line = function() {
          return d3_svg_line(d3_identity);
        };
        var d3_svg_lineInterpolators = d33.map({
          linear: d3_svg_lineLinear,
          "linear-closed": d3_svg_lineLinearClosed,
          step: d3_svg_lineStep,
          "step-before": d3_svg_lineStepBefore,
          "step-after": d3_svg_lineStepAfter,
          basis: d3_svg_lineBasis,
          "basis-open": d3_svg_lineBasisOpen,
          "basis-closed": d3_svg_lineBasisClosed,
          bundle: d3_svg_lineBundle,
          cardinal: d3_svg_lineCardinal,
          "cardinal-open": d3_svg_lineCardinalOpen,
          "cardinal-closed": d3_svg_lineCardinalClosed,
          monotone: d3_svg_lineMonotone
        });
        d3_svg_lineInterpolators.forEach(function(key, value) {
          value.key = key;
          value.closed = /-closed$/.test(key);
        });
        function d3_svg_lineLinear(points) {
          return points.length > 1 ? points.join("L") : points + "Z";
        }
        function d3_svg_lineLinearClosed(points) {
          return points.join("L") + "Z";
        }
        function d3_svg_lineStep(points) {
          var i5 = 0, n2 = points.length, p3 = points[0], path = [p3[0], ",", p3[1]];
          while (++i5 < n2) path.push("H", (p3[0] + (p3 = points[i5])[0]) / 2, "V", p3[1]);
          if (n2 > 1) path.push("H", p3[0]);
          return path.join("");
        }
        function d3_svg_lineStepBefore(points) {
          var i5 = 0, n2 = points.length, p3 = points[0], path = [p3[0], ",", p3[1]];
          while (++i5 < n2) path.push("V", (p3 = points[i5])[1], "H", p3[0]);
          return path.join("");
        }
        function d3_svg_lineStepAfter(points) {
          var i5 = 0, n2 = points.length, p3 = points[0], path = [p3[0], ",", p3[1]];
          while (++i5 < n2) path.push("H", (p3 = points[i5])[0], "V", p3[1]);
          return path.join("");
        }
        function d3_svg_lineCardinalOpen(points, tension) {
          return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
        }
        function d3_svg_lineCardinalClosed(points, tension) {
          return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
        }
        function d3_svg_lineCardinal(points, tension) {
          return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
        }
        function d3_svg_lineHermite(points, tangents) {
          if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
          }
          var quad = points.length != tangents.length, path = "", p0 = points[0], p3 = points[1], t0 = tangents[0], t7 = t0, pi = 1;
          if (quad) {
            path += "Q" + (p3[0] - t0[0] * 2 / 3) + "," + (p3[1] - t0[1] * 2 / 3) + "," + p3[0] + "," + p3[1];
            p0 = points[1];
            pi = 2;
          }
          if (tangents.length > 1) {
            t7 = tangents[1];
            p3 = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p3[0] - t7[0]) + "," + (p3[1] - t7[1]) + "," + p3[0] + "," + p3[1];
            for (var i5 = 2; i5 < tangents.length; i5++, pi++) {
              p3 = points[pi];
              t7 = tangents[i5];
              path += "S" + (p3[0] - t7[0]) + "," + (p3[1] - t7[1]) + "," + p3[0] + "," + p3[1];
            }
          }
          if (quad) {
            var lp = points[pi];
            path += "Q" + (p3[0] + t7[0] * 2 / 3) + "," + (p3[1] + t7[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
          }
          return path;
        }
        function d3_svg_lineCardinalTangents(points, tension) {
          var tangents = [], a3 = (1 - tension) / 2, p0, p1 = points[0], p22 = points[1], i5 = 1, n2 = points.length;
          while (++i5 < n2) {
            p0 = p1;
            p1 = p22;
            p22 = points[i5];
            tangents.push([a3 * (p22[0] - p0[0]), a3 * (p22[1] - p0[1])]);
          }
          return tangents;
        }
        function d3_svg_lineBasis(points) {
          if (points.length < 3) return d3_svg_lineLinear(points);
          var i5 = 1, n2 = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [x0, x0, x0, (pi = points[1])[0]], py = [y0, y0, y0, pi[1]], path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
          points.push(points[n2 - 1]);
          while (++i5 <= n2) {
            pi = points[i5];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
          }
          points.pop();
          path.push("L", pi);
          return path.join("");
        }
        function d3_svg_lineBasisOpen(points) {
          if (points.length < 4) return d3_svg_lineLinear(points);
          var path = [], i5 = -1, n2 = points.length, pi, px = [0], py = [0];
          while (++i5 < 3) {
            pi = points[i5];
            px.push(pi[0]);
            py.push(pi[1]);
          }
          path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
          --i5;
          while (++i5 < n2) {
            pi = points[i5];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
          }
          return path.join("");
        }
        function d3_svg_lineBasisClosed(points) {
          var path, i5 = -1, n2 = points.length, m5 = n2 + 4, pi, px = [], py = [];
          while (++i5 < 4) {
            pi = points[i5 % n2];
            px.push(pi[0]);
            py.push(pi[1]);
          }
          path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
          --i5;
          while (++i5 < m5) {
            pi = points[i5 % n2];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
          }
          return path.join("");
        }
        function d3_svg_lineBundle(points, tension) {
          var n2 = points.length - 1;
          if (n2) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n2][0] - x0, dy = points[n2][1] - y0, i5 = -1, p3, t7;
            while (++i5 <= n2) {
              p3 = points[i5];
              t7 = i5 / n2;
              p3[0] = tension * p3[0] + (1 - tension) * (x0 + t7 * dx);
              p3[1] = tension * p3[1] + (1 - tension) * (y0 + t7 * dy);
            }
          }
          return d3_svg_lineBasis(points);
        }
        function d3_svg_lineDot4(a3, b2) {
          return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2] + a3[3] * b2[3];
        }
        var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0], d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0], d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
        function d3_svg_lineBasisBezier(path, x3, y2) {
          path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x3), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y2), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x3), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y2), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x3), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y2));
        }
        function d3_svg_lineSlope(p0, p1) {
          return (p1[1] - p0[1]) / (p1[0] - p0[0]);
        }
        function d3_svg_lineFiniteDifferences(points) {
          var i5 = 0, j2 = points.length - 1, m5 = [], p0 = points[0], p1 = points[1], d5 = m5[0] = d3_svg_lineSlope(p0, p1);
          while (++i5 < j2) {
            m5[i5] = (d5 + (d5 = d3_svg_lineSlope(p0 = p1, p1 = points[i5 + 1]))) / 2;
          }
          m5[i5] = d5;
          return m5;
        }
        function d3_svg_lineMonotoneTangents(points) {
          var tangents = [], d5, a3, b2, s7, m5 = d3_svg_lineFiniteDifferences(points), i5 = -1, j2 = points.length - 1;
          while (++i5 < j2) {
            d5 = d3_svg_lineSlope(points[i5], points[i5 + 1]);
            if (abs(d5) < \u03B5) {
              m5[i5] = m5[i5 + 1] = 0;
            } else {
              a3 = m5[i5] / d5;
              b2 = m5[i5 + 1] / d5;
              s7 = a3 * a3 + b2 * b2;
              if (s7 > 9) {
                s7 = d5 * 3 / Math.sqrt(s7);
                m5[i5] = s7 * a3;
                m5[i5 + 1] = s7 * b2;
              }
            }
          }
          i5 = -1;
          while (++i5 <= j2) {
            s7 = (points[Math.min(j2, i5 + 1)][0] - points[Math.max(0, i5 - 1)][0]) / (6 * (1 + m5[i5] * m5[i5]));
            tangents.push([s7 || 0, m5[i5] * s7 || 0]);
          }
          return tangents;
        }
        function d3_svg_lineMonotone(points) {
          return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
        }
        d33.svg.line.radial = function() {
          var line = d3_svg_line(d3_svg_lineRadial);
          line.radius = line.x, delete line.x;
          line.angle = line.y, delete line.y;
          return line;
        };
        function d3_svg_lineRadial(points) {
          var point, i5 = -1, n2 = points.length, r6, a3;
          while (++i5 < n2) {
            point = points[i5];
            r6 = point[0];
            a3 = point[1] - half\u03C0;
            point[0] = r6 * Math.cos(a3);
            point[1] = r6 * Math.sin(a3);
          }
          return points;
        }
        function d3_svg_area(projection) {
          var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined2 = d3_true, interpolate3 = d3_svg_lineLinear, interpolateKey = interpolate3.key, interpolateReverse = interpolate3, L3 = "L", tension = 0.7;
          function area(data) {
            var segments = [], points0 = [], points1 = [], i5 = -1, n2 = data.length, d5, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
              return x3;
            } : d3_functor(x1), fy1 = y0 === y1 ? function() {
              return y2;
            } : d3_functor(y1), x3, y2;
            function segment() {
              segments.push("M", interpolate3(projection(points1), tension), L3, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while (++i5 < n2) {
              if (defined2.call(this, d5 = data[i5], i5)) {
                points0.push([x3 = +fx0.call(this, d5, i5), y2 = +fy0.call(this, d5, i5)]);
                points1.push([+fx1.call(this, d5, i5), +fy1.call(this, d5, i5)]);
              } else if (points0.length) {
                segment();
                points0 = [];
                points1 = [];
              }
            }
            if (points0.length) segment();
            return segments.length ? segments.join("") : null;
          }
          area.x = function(_2) {
            if (!arguments.length) return x1;
            x0 = x1 = _2;
            return area;
          };
          area.x0 = function(_2) {
            if (!arguments.length) return x0;
            x0 = _2;
            return area;
          };
          area.x1 = function(_2) {
            if (!arguments.length) return x1;
            x1 = _2;
            return area;
          };
          area.y = function(_2) {
            if (!arguments.length) return y1;
            y0 = y1 = _2;
            return area;
          };
          area.y0 = function(_2) {
            if (!arguments.length) return y0;
            y0 = _2;
            return area;
          };
          area.y1 = function(_2) {
            if (!arguments.length) return y1;
            y1 = _2;
            return area;
          };
          area.defined = function(_2) {
            if (!arguments.length) return defined2;
            defined2 = _2;
            return area;
          };
          area.interpolate = function(_2) {
            if (!arguments.length) return interpolateKey;
            if (typeof _2 === "function") interpolateKey = interpolate3 = _2;
            else interpolateKey = (interpolate3 = d3_svg_lineInterpolators.get(_2) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate3.reverse || interpolate3;
            L3 = interpolate3.closed ? "M" : "L";
            return area;
          };
          area.tension = function(_2) {
            if (!arguments.length) return tension;
            tension = _2;
            return area;
          };
          return area;
        }
        d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
        d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
        d33.svg.area = function() {
          return d3_svg_area(d3_identity);
        };
        d33.svg.area.radial = function() {
          var area = d3_svg_area(d3_svg_lineRadial);
          area.radius = area.x, delete area.x;
          area.innerRadius = area.x0, delete area.x0;
          area.outerRadius = area.x1, delete area.x1;
          area.angle = area.y, delete area.y;
          area.startAngle = area.y0, delete area.y0;
          area.endAngle = area.y1, delete area.y1;
          return area;
        };
        d33.svg.chord = function() {
          var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
          function chord(d5, i5) {
            var s7 = subgroup(this, source, d5, i5), t7 = subgroup(this, target, d5, i5);
            return "M" + s7.p0 + arc(s7.r, s7.p1, s7.a1 - s7.a0) + (equals(s7, t7) ? curve(s7.r, s7.p1, s7.r, s7.p0) : curve(s7.r, s7.p1, t7.r, t7.p0) + arc(t7.r, t7.p1, t7.a1 - t7.a0) + curve(t7.r, t7.p1, s7.r, s7.p0)) + "Z";
          }
          function subgroup(self2, f5, d5, i5) {
            var subgroup2 = f5.call(self2, d5, i5), r6 = radius.call(self2, subgroup2, i5), a0 = startAngle.call(self2, subgroup2, i5) - half\u03C0, a1 = endAngle.call(self2, subgroup2, i5) - half\u03C0;
            return {
              r: r6,
              a0,
              a1,
              p0: [r6 * Math.cos(a0), r6 * Math.sin(a0)],
              p1: [r6 * Math.cos(a1), r6 * Math.sin(a1)]
            };
          }
          function equals(a3, b2) {
            return a3.a0 == b2.a0 && a3.a1 == b2.a1;
          }
          function arc(r6, p3, a3) {
            return "A" + r6 + "," + r6 + " 0 " + +(a3 > \u03C0) + ",1 " + p3;
          }
          function curve(r0, p0, r1, p1) {
            return "Q 0,0 " + p1;
          }
          chord.radius = function(v3) {
            if (!arguments.length) return radius;
            radius = d3_functor(v3);
            return chord;
          };
          chord.source = function(v3) {
            if (!arguments.length) return source;
            source = d3_functor(v3);
            return chord;
          };
          chord.target = function(v3) {
            if (!arguments.length) return target;
            target = d3_functor(v3);
            return chord;
          };
          chord.startAngle = function(v3) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v3);
            return chord;
          };
          chord.endAngle = function(v3) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v3);
            return chord;
          };
          return chord;
        };
        function d3_svg_chordRadius(d5) {
          return d5.radius;
        }
        d33.svg.diagonal = function() {
          var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
          function diagonal(d5, i5) {
            var p0 = source.call(this, d5, i5), p3 = target.call(this, d5, i5), m5 = (p0.y + p3.y) / 2, p4 = [p0, {
              x: p0.x,
              y: m5
            }, {
              x: p3.x,
              y: m5
            }, p3];
            p4 = p4.map(projection);
            return "M" + p4[0] + "C" + p4[1] + " " + p4[2] + " " + p4[3];
          }
          diagonal.source = function(x3) {
            if (!arguments.length) return source;
            source = d3_functor(x3);
            return diagonal;
          };
          diagonal.target = function(x3) {
            if (!arguments.length) return target;
            target = d3_functor(x3);
            return diagonal;
          };
          diagonal.projection = function(x3) {
            if (!arguments.length) return projection;
            projection = x3;
            return diagonal;
          };
          return diagonal;
        };
        function d3_svg_diagonalProjection(d5) {
          return [d5.x, d5.y];
        }
        d33.svg.diagonal.radial = function() {
          var diagonal = d33.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
          diagonal.projection = function(x3) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x3)) : projection;
          };
          return diagonal;
        };
        function d3_svg_diagonalRadialProjection(projection) {
          return function() {
            var d5 = projection.apply(this, arguments), r6 = d5[0], a3 = d5[1] - half\u03C0;
            return [r6 * Math.cos(a3), r6 * Math.sin(a3)];
          };
        }
        d33.svg.symbol = function() {
          var type = d3_svg_symbolType, size = d3_svg_symbolSize;
          function symbol(d5, i5) {
            return (d3_svg_symbols.get(type.call(this, d5, i5)) || d3_svg_symbolCircle)(size.call(this, d5, i5));
          }
          symbol.type = function(x3) {
            if (!arguments.length) return type;
            type = d3_functor(x3);
            return symbol;
          };
          symbol.size = function(x3) {
            if (!arguments.length) return size;
            size = d3_functor(x3);
            return symbol;
          };
          return symbol;
        };
        function d3_svg_symbolSize() {
          return 64;
        }
        function d3_svg_symbolType() {
          return "circle";
        }
        function d3_svg_symbolCircle(size) {
          var r6 = Math.sqrt(size / \u03C0);
          return "M0," + r6 + "A" + r6 + "," + r6 + " 0 1,1 0," + -r6 + "A" + r6 + "," + r6 + " 0 1,1 0," + r6 + "Z";
        }
        var d3_svg_symbols = d33.map({
          circle: d3_svg_symbolCircle,
          cross: function(size) {
            var r6 = Math.sqrt(size / 5) / 2;
            return "M" + -3 * r6 + "," + -r6 + "H" + -r6 + "V" + -3 * r6 + "H" + r6 + "V" + -r6 + "H" + 3 * r6 + "V" + r6 + "H" + r6 + "V" + 3 * r6 + "H" + -r6 + "V" + r6 + "H" + -3 * r6 + "Z";
          },
          diamond: function(size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return "M0," + -ry + "L" + rx + ",0 0," + ry + " " + -rx + ",0Z";
          },
          square: function(size) {
            var r6 = Math.sqrt(size) / 2;
            return "M" + -r6 + "," + -r6 + "L" + r6 + "," + -r6 + " " + r6 + "," + r6 + " " + -r6 + "," + r6 + "Z";
          },
          "triangle-down": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
          },
          "triangle-up": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
          }
        });
        d33.svg.symbolTypes = d3_svg_symbols.keys();
        var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
        d3_selectionPrototype.transition = function(name) {
          var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
            time: Date.now(),
            ease: d3_ease_cubicInOut,
            delay: 0,
            duration: 250
          };
          for (var j2 = -1, m5 = this.length; ++j2 < m5; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j2], i5 = -1, n2 = group.length; ++i5 < n2; ) {
              if (node = group[i5]) d3_transitionNode(node, i5, ns, id, transition);
              subgroup.push(node);
            }
          }
          return d3_transition(subgroups, ns, id);
        };
        d3_selectionPrototype.interrupt = function(name) {
          return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
        };
        var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
        function d3_selection_interruptNS(ns) {
          return function() {
            var lock, activeId, active;
            if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
              active.timer.c = null;
              active.timer.t = NaN;
              if (--lock.count) delete lock[activeId];
              else delete this[ns];
              lock.active += 0.5;
              active.event && active.event.interrupt.call(this, this.__data__, active.index);
            }
          };
        }
        function d3_transition(groups, ns, id) {
          d3_subclass(groups, d3_transitionPrototype);
          groups.namespace = ns;
          groups.id = id;
          return groups;
        }
        var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
        d3_transitionPrototype.call = d3_selectionPrototype.call;
        d3_transitionPrototype.empty = d3_selectionPrototype.empty;
        d3_transitionPrototype.node = d3_selectionPrototype.node;
        d3_transitionPrototype.size = d3_selectionPrototype.size;
        d33.transition = function(selection, name) {
          return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d33.selection().transition(selection);
        };
        d33.transition.prototype = d3_transitionPrototype;
        d3_transitionPrototype.select = function(selector) {
          var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
          selector = d3_selection_selector(selector);
          for (var j2 = -1, m5 = this.length; ++j2 < m5; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j2], i5 = -1, n2 = group.length; ++i5 < n2; ) {
              if ((node = group[i5]) && (subnode = selector.call(node, node.__data__, i5, j2))) {
                if ("__data__" in node) subnode.__data__ = node.__data__;
                d3_transitionNode(subnode, i5, ns, id, node[ns][id]);
                subgroup.push(subnode);
              } else {
                subgroup.push(null);
              }
            }
          }
          return d3_transition(subgroups, ns, id);
        };
        d3_transitionPrototype.selectAll = function(selector) {
          var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
          selector = d3_selection_selectorAll(selector);
          for (var j2 = -1, m5 = this.length; ++j2 < m5; ) {
            for (var group = this[j2], i5 = -1, n2 = group.length; ++i5 < n2; ) {
              if (node = group[i5]) {
                transition = node[ns][id];
                subnodes = selector.call(node, node.__data__, i5, j2);
                subgroups.push(subgroup = []);
                for (var k = -1, o10 = subnodes.length; ++k < o10; ) {
                  if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
                  subgroup.push(subnode);
                }
              }
            }
          }
          return d3_transition(subgroups, ns, id);
        };
        d3_transitionPrototype.filter = function(filter) {
          var subgroups = [], subgroup, group, node;
          if (typeof filter !== "function") filter = d3_selection_filter(filter);
          for (var j2 = 0, m5 = this.length; j2 < m5; j2++) {
            subgroups.push(subgroup = []);
            for (var group = this[j2], i5 = 0, n2 = group.length; i5 < n2; i5++) {
              if ((node = group[i5]) && filter.call(node, node.__data__, i5, j2)) {
                subgroup.push(node);
              }
            }
          }
          return d3_transition(subgroups, this.namespace, this.id);
        };
        d3_transitionPrototype.tween = function(name, tween) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
          return d3_selection_each(this, tween == null ? function(node) {
            node[ns][id].tween.remove(name);
          } : function(node) {
            node[ns][id].tween.set(name, tween);
          });
        };
        function d3_transition_tween(groups, name, value, tween) {
          var id = groups.id, ns = groups.namespace;
          return d3_selection_each(groups, typeof value === "function" ? function(node, i5, j2) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i5, j2)));
          } : (value = tween(value), function(node) {
            node[ns][id].tween.set(name, value);
          }));
        }
        d3_transitionPrototype.attr = function(nameNS, value) {
          if (arguments.length < 2) {
            for (value in nameNS) this.attr(value, nameNS[value]);
            return this;
          }
          var interpolate3 = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d33.ns.qualify(nameNS);
          function attrNull() {
            this.removeAttribute(name);
          }
          function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
          }
          function attrTween(b2) {
            return b2 == null ? attrNull : (b2 += "", function() {
              var a3 = this.getAttribute(name), i5;
              return a3 !== b2 && (i5 = interpolate3(a3, b2), function(t7) {
                this.setAttribute(name, i5(t7));
              });
            });
          }
          function attrTweenNS(b2) {
            return b2 == null ? attrNullNS : (b2 += "", function() {
              var a3 = this.getAttributeNS(name.space, name.local), i5;
              return a3 !== b2 && (i5 = interpolate3(a3, b2), function(t7) {
                this.setAttributeNS(name.space, name.local, i5(t7));
              });
            });
          }
          return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
        };
        d3_transitionPrototype.attrTween = function(nameNS, tween) {
          var name = d33.ns.qualify(nameNS);
          function attrTween(d5, i5) {
            var f5 = tween.call(this, d5, i5, this.getAttribute(name));
            return f5 && function(t7) {
              this.setAttribute(name, f5(t7));
            };
          }
          function attrTweenNS(d5, i5) {
            var f5 = tween.call(this, d5, i5, this.getAttributeNS(name.space, name.local));
            return f5 && function(t7) {
              this.setAttributeNS(name.space, name.local, f5(t7));
            };
          }
          return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
        };
        d3_transitionPrototype.style = function(name, value, priority) {
          var n2 = arguments.length;
          if (n2 < 3) {
            if (typeof name !== "string") {
              if (n2 < 2) value = "";
              for (priority in name) this.style(priority, name[priority], value);
              return this;
            }
            priority = "";
          }
          function styleNull() {
            this.style.removeProperty(name);
          }
          function styleString(b2) {
            return b2 == null ? styleNull : (b2 += "", function() {
              var a3 = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i5;
              return a3 !== b2 && (i5 = d3_interpolate(a3, b2), function(t7) {
                this.style.setProperty(name, i5(t7), priority);
              });
            });
          }
          return d3_transition_tween(this, "style." + name, value, styleString);
        };
        d3_transitionPrototype.styleTween = function(name, tween, priority) {
          if (arguments.length < 3) priority = "";
          function styleTween(d5, i5) {
            var f5 = tween.call(this, d5, i5, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
            return f5 && function(t7) {
              this.style.setProperty(name, f5(t7), priority);
            };
          }
          return this.tween("style." + name, styleTween);
        };
        d3_transitionPrototype.text = function(value) {
          return d3_transition_tween(this, "text", value, d3_transition_text);
        };
        function d3_transition_text(b2) {
          if (b2 == null) b2 = "";
          return function() {
            this.textContent = b2;
          };
        }
        d3_transitionPrototype.remove = function() {
          var ns = this.namespace;
          return this.each("end.transition", function() {
            var p3;
            if (this[ns].count < 2 && (p3 = this.parentNode)) p3.removeChild(this);
          });
        };
        d3_transitionPrototype.ease = function(value) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 1) return this.node()[ns][id].ease;
          if (typeof value !== "function") value = d33.ease.apply(d33, arguments);
          return d3_selection_each(this, function(node) {
            node[ns][id].ease = value;
          });
        };
        d3_transitionPrototype.delay = function(value) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 1) return this.node()[ns][id].delay;
          return d3_selection_each(this, typeof value === "function" ? function(node, i5, j2) {
            node[ns][id].delay = +value.call(node, node.__data__, i5, j2);
          } : (value = +value, function(node) {
            node[ns][id].delay = value;
          }));
        };
        d3_transitionPrototype.duration = function(value) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 1) return this.node()[ns][id].duration;
          return d3_selection_each(this, typeof value === "function" ? function(node, i5, j2) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i5, j2));
          } : (value = Math.max(1, value), function(node) {
            node[ns][id].duration = value;
          }));
        };
        d3_transitionPrototype.each = function(type, listener) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
              d3_transitionInheritId = id;
              d3_selection_each(this, function(node, i5, j2) {
                d3_transitionInherit = node[ns][id];
                type.call(node, node.__data__, i5, j2);
              });
            } finally {
              d3_transitionInherit = inherit;
              d3_transitionInheritId = inheritId;
            }
          } else {
            d3_selection_each(this, function(node) {
              var transition = node[ns][id];
              (transition.event || (transition.event = d33.dispatch("start", "end", "interrupt"))).on(type, listener);
            });
          }
          return this;
        };
        d3_transitionPrototype.transition = function() {
          var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
          for (var j2 = 0, m5 = this.length; j2 < m5; j2++) {
            subgroups.push(subgroup = []);
            for (var group = this[j2], i5 = 0, n2 = group.length; i5 < n2; i5++) {
              if (node = group[i5]) {
                transition = node[ns][id0];
                d3_transitionNode(node, i5, ns, id1, {
                  time: transition.time,
                  ease: transition.ease,
                  delay: transition.delay + transition.duration,
                  duration: transition.duration
                });
              }
              subgroup.push(node);
            }
          }
          return d3_transition(subgroups, ns, id1);
        };
        function d3_transitionNamespace(name) {
          return name == null ? "__transition__" : "__transition_" + name + "__";
        }
        function d3_transitionNode(node, i5, ns, id, inherit) {
          var lock = node[ns] || (node[ns] = {
            active: 0,
            count: 0
          }), transition = lock[id], time, timer, duration, ease, tweens;
          function schedule(elapsed) {
            var delay = transition.delay;
            timer.t = delay + time;
            if (delay <= elapsed) return start3(elapsed - delay);
            timer.c = start3;
          }
          function start3(elapsed) {
            var activeId = lock.active, active = lock[activeId];
            if (active) {
              active.timer.c = null;
              active.timer.t = NaN;
              --lock.count;
              delete lock[activeId];
              active.event && active.event.interrupt.call(node, node.__data__, active.index);
            }
            for (var cancelId in lock) {
              if (+cancelId < id) {
                var cancel = lock[cancelId];
                cancel.timer.c = null;
                cancel.timer.t = NaN;
                --lock.count;
                delete lock[cancelId];
              }
            }
            timer.c = tick;
            d3_timer(function() {
              if (timer.c && tick(elapsed || 1)) {
                timer.c = null;
                timer.t = NaN;
              }
              return 1;
            }, 0, time);
            lock.active = id;
            transition.event && transition.event.start.call(node, node.__data__, i5);
            tweens = [];
            transition.tween.forEach(function(key, value) {
              if (value = value.call(node, node.__data__, i5)) {
                tweens.push(value);
              }
            });
            ease = transition.ease;
            duration = transition.duration;
          }
          function tick(elapsed) {
            var t7 = elapsed / duration, e3 = ease(t7), n2 = tweens.length;
            while (n2 > 0) {
              tweens[--n2].call(node, e3);
            }
            if (t7 >= 1) {
              transition.event && transition.event.end.call(node, node.__data__, i5);
              if (--lock.count) delete lock[id];
              else delete node[ns];
              return 1;
            }
          }
          if (!transition) {
            time = inherit.time;
            timer = d3_timer(schedule, 0, time);
            transition = lock[id] = {
              tween: new d3_Map(),
              time,
              timer,
              delay: inherit.delay,
              duration: inherit.duration,
              ease: inherit.ease,
              index: i5
            };
            inherit = null;
            ++lock.count;
          }
        }
        d33.svg.axis = function() {
          var scale2 = d33.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [10], tickValues = null, tickFormat_;
          function axis(g3) {
            g3.each(function() {
              var g4 = d33.select(this);
              var scale0 = this.__chart__ || scale2, scale1 = this.__chart__ = scale2.copy();
              var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g4.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", \u03B5), tickExit = d33.transition(tick.exit()).style("opacity", \u03B5).remove(), tickUpdate = d33.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
              var range = d3_scaleRange(scale1), path = g4.selectAll(".domain").data([0]), pathUpdate = (path.enter().append("path").attr("class", "domain"), d33.transition(path));
              tickEnter.append("line");
              tickEnter.append("text");
              var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign2 = orient === "top" || orient === "left" ? -1 : 1, x1, x22, y1, y2;
              if (orient === "bottom" || orient === "top") {
                tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x22 = "x2", y2 = "y2";
                text.attr("dy", sign2 < 0 ? "0em" : ".71em").style("text-anchor", "middle");
                pathUpdate.attr("d", "M" + range[0] + "," + sign2 * outerTickSize + "V0H" + range[1] + "V" + sign2 * outerTickSize);
              } else {
                tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x22 = "y2", y2 = "x2";
                text.attr("dy", ".32em").style("text-anchor", sign2 < 0 ? "end" : "start");
                pathUpdate.attr("d", "M" + sign2 * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign2 * outerTickSize);
              }
              lineEnter.attr(y2, sign2 * innerTickSize);
              textEnter.attr(y1, sign2 * tickSpacing);
              lineUpdate.attr(x22, 0).attr(y2, sign2 * innerTickSize);
              textUpdate.attr(x1, 0).attr(y1, sign2 * tickSpacing);
              if (scale1.rangeBand) {
                var x3 = scale1, dx = x3.rangeBand() / 2;
                scale0 = scale1 = function(d5) {
                  return x3(d5) + dx;
                };
              } else if (scale0.rangeBand) {
                scale0 = scale1;
              } else {
                tickExit.call(tickTransform, scale1, scale0);
              }
              tickEnter.call(tickTransform, scale0, scale1);
              tickUpdate.call(tickTransform, scale1, scale1);
            });
          }
          axis.scale = function(x3) {
            if (!arguments.length) return scale2;
            scale2 = x3;
            return axis;
          };
          axis.orient = function(x3) {
            if (!arguments.length) return orient;
            orient = x3 in d3_svg_axisOrients ? x3 + "" : d3_svg_axisDefaultOrient;
            return axis;
          };
          axis.ticks = function() {
            if (!arguments.length) return tickArguments_;
            tickArguments_ = d3_array(arguments);
            return axis;
          };
          axis.tickValues = function(x3) {
            if (!arguments.length) return tickValues;
            tickValues = x3;
            return axis;
          };
          axis.tickFormat = function(x3) {
            if (!arguments.length) return tickFormat_;
            tickFormat_ = x3;
            return axis;
          };
          axis.tickSize = function(x3) {
            var n2 = arguments.length;
            if (!n2) return innerTickSize;
            innerTickSize = +x3;
            outerTickSize = +arguments[n2 - 1];
            return axis;
          };
          axis.innerTickSize = function(x3) {
            if (!arguments.length) return innerTickSize;
            innerTickSize = +x3;
            return axis;
          };
          axis.outerTickSize = function(x3) {
            if (!arguments.length) return outerTickSize;
            outerTickSize = +x3;
            return axis;
          };
          axis.tickPadding = function(x3) {
            if (!arguments.length) return tickPadding;
            tickPadding = +x3;
            return axis;
          };
          axis.tickSubdivide = function() {
            return arguments.length && axis;
          };
          return axis;
        };
        var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
          top: 1,
          right: 1,
          bottom: 1,
          left: 1
        };
        function d3_svg_axisX(selection, x0, x1) {
          selection.attr("transform", function(d5) {
            var v0 = x0(d5);
            return "translate(" + (isFinite(v0) ? v0 : x1(d5)) + ",0)";
          });
        }
        function d3_svg_axisY(selection, y0, y1) {
          selection.attr("transform", function(d5) {
            var v0 = y0(d5);
            return "translate(0," + (isFinite(v0) ? v0 : y1(d5)) + ")";
          });
        }
        d33.svg.brush = function() {
          var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x3 = null, y2 = null, xExtent = [0, 0], yExtent = [0, 0], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
          function brush(g3) {
            g3.each(function() {
              var g4 = d33.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
              var background = g4.selectAll(".background").data([0]);
              background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
              g4.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
              var resize = g4.selectAll(".resize").data(resizes, d3_identity);
              resize.exit().remove();
              resize.enter().append("g").attr("class", function(d5) {
                return "resize " + d5;
              }).style("cursor", function(d5) {
                return d3_svg_brushCursor[d5];
              }).append("rect").attr("x", function(d5) {
                return /[ew]$/.test(d5) ? -3 : null;
              }).attr("y", function(d5) {
                return /^[ns]/.test(d5) ? -3 : null;
              }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
              resize.style("display", brush.empty() ? "none" : null);
              var gUpdate = d33.transition(g4), backgroundUpdate = d33.transition(background), range;
              if (x3) {
                range = d3_scaleRange(x3);
                backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
                redrawX(gUpdate);
              }
              if (y2) {
                range = d3_scaleRange(y2);
                backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
                redrawY(gUpdate);
              }
              redraw(gUpdate);
            });
          }
          brush.event = function(g3) {
            g3.each(function() {
              var event_ = event.of(this, arguments), extent1 = {
                x: xExtent,
                y: yExtent,
                i: xExtentDomain,
                j: yExtentDomain
              }, extent0 = this.__chart__ || extent1;
              this.__chart__ = extent1;
              if (d3_transitionInheritId) {
                d33.select(this).transition().each("start.brush", function() {
                  xExtentDomain = extent0.i;
                  yExtentDomain = extent0.j;
                  xExtent = extent0.x;
                  yExtent = extent0.y;
                  event_({
                    type: "brushstart"
                  });
                }).tween("brush:brush", function() {
                  var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                  xExtentDomain = yExtentDomain = null;
                  return function(t7) {
                    xExtent = extent1.x = xi(t7);
                    yExtent = extent1.y = yi(t7);
                    event_({
                      type: "brush",
                      mode: "resize"
                    });
                  };
                }).each("end.brush", function() {
                  xExtentDomain = extent1.i;
                  yExtentDomain = extent1.j;
                  event_({
                    type: "brush",
                    mode: "resize"
                  });
                  event_({
                    type: "brushend"
                  });
                });
              } else {
                event_({
                  type: "brushstart"
                });
                event_({
                  type: "brush",
                  mode: "resize"
                });
                event_({
                  type: "brushend"
                });
              }
            });
          };
          function redraw(g3) {
            g3.selectAll(".resize").attr("transform", function(d5) {
              return "translate(" + xExtent[+/e$/.test(d5)] + "," + yExtent[+/^s/.test(d5)] + ")";
            });
          }
          function redrawX(g3) {
            g3.select(".extent").attr("x", xExtent[0]);
            g3.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
          }
          function redrawY(g3) {
            g3.select(".extent").attr("y", yExtent[0]);
            g3.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
          }
          function brushstart() {
            var target = this, eventTarget = d33.select(d33.event.target), event_ = event.of(target, arguments), g3 = d33.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x3, resizingY = !/^(e|w)$/.test(resizing) && y2, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d33.mouse(target), offset2;
            var w3 = d33.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
            if (d33.event.changedTouches) {
              w3.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
            } else {
              w3.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
            }
            g3.interrupt().selectAll("*").interrupt();
            if (dragging) {
              origin[0] = xExtent[0] - origin[0];
              origin[1] = yExtent[0] - origin[1];
            } else if (resizing) {
              var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
              offset2 = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];
              origin[0] = xExtent[ex];
              origin[1] = yExtent[ey];
            } else if (d33.event.altKey) center = origin.slice();
            g3.style("pointer-events", "none").selectAll(".resize").style("display", null);
            d33.select("body").style("cursor", eventTarget.style("cursor"));
            event_({
              type: "brushstart"
            });
            brushmove();
            function keydown() {
              if (d33.event.keyCode == 32) {
                if (!dragging) {
                  center = null;
                  origin[0] -= xExtent[1];
                  origin[1] -= yExtent[1];
                  dragging = 2;
                }
                d3_eventPreventDefault();
              }
            }
            function keyup() {
              if (d33.event.keyCode == 32 && dragging == 2) {
                origin[0] += xExtent[1];
                origin[1] += yExtent[1];
                dragging = 0;
                d3_eventPreventDefault();
              }
            }
            function brushmove() {
              var point = d33.mouse(target), moved = false;
              if (offset2) {
                point[0] += offset2[0];
                point[1] += offset2[1];
              }
              if (!dragging) {
                if (d33.event.altKey) {
                  if (!center) center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];
                  origin[0] = xExtent[+(point[0] < center[0])];
                  origin[1] = yExtent[+(point[1] < center[1])];
                } else center = null;
              }
              if (resizingX && move1(point, x3, 0)) {
                redrawX(g3);
                moved = true;
              }
              if (resizingY && move1(point, y2, 1)) {
                redrawY(g3);
                moved = true;
              }
              if (moved) {
                redraw(g3);
                event_({
                  type: "brush",
                  mode: dragging ? "move" : "resize"
                });
              }
            }
            function move1(point, scale2, i5) {
              var range = d3_scaleRange(scale2), r0 = range[0], r1 = range[1], position = origin[i5], extent = i5 ? yExtent : xExtent, size = extent[1] - extent[0], min2, max2;
              if (dragging) {
                r0 -= position;
                r1 -= size + position;
              }
              min2 = (i5 ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i5])) : point[i5];
              if (dragging) {
                max2 = (min2 += position) + size;
              } else {
                if (center) position = Math.max(r0, Math.min(r1, 2 * center[i5] - min2));
                if (position < min2) {
                  max2 = min2;
                  min2 = position;
                } else {
                  max2 = position;
                }
              }
              if (extent[0] != min2 || extent[1] != max2) {
                if (i5) yExtentDomain = null;
                else xExtentDomain = null;
                extent[0] = min2;
                extent[1] = max2;
                return true;
              }
            }
            function brushend() {
              brushmove();
              g3.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
              d33.select("body").style("cursor", null);
              w3.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
              dragRestore();
              event_({
                type: "brushend"
              });
            }
          }
          brush.x = function(z2) {
            if (!arguments.length) return x3;
            x3 = z2;
            resizes = d3_svg_brushResizes[!x3 << 1 | !y2];
            return brush;
          };
          brush.y = function(z2) {
            if (!arguments.length) return y2;
            y2 = z2;
            resizes = d3_svg_brushResizes[!x3 << 1 | !y2];
            return brush;
          };
          brush.clamp = function(z2) {
            if (!arguments.length) return x3 && y2 ? [xClamp, yClamp] : x3 ? xClamp : y2 ? yClamp : null;
            if (x3 && y2) xClamp = !!z2[0], yClamp = !!z2[1];
            else if (x3) xClamp = !!z2;
            else if (y2) yClamp = !!z2;
            return brush;
          };
          brush.extent = function(z2) {
            var x0, x1, y0, y1, t7;
            if (!arguments.length) {
              if (x3) {
                if (xExtentDomain) {
                  x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                } else {
                  x0 = xExtent[0], x1 = xExtent[1];
                  if (x3.invert) x0 = x3.invert(x0), x1 = x3.invert(x1);
                  if (x1 < x0) t7 = x0, x0 = x1, x1 = t7;
                }
              }
              if (y2) {
                if (yExtentDomain) {
                  y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                } else {
                  y0 = yExtent[0], y1 = yExtent[1];
                  if (y2.invert) y0 = y2.invert(y0), y1 = y2.invert(y1);
                  if (y1 < y0) t7 = y0, y0 = y1, y1 = t7;
                }
              }
              return x3 && y2 ? [[x0, y0], [x1, y1]] : x3 ? [x0, x1] : y2 && [y0, y1];
            }
            if (x3) {
              x0 = z2[0], x1 = z2[1];
              if (y2) x0 = x0[0], x1 = x1[0];
              xExtentDomain = [x0, x1];
              if (x3.invert) x0 = x3(x0), x1 = x3(x1);
              if (x1 < x0) t7 = x0, x0 = x1, x1 = t7;
              if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [x0, x1];
            }
            if (y2) {
              y0 = z2[0], y1 = z2[1];
              if (x3) y0 = y0[1], y1 = y1[1];
              yExtentDomain = [y0, y1];
              if (y2.invert) y0 = y2(y0), y1 = y2(y1);
              if (y1 < y0) t7 = y0, y0 = y1, y1 = t7;
              if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [y0, y1];
            }
            return brush;
          };
          brush.clear = function() {
            if (!brush.empty()) {
              xExtent = [0, 0], yExtent = [0, 0];
              xExtentDomain = yExtentDomain = null;
            }
            return brush;
          };
          brush.empty = function() {
            return !!x3 && xExtent[0] == xExtent[1] || !!y2 && yExtent[0] == yExtent[1];
          };
          return d33.rebind(brush, event, "on");
        };
        var d3_svg_brushCursor = {
          n: "ns-resize",
          e: "ew-resize",
          s: "ns-resize",
          w: "ew-resize",
          nw: "nwse-resize",
          ne: "nesw-resize",
          se: "nwse-resize",
          sw: "nesw-resize"
        };
        var d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
        var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
        var d3_time_formatUtc = d3_time_format.utc;
        var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
        d3_time_format.iso = Date.prototype.toISOString && +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
        function d3_time_formatIsoNative(date) {
          return date.toISOString();
        }
        d3_time_formatIsoNative.parse = function(string) {
          var date = new Date(string);
          return isNaN(date) ? null : date;
        };
        d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
        d3_time.second = d3_time_interval(function(date) {
          return new d3_date(Math.floor(date / 1e3) * 1e3);
        }, function(date, offset2) {
          date.setTime(date.getTime() + Math.floor(offset2) * 1e3);
        }, function(date) {
          return date.getSeconds();
        });
        d3_time.seconds = d3_time.second.range;
        d3_time.seconds.utc = d3_time.second.utc.range;
        d3_time.minute = d3_time_interval(function(date) {
          return new d3_date(Math.floor(date / 6e4) * 6e4);
        }, function(date, offset2) {
          date.setTime(date.getTime() + Math.floor(offset2) * 6e4);
        }, function(date) {
          return date.getMinutes();
        });
        d3_time.minutes = d3_time.minute.range;
        d3_time.minutes.utc = d3_time.minute.utc.range;
        d3_time.hour = d3_time_interval(function(date) {
          var timezone = date.getTimezoneOffset() / 60;
          return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
        }, function(date, offset2) {
          date.setTime(date.getTime() + Math.floor(offset2) * 36e5);
        }, function(date) {
          return date.getHours();
        });
        d3_time.hours = d3_time.hour.range;
        d3_time.hours.utc = d3_time.hour.utc.range;
        d3_time.month = d3_time_interval(function(date) {
          date = d3_time.day(date);
          date.setDate(1);
          return date;
        }, function(date, offset2) {
          date.setMonth(date.getMonth() + offset2);
        }, function(date) {
          return date.getMonth();
        });
        d3_time.months = d3_time.month.range;
        d3_time.months.utc = d3_time.month.utc.range;
        function d3_time_scale(linear, methods, format2) {
          function scale2(x3) {
            return linear(x3);
          }
          scale2.invert = function(x3) {
            return d3_time_scaleDate(linear.invert(x3));
          };
          scale2.domain = function(x3) {
            if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
            linear.domain(x3);
            return scale2;
          };
          function tickMethod(extent, count) {
            var span = extent[1] - extent[0], target = span / count, i5 = d33.bisect(d3_time_scaleSteps, target);
            return i5 == d3_time_scaleSteps.length ? [methods.year, d3_scale_linearTickRange(extent.map(function(d5) {
              return d5 / 31536e6;
            }), count)[2]] : !i5 ? [d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2]] : methods[target / d3_time_scaleSteps[i5 - 1] < d3_time_scaleSteps[i5] / target ? i5 - 1 : i5];
          }
          scale2.nice = function(interval, skip2) {
            var domain = scale2.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
            if (method) interval = method[0], skip2 = method[1];
            function skipped(date) {
              return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip2).length;
            }
            return scale2.domain(d3_scale_nice(domain, skip2 > 1 ? {
              floor: function(date) {
                while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
                return date;
              },
              ceil: function(date) {
                while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
                return date;
              }
            } : interval));
          };
          scale2.ticks = function(interval, skip2) {
            var extent = d3_scaleExtent(scale2.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [{
              range: interval
            }, skip2];
            if (method) interval = method[0], skip2 = method[1];
            return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip2 < 1 ? 1 : skip2);
          };
          scale2.tickFormat = function() {
            return format2;
          };
          scale2.copy = function() {
            return d3_time_scale(linear.copy(), methods, format2);
          };
          return d3_scale_linearRebind(scale2, linear);
        }
        function d3_time_scaleDate(t7) {
          return new Date(t7);
        }
        var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6];
        var d3_time_scaleLocalMethods = [[d3_time.second, 1], [d3_time.second, 5], [d3_time.second, 15], [d3_time.second, 30], [d3_time.minute, 1], [d3_time.minute, 5], [d3_time.minute, 15], [d3_time.minute, 30], [d3_time.hour, 1], [d3_time.hour, 3], [d3_time.hour, 6], [d3_time.hour, 12], [d3_time.day, 1], [d3_time.day, 2], [d3_time.week, 1], [d3_time.month, 1], [d3_time.month, 3], [d3_time.year, 1]];
        var d3_time_scaleLocalFormat = d3_time_format.multi([[".%L", function(d5) {
          return d5.getMilliseconds();
        }], [":%S", function(d5) {
          return d5.getSeconds();
        }], ["%I:%M", function(d5) {
          return d5.getMinutes();
        }], ["%I %p", function(d5) {
          return d5.getHours();
        }], ["%a %d", function(d5) {
          return d5.getDay() && d5.getDate() != 1;
        }], ["%b %d", function(d5) {
          return d5.getDate() != 1;
        }], ["%B", function(d5) {
          return d5.getMonth();
        }], ["%Y", d3_true]]);
        var d3_time_scaleMilliseconds = {
          range: function(start3, stop, step) {
            return d33.range(Math.ceil(start3 / step) * step, +stop, step).map(d3_time_scaleDate);
          },
          floor: d3_identity,
          ceil: d3_identity
        };
        d3_time_scaleLocalMethods.year = d3_time.year;
        d3_time.scale = function() {
          return d3_time_scale(d33.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
        };
        var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m5) {
          return [m5[0].utc, m5[1]];
        });
        var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([[".%L", function(d5) {
          return d5.getUTCMilliseconds();
        }], [":%S", function(d5) {
          return d5.getUTCSeconds();
        }], ["%I:%M", function(d5) {
          return d5.getUTCMinutes();
        }], ["%I %p", function(d5) {
          return d5.getUTCHours();
        }], ["%a %d", function(d5) {
          return d5.getUTCDay() && d5.getUTCDate() != 1;
        }], ["%b %d", function(d5) {
          return d5.getUTCDate() != 1;
        }], ["%B", function(d5) {
          return d5.getUTCMonth();
        }], ["%Y", d3_true]]);
        d3_time_scaleUtcMethods.year = d3_time.year.utc;
        d3_time.scale.utc = function() {
          return d3_time_scale(d33.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
        };
        d33.text = d3_xhrType(function(request) {
          return request.responseText;
        });
        d33.json = function(url, callback2) {
          return d3_xhr(url, "application/json", d3_json, callback2);
        };
        function d3_json(request) {
          return JSON.parse(request.responseText);
        }
        d33.html = function(url, callback2) {
          return d3_xhr(url, "text/html", d3_html, callback2);
        };
        function d3_html(request) {
          var range = d3_document.createRange();
          range.selectNode(d3_document.body);
          return range.createContextualFragment(request.responseText);
        }
        d33.xml = d3_xhrType(function(request) {
          return request.responseXML;
        });
        if (typeof define === "function" && define.amd) this.d3 = d33, define(d33);
        else if (typeof module === "object" && module.exports) module.exports = d33;
        else this.d3 = d33;
      }();
    }
  });

  // node_modules/topojson/build/topojson.js
  var require_topojson = __commonJS({
    "node_modules/topojson/build/topojson.js"(exports, module) {
      (function(global2, factory2) {
        typeof exports === "object" && typeof module !== "undefined" ? factory2(exports) : typeof define === "function" && define.amd ? define(["exports"], factory2) : factory2(global2.topojson = global2.topojson || {});
      })(exports, function(exports2) {
        "use strict";
        function noop3() {
        }
        function transformAbsolute(transform) {
          if (!transform) return noop3;
          var x0, y0, kx = transform.scale[0], ky = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
          return function(point, i5) {
            if (!i5) x0 = y0 = 0;
            point[0] = (x0 += point[0]) * kx + dx;
            point[1] = (y0 += point[1]) * ky + dy;
          };
        }
        function transformRelative(transform) {
          if (!transform) return noop3;
          var x0, y0, kx = transform.scale[0], ky = transform.scale[1], dx = transform.translate[0], dy = transform.translate[1];
          return function(point, i5) {
            if (!i5) x0 = y0 = 0;
            var x1 = Math.round((point[0] - dx) / kx), y1 = Math.round((point[1] - dy) / ky);
            point[0] = x1 - x0;
            point[1] = y1 - y0;
            x0 = x1;
            y0 = y1;
          };
        }
        function reverse(array, n2) {
          var t7, j2 = array.length, i5 = j2 - n2;
          while (i5 < --j2) t7 = array[i5], array[i5++] = array[j2], array[j2] = t7;
        }
        function bisect(a3, x3) {
          var lo = 0, hi = a3.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (a3[mid] < x3) lo = mid + 1;
            else hi = mid;
          }
          return lo;
        }
        function feature(topology, o10) {
          return o10.type === "GeometryCollection" ? {
            type: "FeatureCollection",
            features: o10.geometries.map(function(o11) {
              return feature$1(topology, o11);
            })
          } : feature$1(topology, o10);
        }
        function feature$1(topology, o10) {
          var f5 = {
            type: "Feature",
            id: o10.id,
            properties: o10.properties || {},
            geometry: object(topology, o10)
          };
          if (o10.id == null) delete f5.id;
          return f5;
        }
        function object(topology, o10) {
          var absolute = transformAbsolute(topology.transform), arcs = topology.arcs;
          function arc(i5, points) {
            if (points.length) points.pop();
            for (var a3 = arcs[i5 < 0 ? ~i5 : i5], k = 0, n2 = a3.length, p3; k < n2; ++k) {
              points.push(p3 = a3[k].slice());
              absolute(p3, k);
            }
            if (i5 < 0) reverse(points, n2);
          }
          function point(p3) {
            p3 = p3.slice();
            absolute(p3, 0);
            return p3;
          }
          function line(arcs2) {
            var points = [];
            for (var i5 = 0, n2 = arcs2.length; i5 < n2; ++i5) arc(arcs2[i5], points);
            if (points.length < 2) points.push(points[0].slice());
            return points;
          }
          function ring2(arcs2) {
            var points = line(arcs2);
            while (points.length < 4) points.push(points[0].slice());
            return points;
          }
          function polygon(arcs2) {
            return arcs2.map(ring2);
          }
          function geometry(o11) {
            var t7 = o11.type;
            return t7 === "GeometryCollection" ? { type: t7, geometries: o11.geometries.map(geometry) } : t7 in geometryType ? { type: t7, coordinates: geometryType[t7](o11) } : null;
          }
          var geometryType = {
            Point: function(o11) {
              return point(o11.coordinates);
            },
            MultiPoint: function(o11) {
              return o11.coordinates.map(point);
            },
            LineString: function(o11) {
              return line(o11.arcs);
            },
            MultiLineString: function(o11) {
              return o11.arcs.map(line);
            },
            Polygon: function(o11) {
              return polygon(o11.arcs);
            },
            MultiPolygon: function(o11) {
              return o11.arcs.map(polygon);
            }
          };
          return geometry(o10);
        }
        function stitchArcs(topology, arcs) {
          var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
          arcs.forEach(function(i5, j2) {
            var arc = topology.arcs[i5 < 0 ? ~i5 : i5], t7;
            if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
              t7 = arcs[++emptyIndex], arcs[emptyIndex] = i5, arcs[j2] = t7;
            }
          });
          arcs.forEach(function(i5) {
            var e3 = ends(i5), start3 = e3[0], end2 = e3[1], f5, g3;
            if (f5 = fragmentByEnd[start3]) {
              delete fragmentByEnd[f5.end];
              f5.push(i5);
              f5.end = end2;
              if (g3 = fragmentByStart[end2]) {
                delete fragmentByStart[g3.start];
                var fg = g3 === f5 ? f5 : f5.concat(g3);
                fragmentByStart[fg.start = f5.start] = fragmentByEnd[fg.end = g3.end] = fg;
              } else {
                fragmentByStart[f5.start] = fragmentByEnd[f5.end] = f5;
              }
            } else if (f5 = fragmentByStart[end2]) {
              delete fragmentByStart[f5.start];
              f5.unshift(i5);
              f5.start = start3;
              if (g3 = fragmentByEnd[start3]) {
                delete fragmentByEnd[g3.end];
                var gf = g3 === f5 ? f5 : g3.concat(f5);
                fragmentByStart[gf.start = g3.start] = fragmentByEnd[gf.end = f5.end] = gf;
              } else {
                fragmentByStart[f5.start] = fragmentByEnd[f5.end] = f5;
              }
            } else {
              f5 = [i5];
              fragmentByStart[f5.start = start3] = fragmentByEnd[f5.end = end2] = f5;
            }
          });
          function ends(i5) {
            var arc = topology.arcs[i5 < 0 ? ~i5 : i5], p0 = arc[0], p1;
            if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) {
              p1[0] += dp[0], p1[1] += dp[1];
            });
            else p1 = arc[arc.length - 1];
            return i5 < 0 ? [p1, p0] : [p0, p1];
          }
          function flush(fragmentByEnd2, fragmentByStart2) {
            for (var k in fragmentByEnd2) {
              var f5 = fragmentByEnd2[k];
              delete fragmentByStart2[f5.start];
              delete f5.start;
              delete f5.end;
              f5.forEach(function(i5) {
                stitchedArcs[i5 < 0 ? ~i5 : i5] = 1;
              });
              fragments.push(f5);
            }
          }
          flush(fragmentByEnd, fragmentByStart);
          flush(fragmentByStart, fragmentByEnd);
          arcs.forEach(function(i5) {
            if (!stitchedArcs[i5 < 0 ? ~i5 : i5]) fragments.push([i5]);
          });
          return fragments;
        }
        function mesh(topology) {
          return object(topology, meshArcs.apply(this, arguments));
        }
        function meshArcs(topology, o10, filter) {
          var arcs = [];
          function arc(i6) {
            var j2 = i6 < 0 ? ~i6 : i6;
            (geomsByArc[j2] || (geomsByArc[j2] = [])).push({ i: i6, g: geom });
          }
          function line(arcs2) {
            arcs2.forEach(arc);
          }
          function polygon(arcs2) {
            arcs2.forEach(line);
          }
          function geometry(o11) {
            if (o11.type === "GeometryCollection") o11.geometries.forEach(geometry);
            else if (o11.type in geometryType) geom = o11, geometryType[o11.type](o11.arcs);
          }
          if (arguments.length > 1) {
            var geomsByArc = [], geom;
            var geometryType = {
              LineString: line,
              MultiLineString: polygon,
              Polygon: polygon,
              MultiPolygon: function(arcs2) {
                arcs2.forEach(polygon);
              }
            };
            geometry(o10);
            geomsByArc.forEach(arguments.length < 3 ? function(geoms) {
              arcs.push(geoms[0].i);
            } : function(geoms) {
              if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
            });
          } else {
            for (var i5 = 0, n2 = topology.arcs.length; i5 < n2; ++i5) arcs.push(i5);
          }
          return { type: "MultiLineString", arcs: stitchArcs(topology, arcs) };
        }
        function cartesianTriangleArea(triangle) {
          var a3 = triangle[0], b2 = triangle[1], c3 = triangle[2];
          return Math.abs((a3[0] - c3[0]) * (b2[1] - a3[1]) - (a3[0] - b2[0]) * (c3[1] - a3[1]));
        }
        function ring(ring2) {
          var i5 = -1, n2 = ring2.length, a3, b2 = ring2[n2 - 1], area = 0;
          while (++i5 < n2) {
            a3 = b2;
            b2 = ring2[i5];
            area += a3[0] * b2[1] - a3[1] * b2[0];
          }
          return area / 2;
        }
        function merge2(topology) {
          return object(topology, mergeArcs.apply(this, arguments));
        }
        function mergeArcs(topology, objects) {
          var polygonsByArc = {}, polygons = [], components = [];
          objects.forEach(function(o10) {
            if (o10.type === "Polygon") register(o10.arcs);
            else if (o10.type === "MultiPolygon") o10.arcs.forEach(register);
          });
          function register(polygon) {
            polygon.forEach(function(ring$$) {
              ring$$.forEach(function(arc) {
                (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
              });
            });
            polygons.push(polygon);
          }
          function area(ring$$) {
            return Math.abs(ring(object(topology, { type: "Polygon", arcs: [ring$$] }).coordinates[0]));
          }
          polygons.forEach(function(polygon) {
            if (!polygon._) {
              var component = [], neighbors2 = [polygon];
              polygon._ = 1;
              components.push(component);
              while (polygon = neighbors2.pop()) {
                component.push(polygon);
                polygon.forEach(function(ring$$) {
                  ring$$.forEach(function(arc) {
                    polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon2) {
                      if (!polygon2._) {
                        polygon2._ = 1;
                        neighbors2.push(polygon2);
                      }
                    });
                  });
                });
              }
            }
          });
          polygons.forEach(function(polygon) {
            delete polygon._;
          });
          return {
            type: "MultiPolygon",
            arcs: components.map(function(polygons2) {
              var arcs = [], n2;
              polygons2.forEach(function(polygon) {
                polygon.forEach(function(ring$$) {
                  ring$$.forEach(function(arc) {
                    if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                      arcs.push(arc);
                    }
                  });
                });
              });
              arcs = stitchArcs(topology, arcs);
              if ((n2 = arcs.length) > 1) {
                for (var i5 = 1, k = area(arcs[0]), ki, t7; i5 < n2; ++i5) {
                  if ((ki = area(arcs[i5])) > k) {
                    t7 = arcs[0], arcs[0] = arcs[i5], arcs[i5] = t7, k = ki;
                  }
                }
              }
              return arcs;
            })
          };
        }
        function neighbors(objects) {
          var indexesByArc = {}, neighbors2 = objects.map(function() {
            return [];
          });
          function line(arcs, i6) {
            arcs.forEach(function(a3) {
              if (a3 < 0) a3 = ~a3;
              var o10 = indexesByArc[a3];
              if (o10) o10.push(i6);
              else indexesByArc[a3] = [i6];
            });
          }
          function polygon(arcs, i6) {
            arcs.forEach(function(arc) {
              line(arc, i6);
            });
          }
          function geometry(o10, i6) {
            if (o10.type === "GeometryCollection") o10.geometries.forEach(function(o11) {
              geometry(o11, i6);
            });
            else if (o10.type in geometryType) geometryType[o10.type](o10.arcs, i6);
          }
          var geometryType = {
            LineString: line,
            MultiLineString: polygon,
            Polygon: polygon,
            MultiPolygon: function(arcs, i6) {
              arcs.forEach(function(arc) {
                polygon(arc, i6);
              });
            }
          };
          objects.forEach(geometry);
          for (var i5 in indexesByArc) {
            for (var indexes = indexesByArc[i5], m5 = indexes.length, j2 = 0; j2 < m5; ++j2) {
              for (var k = j2 + 1; k < m5; ++k) {
                var ij = indexes[j2], ik = indexes[k], n2;
                if ((n2 = neighbors2[ij])[i5 = bisect(n2, ik)] !== ik) n2.splice(i5, 0, ik);
                if ((n2 = neighbors2[ik])[i5 = bisect(n2, ij)] !== ij) n2.splice(i5, 0, ij);
              }
            }
          }
          return neighbors2;
        }
        function compareArea(a3, b2) {
          return a3[1][2] - b2[1][2];
        }
        function minAreaHeap() {
          var heap = {}, array = [], size = 0;
          heap.push = function(object2) {
            up(array[object2._ = size] = object2, size++);
            return size;
          };
          heap.pop = function() {
            if (size <= 0) return;
            var removed = array[0], object2;
            if (--size > 0) object2 = array[size], down(array[object2._ = 0] = object2, 0);
            return removed;
          };
          heap.remove = function(removed) {
            var i5 = removed._, object2;
            if (array[i5] !== removed) return;
            if (i5 !== --size) object2 = array[size], (compareArea(object2, removed) < 0 ? up : down)(array[object2._ = i5] = object2, i5);
            return i5;
          };
          function up(object2, i5) {
            while (i5 > 0) {
              var j2 = (i5 + 1 >> 1) - 1, parent = array[j2];
              if (compareArea(object2, parent) >= 0) break;
              array[parent._ = i5] = parent;
              array[object2._ = i5 = j2] = object2;
            }
          }
          function down(object2, i5) {
            while (true) {
              var r6 = i5 + 1 << 1, l6 = r6 - 1, j2 = i5, child = array[j2];
              if (l6 < size && compareArea(array[l6], child) < 0) child = array[j2 = l6];
              if (r6 < size && compareArea(array[r6], child) < 0) child = array[j2 = r6];
              if (j2 === i5) break;
              array[child._ = i5] = child;
              array[object2._ = i5 = j2] = object2;
            }
          }
          return heap;
        }
        function presimplify(topology, triangleArea) {
          var absolute = transformAbsolute(topology.transform), relative = transformRelative(topology.transform), heap = minAreaHeap();
          if (!triangleArea) triangleArea = cartesianTriangleArea;
          topology.arcs.forEach(function(arc) {
            var triangles = [], maxArea = 0, triangle, i5, n2, p3;
            for (i5 = 0, n2 = arc.length; i5 < n2; ++i5) {
              p3 = arc[i5];
              absolute(arc[i5] = [p3[0], p3[1], Infinity], i5);
            }
            for (i5 = 1, n2 = arc.length - 1; i5 < n2; ++i5) {
              triangle = arc.slice(i5 - 1, i5 + 2);
              triangle[1][2] = triangleArea(triangle);
              triangles.push(triangle);
              heap.push(triangle);
            }
            for (i5 = 0, n2 = triangles.length; i5 < n2; ++i5) {
              triangle = triangles[i5];
              triangle.previous = triangles[i5 - 1];
              triangle.next = triangles[i5 + 1];
            }
            while (triangle = heap.pop()) {
              var previous = triangle.previous, next = triangle.next;
              if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
              else maxArea = triangle[1][2];
              if (previous) {
                previous.next = next;
                previous[2] = triangle[2];
                update(previous);
              }
              if (next) {
                next.previous = previous;
                next[0] = triangle[0];
                update(next);
              }
            }
            arc.forEach(relative);
          });
          function update(triangle) {
            heap.remove(triangle);
            triangle[1][2] = triangleArea(triangle);
            heap.push(triangle);
          }
          return topology;
        }
        var version2 = "1.6.27";
        exports2.version = version2;
        exports2.mesh = mesh;
        exports2.meshArcs = meshArcs;
        exports2.merge = merge2;
        exports2.mergeArcs = mergeArcs;
        exports2.feature = feature;
        exports2.neighbors = neighbors;
        exports2.presimplify = presimplify;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/datamaps/dist/datamaps.all.js
  var require_datamaps_all = __commonJS({
    "node_modules/datamaps/dist/datamaps.all.js"(exports, module) {
      (function() {
        var svg;
        var d33 = window.d3, topojson = window.topojson;
        var defaultOptions = {
          scope: "world",
          responsive: false,
          aspectRatio: 0.5625,
          setProjection,
          projection: "equirectangular",
          dataType: "json",
          data: {},
          done: function() {
          },
          fills: {
            defaultFill: "#ABDDA4"
          },
          filters: {},
          geographyConfig: {
            dataUrl: null,
            hideAntarctica: true,
            hideHawaiiAndAlaska: false,
            borderWidth: 1,
            borderOpacity: 1,
            borderColor: "#FDFDFD",
            popupTemplate: function(geography, data) {
              return '<div class="hoverinfo"><strong>' + geography.properties.name + "</strong></div>";
            },
            popupOnHover: true,
            highlightOnHover: true,
            highlightFillColor: "#FC8D59",
            highlightBorderColor: "rgba(250, 15, 160, 0.2)",
            highlightBorderWidth: 2,
            highlightBorderOpacity: 1
          },
          projectionConfig: {
            rotation: [97, 0]
          },
          bubblesConfig: {
            borderWidth: 2,
            borderOpacity: 1,
            borderColor: "#FFFFFF",
            popupOnHover: true,
            radius: null,
            popupTemplate: function(geography, data) {
              return '<div class="hoverinfo"><strong>' + data.name + "</strong></div>";
            },
            fillOpacity: 0.75,
            animate: true,
            highlightOnHover: true,
            highlightFillColor: "#FC8D59",
            highlightBorderColor: "rgba(250, 15, 160, 0.2)",
            highlightBorderWidth: 2,
            highlightBorderOpacity: 1,
            highlightFillOpacity: 0.85,
            exitDelay: 100,
            key: JSON.stringify
          },
          arcConfig: {
            strokeColor: "#DD1C77",
            strokeWidth: 1,
            arcSharpness: 1,
            animationSpeed: 600,
            popupOnHover: false,
            popupTemplate: function(geography, data) {
              if (data.origin && data.destination && data.origin.latitude && data.origin.longitude && data.destination.latitude && data.destination.longitude) {
                return '<div class="hoverinfo"><strong>Arc</strong><br>Origin: ' + JSON.stringify(data.origin) + "<br>Destination: " + JSON.stringify(data.destination) + "</div>";
              } else if (data.origin && data.destination) {
                return '<div class="hoverinfo"><strong>Arc</strong><br>' + data.origin + " -> " + data.destination + "</div>";
              } else {
                return "";
              }
            }
          }
        };
        function val(datumValue, optionsValue, context) {
          if (typeof context === "undefined") {
            context = optionsValue;
            optionsValues = void 0;
          }
          var value = typeof datumValue !== "undefined" ? datumValue : optionsValue;
          if (typeof value === "undefined") {
            return null;
          }
          if (typeof value === "function") {
            var fnContext = [context];
            if (context.geography) {
              fnContext = [context.geography, context.data];
            }
            return value.apply(null, fnContext);
          } else {
            return value;
          }
        }
        function addContainer(element, height, width) {
          this.svg = d33.select(element).append("svg").attr("width", width || element.offsetWidth).attr("data-width", width || element.offsetWidth).attr("class", "datamap").attr("height", height || element.offsetHeight).style("overflow", "hidden");
          if (this.options.responsive) {
            d33.select(this.options.element).style({ "position": "relative", "padding-bottom": this.options.aspectRatio * 100 + "%" });
            d33.select(this.options.element).select("svg").style({ "position": "absolute", "width": "100%", "height": "100%" });
            d33.select(this.options.element).select("svg").select("g").selectAll("path").style("vector-effect", "non-scaling-stroke");
          }
          return this.svg;
        }
        function setProjection(element, options) {
          var width = options.width || element.offsetWidth;
          var height = options.height || element.offsetHeight;
          var projection, path;
          var svg2 = this.svg;
          if (options && typeof options.scope === "undefined") {
            options.scope = "world";
          }
          if (options.scope === "usa") {
            projection = d33.geo.albersUsa().scale(width).translate([width / 2, height / 2]);
          } else if (options.scope === "world") {
            projection = d33.geo[options.projection]().scale((width + 1) / 2 / Math.PI).translate([width / 2, height / (options.projection === "mercator" ? 1.45 : 1.8)]);
          }
          if (options.projection === "orthographic") {
            svg2.append("defs").append("path").datum({ type: "Sphere" }).attr("id", "sphere").attr("d", path);
            svg2.append("use").attr("class", "stroke").attr("xlink:href", "#sphere");
            svg2.append("use").attr("class", "fill").attr("xlink:href", "#sphere");
            projection.scale(250).clipAngle(90).rotate(options.projectionConfig.rotation);
          }
          path = d33.geo.path().projection(projection);
          return { path, projection };
        }
        function addStyleBlock() {
          if (d33.select(".datamaps-style-block").empty()) {
            d33.select("head").append("style").attr("class", "datamaps-style-block").html('.datamap path.datamaps-graticule { fill: none; stroke: #777; stroke-width: 0.5px; stroke-opacity: .5; pointer-events: none; } .datamap .labels {pointer-events: none;} .datamap path:not(.datamaps-arc), .datamap circle, .datamap line {stroke: #FFFFFF; vector-effect: non-scaling-stroke; stroke-width: 1px;} .datamaps-legend dt, .datamaps-legend dd { float: left; margin: 0 3px 0 0;} .datamaps-legend dd {width: 20px; margin-right: 6px; border-radius: 3px;} .datamaps-legend {padding-bottom: 20px; z-index: 1001; position: absolute; left: 4px; font-size: 12px; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;} .datamaps-hoverover {display: none; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; } .hoverinfo {padding: 4px; border-radius: 1px; background-color: #FFF; box-shadow: 1px 1px 5px #CCC; font-size: 12px; border: 1px solid #CCC; } .hoverinfo hr {border:1px dotted #CCC; }');
          }
        }
        function drawSubunits(data) {
          var fillData = this.options.fills, colorCodeData = this.options.data || {}, geoConfig = this.options.geographyConfig;
          var subunits = this.svg.select("g.datamaps-subunits");
          if (subunits.empty()) {
            subunits = this.addLayer("datamaps-subunits", null, true);
          }
          var geoData = topojson.feature(data, data.objects[this.options.scope]).features;
          if (geoConfig.hideAntarctica) {
            geoData = geoData.filter(function(feature) {
              return feature.id !== "ATA";
            });
          }
          if (geoConfig.hideHawaiiAndAlaska) {
            geoData = geoData.filter(function(feature) {
              return feature.id !== "HI" && feature.id !== "AK";
            });
          }
          var geo = subunits.selectAll("path.datamaps-subunit").data(geoData);
          geo.enter().append("path").attr("d", this.path).attr("class", function(d5) {
            return "datamaps-subunit " + d5.id;
          }).attr("data-info", function(d5) {
            return JSON.stringify(colorCodeData[d5.id]);
          }).style("fill", function(d5) {
            var fillColor;
            var datum = colorCodeData[d5.id];
            if (datum && datum.fillKey) {
              fillColor = fillData[val(datum.fillKey, { data: colorCodeData[d5.id], geography: d5 })];
            }
            if (typeof fillColor === "undefined") {
              fillColor = val(datum && datum.fillColor, fillData.defaultFill, { data: colorCodeData[d5.id], geography: d5 });
            }
            return fillColor;
          }).style("stroke-width", geoConfig.borderWidth).style("stroke-opacity", geoConfig.borderOpacity).style("stroke", geoConfig.borderColor);
        }
        function handleGeographyConfig() {
          var hoverover2;
          var svg2 = this.svg;
          var self2 = this;
          var options = this.options.geographyConfig;
          if (options.highlightOnHover || options.popupOnHover) {
            svg2.selectAll(".datamaps-subunit").on("mouseover", function(d5) {
              var $this = d33.select(this);
              var datum = self2.options.data[d5.id] || {};
              if (options.highlightOnHover) {
                var previousAttributes = {
                  "fill": $this.style("fill"),
                  "stroke": $this.style("stroke"),
                  "stroke-width": $this.style("stroke-width"),
                  "fill-opacity": $this.style("fill-opacity")
                };
                $this.style("fill", val(datum.highlightFillColor, options.highlightFillColor, datum)).style("stroke", val(datum.highlightBorderColor, options.highlightBorderColor, datum)).style("stroke-width", val(datum.highlightBorderWidth, options.highlightBorderWidth, datum)).style("stroke-opacity", val(datum.highlightBorderOpacity, options.highlightBorderOpacity, datum)).style("fill-opacity", val(datum.highlightFillOpacity, options.highlightFillOpacity, datum)).attr("data-previousAttributes", JSON.stringify(previousAttributes));
                if (!/((MSIE)|(Trident))/.test(navigator.userAgent)) {
                  moveToFront.call(this);
                }
              }
              if (options.popupOnHover) {
                self2.updatePopup($this, d5, options, svg2);
              }
            }).on("mouseout", function() {
              var $this = d33.select(this);
              if (options.highlightOnHover) {
                var previousAttributes = JSON.parse($this.attr("data-previousAttributes"));
                for (var attr in previousAttributes) {
                  $this.style(attr, previousAttributes[attr]);
                }
              }
              $this.on("mousemove", null);
              d33.selectAll(".datamaps-hoverover").style("display", "none");
            });
          }
          function moveToFront() {
            this.parentNode.appendChild(this);
          }
        }
        function addLegend(layer, data, options) {
          data = data || {};
          if (!this.options.fills) {
            return;
          }
          var html = "<dl>";
          var label = "";
          if (data.legendTitle) {
            html = "<h2>" + data.legendTitle + "</h2>" + html;
          }
          for (var fillKey in this.options.fills) {
            if (fillKey === "defaultFill") {
              if (!data.defaultFillName) {
                continue;
              }
              label = data.defaultFillName;
            } else {
              if (data.labels && data.labels[fillKey]) {
                label = data.labels[fillKey];
              } else {
                label = fillKey + ": ";
              }
            }
            html += "<dt>" + label + "</dt>";
            html += '<dd style="background-color:' + this.options.fills[fillKey] + '">&nbsp;</dd>';
          }
          html += "</dl>";
          var hoverover2 = d33.select(this.options.element).append("div").attr("class", "datamaps-legend").html(html);
        }
        function addGraticule(layer, options) {
          var graticule = d33.geo.graticule();
          this.svg.insert("path", ".datamaps-subunits").datum(graticule).attr("class", "datamaps-graticule").attr("d", this.path);
        }
        function handleArcs(layer, data, options) {
          var self2 = this, svg2 = this.svg;
          if (!data || data && !data.slice) {
            throw "Datamaps Error - arcs must be an array";
          }
          for (var i5 = 0; i5 < data.length; i5++) {
            data[i5] = defaults2(data[i5], data[i5].options);
            delete data[i5].options;
          }
          if (typeof options === "undefined") {
            options = defaultOptions.arcConfig;
          }
          var arcs = layer.selectAll("path.datamaps-arc").data(data, JSON.stringify);
          var path = d33.geo.path().projection(self2.projection);
          arcs.enter().append("svg:path").attr("class", "datamaps-arc").style("stroke-linecap", "round").style("stroke", function(datum) {
            return val(datum.strokeColor, options.strokeColor, datum);
          }).style("fill", "none").style("stroke-width", function(datum) {
            return val(datum.strokeWidth, options.strokeWidth, datum);
          }).attr("d", function(datum) {
            var originXY, destXY;
            if (typeof datum.origin === "string") {
              switch (datum.origin) {
                case "CAN":
                  originXY = self2.latLngToXY(56.624472, -114.665293);
                  break;
                case "CHL":
                  originXY = self2.latLngToXY(-33.44889, -70.669265);
                  break;
                case "IDN":
                  originXY = self2.latLngToXY(-6.208763, 106.845599);
                  break;
                case "JPN":
                  originXY = self2.latLngToXY(35.689487, 139.691706);
                  break;
                case "MYS":
                  originXY = self2.latLngToXY(3.139003, 101.686855);
                  break;
                case "NOR":
                  originXY = self2.latLngToXY(59.913869, 10.752245);
                  break;
                case "USA":
                  originXY = self2.latLngToXY(41.140276, -100.760145);
                  break;
                case "VNM":
                  originXY = self2.latLngToXY(21.027764, 105.83416);
                  break;
                default:
                  originXY = self2.path.centroid(svg2.select("path." + datum.origin).data()[0]);
              }
            } else {
              originXY = self2.latLngToXY(val(datum.origin.latitude, datum), val(datum.origin.longitude, datum));
            }
            if (typeof datum.destination === "string") {
              switch (datum.destination) {
                case "CAN":
                  destXY = self2.latLngToXY(56.624472, -114.665293);
                  break;
                case "CHL":
                  destXY = self2.latLngToXY(-33.44889, -70.669265);
                  break;
                case "IDN":
                  destXY = self2.latLngToXY(-6.208763, 106.845599);
                  break;
                case "JPN":
                  destXY = self2.latLngToXY(35.689487, 139.691706);
                  break;
                case "MYS":
                  destXY = self2.latLngToXY(3.139003, 101.686855);
                  break;
                case "NOR":
                  destXY = self2.latLngToXY(59.913869, 10.752245);
                  break;
                case "USA":
                  destXY = self2.latLngToXY(41.140276, -100.760145);
                  break;
                case "VNM":
                  destXY = self2.latLngToXY(21.027764, 105.83416);
                  break;
                default:
                  destXY = self2.path.centroid(svg2.select("path." + datum.destination).data()[0]);
              }
            } else {
              destXY = self2.latLngToXY(val(datum.destination.latitude, datum), val(datum.destination.longitude, datum));
            }
            var midXY = [(originXY[0] + destXY[0]) / 2, (originXY[1] + destXY[1]) / 2];
            if (options.greatArc) {
              var greatArc = d33.geo.greatArc().source(function(d5) {
                return [val(d5.origin.longitude, d5), val(d5.origin.latitude, d5)];
              }).target(function(d5) {
                return [val(d5.destination.longitude, d5), val(d5.destination.latitude, d5)];
              });
              return path(greatArc(datum));
            }
            var sharpness = val(datum.arcSharpness, options.arcSharpness, datum);
            return "M" + originXY[0] + "," + originXY[1] + "S" + (midXY[0] + 50 * sharpness) + "," + (midXY[1] - 75 * sharpness) + "," + destXY[0] + "," + destXY[1];
          }).attr("data-info", function(datum) {
            return JSON.stringify(datum);
          }).on("mouseover", function(datum) {
            var $this = d33.select(this);
            if (options.popupOnHover) {
              self2.updatePopup($this, datum, options, svg2);
            }
          }).on("mouseout", function(datum) {
            var $this = d33.select(this);
            d33.selectAll(".datamaps-hoverover").style("display", "none");
          }).transition().delay(100).style("fill", function(datum) {
            var length = this.getTotalLength();
            this.style.transition = this.style.WebkitTransition = "none";
            this.style.strokeDasharray = length + " " + length;
            this.style.strokeDashoffset = length;
            this.getBoundingClientRect();
            this.style.transition = this.style.WebkitTransition = "stroke-dashoffset " + val(datum.animationSpeed, options.animationSpeed, datum) + "ms ease-out";
            this.style.strokeDashoffset = "0";
            return "none";
          });
          arcs.exit().transition().style("opacity", 0).remove();
        }
        function handleLabels(layer, options) {
          var self2 = this;
          options = options || {};
          var labelStartCoodinates = this.projection([-67.707617, 42.722131]);
          this.svg.selectAll(".datamaps-subunit").attr("data-foo", function(d5) {
            var center = self2.path.centroid(d5);
            var xOffset = 7.5, yOffset = 5;
            if (["FL", "KY", "MI"].indexOf(d5.id) > -1) xOffset = -2.5;
            if (d5.id === "NY") xOffset = -1;
            if (d5.id === "MI") yOffset = 18;
            if (d5.id === "LA") xOffset = 13;
            var x3, y2;
            x3 = center[0] - xOffset;
            y2 = center[1] + yOffset;
            var smallStateIndex = ["VT", "NH", "MA", "RI", "CT", "NJ", "DE", "MD", "DC"].indexOf(d5.id);
            if (smallStateIndex > -1) {
              var yStart = labelStartCoodinates[1];
              x3 = labelStartCoodinates[0];
              y2 = yStart + smallStateIndex * (2 + (options.fontSize || 12));
              layer.append("line").attr("x1", x3 - 3).attr("y1", y2 - 5).attr("x2", center[0]).attr("y2", center[1]).style("stroke", options.labelColor || "#000").style("stroke-width", options.lineWidth || 1);
            }
            layer.append("text").attr("x", x3).attr("y", y2).style("font-size", (options.fontSize || 10) + "px").style("font-family", options.fontFamily || "Verdana").style("fill", options.labelColor || "#000").text(function() {
              if (options.customLabelText && options.customLabelText[d5.id]) {
                return options.customLabelText[d5.id];
              } else {
                return d5.id;
              }
            });
            return "bar";
          });
        }
        function handleBubbles(layer, data, options) {
          var self2 = this, fillData = this.options.fills, filterData = this.options.filters, svg2 = this.svg;
          if (!data || data && !data.slice) {
            throw "Datamaps Error - bubbles must be an array";
          }
          var bubbles = layer.selectAll("circle.datamaps-bubble").data(data, options.key);
          bubbles.enter().append("svg:circle").attr("class", "datamaps-bubble").attr("cx", function(datum) {
            var latLng;
            if (datumHasCoords(datum)) {
              latLng = self2.latLngToXY(datum.latitude, datum.longitude);
            } else if (datum.centered) {
              if (datum.centered === "USA") {
                latLng = self2.projection([-98.58333, 39.83333]);
              } else {
                latLng = self2.path.centroid(svg2.select("path." + datum.centered).data()[0]);
              }
            }
            if (latLng) return latLng[0];
          }).attr("cy", function(datum) {
            var latLng;
            if (datumHasCoords(datum)) {
              latLng = self2.latLngToXY(datum.latitude, datum.longitude);
            } else if (datum.centered) {
              if (datum.centered === "USA") {
                latLng = self2.projection([-98.58333, 39.83333]);
              } else {
                latLng = self2.path.centroid(svg2.select("path." + datum.centered).data()[0]);
              }
            }
            if (latLng) return latLng[1];
          }).attr("r", function(datum) {
            return options.animate ? 0 : val(datum.radius, options.radius, datum);
          }).attr("data-info", function(datum) {
            return JSON.stringify(datum);
          }).attr("filter", function(datum) {
            var filterKey = filterData[val(datum.filterKey, options.filterKey, datum)];
            if (filterKey) {
              return filterKey;
            }
          }).style("stroke", function(datum) {
            return val(datum.borderColor, options.borderColor, datum);
          }).style("stroke-width", function(datum) {
            return val(datum.borderWidth, options.borderWidth, datum);
          }).style("stroke-opacity", function(datum) {
            return val(datum.borderOpacity, options.borderOpacity, datum);
          }).style("fill-opacity", function(datum) {
            return val(datum.fillOpacity, options.fillOpacity, datum);
          }).style("fill", function(datum) {
            var fillColor = fillData[val(datum.fillKey, options.fillKey, datum)];
            return fillColor || fillData.defaultFill;
          }).on("mouseover", function(datum) {
            var $this = d33.select(this);
            if (options.highlightOnHover) {
              var previousAttributes = {
                "fill": $this.style("fill"),
                "stroke": $this.style("stroke"),
                "stroke-width": $this.style("stroke-width"),
                "fill-opacity": $this.style("fill-opacity")
              };
              $this.style("fill", val(datum.highlightFillColor, options.highlightFillColor, datum)).style("stroke", val(datum.highlightBorderColor, options.highlightBorderColor, datum)).style("stroke-width", val(datum.highlightBorderWidth, options.highlightBorderWidth, datum)).style("stroke-opacity", val(datum.highlightBorderOpacity, options.highlightBorderOpacity, datum)).style("fill-opacity", val(datum.highlightFillOpacity, options.highlightFillOpacity, datum)).attr("data-previousAttributes", JSON.stringify(previousAttributes));
            }
            if (options.popupOnHover) {
              self2.updatePopup($this, datum, options, svg2);
            }
          }).on("mouseout", function(datum) {
            var $this = d33.select(this);
            if (options.highlightOnHover) {
              var previousAttributes = JSON.parse($this.attr("data-previousAttributes"));
              for (var attr in previousAttributes) {
                $this.style(attr, previousAttributes[attr]);
              }
            }
            d33.selectAll(".datamaps-hoverover").style("display", "none");
          });
          bubbles.transition().duration(400).attr("r", function(datum) {
            return val(datum.radius, options.radius, datum);
          }).transition().duration(0).attr("data-info", function(d5) {
            return JSON.stringify(d5);
          });
          bubbles.exit().transition().delay(options.exitDelay).attr("r", 0).remove();
          function datumHasCoords(datum) {
            return typeof datum !== "undefined" && typeof datum.latitude !== "undefined" && typeof datum.longitude !== "undefined";
          }
        }
        function defaults2(obj) {
          Array.prototype.slice.call(arguments, 1).forEach(function(source) {
            if (source) {
              for (var prop in source) {
                if (obj[prop] == null) {
                  if (typeof source[prop] == "function") {
                    obj[prop] = source[prop];
                  } else {
                    obj[prop] = JSON.parse(JSON.stringify(source[prop]));
                  }
                }
              }
            }
          });
          return obj;
        }
        function Datamap2(options) {
          if (typeof d33 === "undefined" || typeof topojson === "undefined") {
            throw new Error("Include d3.js (v3.0.3 or greater) and topojson on this page before creating a new map");
          }
          this.options = defaults2(options, defaultOptions);
          this.options.geographyConfig = defaults2(options.geographyConfig, defaultOptions.geographyConfig);
          this.options.projectionConfig = defaults2(options.projectionConfig, defaultOptions.projectionConfig);
          this.options.bubblesConfig = defaults2(options.bubblesConfig, defaultOptions.bubblesConfig);
          this.options.arcConfig = defaults2(options.arcConfig, defaultOptions.arcConfig);
          if (d33.select(this.options.element).select("svg").length > 0) {
            addContainer.call(this, this.options.element, this.options.height, this.options.width);
          }
          this.addPlugin("bubbles", handleBubbles);
          this.addPlugin("legend", addLegend);
          this.addPlugin("arc", handleArcs);
          this.addPlugin("labels", handleLabels);
          this.addPlugin("graticule", addGraticule);
          if (!this.options.disableDefaultStyles) {
            addStyleBlock();
          }
          return this.draw();
        }
        Datamap2.prototype.resize = function() {
          var self2 = this;
          var options = self2.options;
          if (options.responsive) {
            var newsize = options.element.clientWidth, oldsize = d33.select(options.element).select("svg").attr("data-width");
            d33.select(options.element).select("svg").selectAll("g").attr("transform", "scale(" + newsize / oldsize + ")");
          }
        };
        Datamap2.prototype.draw = function() {
          var self2 = this;
          var options = self2.options;
          var pathAndProjection = options.setProjection.apply(this, [options.element, options]);
          this.path = pathAndProjection.path;
          this.projection = pathAndProjection.projection;
          if (options.geographyConfig.dataUrl) {
            d33.json(options.geographyConfig.dataUrl, function(error, results) {
              if (error) throw new Error(error);
              self2.customTopo = results;
              draw2(results);
            });
          } else {
            draw2(this[options.scope + "Topo"] || options.geographyConfig.dataJson);
          }
          return this;
          function draw2(data) {
            if (self2.options.dataUrl) {
              d33[self2.options.dataType](self2.options.dataUrl, function(data2) {
                if (self2.options.dataType === "csv" && (data2 && data2.slice)) {
                  var tmpData = {};
                  for (var i5 = 0; i5 < data2.length; i5++) {
                    tmpData[data2[i5].id] = data2[i5];
                  }
                  data2 = tmpData;
                }
                Datamaps.prototype.updateChoropleth.call(self2, data2);
              });
            }
            drawSubunits.call(self2, data);
            handleGeographyConfig.call(self2);
            if (self2.options.geographyConfig.popupOnHover || self2.options.bubblesConfig.popupOnHover) {
              hoverover = d33.select(self2.options.element).append("div").attr("class", "datamaps-hoverover").style("z-index", 10001).style("position", "absolute");
            }
            self2.options.done(self2);
          }
        };
        Datamap2.prototype.worldTopo = {
          "type": "Topology",
          "objects": {
            "world": {
              "type": "GeometryCollection",
              "geometries": [{
                "type": "Polygon",
                "properties": {
                  "name": "Afghanistan"
                },
                "id": "AFG",
                "arcs": [
                  [0, 1, 2, 3, 4, 5]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Angola"
                },
                "id": "AGO",
                "arcs": [
                  [
                    [6, 7, 8, 9]
                  ],
                  [
                    [10, 11, 12]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Albania"
                },
                "id": "ALB",
                "arcs": [
                  [13, 14, 15, 16, 17]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "United Arab Emirates"
                },
                "id": "ARE",
                "arcs": [
                  [18, 19, 20, 21, 22]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Argentina"
                },
                "id": "ARG",
                "arcs": [
                  [
                    [23, 24]
                  ],
                  [
                    [25, 26, 27, 28, 29, 30]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Armenia"
                },
                "id": "ARM",
                "arcs": [
                  [31, 32, 33, 34, 35]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Antarctica"
                },
                "id": "ATA",
                "arcs": [
                  [
                    [36]
                  ],
                  [
                    [37]
                  ],
                  [
                    [38]
                  ],
                  [
                    [39]
                  ],
                  [
                    [40]
                  ],
                  [
                    [41]
                  ],
                  [
                    [42]
                  ],
                  [
                    [43]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "French Southern and Antarctic Lands"
                },
                "id": "ATF",
                "arcs": [
                  [44]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Australia"
                },
                "id": "AUS",
                "arcs": [
                  [
                    [45]
                  ],
                  [
                    [46]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Austria"
                },
                "id": "AUT",
                "arcs": [
                  [47, 48, 49, 50, 51, 52, 53]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Azerbaijan"
                },
                "id": "AZE",
                "arcs": [
                  [
                    [54, -35]
                  ],
                  [
                    [55, 56, -33, 57, 58]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Burundi"
                },
                "id": "BDI",
                "arcs": [
                  [59, 60, 61]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Belgium"
                },
                "id": "BEL",
                "arcs": [
                  [62, 63, 64, 65, 66]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Benin"
                },
                "id": "BEN",
                "arcs": [
                  [67, 68, 69, 70, 71]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Burkina Faso"
                },
                "id": "BFA",
                "arcs": [
                  [72, 73, 74, -70, 75, 76]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Bangladesh"
                },
                "id": "BGD",
                "arcs": [
                  [77, 78, 79]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Bulgaria"
                },
                "id": "BGR",
                "arcs": [
                  [80, 81, 82, 83, 84, 85]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "The Bahamas"
                },
                "id": "BHS",
                "arcs": [
                  [
                    [86]
                  ],
                  [
                    [87]
                  ],
                  [
                    [88]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Bosnia and Herzegovina"
                },
                "id": "BIH",
                "arcs": [
                  [89, 90, 91]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Belarus"
                },
                "id": "BLR",
                "arcs": [
                  [92, 93, 94, 95, 96]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Belize"
                },
                "id": "BLZ",
                "arcs": [
                  [97, 98, 99]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Bolivia"
                },
                "id": "BOL",
                "arcs": [
                  [100, 101, 102, 103, -31]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Brazil"
                },
                "id": "BRA",
                "arcs": [
                  [-27, 104, -103, 105, 106, 107, 108, 109, 110, 111, 112]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Brunei"
                },
                "id": "BRN",
                "arcs": [
                  [113, 114]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Bhutan"
                },
                "id": "BTN",
                "arcs": [
                  [115, 116]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Botswana"
                },
                "id": "BWA",
                "arcs": [
                  [117, 118, 119, 120]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Central African Republic"
                },
                "id": "CAF",
                "arcs": [
                  [121, 122, 123, 124, 125, 126, 127]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Canada"
                },
                "id": "CAN",
                "arcs": [
                  [
                    [128]
                  ],
                  [
                    [129]
                  ],
                  [
                    [130]
                  ],
                  [
                    [131]
                  ],
                  [
                    [132]
                  ],
                  [
                    [133]
                  ],
                  [
                    [134]
                  ],
                  [
                    [135]
                  ],
                  [
                    [136]
                  ],
                  [
                    [137]
                  ],
                  [
                    [138, 139, 140, 141]
                  ],
                  [
                    [142]
                  ],
                  [
                    [143]
                  ],
                  [
                    [144]
                  ],
                  [
                    [145]
                  ],
                  [
                    [146]
                  ],
                  [
                    [147]
                  ],
                  [
                    [148]
                  ],
                  [
                    [149]
                  ],
                  [
                    [150]
                  ],
                  [
                    [151]
                  ],
                  [
                    [152]
                  ],
                  [
                    [153]
                  ],
                  [
                    [154]
                  ],
                  [
                    [155]
                  ],
                  [
                    [156]
                  ],
                  [
                    [157]
                  ],
                  [
                    [158]
                  ],
                  [
                    [159]
                  ],
                  [
                    [160]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Switzerland"
                },
                "id": "CHE",
                "arcs": [
                  [-51, 161, 162, 163]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Chile"
                },
                "id": "CHL",
                "arcs": [
                  [
                    [-24, 164]
                  ],
                  [
                    [-30, 165, 166, -101]
                  ]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "China"
                },
                "id": "CHN",
                "arcs": [
                  [
                    [167]
                  ],
                  [
                    [168, 169, 170, 171, 172, 173, -117, 174, 175, 176, 177, -4, 178, 179, 180, 181, 182, 183]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Ivory Coast"
                },
                "id": "CIV",
                "arcs": [
                  [184, 185, 186, 187, -73, 188]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Cameroon"
                },
                "id": "CMR",
                "arcs": [
                  [189, 190, 191, 192, 193, 194, -128, 195]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Democratic Republic of the Congo"
                },
                "id": "COD",
                "arcs": [
                  [196, 197, -60, 198, 199, -10, 200, -13, 201, -126, 202]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Republic of the Congo"
                },
                "id": "COG",
                "arcs": [
                  [-12, 203, 204, -196, -127, -202]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Colombia"
                },
                "id": "COL",
                "arcs": [
                  [205, 206, 207, 208, 209, -107, 210]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Costa Rica"
                },
                "id": "CRI",
                "arcs": [
                  [211, 212, 213, 214]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Cuba"
                },
                "id": "CUB",
                "arcs": [
                  [215]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Northern Cyprus"
                },
                "id": "-99",
                "arcs": [
                  [216, 217]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Cyprus"
                },
                "id": "CYP",
                "arcs": [
                  [218, -218]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Czech Republic"
                },
                "id": "CZE",
                "arcs": [
                  [-53, 219, 220, 221]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Germany"
                },
                "id": "DEU",
                "arcs": [
                  [222, 223, -220, -52, -164, 224, 225, -64, 226, 227, 228]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Djibouti"
                },
                "id": "DJI",
                "arcs": [
                  [229, 230, 231, 232]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Denmark"
                },
                "id": "DNK",
                "arcs": [
                  [
                    [233]
                  ],
                  [
                    [-229, 234]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Dominican Republic"
                },
                "id": "DOM",
                "arcs": [
                  [235, 236]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Algeria"
                },
                "id": "DZA",
                "arcs": [
                  [237, 238, 239, 240, 241, 242, 243, 244]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Ecuador"
                },
                "id": "ECU",
                "arcs": [
                  [245, -206, 246]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Egypt"
                },
                "id": "EGY",
                "arcs": [
                  [247, 248, 249, 250, 251]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Eritrea"
                },
                "id": "ERI",
                "arcs": [
                  [252, 253, 254, -233]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Spain"
                },
                "id": "ESP",
                "arcs": [
                  [255, 256, 257, 258]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Estonia"
                },
                "id": "EST",
                "arcs": [
                  [259, 260, 261]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Ethiopia"
                },
                "id": "ETH",
                "arcs": [
                  [-232, 262, 263, 264, 265, 266, 267, -253]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Finland"
                },
                "id": "FIN",
                "arcs": [
                  [268, 269, 270, 271]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Fiji"
                },
                "id": "FJI",
                "arcs": [
                  [
                    [272]
                  ],
                  [
                    [273, 274]
                  ],
                  [
                    [275, -275]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Falkland Islands"
                },
                "id": "FLK",
                "arcs": [
                  [276]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "France"
                },
                "id": "FRA",
                "arcs": [
                  [
                    [277]
                  ],
                  [
                    [278, -225, -163, 279, 280, -257, 281, -66]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "French Guiana"
                },
                "id": "GUF",
                "arcs": [
                  [282, 283, 284, 285, -111]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Gabon"
                },
                "id": "GAB",
                "arcs": [
                  [286, 287, -190, -205]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "United Kingdom"
                },
                "id": "GBR",
                "arcs": [
                  [
                    [288, 289]
                  ],
                  [
                    [290]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Georgia"
                },
                "id": "GEO",
                "arcs": [
                  [291, 292, -58, -32, 293]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Ghana"
                },
                "id": "GHA",
                "arcs": [
                  [294, -189, -77, 295]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Guinea"
                },
                "id": "GIN",
                "arcs": [
                  [296, 297, 298, 299, 300, 301, -187]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Gambia"
                },
                "id": "GMB",
                "arcs": [
                  [302, 303]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Guinea Bissau"
                },
                "id": "GNB",
                "arcs": [
                  [304, 305, -300]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Equatorial Guinea"
                },
                "id": "GNQ",
                "arcs": [
                  [306, -191, -288]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Greece"
                },
                "id": "GRC",
                "arcs": [
                  [
                    [307]
                  ],
                  [
                    [308, -15, 309, -84, 310]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Greenland"
                },
                "id": "GRL",
                "arcs": [
                  [311]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Guatemala"
                },
                "id": "GTM",
                "arcs": [
                  [312, 313, -100, 314, 315, 316]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Guyana"
                },
                "id": "GUY",
                "arcs": [
                  [317, 318, -109, 319]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Honduras"
                },
                "id": "HND",
                "arcs": [
                  [320, 321, -316, 322, 323]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Croatia"
                },
                "id": "HRV",
                "arcs": [
                  [324, -92, 325, 326, 327, 328]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Haiti"
                },
                "id": "HTI",
                "arcs": [
                  [-237, 329]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Hungary"
                },
                "id": "HUN",
                "arcs": [
                  [-48, 330, 331, 332, 333, -329, 334]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Indonesia"
                },
                "id": "IDN",
                "arcs": [
                  [
                    [335]
                  ],
                  [
                    [336, 337]
                  ],
                  [
                    [338]
                  ],
                  [
                    [339]
                  ],
                  [
                    [340]
                  ],
                  [
                    [341]
                  ],
                  [
                    [342]
                  ],
                  [
                    [343]
                  ],
                  [
                    [344, 345]
                  ],
                  [
                    [346]
                  ],
                  [
                    [347]
                  ],
                  [
                    [348, 349]
                  ],
                  [
                    [350]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "India"
                },
                "id": "IND",
                "arcs": [
                  [-177, 351, -175, -116, -174, 352, -80, 353, 354]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Ireland"
                },
                "id": "IRL",
                "arcs": [
                  [355, -289]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Iran"
                },
                "id": "IRN",
                "arcs": [
                  [356, -6, 357, 358, 359, 360, -55, -34, -57, 361]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Iraq"
                },
                "id": "IRQ",
                "arcs": [
                  [362, 363, 364, 365, 366, 367, -360]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Iceland"
                },
                "id": "ISL",
                "arcs": [
                  [368]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Israel"
                },
                "id": "ISR",
                "arcs": [
                  [369, 370, 371, -252, 372, 373, 374]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Italy"
                },
                "id": "ITA",
                "arcs": [
                  [
                    [375]
                  ],
                  [
                    [376]
                  ],
                  [
                    [377, 378, -280, -162, -50]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Jamaica"
                },
                "id": "JAM",
                "arcs": [
                  [379]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Jordan"
                },
                "id": "JOR",
                "arcs": [
                  [-370, 380, -366, 381, 382, -372, 383]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Japan"
                },
                "id": "JPN",
                "arcs": [
                  [
                    [384]
                  ],
                  [
                    [385]
                  ],
                  [
                    [386]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Kazakhstan"
                },
                "id": "KAZ",
                "arcs": [
                  [387, 388, 389, 390, -181, 391]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Kenya"
                },
                "id": "KEN",
                "arcs": [
                  [392, 393, 394, 395, -265, 396]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Kyrgyzstan"
                },
                "id": "KGZ",
                "arcs": [
                  [-392, -180, 397, 398]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Cambodia"
                },
                "id": "KHM",
                "arcs": [
                  [399, 400, 401, 402]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "South Korea"
                },
                "id": "KOR",
                "arcs": [
                  [403, 404]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Kosovo"
                },
                "id": "-99",
                "arcs": [
                  [-18, 405, 406, 407]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Kuwait"
                },
                "id": "KWT",
                "arcs": [
                  [408, 409, -364]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Laos"
                },
                "id": "LAO",
                "arcs": [
                  [410, 411, -172, 412, -401]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Lebanon"
                },
                "id": "LBN",
                "arcs": [
                  [-374, 413, 414]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Liberia"
                },
                "id": "LBR",
                "arcs": [
                  [415, 416, -297, -186]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Libya"
                },
                "id": "LBY",
                "arcs": [
                  [417, -245, 418, 419, -250, 420, 421]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Sri Lanka"
                },
                "id": "LKA",
                "arcs": [
                  [422]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Lesotho"
                },
                "id": "LSO",
                "arcs": [
                  [423]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Lithuania"
                },
                "id": "LTU",
                "arcs": [
                  [424, 425, 426, -93, 427]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Luxembourg"
                },
                "id": "LUX",
                "arcs": [
                  [-226, -279, -65]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Latvia"
                },
                "id": "LVA",
                "arcs": [
                  [428, -262, 429, -94, -427]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Morocco"
                },
                "id": "MAR",
                "arcs": [
                  [-242, 430, 431]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Moldova"
                },
                "id": "MDA",
                "arcs": [
                  [432, 433]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Madagascar"
                },
                "id": "MDG",
                "arcs": [
                  [434]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Mexico"
                },
                "id": "MEX",
                "arcs": [
                  [435, -98, -314, 436, 437]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Macedonia"
                },
                "id": "MKD",
                "arcs": [
                  [-408, 438, -85, -310, -14]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Mali"
                },
                "id": "MLI",
                "arcs": [
                  [439, -239, 440, -74, -188, -302, 441]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Myanmar"
                },
                "id": "MMR",
                "arcs": [
                  [442, -78, -353, -173, -412, 443]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Montenegro"
                },
                "id": "MNE",
                "arcs": [
                  [444, -326, -91, 445, -406, -17]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Mongolia"
                },
                "id": "MNG",
                "arcs": [
                  [446, -183]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Mozambique"
                },
                "id": "MOZ",
                "arcs": [
                  [447, 448, 449, 450, 451, 452, 453, 454]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Mauritania"
                },
                "id": "MRT",
                "arcs": [
                  [455, 456, 457, -240, -440]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Malawi"
                },
                "id": "MWI",
                "arcs": [
                  [-455, 458, 459]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Malaysia"
                },
                "id": "MYS",
                "arcs": [
                  [
                    [460, 461]
                  ],
                  [
                    [-349, 462, -115, 463]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Namibia"
                },
                "id": "NAM",
                "arcs": [
                  [464, -8, 465, -119, 466]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "New Caledonia"
                },
                "id": "NCL",
                "arcs": [
                  [467]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Niger"
                },
                "id": "NER",
                "arcs": [
                  [-75, -441, -238, -418, 468, -194, 469, -71]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Nigeria"
                },
                "id": "NGA",
                "arcs": [
                  [470, -72, -470, -193]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Nicaragua"
                },
                "id": "NIC",
                "arcs": [
                  [471, -324, 472, -213]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Netherlands"
                },
                "id": "NLD",
                "arcs": [
                  [-227, -63, 473]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Norway"
                },
                "id": "NOR",
                "arcs": [
                  [
                    [474, -272, 475, 476]
                  ],
                  [
                    [477]
                  ],
                  [
                    [478]
                  ],
                  [
                    [479]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Nepal"
                },
                "id": "NPL",
                "arcs": [
                  [-352, -176]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "New Zealand"
                },
                "id": "NZL",
                "arcs": [
                  [
                    [480]
                  ],
                  [
                    [481]
                  ]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Oman"
                },
                "id": "OMN",
                "arcs": [
                  [
                    [482, 483, -22, 484]
                  ],
                  [
                    [-20, 485]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Pakistan"
                },
                "id": "PAK",
                "arcs": [
                  [-178, -355, 486, -358, -5]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Panama"
                },
                "id": "PAN",
                "arcs": [
                  [487, -215, 488, -208]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Peru"
                },
                "id": "PER",
                "arcs": [
                  [-167, 489, -247, -211, -106, -102]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Philippines"
                },
                "id": "PHL",
                "arcs": [
                  [
                    [490]
                  ],
                  [
                    [491]
                  ],
                  [
                    [492]
                  ],
                  [
                    [493]
                  ],
                  [
                    [494]
                  ],
                  [
                    [495]
                  ],
                  [
                    [496]
                  ]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Papua New Guinea"
                },
                "id": "PNG",
                "arcs": [
                  [
                    [497]
                  ],
                  [
                    [498]
                  ],
                  [
                    [-345, 499]
                  ],
                  [
                    [500]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Poland"
                },
                "id": "POL",
                "arcs": [
                  [-224, 501, 502, -428, -97, 503, 504, -221]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Puerto Rico"
                },
                "id": "PRI",
                "arcs": [
                  [505]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "North Korea"
                },
                "id": "PRK",
                "arcs": [
                  [506, 507, -405, 508, -169]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Portugal"
                },
                "id": "PRT",
                "arcs": [
                  [-259, 509]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Paraguay"
                },
                "id": "PRY",
                "arcs": [
                  [-104, -105, -26]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Qatar"
                },
                "id": "QAT",
                "arcs": [
                  [510, 511]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Romania"
                },
                "id": "ROU",
                "arcs": [
                  [512, -434, 513, 514, -81, 515, -333]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Russia"
                },
                "id": "RUS",
                "arcs": [
                  [
                    [516]
                  ],
                  [
                    [-503, 517, -425]
                  ],
                  [
                    [518, 519]
                  ],
                  [
                    [520]
                  ],
                  [
                    [521]
                  ],
                  [
                    [522]
                  ],
                  [
                    [523]
                  ],
                  [
                    [524]
                  ],
                  [
                    [525]
                  ],
                  [
                    [526, -507, -184, -447, -182, -391, 527, -59, -293, 528, 529, -95, -430, -261, 530, -269, -475, 531, -520]
                  ],
                  [
                    [532]
                  ],
                  [
                    [533]
                  ],
                  [
                    [534]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Rwanda"
                },
                "id": "RWA",
                "arcs": [
                  [535, -61, -198, 536]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Western Sahara"
                },
                "id": "ESH",
                "arcs": [
                  [-241, -458, 537, -431]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Saudi Arabia"
                },
                "id": "SAU",
                "arcs": [
                  [538, -382, -365, -410, 539, -512, 540, -23, -484, 541]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Sudan"
                },
                "id": "SDN",
                "arcs": [
                  [542, 543, -123, 544, -421, -249, 545, -254, -268, 546]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "South Sudan"
                },
                "id": "SSD",
                "arcs": [
                  [547, -266, -396, 548, -203, -125, 549, -543]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Senegal"
                },
                "id": "SEN",
                "arcs": [
                  [550, -456, -442, -301, -306, 551, -304]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Solomon Islands"
                },
                "id": "SLB",
                "arcs": [
                  [
                    [552]
                  ],
                  [
                    [553]
                  ],
                  [
                    [554]
                  ],
                  [
                    [555]
                  ],
                  [
                    [556]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Sierra Leone"
                },
                "id": "SLE",
                "arcs": [
                  [557, -298, -417]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "El Salvador"
                },
                "id": "SLV",
                "arcs": [
                  [558, -317, -322]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Somaliland"
                },
                "id": "-99",
                "arcs": [
                  [-263, -231, 559, 560]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Somalia"
                },
                "id": "SOM",
                "arcs": [
                  [-397, -264, -561, 561]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Republic of Serbia"
                },
                "id": "SRB",
                "arcs": [
                  [-86, -439, -407, -446, -90, -325, -334, -516]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Suriname"
                },
                "id": "SUR",
                "arcs": [
                  [562, -285, 563, -283, -110, -319]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Slovakia"
                },
                "id": "SVK",
                "arcs": [
                  [-505, 564, -331, -54, -222]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Slovenia"
                },
                "id": "SVN",
                "arcs": [
                  [-49, -335, -328, 565, -378]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Sweden"
                },
                "id": "SWE",
                "arcs": [
                  [-476, -271, 566]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Swaziland"
                },
                "id": "SWZ",
                "arcs": [
                  [567, -451]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Syria"
                },
                "id": "SYR",
                "arcs": [
                  [-381, -375, -415, 568, 569, -367]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Chad"
                },
                "id": "TCD",
                "arcs": [
                  [-469, -422, -545, -122, -195]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Togo"
                },
                "id": "TGO",
                "arcs": [
                  [570, -296, -76, -69]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Thailand"
                },
                "id": "THA",
                "arcs": [
                  [571, -462, 572, -444, -411, -400]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Tajikistan"
                },
                "id": "TJK",
                "arcs": [
                  [-398, -179, -3, 573]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Turkmenistan"
                },
                "id": "TKM",
                "arcs": [
                  [-357, 574, -389, 575, -1]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "East Timor"
                },
                "id": "TLS",
                "arcs": [
                  [576, -337]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Trinidad and Tobago"
                },
                "id": "TTO",
                "arcs": [
                  [577]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Tunisia"
                },
                "id": "TUN",
                "arcs": [
                  [-244, 578, -419]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Turkey"
                },
                "id": "TUR",
                "arcs": [
                  [
                    [-294, -36, -361, -368, -570, 579]
                  ],
                  [
                    [-311, -83, 580]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Taiwan"
                },
                "id": "TWN",
                "arcs": [
                  [581]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "United Republic of Tanzania"
                },
                "id": "TZA",
                "arcs": [
                  [-394, 582, -448, -460, 583, -199, -62, -536, 584]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Uganda"
                },
                "id": "UGA",
                "arcs": [
                  [-537, -197, -549, -395, -585]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Ukraine"
                },
                "id": "UKR",
                "arcs": [
                  [-530, 585, -514, -433, -513, -332, -565, -504, -96]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Uruguay"
                },
                "id": "URY",
                "arcs": [
                  [-113, 586, -28]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "United States of America"
                },
                "id": "USA",
                "arcs": [
                  [
                    [587]
                  ],
                  [
                    [588]
                  ],
                  [
                    [589]
                  ],
                  [
                    [590]
                  ],
                  [
                    [591]
                  ],
                  [
                    [592, -438, 593, -139]
                  ],
                  [
                    [594]
                  ],
                  [
                    [595]
                  ],
                  [
                    [596]
                  ],
                  [
                    [-141, 597]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Uzbekistan"
                },
                "id": "UZB",
                "arcs": [
                  [-576, -388, -399, -574, -2]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Venezuela"
                },
                "id": "VEN",
                "arcs": [
                  [598, -320, -108, -210]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Vietnam"
                },
                "id": "VNM",
                "arcs": [
                  [599, -402, -413, -171]
                ]
              }, {
                "type": "MultiPolygon",
                "properties": {
                  "name": "Vanuatu"
                },
                "id": "VUT",
                "arcs": [
                  [
                    [600]
                  ],
                  [
                    [601]
                  ]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "West Bank"
                },
                "id": "PSE",
                "arcs": [
                  [-384, -371]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Yemen"
                },
                "id": "YEM",
                "arcs": [
                  [602, -542, -483]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "South Africa"
                },
                "id": "ZAF",
                "arcs": [
                  [-467, -118, 603, -452, -568, -450, 604],
                  [-424]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Zambia"
                },
                "id": "ZMB",
                "arcs": [
                  [-459, -454, 605, -120, -466, -7, -200, -584]
                ]
              }, {
                "type": "Polygon",
                "properties": {
                  "name": "Zimbabwe"
                },
                "id": "ZWE",
                "arcs": [
                  [-604, -121, -606, -453]
                ]
              }]
            }
          },
          "arcs": [
            [
              [6700, 7164],
              [28, -23],
              [21, 8],
              [6, 27],
              [22, 9],
              [15, 18],
              [6, 47],
              [23, 11],
              [5, 21],
              [13, -15],
              [8, -2]
            ],
            [
              [6847, 7265],
              [16, -1],
              [20, -12]
            ],
            [
              [6883, 7252],
              [9, -7],
              [20, 19],
              [9, -12],
              [9, 27],
              [17, -1],
              [4, 9],
              [3, 24],
              [12, 20],
              [15, -13],
              [-3, -18],
              [9, -3],
              [-3, -50],
              [11, -19],
              [10, 12],
              [12, 6],
              [17, 27],
              [19, -5],
              [29, 0]
            ],
            [
              [7082, 7268],
              [5, -17]
            ],
            [
              [7087, 7251],
              [-16, -6],
              [-14, -11],
              [-32, -7],
              [-30, -13],
              [-16, -25],
              [6, -25],
              [4, -30],
              [-14, -25],
              [1, -22],
              [-8, -22],
              [-26, 2],
              [11, -39],
              [-18, -15],
              [-12, -35],
              [2, -36],
              [-11, -16],
              [-10, 5],
              [-22, -8],
              [-3, -16],
              [-20, 0],
              [-16, -34],
              [-1, -50],
              [-36, -24],
              [-19, 5],
              [-6, -13],
              [-16, 7],
              [-28, -8],
              [-47, 30]
            ],
            [
              [6690, 6820],
              [25, 53],
              [-2, 38],
              [-21, 10],
              [-2, 38],
              [-9, 47],
              [12, 32],
              [-12, 9],
              [7, 43],
              [12, 74]
            ],
            [
              [5664, 4412],
              [3, -18],
              [-4, -29],
              [5, -28],
              [-4, -22],
              [3, -20],
              [-58, 1],
              [-2, -188],
              [19, -49],
              [18, -37]
            ],
            [
              [5644, 4022],
              [-51, -24],
              [-67, 9],
              [-19, 28],
              [-113, -3],
              [-4, -4],
              [-17, 27],
              [-18, 2],
              [-16, -10],
              [-14, -12]
            ],
            [
              [5325, 4035],
              [-2, 38],
              [4, 51],
              [9, 55],
              [2, 25],
              [9, 53],
              [6, 24],
              [16, 39],
              [9, 26],
              [3, 44],
              [-1, 34],
              [-9, 21],
              [-7, 36],
              [-7, 35],
              [2, 12],
              [8, 24],
              [-8, 57],
              [-6, 39],
              [-14, 38],
              [3, 11]
            ],
            [
              [5342, 4697],
              [11, 8],
              [8, -1],
              [10, 7],
              [82, -1],
              [7, -44],
              [8, -35],
              [6, -19],
              [11, -31],
              [18, 5],
              [9, 8],
              [16, -8],
              [4, 14],
              [7, 35],
              [17, 2],
              [2, 10],
              [14, 1],
              [-3, -22],
              [34, 1],
              [1, -37],
              [5, -23],
              [-4, -36],
              [2, -36],
              [9, -22],
              [-1, -70],
              [7, 5],
              [12, -1],
              [17, 8],
              [13, -3]
            ],
            [
              [5338, 4715],
              [-8, 45]
            ],
            [
              [5330, 4760],
              [12, 25],
              [8, 10],
              [10, -20]
            ],
            [
              [5360, 4775],
              [-10, -12],
              [-4, -16],
              [-1, -25],
              [-7, -7]
            ],
            [
              [5571, 7530],
              [-3, -20],
              [4, -25],
              [11, -15]
            ],
            [
              [5583, 7470],
              [0, -15],
              [-9, -9],
              [-2, -19],
              [-13, -29]
            ],
            [
              [5559, 7398],
              [-5, 5],
              [0, 13],
              [-15, 19],
              [-3, 29],
              [2, 40],
              [4, 18],
              [-4, 10]
            ],
            [
              [5538, 7532],
              [-2, 18],
              [12, 29],
              [1, -11],
              [8, 6]
            ],
            [
              [5557, 7574],
              [6, -16],
              [7, -6],
              [1, -22]
            ],
            [
              [6432, 6490],
              [5, 3],
              [1, -16],
              [22, 9],
              [23, -2],
              [17, -1],
              [19, 39],
              [20, 38],
              [18, 37]
            ],
            [
              [6557, 6597],
              [5, -20]
            ],
            [
              [6562, 6577],
              [4, -47]
            ],
            [
              [6566, 6530],
              [-14, 0],
              [-3, -39],
              [5, -8],
              [-12, -12],
              [0, -24],
              [-8, -24],
              [-1, -24]
            ],
            [
              [6533, 6399],
              [-6, -12],
              [-83, 29],
              [-11, 60],
              [-1, 14]
            ],
            [
              [3140, 1814],
              [-17, 2],
              [-30, 0],
              [0, 132]
            ],
            [
              [3093, 1948],
              [11, -27],
              [14, -45],
              [36, -35],
              [39, -15],
              [-13, -30],
              [-26, -2],
              [-14, 20]
            ],
            [
              [3258, 3743],
              [51, -96],
              [23, -9],
              [34, -44],
              [29, -23],
              [4, -26],
              [-28, -90],
              [28, -16],
              [32, -9],
              [22, 10],
              [25, 45],
              [4, 52]
            ],
            [
              [3482, 3537],
              [14, 11],
              [14, -34],
              [-1, -47],
              [-23, -33],
              [-19, -24],
              [-31, -57],
              [-37, -81]
            ],
            [
              [3399, 3272],
              [-7, -47],
              [-7, -61],
              [0, -58],
              [-6, -14],
              [-2, -38]
            ],
            [
              [3377, 3054],
              [-2, -31],
              [35, -50],
              [-4, -41],
              [18, -26],
              [-2, -29],
              [-26, -75],
              [-42, -32],
              [-55, -12],
              [-31, 6],
              [6, -36],
              [-6, -44],
              [5, -30],
              [-16, -20],
              [-29, -8],
              [-26, 21],
              [-11, -15],
              [4, -59],
              [18, -18],
              [16, 19],
              [8, -31],
              [-26, -18],
              [-22, -37],
              [-4, -59],
              [-7, -32],
              [-26, 0],
              [-22, -31],
              [-8, -44],
              [28, -43],
              [26, -12],
              [-9, -53],
              [-33, -33],
              [-18, -70],
              [-25, -23],
              [-12, -28],
              [9, -61],
              [19, -34],
              [-12, 3]
            ],
            [
              [3095, 1968],
              [-26, 9],
              [-67, 8],
              [-11, 34],
              [0, 45],
              [-18, -4],
              [-10, 21],
              [-3, 63],
              [22, 26],
              [9, 37],
              [-4, 30],
              [15, 51],
              [10, 78],
              [-3, 35],
              [12, 11],
              [-3, 22],
              [-13, 12],
              [10, 25],
              [-13, 22],
              [-6, 68],
              [11, 12],
              [-5, 72],
              [7, 61],
              [7, 52],
              [17, 22],
              [-9, 58],
              [0, 54],
              [21, 38],
              [-1, 50],
              [16, 57],
              [0, 55],
              [-7, 11],
              [-13, 102],
              [17, 60],
              [-2, 58],
              [10, 53],
              [18, 56],
              [20, 36],
              [-9, 24],
              [6, 19],
              [-1, 98],
              [30, 29],
              [10, 62],
              [-3, 14]
            ],
            [
              [3136, 3714],
              [23, 54],
              [36, -15],
              [16, -42],
              [11, 47],
              [32, -2],
              [4, -13]
            ],
            [
              [6210, 7485],
              [39, 9]
            ],
            [
              [6249, 7494],
              [5, -15],
              [11, -10],
              [-6, -15],
              [15, -21],
              [-8, -18],
              [12, -16],
              [13, -10],
              [0, -41]
            ],
            [
              [6291, 7348],
              [-10, -2]
            ],
            [
              [6281, 7346],
              [-11, 34],
              [0, 10],
              [-12, -1],
              [-9, 16],
              [-5, -1]
            ],
            [
              [6244, 7404],
              [-11, 17],
              [-21, 15],
              [3, 28],
              [-5, 21]
            ],
            [
              [3345, 329],
              [-8, -30],
              [-8, -27],
              [-59, 8],
              [-62, -3],
              [-34, 20],
              [0, 2],
              [-16, 17],
              [63, -2],
              [60, -6],
              [20, 24],
              [15, 21],
              [29, -24]
            ],
            [
              [577, 361],
              [-53, -8],
              [-36, 21],
              [-17, 21],
              [-1, 3],
              [-18, 16],
              [17, 22],
              [52, -9],
              [28, -18],
              [21, -21],
              [7, -27]
            ],
            [
              [3745, 447],
              [35, -26],
              [12, -36],
              [3, -25],
              [1, -30],
              [-43, -19],
              [-45, -15],
              [-52, -14],
              [-59, -11],
              [-65, 3],
              [-37, 20],
              [5, 24],
              [59, 16],
              [24, 20],
              [18, 26],
              [12, 22],
              [17, 20],
              [18, 25],
              [14, 0],
              [41, 12],
              [42, -12]
            ],
            [
              [1633, 715],
              [36, -9],
              [33, 10],
              [-16, -20],
              [-26, -15],
              [-39, 4],
              [-27, 21],
              [6, 20],
              [33, -11]
            ],
            [
              [1512, 716],
              [43, -23],
              [-17, 3],
              [-36, 5],
              [-38, 17],
              [20, 12],
              [28, -14]
            ],
            [
              [2250, 808],
              [31, -8],
              [30, 7],
              [17, -34],
              [-22, 5],
              [-34, -2],
              [-34, 2],
              [-38, -4],
              [-28, 12],
              [-15, 24],
              [18, 11],
              [35, -8],
              [40, -5]
            ],
            [
              [3098, 866],
              [4, -27],
              [-5, -23],
              [-8, -22],
              [-33, -8],
              [-31, -12],
              [-36, 1],
              [14, 24],
              [-33, -9],
              [-31, -8],
              [-21, 18],
              [-2, 24],
              [30, 23],
              [20, 7],
              [32, -2],
              [8, 30],
              [1, 22],
              [0, 47],
              [16, 28],
              [25, 9],
              [15, -22],
              [6, -22],
              [12, -26],
              [10, -26],
              [7, -26]
            ],
            [
              [3371, 1268],
              [-11, -13],
              [-21, 9],
              [-23, -6],
              [-19, -14],
              [-20, -15],
              [-14, -17],
              [-4, -23],
              [2, -22],
              [13, -20],
              [-19, -14],
              [-26, -4],
              [-15, -20],
              [-17, -19],
              [-17, -25],
              [-4, -22],
              [9, -24],
              [15, -19],
              [23, -14],
              [21, -18],
              [12, -23],
              [6, -22],
              [8, -24],
              [13, -19],
              [8, -22],
              [4, -55],
              [8, -22],
              [2, -23],
              [9, -23],
              [-4, -31],
              [-15, -24],
              [-17, -20],
              [-37, -8],
              [-12, -21],
              [-17, -20],
              [-42, -22],
              [-37, -9],
              [-35, -13],
              [-37, -13],
              [-22, -24],
              [-45, -2],
              [-49, 2],
              [-44, -4],
              [-47, 0],
              [9, -24],
              [42, -10],
              [31, -16],
              [18, -21],
              [-31, -19],
              [-48, 6],
              [-40, -15],
              [-2, -24],
              [-1, -23],
              [33, -20],
              [6, -22],
              [35, -22],
              [59, -9],
              [50, -16],
              [40, -19],
              [50, -18],
              [70, -10],
              [68, -16],
              [47, -17],
              [52, -20],
              [27, -28],
              [13, -22],
              [34, 21],
              [46, 17],
              [48, 19],
              [58, 15],
              [49, 16],
              [69, 1],
              [68, -8],
              [56, -14],
              [18, 26],
              [39, 17],
              [70, 1],
              [55, 13],
              [52, 13],
              [58, 8],
              [62, 10],
              [43, 15],
              [-20, 21],
              [-12, 21],
              [0, 22],
              [-54, -2],
              [-57, -10],
              [-54, 0],
              [-8, 22],
              [4, 44],
              [12, 13],
              [40, 14],
              [47, 14],
              [34, 17],
              [33, 18],
              [25, 23],
              [38, 10],
              [38, 8],
              [19, 5],
              [43, 2],
              [41, 8],
              [34, 12],
              [34, 14],
              [30, 14],
              [39, 18],
              [24, 20],
              [26, 17],
              [9, 24],
              [-30, 13],
              [10, 25],
              [18, 18],
              [29, 12],
              [31, 14],
              [28, 18],
              [22, 23],
              [13, 28],
              [21, 16],
              [33, -3],
              [13, -20],
              [34, -2],
              [1, 22],
              [14, 23],
              [30, -6],
              [7, -22],
              [33, -3],
              [36, 10],
              [35, 7],
              [31, -3],
              [12, -25],
              [31, 20],
              [28, 10],
              [31, 9],
              [31, 8],
              [29, 14],
              [31, 9],
              [24, 13],
              [17, 20],
              [20, -15],
              [29, 8],
              [20, -27],
              [16, -21],
              [32, 11],
              [12, 24],
              [28, 16],
              [37, -4],
              [11, -22],
              [22, 22],
              [30, 7],
              [33, 3],
              [29, -2],
              [31, -7],
              [30, -3],
              [13, -20],
              [18, -17],
              [31, 10],
              [32, 3],
              [32, 0],
              [31, 1],
              [28, 8],
              [29, 7],
              [25, 16],
              [26, 11],
              [28, 5],
              [21, 17],
              [15, 32],
              [16, 20],
              [29, -10],
              [11, -21],
              [24, -13],
              [29, 4],
              [19, -21],
              [21, -15],
              [28, 14],
              [10, 26],
              [25, 10],
              [29, 20],
              [27, 8],
              [33, 11],
              [22, 13],
              [22, 14],
              [22, 13],
              [26, -7],
              [25, 21],
              [18, 16],
              [26, -1],
              [23, 14],
              [6, 21],
              [23, 16],
              [23, 11],
              [28, 10],
              [25, 4],
              [25, -3],
              [26, -6],
              [22, -16],
              [3, -26],
              [24, -19],
              [17, -17],
              [33, -7],
              [19, -16],
              [23, -16],
              [26, -3],
              [23, 11],
              [24, 24],
              [26, -12],
              [27, -7],
              [26, -7],
              [27, -5],
              [28, 0],
              [23, -61],
              [-1, -15],
              [-4, -27],
              [-26, -15],
              [-22, -22],
              [4, -23],
              [31, 1],
              [-4, -23],
              [-14, -22],
              [-13, -24],
              [21, -19],
              [32, -6],
              [32, 11],
              [15, 23],
              [10, 22],
              [15, 18],
              [17, 18],
              [7, 21],
              [15, 29],
              [18, 5],
              [31, 3],
              [28, 7],
              [28, 9],
              [14, 23],
              [8, 22],
              [19, 22],
              [27, 15],
              [23, 12],
              [16, 19],
              [15, 11],
              [21, 9],
              [27, -6],
              [25, 6],
              [28, 7],
              [30, -4],
              [20, 17],
              [14, 39],
              [11, -16],
              [13, -28],
              [23, -12],
              [27, -4],
              [26, 7],
              [29, -5],
              [26, -1],
              [17, 6],
              [24, -4],
              [21, -12],
              [25, 8],
              [30, 0],
              [25, 8],
              [29, -8],
              [19, 19],
              [14, 20],
              [19, 16],
              [35, 44],
              [18, -8],
              [21, -16],
              [18, -21],
              [36, -36],
              [27, -1],
              [25, 0],
              [30, 7],
              [30, 8],
              [23, 16],
              [19, 18],
              [31, 2],
              [21, 13],
              [22, -12],
              [14, -18],
              [19, -19],
              [31, 2],
              [19, -15],
              [33, -15],
              [35, -5],
              [29, 4],
              [21, 19],
              [19, 18],
              [25, 5],
              [25, -8],
              [29, -6],
              [26, 9],
              [25, 0],
              [24, -6],
              [26, -5],
              [25, 10],
              [30, 9],
              [28, 3],
              [32, 0],
              [25, 5],
              [25, 5],
              [8, 29],
              [1, 24],
              [17, -16],
              [5, -27],
              [10, -24],
              [11, -20],
              [23, -10],
              [32, 4],
              [36, 1],
              [25, 3],
              [37, 0],
              [26, 1],
              [36, -2],
              [31, -5],
              [20, -18],
              [-5, -22],
              [18, -18],
              [30, -13],
              [31, -15],
              [35, -11],
              [38, -9],
              [28, -9],
              [32, -2],
              [18, 20],
              [24, -16],
              [21, -19],
              [25, -13],
              [34, -6],
              [32, -7],
              [13, -23],
              [32, -14],
              [21, -21],
              [31, -9],
              [32, 1],
              [30, -4],
              [33, 1],
              [34, -4],
              [31, -8],
              [28, -14],
              [29, -12],
              [20, -17],
              [-3, -23],
              [-15, -21],
              [-13, -27],
              [-9, -21],
              [-14, -24],
              [-36, -9],
              [-16, -21],
              [-36, -13],
              [-13, -23],
              [-19, -22],
              [-20, -18],
              [-11, -25],
              [-7, -22],
              [-3, -26],
              [0, -22],
              [16, -23],
              [6, -22],
              [13, -21],
              [52, -8],
              [11, -26],
              [-50, -9],
              [-43, -13],
              [-52, -2],
              [-24, -34],
              [-5, -27],
              [-12, -22],
              [-14, -22],
              [37, -20],
              [14, -24],
              [24, -22],
              [33, -20],
              [39, -19],
              [42, -18],
              [64, -19],
              [14, -29],
              [80, -12],
              [5, -5],
              [21, -17],
              [77, 15],
              [63, -19],
              [48, -14],
              [-9997, -1],
              [24, 35],
              [50, -19],
              [3, 2],
              [30, 19],
              [4, 0],
              [3, -1],
              [40, -25],
              [35, 25],
              [7, 3],
              [81, 11],
              [27, -14],
              [13, -7],
              [41, -20],
              [79, -15],
              [63, -18],
              [107, -14],
              [80, 16],
              [118, -11],
              [67, -19],
              [73, 17],
              [78, 17],
              [6, 27],
              [-110, 3],
              [-89, 14],
              [-24, 23],
              [-74, 12],
              [5, 27],
              [10, 24],
              [10, 22],
              [-5, 25],
              [-46, 16],
              [-22, 21],
              [-43, 18],
              [68, -3],
              [64, 9],
              [40, -20],
              [50, 18],
              [45, 22],
              [23, 19],
              [-10, 25],
              [-36, 16],
              [-41, 17],
              [-57, 4],
              [-50, 8],
              [-54, 6],
              [-18, 22],
              [-36, 18],
              [-21, 21],
              [-9, 67],
              [14, -6],
              [25, -18],
              [45, 6],
              [44, 8],
              [23, -26],
              [44, 6],
              [37, 13],
              [35, 16],
              [32, 20],
              [41, 5],
              [-1, 22],
              [-9, 22],
              [8, 21],
              [36, 11],
              [16, -20],
              [42, 12],
              [32, 15],
              [40, 1],
              [38, 6],
              [37, 13],
              [30, 13],
              [34, 13],
              [22, -4],
              [19, -4],
              [41, 8],
              [37, -10],
              [38, 1],
              [37, 8],
              [37, -6],
              [41, -6],
              [39, 3],
              [40, -2],
              [42, -1],
              [38, 3],
              [28, 17],
              [34, 9],
              [35, -13],
              [33, 11],
              [30, 21],
              [18, -19],
              [9, -21],
              [18, -19],
              [29, 17],
              [33, -22],
              [38, -7],
              [32, -16],
              [39, 3],
              [36, 11],
              [41, -3],
              [38, -8],
              [38, -10],
              [15, 25],
              [-18, 20],
              [-14, 21],
              [-36, 5],
              [-15, 22],
              [-6, 22],
              [-10, 43],
              [21, -8],
              [36, -3],
              [36, 3],
              [33, -9],
              [28, -17],
              [12, -21],
              [38, -4],
              [36, 9],
              [38, 11],
              [34, 7],
              [28, -14],
              [37, 5],
              [24, 45],
              [23, -27],
              [32, -10],
              [34, 6],
              [23, -23],
              [37, -3],
              [33, -7],
              [34, -12],
              [21, 22],
              [11, 20],
              [28, -23],
              [38, 6],
              [28, -13],
              [19, -19],
              [37, 5],
              [29, 13],
              [29, 15],
              [33, 8],
              [39, 7],
              [36, 8],
              [27, 13],
              [16, 19],
              [7, 25],
              [-3, 24],
              [-9, 24],
              [-10, 23],
              [-9, 23],
              [-7, 21],
              [-1, 23],
              [2, 23],
              [13, 22],
              [11, 24],
              [5, 23],
              [-6, 26],
              [-3, 23],
              [14, 27],
              [15, 17],
              [18, 22],
              [19, 19],
              [22, 17],
              [11, 25],
              [15, 17],
              [18, 15],
              [26, 3],
              [18, 19],
              [19, 11],
              [23, 7],
              [20, 15],
              [16, 19],
              [22, 7],
              [16, -15],
              [-10, -20],
              [-29, -17]
            ],
            [
              [6914, 2185],
              [18, -19],
              [26, -7],
              [1, -11],
              [-7, -27],
              [-43, -4],
              [-1, 31],
              [4, 25],
              [2, 12]
            ],
            [
              [9038, 2648],
              [27, -21],
              [15, 8],
              [22, 12],
              [16, -4],
              [2, -70],
              [-9, -21],
              [-3, -47],
              [-10, 16],
              [-19, -41],
              [-6, 3],
              [-17, 2],
              [-17, 50],
              [-4, 39],
              [-16, 52],
              [1, 27],
              [18, -5]
            ],
            [
              [8987, 4244],
              [10, -46],
              [18, 22],
              [9, -25],
              [13, -23],
              [-3, -26],
              [6, -51],
              [5, -29],
              [7, -7],
              [7, -51],
              [-3, -30],
              [9, -40],
              [31, -31],
              [19, -28],
              [19, -26],
              [-4, -14],
              [16, -37],
              [11, -64],
              [11, 13],
              [11, -26],
              [7, 9],
              [5, -63],
              [19, -36],
              [13, -22],
              [22, -48],
              [8, -48],
              [1, -33],
              [-2, -37],
              [13, -50],
              [-2, -52],
              [-5, -28],
              [-7, -52],
              [1, -34],
              [-6, -43],
              [-12, -53],
              [-21, -29],
              [-10, -46],
              [-9, -29],
              [-8, -51],
              [-11, -30],
              [-7, -44],
              [-4, -41],
              [2, -18],
              [-16, -21],
              [-31, -2],
              [-26, -24],
              [-13, -23],
              [-17, -26],
              [-23, 27],
              [-17, 10],
              [5, 31],
              [-15, -11],
              [-25, -43],
              [-24, 16],
              [-15, 9],
              [-16, 4],
              [-27, 17],
              [-18, 37],
              [-5, 45],
              [-7, 30],
              [-13, 24],
              [-27, 7],
              [9, 28],
              [-7, 44],
              [-13, -41],
              [-25, -11],
              [14, 33],
              [5, 34],
              [10, 29],
              [-2, 44],
              [-22, -50],
              [-18, -21],
              [-10, -47],
              [-22, 25],
              [1, 31],
              [-18, 43],
              [-14, 22],
              [5, 14],
              [-36, 35],
              [-19, 2],
              [-27, 29],
              [-50, -6],
              [-36, -21],
              [-31, -20],
              [-27, 4],
              [-29, -30],
              [-24, -14],
              [-6, -31],
              [-10, -24],
              [-23, -1],
              [-18, -5],
              [-24, 10],
              [-20, -6],
              [-19, -3],
              [-17, -31],
              [-8, 2],
              [-14, -16],
              [-13, -19],
              [-21, 2],
              [-18, 0],
              [-30, 38],
              [-15, 11],
              [1, 34],
              [14, 8],
              [4, 14],
              [-1, 21],
              [4, 41],
              [-3, 35],
              [-15, 60],
              [-4, 33],
              [1, 34],
              [-11, 38],
              [-1, 18],
              [-12, 23],
              [-4, 47],
              [-16, 46],
              [-4, 26],
              [13, -26],
              [-10, 55],
              [14, -17],
              [8, -23],
              [0, 30],
              [-14, 47],
              [-3, 18],
              [-6, 18],
              [3, 34],
              [6, 15],
              [4, 29],
              [-3, 35],
              [11, 42],
              [2, -45],
              [12, 41],
              [22, 20],
              [14, 25],
              [21, 22],
              [13, 4],
              [7, -7],
              [22, 22],
              [17, 6],
              [4, 13],
              [8, 6],
              [15, -2],
              [29, 18],
              [15, 26],
              [7, 31],
              [17, 30],
              [1, 24],
              [1, 32],
              [19, 50],
              [12, -51],
              [12, 12],
              [-10, 28],
              [9, 29],
              [12, -13],
              [3, 45],
              [15, 29],
              [7, 23],
              [14, 10],
              [0, 17],
              [13, -7],
              [0, 15],
              [12, 8],
              [14, 8],
              [20, -27],
              [16, -35],
              [17, 0],
              [18, -6],
              [-6, 33],
              [13, 47],
              [13, 15],
              [-5, 15],
              [12, 34],
              [17, 21],
              [14, -7],
              [24, 11],
              [-1, 30],
              [-20, 19],
              [15, 9],
              [18, -15],
              [15, -24],
              [23, -15],
              [8, 6],
              [17, -18],
              [17, 17],
              [10, -5],
              [7, 11],
              [12, -29],
              [-7, -32],
              [-11, -24],
              [-9, -2],
              [3, -23],
              [-8, -30],
              [-10, -29],
              [2, -17],
              [22, -32],
              [21, -19],
              [15, -20],
              [20, -35],
              [8, 0],
              [14, -15],
              [4, -19],
              [27, -20],
              [18, 20],
              [6, 32],
              [5, 26],
              [4, 33],
              [8, 47],
              [-4, 28],
              [2, 17],
              [-3, 34],
              [4, 45],
              [5, 12],
              [-4, 20],
              [7, 31],
              [5, 32],
              [1, 17],
              [10, 22],
              [8, -29],
              [2, -37],
              [7, -7],
              [1, -25],
              [10, -30],
              [2, -33],
              [-1, -22]
            ],
            [
              [5471, 7900],
              [-2, -24],
              [-16, 0],
              [6, -13],
              [-9, -38]
            ],
            [
              [5450, 7825],
              [-6, -10],
              [-24, -1],
              [-14, -13],
              [-23, 4]
            ],
            [
              [5383, 7805],
              [-40, 15],
              [-6, 21],
              [-27, -10],
              [-4, -12],
              [-16, 9]
            ],
            [
              [5290, 7828],
              [-15, 1],
              [-12, 11],
              [4, 15],
              [-1, 10]
            ],
            [
              [5266, 7865],
              [8, 3],
              [14, -16],
              [4, 16],
              [25, -3],
              [20, 11],
              [13, -2],
              [9, -12],
              [2, 10],
              [-4, 38],
              [10, 8],
              [10, 27]
            ],
            [
              [5377, 7945],
              [21, -19],
              [15, 24],
              [10, 5],
              [22, -18],
              [13, 3],
              [13, -12]
            ],
            [
              [5471, 7928],
              [-3, -7],
              [3, -21]
            ],
            [
              [6281, 7346],
              [-19, 8],
              [-14, 27],
              [-4, 23]
            ],
            [
              [6349, 7527],
              [15, -31],
              [14, -42],
              [13, -2],
              [8, -16],
              [-23, -5],
              [-5, -46],
              [-4, -21],
              [-11, -13],
              [1, -30]
            ],
            [
              [6357, 7321],
              [-7, -3],
              [-17, 31],
              [10, 30],
              [-9, 17],
              [-10, -4],
              [-33, -44]
            ],
            [
              [6249, 7494],
              [6, 10],
              [21, -17],
              [15, -4],
              [4, 7],
              [-14, 32],
              [7, 9]
            ],
            [
              [6288, 7531],
              [8, -2],
              [19, -36],
              [13, -4],
              [4, 15],
              [17, 23]
            ],
            [
              [5814, 4792],
              [-1, 71],
              [-7, 27]
            ],
            [
              [5806, 4890],
              [17, -5],
              [8, 34],
              [15, -4]
            ],
            [
              [5846, 4915],
              [1, -23],
              [6, -14],
              [1, -19],
              [-7, -12],
              [-11, -31],
              [-10, -22],
              [-12, -2]
            ],
            [
              [5092, 8091],
              [20, -5],
              [26, 12],
              [17, -25],
              [16, -14]
            ],
            [
              [5171, 8059],
              [-4, -40]
            ],
            [
              [5167, 8019],
              [-7, -2],
              [-3, -33]
            ],
            [
              [5157, 7984],
              [-24, 26],
              [-14, -4],
              [-20, 28],
              [-13, 23],
              [-13, 1],
              [-4, 21]
            ],
            [
              [5069, 8079],
              [23, 12]
            ],
            [
              [5074, 5427],
              [-23, -7]
            ],
            [
              [5051, 5420],
              [-7, 41],
              [2, 136],
              [-6, 12],
              [-1, 29],
              [-10, 21],
              [-8, 17],
              [3, 31]
            ],
            [
              [5024, 5707],
              [10, 7],
              [6, 26],
              [13, 5],
              [6, 18]
            ],
            [
              [5059, 5763],
              [10, 17],
              [10, 0],
              [21, -34]
            ],
            [
              [5100, 5746],
              [-1, -19],
              [6, -35],
              [-6, -24],
              [3, -16],
              [-13, -37],
              [-9, -18],
              [-5, -37],
              [1, -38],
              [-2, -95]
            ],
            [
              [4921, 5627],
              [-19, 15],
              [-13, -2],
              [-10, -15],
              [-12, 13],
              [-5, 19],
              [-13, 13]
            ],
            [
              [4849, 5670],
              [-1, 34],
              [7, 26],
              [-1, 20],
              [23, 48],
              [4, 41],
              [7, 14],
              [14, -8],
              [11, 12],
              [4, 16],
              [22, 26],
              [5, 19],
              [26, 24],
              [15, 9],
              [7, -12],
              [18, 0]
            ],
            [
              [5010, 5939],
              [-2, -28],
              [3, -27],
              [16, -39],
              [1, -28],
              [32, -14],
              [-1, -40]
            ],
            [
              [5024, 5707],
              [-24, 1]
            ],
            [
              [5e3, 5708],
              [-13, 5],
              [-9, -9],
              [-12, 4],
              [-48, -3],
              [-1, -33],
              [4, -45]
            ],
            [
              [7573, 6360],
              [0, -43],
              [-10, 9],
              [2, -47]
            ],
            [
              [7565, 6279],
              [-8, 30],
              [-1, 31],
              [-6, 28],
              [-11, 34],
              [-26, 3],
              [3, -25],
              [-9, -32],
              [-12, 12],
              [-4, -11],
              [-8, 6],
              [-11, 5]
            ],
            [
              [7472, 6360],
              [-4, 49],
              [-10, 45],
              [5, 35],
              [-17, 16],
              [6, 22],
              [18, 22],
              [-20, 31],
              [9, 40],
              [22, -26],
              [14, -3],
              [2, -41],
              [26, -8],
              [26, 1],
              [16, -10],
              [-13, -50],
              [-12, -3],
              [-9, -34],
              [16, -31],
              [4, 38],
              [8, 0],
              [14, -93]
            ],
            [
              [5629, 7671],
              [8, -25],
              [11, 5],
              [21, -9],
              [41, -4],
              [13, 16],
              [33, 13],
              [20, -21],
              [17, -6]
            ],
            [
              [5793, 7640],
              [-15, -25],
              [-10, -42],
              [9, -34]
            ],
            [
              [5777, 7539],
              [-24, 8],
              [-28, -18]
            ],
            [
              [5725, 7529],
              [0, -30],
              [-26, -5],
              [-19, 20],
              [-22, -16],
              [-21, 2]
            ],
            [
              [5637, 7500],
              [-2, 39],
              [-14, 19]
            ],
            [
              [5621, 7558],
              [5, 8],
              [-3, 7],
              [4, 19],
              [11, 18],
              [-14, 26],
              [-2, 21],
              [7, 14]
            ],
            [
              [2846, 6461],
              [-7, -3],
              [-7, 34],
              [-10, 17],
              [6, 38],
              [8, -3],
              [10, -49],
              [0, -34]
            ],
            [
              [2838, 6628],
              [-30, -10],
              [-2, 22],
              [13, 5],
              [18, -2],
              [1, -15]
            ],
            [
              [2861, 6628],
              [-5, -42],
              [-5, 8],
              [0, 31],
              [-12, 23],
              [0, 7],
              [22, -27]
            ],
            [
              [5527, 7708],
              [10, 0],
              [-7, -26],
              [14, -23],
              [-4, -28],
              [-7, -2]
            ],
            [
              [5533, 7629],
              [-5, -6],
              [-9, -13],
              [-4, -33]
            ],
            [
              [5515, 7577],
              [-25, 23],
              [-10, 24],
              [-11, 13],
              [-12, 22],
              [-6, 19],
              [-14, 27],
              [6, 25],
              [10, -14],
              [6, 12],
              [13, 2],
              [24, -10],
              [19, 1],
              [12, -13]
            ],
            [
              [5652, 8242],
              [27, 0],
              [30, 22],
              [6, 34],
              [23, 19],
              [-3, 26]
            ],
            [
              [5735, 8343],
              [17, 10],
              [30, 23]
            ],
            [
              [5782, 8376],
              [29, -15],
              [4, -15],
              [15, 7],
              [27, -14],
              [3, -27],
              [-6, -16],
              [17, -39],
              [12, -11],
              [-2, -11],
              [19, -10],
              [8, -16],
              [-11, -13],
              [-23, 2],
              [-5, -5],
              [7, -20],
              [6, -37]
            ],
            [
              [5882, 8136],
              [-23, -4],
              [-9, -13],
              [-2, -30],
              [-11, 6],
              [-25, -3],
              [-7, 14],
              [-11, -10],
              [-10, 8],
              [-22, 1],
              [-31, 15],
              [-28, 4],
              [-22, -1],
              [-15, -16],
              [-13, -2]
            ],
            [
              [5653, 8105],
              [-1, 26],
              [-8, 27],
              [17, 12],
              [0, 24],
              [-8, 22],
              [-1, 26]
            ],
            [
              [2524, 6110],
              [-1, 8],
              [4, 3],
              [5, -7],
              [10, 36],
              [5, 0]
            ],
            [
              [2547, 6150],
              [0, -8],
              [5, -1],
              [0, -16],
              [-5, -25],
              [3, -9],
              [-3, -21],
              [2, -6],
              [-4, -30],
              [-5, -16],
              [-5, -1],
              [-6, -21]
            ],
            [
              [2529, 5996],
              [-8, 0],
              [2, 67],
              [1, 47]
            ],
            [
              [3136, 3714],
              [-20, -8],
              [-11, 82],
              [-15, 66],
              [9, 57],
              [-15, 25],
              [-4, 43],
              [-13, 40]
            ],
            [
              [3067, 4019],
              [17, 64],
              [-12, 49],
              [7, 20],
              [-5, 22],
              [10, 30],
              [1, 50],
              [1, 41],
              [6, 20],
              [-24, 96]
            ],
            [
              [3068, 4411],
              [21, -5],
              [14, 1],
              [6, 18],
              [25, 24],
              [14, 22],
              [37, 10],
              [-3, -44],
              [3, -23],
              [-2, -40],
              [30, -53],
              [31, -9],
              [11, -23],
              [19, -11],
              [11, -17],
              [18, 0],
              [16, -17],
              [1, -34],
              [6, -18],
              [0, -25],
              [-8, -1],
              [11, -69],
              [53, -2],
              [-4, -35],
              [3, -23],
              [15, -16],
              [6, -37],
              [-4, -47],
              [-8, -26],
              [3, -33],
              [-9, -12]
            ],
            [
              [3384, 3866],
              [-1, 18],
              [-25, 30],
              [-26, 1],
              [-49, -17],
              [-13, -52],
              [-1, -32],
              [-11, -71]
            ],
            [
              [3482, 3537],
              [6, 34],
              [3, 35],
              [1, 32],
              [-10, 11],
              [-11, -9],
              [-10, 2],
              [-4, 23],
              [-2, 54],
              [-5, 18],
              [-19, 16],
              [-11, -12],
              [-30, 11],
              [2, 81],
              [-8, 33]
            ],
            [
              [3068, 4411],
              [-15, -11],
              [-13, 7],
              [2, 90],
              [-23, -35],
              [-24, 2],
              [-11, 31],
              [-18, 4],
              [5, 25],
              [-15, 36],
              [-11, 53],
              [7, 11],
              [0, 25],
              [17, 17],
              [-3, 32],
              [7, 20],
              [2, 28],
              [32, 40],
              [22, 11],
              [4, 9],
              [25, -2]
            ],
            [
              [3058, 4804],
              [13, 162],
              [0, 25],
              [-4, 34],
              [-12, 22],
              [0, 42],
              [15, 10],
              [6, -6],
              [1, 23],
              [-16, 6],
              [-1, 37],
              [54, -2],
              [10, 21],
              [7, -19],
              [6, -35],
              [5, 8]
            ],
            [
              [3142, 5132],
              [15, -32],
              [22, 4],
              [5, 18],
              [21, 14],
              [11, 10],
              [4, 25],
              [19, 17],
              [-1, 12],
              [-24, 5],
              [-3, 37],
              [1, 40],
              [-13, 15],
              [5, 6],
              [21, -8],
              [22, -15],
              [8, 14],
              [20, 9],
              [31, 23],
              [10, 22],
              [-3, 17]
            ],
            [
              [3313, 5365],
              [14, 2],
              [7, -13],
              [-4, -26],
              [9, -9],
              [7, -28],
              [-8, -20],
              [-4, -51],
              [7, -30],
              [2, -27],
              [17, -28],
              [14, -3],
              [3, 12],
              [8, 3],
              [13, 10],
              [9, 16],
              [15, -5],
              [7, 2]
            ],
            [
              [3429, 5170],
              [15, -5],
              [3, 12],
              [-5, 12],
              [3, 17],
              [11, -5],
              [13, 6],
              [16, -13]
            ],
            [
              [3485, 5194],
              [12, -12],
              [9, 16],
              [6, -3],
              [4, -16],
              [13, 4],
              [11, 22],
              [8, 44],
              [17, 54]
            ],
            [
              [3565, 5303],
              [9, 3],
              [7, -33],
              [16, -103],
              [14, -10],
              [1, -41],
              [-21, -48],
              [9, -18],
              [49, -9],
              [1, -60],
              [21, 39],
              [35, -21],
              [46, -36],
              [14, -35],
              [-5, -32],
              [33, 18],
              [54, -32],
              [41, 3],
              [41, -49],
              [36, -66],
              [21, -17],
              [24, -3],
              [10, -18],
              [9, -76],
              [5, -35],
              [-11, -98],
              [-14, -39],
              [-39, -82],
              [-18, -67],
              [-21, -51],
              [-7, -1],
              [-7, -43],
              [2, -111],
              [-8, -91],
              [-3, -39],
              [-9, -23],
              [-5, -79],
              [-28, -77],
              [-5, -61],
              [-22, -26],
              [-7, -35],
              [-30, 0],
              [-44, -23],
              [-19, -26],
              [-31, -18],
              [-33, -47],
              [-23, -58],
              [-5, -44],
              [5, -33],
              [-5, -60],
              [-6, -28],
              [-20, -33],
              [-31, -104],
              [-24, -47],
              [-19, -27],
              [-13, -57],
              [-18, -33]
            ],
            [
              [3517, 3063],
              [-8, 33],
              [13, 28],
              [-16, 40],
              [-22, 33],
              [-29, 38],
              [-10, -2],
              [-28, 46],
              [-18, -7]
            ],
            [
              [8172, 5325],
              [11, 22],
              [23, 32]
            ],
            [
              [8206, 5379],
              [-1, -29],
              [-2, -37],
              [-13, 1],
              [-6, -20],
              [-12, 31]
            ],
            [
              [7546, 6698],
              [12, -19],
              [-2, -36],
              [-23, -2],
              [-23, 4],
              [-18, -9],
              [-25, 22],
              [-1, 12]
            ],
            [
              [7466, 6670],
              [19, 44],
              [15, 15],
              [20, -14],
              [14, -1],
              [12, -16]
            ],
            [
              [5817, 3752],
              [-39, -43],
              [-25, -44],
              [-10, -40],
              [-8, -22],
              [-15, -4],
              [-5, -29],
              [-3, -18],
              [-17, -14],
              [-23, 3],
              [-13, 17],
              [-12, 7],
              [-14, -14],
              [-6, -28],
              [-14, -18],
              [-13, -26],
              [-20, -6],
              [-6, 20],
              [2, 36],
              [-16, 56],
              [-8, 9]
            ],
            [
              [5552, 3594],
              [0, 173],
              [27, 2],
              [1, 210],
              [21, 2],
              [43, 21],
              [10, -24],
              [18, 23],
              [9, 0],
              [15, 13]
            ],
            [
              [5696, 4014],
              [5, -4]
            ],
            [
              [5701, 4010],
              [11, -48],
              [5, -10],
              [9, -34],
              [32, -65],
              [12, -7],
              [0, -20],
              [8, -38],
              [21, -9],
              [18, -27]
            ],
            [
              [5424, 5496],
              [23, 4],
              [5, 16],
              [5, -2],
              [7, -13],
              [34, 23],
              [12, 23],
              [15, 20],
              [-3, 21],
              [8, 6],
              [27, -4],
              [26, 27],
              [20, 65],
              [14, 24],
              [18, 10]
            ],
            [
              [5635, 5716],
              [3, -26],
              [16, -36],
              [0, -25],
              [-5, -24],
              [2, -18],
              [10, -18]
            ],
            [
              [5661, 5569],
              [21, -25]
            ],
            [
              [5682, 5544],
              [15, -24],
              [0, -19],
              [19, -31],
              [12, -26],
              [7, -35],
              [20, -24],
              [5, -18]
            ],
            [
              [5760, 5367],
              [-9, -7],
              [-18, 2],
              [-21, 6],
              [-10, -5],
              [-5, -14],
              [-9, -2],
              [-10, 12],
              [-31, -29],
              [-13, 6],
              [-4, -5],
              [-8, -35],
              [-21, 11],
              [-20, 6],
              [-18, 22],
              [-23, 20],
              [-15, -19],
              [-10, -30],
              [-3, -41]
            ],
            [
              [5512, 5265],
              [-18, 3],
              [-19, 10],
              [-16, -32],
              [-15, -55]
            ],
            [
              [5444, 5191],
              [-3, 18],
              [-1, 27],
              [-13, 19],
              [-10, 30],
              [-2, 21],
              [-13, 31],
              [2, 18],
              [-3, 25],
              [2, 45],
              [7, 11],
              [14, 60]
            ],
            [
              [3231, 7808],
              [20, -8],
              [26, 1],
              [-14, -24],
              [-10, -4],
              [-35, 25],
              [-7, 20],
              [10, 18],
              [10, -28]
            ],
            [
              [3283, 7958],
              [-14, -1],
              [-36, 19],
              [-26, 28],
              [10, 5],
              [37, -15],
              [28, -25],
              [1, -11]
            ],
            [
              [1569, 7923],
              [-14, -8],
              [-46, 27],
              [-8, 21],
              [-25, 21],
              [-5, 16],
              [-28, 11],
              [-11, 32],
              [2, 14],
              [30, -13],
              [17, -9],
              [26, -6],
              [9, -21],
              [14, -28],
              [28, -24],
              [11, -33]
            ],
            [
              [3440, 8052],
              [-18, -52],
              [18, 20],
              [19, -12],
              [-10, -21],
              [25, -16],
              [12, 14],
              [28, -18],
              [-8, -43],
              [19, 10],
              [4, -32],
              [8, -36],
              [-11, -52],
              [-13, -2],
              [-18, 11],
              [6, 48],
              [-8, 8],
              [-32, -52],
              [-17, 2],
              [20, 28],
              [-27, 14],
              [-30, -3],
              [-54, 2],
              [-4, 17],
              [17, 21],
              [-12, 16],
              [24, 36],
              [28, 94],
              [18, 33],
              [24, 21],
              [13, -3],
              [-6, -16],
              [-15, -37]
            ],
            [
              [1313, 8250],
              [27, 5],
              [-8, -67],
              [24, -48],
              [-11, 0],
              [-17, 27],
              [-10, 27],
              [-14, 19],
              [-5, 26],
              [1, 19],
              [13, -8]
            ],
            [
              [2798, 8730],
              [-11, -31],
              [-12, 5],
              [-8, 17],
              [2, 4],
              [10, 18],
              [12, -1],
              [7, -12]
            ],
            [
              [2725, 8762],
              [-33, -32],
              [-19, 1],
              [-6, 16],
              [20, 27],
              [38, 0],
              [0, -12]
            ],
            [
              [2634, 8936],
              [5, -26],
              [15, 9],
              [16, -15],
              [30, -20],
              [32, -19],
              [2, -28],
              [21, 5],
              [20, -20],
              [-25, -18],
              [-43, 14],
              [-16, 26],
              [-27, -31],
              [-40, -31],
              [-9, 35],
              [-38, -6],
              [24, 30],
              [4, 46],
              [9, 54],
              [20, -5]
            ],
            [
              [2892, 9024],
              [-31, -3],
              [-7, 29],
              [12, 34],
              [26, 8],
              [21, -17],
              [1, -25],
              [-4, -8],
              [-18, -18]
            ],
            [
              [2343, 9140],
              [-17, -21],
              [-38, 18],
              [-22, -6],
              [-38, 26],
              [24, 19],
              [19, 25],
              [30, -16],
              [17, -11],
              [8, -11],
              [17, -23]
            ],
            [
              [3135, 7724],
              [-18, 33],
              [0, 81],
              [-13, 17],
              [-18, -10],
              [-10, 16],
              [-21, -45],
              [-8, -46],
              [-10, -27],
              [-12, -9],
              [-9, -3],
              [-3, -15],
              [-51, 0],
              [-42, 0],
              [-12, -11],
              [-30, -42],
              [-3, -5],
              [-9, -23],
              [-26, 0],
              [-27, 0],
              [-12, -10],
              [4, -11],
              [2, -18],
              [0, -6],
              [-36, -30],
              [-29, -9],
              [-32, -31],
              [-7, 0],
              [-10, 9],
              [-3, 8],
              [1, 6],
              [6, 21],
              [13, 33],
              [8, 35],
              [-5, 51],
              [-6, 53],
              [-29, 28],
              [3, 11],
              [-4, 7],
              [-8, 0],
              [-5, 9],
              [-2, 14],
              [-5, -6],
              [-7, 2],
              [1, 6],
              [-6, 6],
              [-3, 15],
              [-21, 19],
              [-23, 20],
              [-27, 23],
              [-26, 21],
              [-25, -17],
              [-9, 0],
              [-34, 15],
              [-23, -8],
              [-27, 19],
              [-28, 9],
              [-19, 4],
              [-9, 10],
              [-5, 32],
              [-9, 0],
              [-1, -23],
              [-57, 0],
              [-95, 0],
              [-94, 0],
              [-84, 0],
              [-83, 0],
              [-82, 0],
              [-85, 0],
              [-27, 0],
              [-82, 0],
              [-79, 0]
            ],
            [
              [1588, 7952],
              [-4, 0],
              [-54, 58],
              [-20, 26],
              [-50, 24],
              [-15, 53],
              [3, 36],
              [-35, 25],
              [-5, 48],
              [-34, 43],
              [0, 30]
            ],
            [
              [1374, 8295],
              [15, 29],
              [0, 37],
              [-48, 37],
              [-28, 68],
              [-17, 42],
              [-26, 27],
              [-19, 24],
              [-14, 31],
              [-28, -20],
              [-27, -33],
              [-25, 39],
              [-19, 26],
              [-27, 16],
              [-28, 2],
              [0, 337],
              [1, 219]
            ],
            [
              [1084, 9176],
              [51, -14],
              [44, -29],
              [29, -5],
              [24, 24],
              [34, 19],
              [41, -7],
              [42, 26],
              [45, 14],
              [20, -24],
              [20, 14],
              [6, 27],
              [20, -6],
              [47, -53],
              [37, 40],
              [3, -45],
              [34, 10],
              [11, 17],
              [34, -3],
              [42, -25],
              [65, -22],
              [38, -10],
              [28, 4],
              [37, -30],
              [-39, -29],
              [50, -13],
              [75, 7],
              [24, 11],
              [29, -36],
              [31, 30],
              [-29, 25],
              [18, 20],
              [34, 3],
              [22, 6],
              [23, -14],
              [28, -32],
              [31, 5],
              [49, -27],
              [43, 9],
              [40, -1],
              [-3, 37],
              [25, 10],
              [43, -20],
              [0, -56],
              [17, 47],
              [23, -1],
              [12, 59],
              [-30, 36],
              [-32, 24],
              [2, 65],
              [33, 43],
              [37, -9],
              [28, -26],
              [38, -67],
              [-25, -29],
              [52, -12],
              [-1, -60],
              [38, 46],
              [33, -38],
              [-9, -44],
              [27, -40],
              [29, 43],
              [21, 51],
              [1, 65],
              [40, -5],
              [41, -8],
              [37, -30],
              [2, -29],
              [-21, -31],
              [20, -32],
              [-4, -29],
              [-54, -41],
              [-39, -9],
              [-29, 18],
              [-8, -30],
              [-27, -50],
              [-8, -26],
              [-32, -40],
              [-40, -4],
              [-22, -25],
              [-2, -38],
              [-32, -7],
              [-34, -48],
              [-30, -67],
              [-11, -46],
              [-1, -69],
              [40, -10],
              [13, -55],
              [13, -45],
              [39, 12],
              [51, -26],
              [28, -22],
              [20, -28],
              [35, -17],
              [29, -24],
              [46, -4],
              [30, -6],
              [-4, -51],
              [8, -59],
              [21, -66],
              [41, -56],
              [21, 19],
              [15, 61],
              [-14, 93],
              [-20, 31],
              [45, 28],
              [31, 41],
              [16, 41],
              [-3, 40],
              [-19, 50],
              [-33, 44],
              [32, 62],
              [-12, 54],
              [-9, 92],
              [19, 14],
              [48, -16],
              [29, -6],
              [23, 15],
              [25, -20],
              [35, -34],
              [8, -23],
              [50, -4],
              [-1, -50],
              [9, -74],
              [25, -10],
              [21, -35],
              [40, 33],
              [26, 65],
              [19, 28],
              [21, -53],
              [36, -75],
              [31, -71],
              [-11, -37],
              [37, -33],
              [25, -34],
              [44, -15],
              [18, -19],
              [11, -50],
              [22, -8],
              [11, -22],
              [2, -67],
              [-20, -22],
              [-20, -21],
              [-46, -21],
              [-35, -48],
              [-47, -10],
              [-59, 13],
              [-42, 0],
              [-29, -4],
              [-23, -43],
              [-35, -26],
              [-40, -78],
              [-32, -54],
              [23, 9],
              [45, 78],
              [58, 49],
              [42, 6],
              [24, -29],
              [-26, -40],
              [9, -63],
              [9, -45],
              [36, -29],
              [46, 8],
              [28, 67],
              [2, -43],
              [17, -22],
              [-34, -38],
              [-61, -36],
              [-28, -23],
              [-31, -43],
              [-21, 4],
              [-1, 50],
              [48, 49],
              [-44, -2],
              [-31, -7]
            ],
            [
              [1829, 9377],
              [-14, -27],
              [61, 17],
              [39, -29],
              [31, 30],
              [26, -20],
              [23, -58],
              [14, 25],
              [-20, 60],
              [24, 9],
              [28, -9],
              [31, -24],
              [17, -58],
              [9, -41],
              [47, -30],
              [50, -28],
              [-3, -26],
              [-46, -4],
              [18, -23],
              [-9, -22],
              [-51, 9],
              [-48, 16],
              [-32, -3],
              [-52, -20],
              [-70, -9],
              [-50, -6],
              [-15, 28],
              [-38, 16],
              [-24, -6],
              [-35, 47],
              [19, 6],
              [43, 10],
              [39, -3],
              [36, 11],
              [-54, 13],
              [-59, -4],
              [-39, 1],
              [-15, 22],
              [64, 23],
              [-42, -1],
              [-49, 16],
              [23, 44],
              [20, 24],
              [74, 36],
              [29, -12]
            ],
            [
              [2097, 9395],
              [-24, -39],
              [-44, 41],
              [10, 9],
              [37, 2],
              [21, -13]
            ],
            [
              [2879, 9376],
              [3, -16],
              [-30, 2],
              [-30, 1],
              [-30, -8],
              [-8, 3],
              [-31, 32],
              [1, 21],
              [14, 4],
              [63, -6],
              [48, -33]
            ],
            [
              [2595, 9379],
              [22, -36],
              [26, 47],
              [70, 24],
              [48, -61],
              [-4, -38],
              [55, 17],
              [26, 23],
              [62, -30],
              [38, -28],
              [3, -25],
              [52, 13],
              [29, -38],
              [67, -23],
              [24, -24],
              [26, -55],
              [-51, -28],
              [66, -38],
              [44, -13],
              [40, -55],
              [44, -3],
              [-9, -42],
              [-49, -69],
              [-34, 26],
              [-44, 57],
              [-36, -8],
              [-3, -34],
              [29, -34],
              [38, -27],
              [11, -16],
              [18, -58],
              [-9, -43],
              [-35, 16],
              [-70, 47],
              [39, -51],
              [29, -35],
              [5, -21],
              [-76, 24],
              [-59, 34],
              [-34, 29],
              [10, 17],
              [-42, 30],
              [-40, 29],
              [0, -18],
              [-80, -9],
              [-23, 20],
              [18, 44],
              [52, 1],
              [57, 7],
              [-9, 21],
              [10, 30],
              [36, 57],
              [-8, 27],
              [-11, 20],
              [-42, 29],
              [-57, 20],
              [18, 15],
              [-29, 36],
              [-25, 4],
              [-22, 20],
              [-14, -18],
              [-51, -7],
              [-101, 13],
              [-59, 17],
              [-45, 9],
              [-23, 21],
              [29, 27],
              [-39, 0],
              [-9, 60],
              [21, 53],
              [29, 24],
              [72, 16],
              [-21, -39]
            ],
            [
              [2212, 9420],
              [33, -12],
              [50, 7],
              [7, -17],
              [-26, -28],
              [42, -26],
              [-5, -53],
              [-45, -23],
              [-27, 5],
              [-19, 23],
              [-69, 45],
              [0, 19],
              [57, -7],
              [-31, 38],
              [33, 29]
            ],
            [
              [2411, 9357],
              [-30, -45],
              [-32, 3],
              [-17, 52],
              [1, 29],
              [14, 25],
              [28, 16],
              [58, -2],
              [53, -14],
              [-42, -53],
              [-33, -11]
            ],
            [
              [1654, 9275],
              [-73, -29],
              [-15, 26],
              [-64, 31],
              [12, 25],
              [19, 43],
              [24, 39],
              [-27, 36],
              [94, 10],
              [39, -13],
              [71, -3],
              [27, -17],
              [30, -25],
              [-35, -15],
              [-68, -41],
              [-34, -42],
              [0, -25]
            ],
            [
              [2399, 9487],
              [-15, -23],
              [-40, 5],
              [-34, 15],
              [15, 27],
              [40, 16],
              [24, -21],
              [10, -19]
            ],
            [
              [2264, 9590],
              [21, -27],
              [1, -31],
              [-13, -44],
              [-46, -6],
              [-30, 10],
              [1, 34],
              [-45, -4],
              [-2, 45],
              [30, -2],
              [41, 21],
              [40, -4],
              [2, 8]
            ],
            [
              [1994, 9559],
              [11, -21],
              [25, 10],
              [29, -2],
              [5, -29],
              [-17, -28],
              [-94, -10],
              [-70, -25],
              [-43, -2],
              [-3, 20],
              [57, 26],
              [-125, -7],
              [-39, 10],
              [38, 58],
              [26, 17],
              [78, -20],
              [50, -35],
              [48, -5],
              [-40, 57],
              [26, 21],
              [29, -7],
              [9, -28]
            ],
            [
              [2370, 9612],
              [30, -19],
              [55, 0],
              [24, -19],
              [-6, -22],
              [32, -14],
              [17, -14],
              [38, -2],
              [40, -5],
              [44, 13],
              [57, 5],
              [45, -5],
              [30, -22],
              [6, -24],
              [-17, -16],
              [-42, -13],
              [-35, 8],
              [-80, -10],
              [-57, -1],
              [-45, 8],
              [-74, 19],
              [-9, 32],
              [-4, 29],
              [-27, 26],
              [-58, 7],
              [-32, 19],
              [10, 24],
              [58, -4]
            ],
            [
              [1772, 9645],
              [-4, -46],
              [-21, -20],
              [-26, -3],
              [-52, -26],
              [-44, -9],
              [-38, 13],
              [47, 44],
              [57, 39],
              [43, -1],
              [38, 9]
            ],
            [
              [2393, 9637],
              [-13, -2],
              [-52, 4],
              [-7, 17],
              [56, -1],
              [19, -11],
              [-3, -7]
            ],
            [
              [1939, 9648],
              [-52, -17],
              [-41, 19],
              [23, 19],
              [40, 6],
              [39, -10],
              [-9, -17]
            ],
            [
              [1954, 9701],
              [-34, -11],
              [-46, 0],
              [0, 8],
              [29, 18],
              [14, -3],
              [37, -12]
            ],
            [
              [2338, 9669],
              [-41, -12],
              [-23, 13],
              [-12, 23],
              [-2, 24],
              [36, -2],
              [16, -4],
              [33, -21],
              [-7, -21]
            ],
            [
              [2220, 9685],
              [11, -25],
              [-45, 7],
              [-46, 19],
              [-62, 2],
              [27, 18],
              [-34, 14],
              [-2, 22],
              [55, -8],
              [75, -21],
              [21, -28]
            ],
            [
              [2583, 9764],
              [33, -20],
              [-38, -17],
              [-51, -45],
              [-50, -4],
              [-57, 8],
              [-30, 24],
              [0, 21],
              [22, 16],
              [-50, 0],
              [-31, 19],
              [-18, 27],
              [20, 26],
              [19, 18],
              [28, 4],
              [-12, 14],
              [65, 3],
              [35, -32],
              [47, -12],
              [46, -11],
              [22, -39]
            ],
            [
              [3097, 9967],
              [74, -4],
              [60, -8],
              [51, -16],
              [-2, -16],
              [-67, -25],
              [-68, -12],
              [-25, -14],
              [61, 1],
              [-66, -36],
              [-45, -17],
              [-48, -48],
              [-57, -10],
              [-18, -12],
              [-84, -6],
              [39, -8],
              [-20, -10],
              [23, -29],
              [-26, -21],
              [-43, -16],
              [-13, -24],
              [-39, -17],
              [4, -14],
              [48, 3],
              [0, -15],
              [-74, -35],
              [-73, 16],
              [-81, -9],
              [-42, 7],
              [-52, 3],
              [-4, 29],
              [52, 13],
              [-14, 43],
              [17, 4],
              [74, -26],
              [-38, 38],
              [-45, 11],
              [23, 23],
              [49, 14],
              [8, 21],
              [-39, 23],
              [-12, 31],
              [76, -3],
              [22, -6],
              [43, 21],
              [-62, 7],
              [-98, -4],
              [-49, 20],
              [-23, 24],
              [-32, 17],
              [-6, 21],
              [41, 11],
              [32, 2],
              [55, 9],
              [41, 22],
              [34, -3],
              [30, -16],
              [21, 32],
              [37, 9],
              [50, 7],
              [85, 2],
              [14, -6],
              [81, 10],
              [60, -4],
              [60, -4]
            ],
            [
              [5290, 7828],
              [-3, -24],
              [-12, -10],
              [-20, 7],
              [-6, -24],
              [-14, -2],
              [-5, 10],
              [-15, -20],
              [-13, -3],
              [-12, 13]
            ],
            [
              [5190, 7775],
              [-10, 25],
              [-13, -9],
              [0, 27],
              [21, 33],
              [-1, 15],
              [12, -5],
              [8, 10]
            ],
            [
              [5207, 7871],
              [24, -1],
              [5, 13],
              [30, -18]
            ],
            [
              [3140, 1814],
              [-10, -24],
              [-23, -18],
              [-14, 2],
              [-16, 5],
              [-21, 18],
              [-29, 8],
              [-35, 33],
              [-28, 32],
              [-38, 66],
              [23, -12],
              [39, -40],
              [36, -21],
              [15, 27],
              [9, 41],
              [25, 24],
              [20, -7]
            ],
            [
              [3095, 1968],
              [-25, 0],
              [-13, -14],
              [-25, -22],
              [-5, -55],
              [-11, -1],
              [-32, 19],
              [-32, 41],
              [-34, 34],
              [-9, 37],
              [8, 35],
              [-14, 39],
              [-4, 101],
              [12, 57],
              [30, 45],
              [-43, 18],
              [27, 52],
              [9, 98],
              [31, -21],
              [15, 123],
              [-19, 15],
              [-9, -73],
              [-17, 8],
              [9, 84],
              [9, 110],
              [13, 40],
              [-8, 58],
              [-2, 66],
              [11, 2],
              [17, 96],
              [20, 94],
              [11, 88],
              [-6, 89],
              [8, 49],
              [-3, 72],
              [16, 73],
              [5, 114],
              [9, 123],
              [9, 132],
              [-2, 96],
              [-6, 84]
            ],
            [
              [3045, 3974],
              [14, 15],
              [8, 30]
            ],
            [
              [8064, 6161],
              [-24, -28],
              [-23, 18],
              [0, 51],
              [13, 26],
              [31, 17],
              [16, -1],
              [6, -23],
              [-12, -26],
              [-7, -34]
            ],
            [
              [8628, 7562],
              [-18, 35],
              [-11, -33],
              [-43, -26],
              [4, -31],
              [-24, 2],
              [-13, 19],
              [-19, -42],
              [-30, -32],
              [-23, -38]
            ],
            [
              [8451, 7416],
              [-39, -17],
              [-20, -27],
              [-30, -17],
              [15, 28],
              [-6, 23],
              [22, 40],
              [-15, 30],
              [-24, -20],
              [-32, -41],
              [-17, -39],
              [-27, -2],
              [-14, -28],
              [15, -40],
              [22, -10],
              [1, -26],
              [22, -17],
              [31, 42],
              [25, -23],
              [18, -2],
              [4, -31],
              [-39, -16],
              [-13, -32],
              [-27, -30],
              [-14, -41],
              [30, -33],
              [11, -58],
              [17, -54],
              [18, -45],
              [0, -44],
              [-17, -16],
              [6, -32],
              [17, -18],
              [-5, -48],
              [-7, -47],
              [-15, -5],
              [-21, -64],
              [-22, -78],
              [-26, -70],
              [-38, -55],
              [-39, -50],
              [-31, -6],
              [-17, -27],
              [-10, 20],
              [-15, -30],
              [-39, -29],
              [-29, -9],
              [-10, -63],
              [-15, -3],
              [-8, 43],
              [7, 22],
              [-37, 19],
              [-13, -9]
            ],
            [
              [8001, 6331],
              [-28, 15],
              [-14, 24],
              [5, 34],
              [-26, 11],
              [-13, 22],
              [-24, -31],
              [-27, -7],
              [-22, 0],
              [-15, -14]
            ],
            [
              [7837, 6385],
              [-14, -9],
              [4, -68],
              [-15, 2],
              [-2, 14]
            ],
            [
              [7810, 6324],
              [-1, 24],
              [-20, -17],
              [-12, 11],
              [-21, 22],
              [8, 49],
              [-18, 12],
              [-6, 54],
              [-30, -10],
              [4, 70],
              [26, 50],
              [1, 48],
              [-1, 46],
              [-12, 14],
              [-9, 35],
              [-16, -5]
            ],
            [
              [7703, 6727],
              [-30, 9],
              [9, 25],
              [-13, 36],
              [-20, -24],
              [-23, 14],
              [-32, -37],
              [-25, -44],
              [-23, -8]
            ],
            [
              [7466, 6670],
              [-2, 47],
              [-17, -13]
            ],
            [
              [7447, 6704],
              [-32, 6],
              [-32, 14],
              [-22, 26],
              [-22, 11],
              [-9, 29],
              [-16, 8],
              [-28, 39],
              [-22, 18],
              [-12, -14]
            ],
            [
              [7252, 6841],
              [-38, 41],
              [-28, 37],
              [-7, 65],
              [20, -7],
              [1, 30],
              [-12, 30],
              [3, 48],
              [-30, 69]
            ],
            [
              [7161, 7154],
              [-45, 24],
              [-8, 46],
              [-21, 27]
            ],
            [
              [7082, 7268],
              [-4, 34],
              [1, 23],
              [-17, 13],
              [-9, -6],
              [-7, 55]
            ],
            [
              [7046, 7387],
              [8, 13],
              [-4, 14],
              [26, 28],
              [20, 12],
              [29, -8],
              [11, 38],
              [35, 7],
              [10, 23],
              [44, 32],
              [4, 13]
            ],
            [
              [7229, 7559],
              [-2, 34],
              [19, 15],
              [-25, 103],
              [55, 24],
              [14, 13],
              [20, 106],
              [55, -20],
              [15, 27],
              [2, 59],
              [23, 6],
              [21, 39]
            ],
            [
              [7426, 7965],
              [11, 5]
            ],
            [
              [7437, 7970],
              [7, -41],
              [23, -32],
              [40, -22],
              [19, -47],
              [-10, -70],
              [10, -25],
              [33, -10],
              [37, -8],
              [33, -37],
              [18, -7],
              [12, -54],
              [17, -35],
              [30, 1],
              [58, -13],
              [36, 8],
              [28, -9],
              [41, -36],
              [34, 0],
              [12, -18],
              [32, 32],
              [45, 20],
              [42, 2],
              [32, 21],
              [20, 32],
              [20, 20],
              [-5, 19],
              [-9, 23],
              [15, 38],
              [15, -5],
              [29, -12],
              [28, 31],
              [42, 23],
              [20, 39],
              [20, 17],
              [40, 8],
              [22, -7],
              [3, 21],
              [-25, 41],
              [-22, 19],
              [-22, -22],
              [-27, 10],
              [-16, -8],
              [-7, 24],
              [20, 59],
              [13, 45]
            ],
            [
              [8240, 8005],
              [34, -23],
              [39, 38],
              [-1, 26],
              [26, 62],
              [15, 19],
              [0, 33],
              [-16, 14],
              [23, 29],
              [35, 11],
              [37, 2],
              [41, -18],
              [25, -22],
              [17, -59],
              [10, -26],
              [10, -36],
              [10, -58],
              [49, -19],
              [32, -42],
              [12, -55],
              [42, 0],
              [24, 23],
              [46, 17],
              [-15, -53],
              [-11, -21],
              [-9, -65],
              [-19, -58],
              [-33, 11],
              [-24, -21],
              [7, -51],
              [-4, -69],
              [-14, -2],
              [0, -30]
            ],
            [
              [4920, 5353],
              [-12, -1],
              [-20, 12],
              [-18, -1],
              [-33, -10],
              [-19, -18],
              [-27, -21],
              [-6, 1]
            ],
            [
              [4785, 5315],
              [2, 49],
              [3, 7],
              [-1, 24],
              [-12, 24],
              [-8, 4],
              [-8, 17],
              [6, 26],
              [-3, 28],
              [1, 18]
            ],
            [
              [4765, 5512],
              [5, 0],
              [1, 25],
              [-2, 12],
              [3, 8],
              [10, 7],
              [-7, 47],
              [-6, 25],
              [2, 20],
              [5, 4]
            ],
            [
              [4776, 5660],
              [4, 6],
              [8, -9],
              [21, -1],
              [5, 18],
              [5, -1],
              [8, 6],
              [4, -25],
              [7, 7],
              [11, 9]
            ],
            [
              [4921, 5627],
              [7, -84],
              [-11, -50],
              [-8, -66],
              [12, -51],
              [-1, -23]
            ],
            [
              [5363, 5191],
              [-4, 4],
              [-16, -8],
              [-17, 8],
              [-13, -4]
            ],
            [
              [5313, 5191],
              [-45, 1]
            ],
            [
              [5268, 5192],
              [4, 47],
              [-11, 39],
              [-13, 10],
              [-6, 27],
              [-7, 8],
              [1, 16]
            ],
            [
              [5236, 5339],
              [7, 42],
              [13, 57],
              [8, 1],
              [17, 34],
              [10, 1],
              [16, -24],
              [19, 20],
              [2, 25],
              [7, 23],
              [4, 30],
              [15, 25],
              [5, 41],
              [6, 13],
              [4, 31],
              [7, 37],
              [24, 46],
              [1, 20],
              [3, 10],
              [-11, 24]
            ],
            [
              [5393, 5795],
              [1, 19],
              [8, 3]
            ],
            [
              [5402, 5817],
              [11, -38],
              [2, -39],
              [-1, -39],
              [15, -54],
              [-15, 1],
              [-8, -4],
              [-13, 6],
              [-6, -28],
              [16, -35],
              [13, -10],
              [3, -24],
              [9, -41],
              [-4, -16]
            ],
            [
              [5444, 5191],
              [-2, -31],
              [-22, 14],
              [-22, 15],
              [-35, 2]
            ],
            [
              [5856, 5265],
              [-2, -69],
              [11, -8],
              [-9, -21],
              [-10, -16],
              [-11, -31],
              [-6, -27],
              [-1, -48],
              [-7, -22],
              [0, -45]
            ],
            [
              [5821, 4978],
              [-8, -16],
              [-1, -35],
              [-4, -5],
              [-2, -32]
            ],
            [
              [5814, 4792],
              [5, -55],
              [-2, -30],
              [5, -35],
              [16, -33],
              [15, -74]
            ],
            [
              [5853, 4565],
              [-11, 6],
              [-37, -10],
              [-7, -7],
              [-8, -38],
              [6, -26],
              [-5, -70],
              [-3, -59],
              [7, -11],
              [19, -23],
              [8, 11],
              [2, -64],
              [-21, 1],
              [-11, 32],
              [-10, 25],
              [-22, 9],
              [-6, 31],
              [-17, -19],
              [-22, 8],
              [-10, 27],
              [-17, 6],
              [-13, -2],
              [-2, 19],
              [-9, 1]
            ],
            [
              [5342, 4697],
              [-4, 18]
            ],
            [
              [5360, 4775],
              [8, -6],
              [9, 23],
              [15, -1],
              [2, -17],
              [11, -10],
              [16, 37],
              [16, 29],
              [7, 19],
              [-1, 48],
              [12, 58],
              [13, 30],
              [18, 29],
              [3, 18],
              [1, 22],
              [5, 21],
              [-2, 33],
              [4, 52],
              [5, 37],
              [8, 32],
              [2, 36]
            ],
            [
              [5760, 5367],
              [17, -49],
              [12, -7],
              [8, 10],
              [12, -4],
              [16, 12],
              [6, -25],
              [25, -39]
            ],
            [
              [5330, 4760],
              [-22, 62]
            ],
            [
              [5308, 4822],
              [21, 33],
              [-11, 39],
              [10, 15],
              [19, 7],
              [2, 26],
              [15, -28],
              [24, -2],
              [9, 27],
              [3, 40],
              [-3, 46],
              [-13, 35],
              [12, 68],
              [-7, 12],
              [-21, -5],
              [-7, 31],
              [2, 25]
            ],
            [
              [2906, 5049],
              [-12, 14],
              [-14, 19],
              [-7, -9],
              [-24, 8],
              [-7, 25],
              [-5, -1],
              [-28, 34]
            ],
            [
              [2809, 5139],
              [-3, 18],
              [10, 5],
              [-1, 29],
              [6, 22],
              [14, 4],
              [12, 37],
              [10, 31],
              [-10, 14],
              [5, 34],
              [-6, 54],
              [6, 16],
              [-4, 50],
              [-12, 31]
            ],
            [
              [2836, 5484],
              [4, 29],
              [9, -4],
              [5, 17],
              [-6, 35],
              [3, 9]
            ],
            [
              [2851, 5570],
              [14, -2],
              [21, 41],
              [12, 6],
              [0, 20],
              [5, 50],
              [16, 27],
              [17, 1],
              [3, 13],
              [21, -5],
              [22, 30],
              [11, 13],
              [14, 28],
              [9, -3],
              [8, -16],
              [-6, -20]
            ],
            [
              [3018, 5753],
              [-18, -10],
              [-7, -29],
              [-10, -17],
              [-8, -22],
              [-4, -42],
              [-8, -35],
              [15, -4],
              [3, -27],
              [6, -13],
              [3, -24],
              [-4, -22],
              [1, -12],
              [7, -5],
              [7, -20],
              [36, 5],
              [16, -7],
              [19, -51],
              [11, 6],
              [20, -3],
              [16, 7],
              [10, -10],
              [-5, -32],
              [-6, -20],
              [-2, -42],
              [5, -40],
              [8, -17],
              [1, -13],
              [-14, -30],
              [10, -13],
              [8, -21],
              [8, -58]
            ],
            [
              [3058, 4804],
              [-14, 31],
              [-8, 1],
              [18, 61],
              [-21, 27],
              [-17, -5],
              [-10, 10],
              [-15, -15],
              [-21, 7],
              [-16, 62],
              [-13, 15],
              [-9, 28],
              [-19, 28],
              [-7, -5]
            ],
            [
              [2695, 5543],
              [-15, 14],
              [-6, 12],
              [4, 10],
              [-1, 13],
              [-8, 14],
              [-11, 12],
              [-10, 8],
              [-1, 17],
              [-8, 10],
              [2, -17],
              [-5, -14],
              [-7, 17],
              [-9, 5],
              [-4, 12],
              [1, 18],
              [3, 19],
              [-8, 8],
              [7, 12]
            ],
            [
              [2619, 5713],
              [4, 7],
              [18, -15],
              [7, 7],
              [9, -5],
              [4, -12],
              [8, -4],
              [7, 13]
            ],
            [
              [2676, 5704],
              [7, -32],
              [11, -24],
              [13, -25]
            ],
            [
              [2707, 5623],
              [-11, -6],
              [0, -23],
              [6, -9],
              [-4, -7],
              [1, -11],
              [-2, -12],
              [-2, -12]
            ],
            [
              [2715, 6427],
              [23, -4],
              [22, 0],
              [26, -21],
              [11, -21],
              [26, 6],
              [10, -13],
              [24, -37],
              [17, -27],
              [9, 1],
              [17, -12],
              [-2, -17],
              [20, -2],
              [21, -24],
              [-3, -14],
              [-19, -7],
              [-18, -3],
              [-19, 4],
              [-40, -5],
              [18, 32],
              [-11, 16],
              [-18, 4],
              [-9, 17],
              [-7, 33],
              [-16, -2],
              [-26, 16],
              [-8, 12],
              [-36, 10],
              [-10, 11],
              [11, 15],
              [-28, 3],
              [-20, -31],
              [-11, -1],
              [-4, -14],
              [-14, -7],
              [-12, 6],
              [15, 18],
              [6, 22],
              [13, 13],
              [14, 11],
              [21, 6],
              [7, 6]
            ],
            [
              [5909, 7133],
              [2, 1],
              [4, 14],
              [20, -1],
              [25, 18],
              [-19, -25],
              [2, -11]
            ],
            [
              [5943, 7129],
              [-3, 2],
              [-5, -5],
              [-4, 1],
              [-2, -2],
              [0, 6],
              [-2, 4],
              [-6, 0],
              [-7, -5],
              [-5, 3]
            ],
            [
              [5943, 7129],
              [1, -5],
              [-28, -24],
              [-14, 8],
              [-7, 23],
              [14, 2]
            ],
            [
              [5377, 7945],
              [-16, 25],
              [-14, 15],
              [-3, 25],
              [-5, 17],
              [21, 13],
              [10, 15],
              [20, 11],
              [7, 11],
              [7, -6],
              [13, 6]
            ],
            [
              [5417, 8077],
              [13, -19],
              [21, -5],
              [-2, -17],
              [15, -12],
              [4, 15],
              [19, -6],
              [3, -19],
              [20, -3],
              [13, -29]
            ],
            [
              [5523, 7982],
              [-8, 0],
              [-4, -11],
              [-7, -3],
              [-2, -13],
              [-5, -3],
              [-1, -5],
              [-9, -7],
              [-12, 1],
              [-4, -13]
            ],
            [
              [5275, 8306],
              [1, -23],
              [28, -14],
              [-1, -21],
              [29, 11],
              [15, 16],
              [32, -23],
              [13, -19]
            ],
            [
              [5392, 8233],
              [6, -30],
              [-8, -16],
              [11, -21],
              [6, -31],
              [-2, -21],
              [12, -37]
            ],
            [
              [5207, 7871],
              [3, 42],
              [14, 40],
              [-40, 11],
              [-13, 16]
            ],
            [
              [5171, 7980],
              [2, 26],
              [-6, 13]
            ],
            [
              [5171, 8059],
              [-5, 62],
              [17, 0],
              [7, 22],
              [6, 54],
              [-5, 20]
            ],
            [
              [5191, 8217],
              [6, 13],
              [23, 3],
              [5, -13],
              [19, 29],
              [-6, 22],
              [-2, 34]
            ],
            [
              [5236, 8305],
              [21, -8],
              [18, 9]
            ],
            [
              [6196, 5808],
              [7, -19],
              [-1, -24],
              [-16, -14],
              [12, -16]
            ],
            [
              [6198, 5735],
              [-10, -32]
            ],
            [
              [6188, 5703],
              [-7, 11],
              [-6, -5],
              [-16, 1],
              [0, 18],
              [-2, 17],
              [9, 27],
              [10, 26]
            ],
            [
              [6176, 5798],
              [12, -5],
              [8, 15]
            ],
            [
              [5352, 8343],
              [-17, -48],
              [-29, 33],
              [-4, 25],
              [41, 19],
              [9, -29]
            ],
            [
              [5236, 8305],
              [-11, 32],
              [-1, 61],
              [5, 16],
              [8, 17],
              [24, 4],
              [10, 16],
              [22, 17],
              [-1, -30],
              [-8, -20],
              [4, -16],
              [15, -9],
              [-7, -22],
              [-8, 6],
              [-20, -42],
              [7, -29]
            ],
            [
              [3008, 6222],
              [3, 10],
              [22, 0],
              [16, -15],
              [8, 1],
              [5, -21],
              [15, 1],
              [-1, -17],
              [12, -2],
              [14, -22],
              [-10, -24],
              [-14, 13],
              [-12, -3],
              [-9, 3],
              [-5, -11],
              [-11, -3],
              [-4, 14],
              [-10, -8],
              [-11, -41],
              [-7, 10],
              [-1, 17]
            ],
            [
              [3008, 6124],
              [0, 16],
              [-7, 17],
              [7, 10],
              [2, 23],
              [-2, 32]
            ],
            [
              [5333, 6444],
              [-95, -112],
              [-81, -117],
              [-39, -26]
            ],
            [
              [5118, 6189],
              [-31, -6],
              [0, 38],
              [-13, 10],
              [-17, 16],
              [-7, 28],
              [-94, 129],
              [-93, 129]
            ],
            [
              [4863, 6533],
              [-105, 143]
            ],
            [
              [4758, 6676],
              [1, 11],
              [0, 4]
            ],
            [
              [4759, 6691],
              [0, 70],
              [44, 44],
              [28, 9],
              [23, 16],
              [11, 29],
              [32, 24],
              [1, 44],
              [16, 5],
              [13, 22],
              [36, 9],
              [5, 23],
              [-7, 13],
              [-10, 62],
              [-1, 36],
              [-11, 38]
            ],
            [
              [4939, 7135],
              [27, 32],
              [30, 11],
              [17, 24],
              [27, 18],
              [47, 11],
              [46, 4],
              [14, -8],
              [26, 23],
              [30, 0],
              [11, -13],
              [19, 3]
            ],
            [
              [5233, 7240],
              [-5, -30],
              [4, -56],
              [-6, -49],
              [-18, -33],
              [3, -45],
              [23, -35],
              [0, -14],
              [17, -24],
              [12, -106]
            ],
            [
              [5263, 6848],
              [9, -52],
              [1, -28],
              [-5, -48],
              [2, -27],
              [-3, -32],
              [2, -37],
              [-11, -25],
              [17, -43],
              [1, -25],
              [10, -33],
              [13, 11],
              [22, -28],
              [12, -37]
            ],
            [
              [2769, 4856],
              [15, 45],
              [-6, 25],
              [-11, -27],
              [-16, 26],
              [5, 16],
              [-4, 54],
              [9, 9],
              [5, 37],
              [11, 38],
              [-2, 24],
              [15, 13],
              [19, 23]
            ],
            [
              [2906, 5049],
              [4, -45],
              [-9, -39],
              [-30, -62],
              [-33, -23],
              [-17, -51],
              [-6, -40],
              [-15, -24],
              [-12, 29],
              [-11, 7],
              [-12, -5],
              [-1, 22],
              [8, 14],
              [-3, 24]
            ],
            [
              [5969, 6800],
              [-7, -23],
              [-6, -45],
              [-8, -31],
              [-6, -10],
              [-10, 19],
              [-12, 26],
              [-20, 85],
              [-3, -5],
              [12, -63],
              [17, -59],
              [21, -92],
              [10, -32],
              [9, -34],
              [25, -65],
              [-6, -10],
              [1, -39],
              [33, -53],
              [4, -12]
            ],
            [
              [6023, 6357],
              [-110, 0],
              [-107, 0],
              [-112, 0]
            ],
            [
              [5694, 6357],
              [0, 218],
              [0, 210],
              [-8, 47],
              [7, 37],
              [-5, 25],
              [10, 29]
            ],
            [
              [5698, 6923],
              [37, 0],
              [27, -15],
              [28, -18],
              [13, -9],
              [21, 19],
              [11, 17],
              [25, 5],
              [20, -8],
              [7, -29],
              [7, 19],
              [22, -14],
              [22, -3],
              [13, 15]
            ],
            [
              [5951, 6902],
              [18, -102]
            ],
            [
              [6176, 5798],
              [-10, 20],
              [-11, 34],
              [-12, 19],
              [-8, 21],
              [-24, 23],
              [-19, 1],
              [-7, 12],
              [-16, -14],
              [-17, 27],
              [-8, -44],
              [-33, 13]
            ],
            [
              [6011, 5910],
              [-3, 23],
              [12, 87],
              [3, 39],
              [9, 18],
              [20, 10],
              [14, 34]
            ],
            [
              [6066, 6121],
              [16, -69],
              [8, -54],
              [15, -29],
              [38, -55],
              [16, -34],
              [15, -34],
              [8, -20],
              [14, -18]
            ],
            [
              [4749, 7532],
              [1, 42],
              [-11, 25],
              [39, 43],
              [34, -11],
              [37, 1],
              [30, -10],
              [23, 3],
              [45, -2]
            ],
            [
              [4947, 7623],
              [11, -23],
              [51, -27],
              [10, 13],
              [31, -27],
              [32, 8]
            ],
            [
              [5082, 7567],
              [2, -35],
              [-26, -39],
              [-36, -12],
              [-2, -20],
              [-18, -33],
              [-10, -48],
              [11, -34],
              [-16, -26],
              [-6, -39],
              [-21, -11],
              [-20, -46],
              [-35, -1],
              [-27, 1],
              [-17, -21],
              [-11, -22],
              [-13, 5],
              [-11, 20],
              [-8, 34],
              [-26, 9]
            ],
            [
              [4792, 7249],
              [-2, 20],
              [10, 22],
              [4, 16],
              [-9, 17],
              [7, 39],
              [-11, 36],
              [12, 5],
              [1, 27],
              [5, 9],
              [0, 46],
              [13, 16],
              [-8, 30],
              [-16, 2],
              [-5, -8],
              [-16, 0],
              [-7, 29],
              [-11, -8],
              [-10, -15]
            ],
            [
              [5675, 8472],
              [3, 35],
              [-10, -8],
              [-18, 21],
              [-2, 34],
              [35, 17],
              [35, 8],
              [30, -10],
              [29, 2]
            ],
            [
              [5777, 8571],
              [4, -10],
              [-20, -34],
              [8, -55],
              [-12, -19]
            ],
            [
              [5757, 8453],
              [-22, 0],
              [-24, 22],
              [-13, 7],
              [-23, -10]
            ],
            [
              [6188, 5703],
              [-6, -21],
              [10, -32],
              [10, -29],
              [11, -21],
              [90, -70],
              [24, 0]
            ],
            [
              [6327, 5530],
              [-79, -177],
              [-36, -3],
              [-25, -41],
              [-17, -1],
              [-8, -19]
            ],
            [
              [6162, 5289],
              [-19, 0],
              [-11, 20],
              [-26, -25],
              [-8, -24],
              [-18, 4],
              [-6, 7],
              [-7, -1],
              [-9, 0],
              [-35, 50],
              [-19, 0],
              [-10, 20],
              [0, 33],
              [-14, 10]
            ],
            [
              [5980, 5383],
              [-17, 64],
              [-12, 14],
              [-5, 23],
              [-14, 29],
              [-17, 4],
              [9, 34],
              [15, 2],
              [4, 18]
            ],
            [
              [5943, 5571],
              [0, 53]
            ],
            [
              [5943, 5624],
              [8, 62],
              [13, 16],
              [3, 24],
              [12, 45],
              [17, 30],
              [11, 58],
              [4, 51]
            ],
            [
              [5794, 9138],
              [-4, -42],
              [42, -39],
              [-26, -45],
              [33, -67],
              [-19, -51],
              [25, -43],
              [-11, -39],
              [41, -40],
              [-11, -31],
              [-25, -34],
              [-60, -75]
            ],
            [
              [5779, 8632],
              [-50, -5],
              [-49, -21],
              [-45, -13],
              [-16, 32],
              [-27, 20],
              [6, 58],
              [-14, 53],
              [14, 35],
              [25, 37],
              [63, 64],
              [19, 12],
              [-3, 25],
              [-39, 28]
            ],
            [
              [5663, 8957],
              [-9, 23],
              [-1, 91],
              [-43, 40],
              [-37, 29]
            ],
            [
              [5573, 9140],
              [17, 16],
              [30, -32],
              [37, 3],
              [30, -14],
              [26, 26],
              [14, 44],
              [43, 20],
              [35, -24],
              [-11, -41]
            ],
            [
              [9954, 4033],
              [9, -17],
              [-4, -31],
              [-17, -8],
              [-16, 7],
              [-2, 26],
              [10, 21],
              [13, -8],
              [7, 10]
            ],
            [
              [0, 4079],
              [9981, -14],
              [-17, -13],
              [-4, 23],
              [14, 12],
              [9, 3],
              [-9983, 18]
            ],
            [
              [0, 4108],
              [0, -29]
            ],
            [
              [0, 4108],
              [6, 3],
              [-4, -28],
              [-2, -4]
            ],
            [
              [3300, 1994],
              [33, 36],
              [24, -15],
              [16, 24],
              [22, -27],
              [-8, -21],
              [-37, -17],
              [-13, 20],
              [-23, -26],
              [-14, 26]
            ],
            [
              [5265, 7548],
              [-9, -46],
              [-13, 12],
              [-6, 40],
              [5, 22],
              [18, 22],
              [5, -50]
            ],
            [
              [5157, 7984],
              [6, -6],
              [8, 2]
            ],
            [
              [5190, 7775],
              [-2, -17],
              [9, -22],
              [-10, -18],
              [7, -46],
              [15, -8],
              [-3, -25]
            ],
            [
              [5206, 7639],
              [-25, -34],
              [-55, 16],
              [-40, -19],
              [-4, -35]
            ],
            [
              [4947, 7623],
              [14, 35],
              [5, 118],
              [-28, 62],
              [-21, 30],
              [-42, 23],
              [-3, 43],
              [36, 12],
              [47, -15],
              [-9, 67],
              [26, -25],
              [65, 46],
              [8, 48],
              [24, 12]
            ],
            [
              [3485, 5194],
              [7, 25],
              [3, 27]
            ],
            [
              [3495, 5246],
              [4, 26],
              [-10, 34]
            ],
            [
              [3489, 5306],
              [-3, 41],
              [15, 51]
            ],
            [
              [3501, 5398],
              [9, -7],
              [21, -14],
              [29, -50],
              [5, -24]
            ],
            [
              [5308, 4822],
              [-29, 60],
              [-18, 49],
              [-17, 61],
              [1, 19],
              [6, 19],
              [7, 43],
              [5, 44]
            ],
            [
              [5263, 5117],
              [10, 4],
              [40, -1],
              [0, 71]
            ],
            [
              [4827, 8240],
              [-21, 12],
              [-17, -1],
              [6, 32],
              [-6, 32]
            ],
            [
              [4789, 8315],
              [23, 2],
              [30, -37],
              [-15, -40]
            ],
            [
              [4916, 8521],
              [-30, -63],
              [29, 8],
              [30, -1],
              [-7, -48],
              [-25, -53],
              [29, -4],
              [2, -6],
              [25, -69],
              [19, -10],
              [17, -67],
              [8, -24],
              [33, -11],
              [-3, -38],
              [-14, -17],
              [11, -30],
              [-25, -31],
              [-37, 0],
              [-48, -16],
              [-13, 12],
              [-18, -28],
              [-26, 7],
              [-19, -23],
              [-15, 12],
              [41, 62],
              [25, 13],
              [-1, 0],
              [-43, 9],
              [-8, 24],
              [29, 18],
              [-15, 32],
              [5, 39],
              [42, -6],
              [4, 35],
              [-19, 36],
              [0, 1],
              [-34, 10],
              [-7, 16],
              [10, 27],
              [-9, 16],
              [-15, -28],
              [-1, 57],
              [-14, 30],
              [10, 61],
              [21, 48],
              [23, -4],
              [33, 4]
            ],
            [
              [6154, 7511],
              [4, 26],
              [-7, 40],
              [-16, 22],
              [-16, 6],
              [-10, 19]
            ],
            [
              [6109, 7624],
              [4, 6],
              [23, -10],
              [41, -9],
              [38, -28],
              [5, -11],
              [17, 9],
              [25, -13],
              [9, -24],
              [17, -13]
            ],
            [
              [6210, 7485],
              [-27, 29],
              [-29, -3]
            ],
            [
              [5029, 5408],
              [-44, -35],
              [-15, -20],
              [-25, -17],
              [-25, 17]
            ],
            [
              [5e3, 5708],
              [-2, -18],
              [12, -30],
              [0, -43],
              [2, -47],
              [7, -21],
              [-6, -54],
              [2, -29],
              [8, -37],
              [6, -21]
            ],
            [
              [4765, 5512],
              [-8, 1],
              [-5, -24],
              [-8, 1],
              [-6, 12],
              [2, 24],
              [-11, 36],
              [-8, -7],
              [-6, -1]
            ],
            [
              [4715, 5554],
              [-7, -3],
              [0, 21],
              [-4, 16],
              [0, 17],
              [-6, 25],
              [-7, 21],
              [-23, 0],
              [-6, -11],
              [-8, -1],
              [-4, -13],
              [-4, -17],
              [-14, -26]
            ],
            [
              [4632, 5583],
              [-13, 35],
              [-10, 24],
              [-8, 7],
              [-6, 12],
              [-4, 26],
              [-4, 13],
              [-8, 10]
            ],
            [
              [4579, 5710],
              [13, 29],
              [8, -2],
              [7, 10],
              [6, 0],
              [5, 8],
              [-3, 20],
              [3, 6],
              [1, 20]
            ],
            [
              [4619, 5801],
              [13, -1],
              [20, -14],
              [6, 1],
              [3, 7],
              [15, -5],
              [4, 4]
            ],
            [
              [4680, 5793],
              [1, -22],
              [5, 0],
              [7, 8],
              [5, -2],
              [7, -15],
              [12, -5],
              [8, 13],
              [9, 8],
              [6, 8],
              [6, -1],
              [6, -13],
              [3, -17],
              [12, -24],
              [-6, -16],
              [-1, -19],
              [6, 6],
              [3, -7],
              [-1, -17],
              [8, -18]
            ],
            [
              [4532, 5834],
              [3, 27]
            ],
            [
              [4535, 5861],
              [31, 1],
              [6, 14],
              [9, 1],
              [11, -14],
              [8, -1],
              [9, 10],
              [6, -17],
              [-12, -13],
              [-12, 1],
              [-12, 13],
              [-10, -14],
              [-5, -1],
              [-7, -8],
              [-25, 1]
            ],
            [
              [4579, 5710],
              [-15, 24],
              [-11, 4],
              [-7, 17],
              [1, 9],
              [-9, 13],
              [-2, 12]
            ],
            [
              [4536, 5789],
              [15, 10],
              [9, -2],
              [8, 7],
              [51, -3]
            ],
            [
              [5263, 5117],
              [-5, 9],
              [10, 66]
            ],
            [
              [5658, 7167],
              [15, -20],
              [22, 3],
              [20, -4],
              [0, -10],
              [15, 7],
              [-4, -18],
              [-40, -5],
              [1, 10],
              [-34, 12],
              [5, 25]
            ],
            [
              [5723, 7469],
              [-17, 2],
              [-14, 6],
              [-34, -16],
              [19, -33],
              [-14, -10],
              [-15, 0],
              [-15, 31],
              [-5, -13],
              [6, -36],
              [14, -27],
              [-10, -13],
              [15, -27],
              [14, -18],
              [0, -33],
              [-25, 16],
              [8, -30],
              [-18, -7],
              [11, -52],
              [-19, -1],
              [-23, 26],
              [-10, 47],
              [-5, 40],
              [-11, 27],
              [-14, 34],
              [-2, 16]
            ],
            [
              [5583, 7470],
              [18, 6],
              [11, 13],
              [15, -2],
              [5, 11],
              [5, 2]
            ],
            [
              [5725, 7529],
              [13, -16],
              [-8, -37],
              [-7, -7]
            ],
            [
              [3701, 9939],
              [93, 35],
              [97, -2],
              [36, 21],
              [98, 6],
              [222, -7],
              [174, -47],
              [-52, -23],
              [-106, -3],
              [-150, -5],
              [14, -11],
              [99, 7],
              [83, -21],
              [54, 18],
              [23, -21],
              [-30, -34],
              [71, 22],
              [135, 23],
              [83, -12],
              [15, -25],
              [-113, -42],
              [-16, -14],
              [-88, -10],
              [64, -3],
              [-32, -43],
              [-23, -38],
              [1, -66],
              [33, -38],
              [-43, -3],
              [-46, -19],
              [52, -31],
              [6, -50],
              [-30, -6],
              [36, -50],
              [-61, -5],
              [32, -24],
              [-9, -20],
              [-39, -10],
              [-39, 0],
              [35, -40],
              [0, -26],
              [-55, 24],
              [-14, -15],
              [37, -15],
              [37, -36],
              [10, -48],
              [-49, -11],
              [-22, 22],
              [-34, 34],
              [10, -40],
              [-33, -31],
              [73, -2],
              [39, -3],
              [-75, -52],
              [-75, -46],
              [-81, -21],
              [-31, 0],
              [-29, -23],
              [-38, -62],
              [-60, -42],
              [-19, -2],
              [-37, -15],
              [-40, -13],
              [-24, -37],
              [0, -41],
              [-15, -39],
              [-45, -47],
              [11, -47],
              [-12, -48],
              [-14, -58],
              [-39, -4],
              [-41, 49],
              [-56, 0],
              [-27, 32],
              [-18, 58],
              [-49, 73],
              [-14, 39],
              [-3, 53],
              [-39, 54],
              [10, 44],
              [-18, 21],
              [27, 69],
              [42, 22],
              [11, 25],
              [6, 46],
              [-32, -21],
              [-15, -9],
              [-25, -8],
              [-34, 19],
              [-2, 40],
              [11, 31],
              [25, 1],
              [57, -15],
              [-48, 37],
              [-24, 20],
              [-28, -8],
              [-23, 15],
              [31, 55],
              [-17, 22],
              [-22, 41],
              [-34, 62],
              [-35, 23],
              [0, 25],
              [-74, 34],
              [-59, 5],
              [-74, -3],
              [-68, -4],
              [-32, 19],
              [-49, 37],
              [73, 19],
              [56, 3],
              [-119, 15],
              [-62, 24],
              [3, 23],
              [106, 28],
              [101, 29],
              [11, 21],
              [-75, 22],
              [24, 23],
              [97, 41],
              [40, 7],
              [-12, 26],
              [66, 16],
              [86, 9],
              [85, 1],
              [30, -19],
              [74, 33],
              [66, -22],
              [39, -5],
              [58, -19],
              [-66, 32],
              [4, 25]
            ],
            [
              [2497, 5869],
              [-14, 10],
              [-17, 1],
              [-13, 12],
              [-15, 24]
            ],
            [
              [2438, 5916],
              [1, 18],
              [3, 13],
              [-4, 12],
              [13, 48],
              [36, 0],
              [1, 20],
              [-5, 4],
              [-3, 12],
              [-10, 14],
              [-11, 20],
              [13, 0],
              [0, 33],
              [26, 0],
              [26, 0]
            ],
            [
              [2529, 5996],
              [10, -11],
              [2, 9],
              [8, -7]
            ],
            [
              [2549, 5987],
              [-13, -23],
              [-13, -16],
              [-2, -12],
              [2, -11],
              [-5, -15]
            ],
            [
              [2518, 5910],
              [-7, -4],
              [2, -7],
              [-6, -6],
              [-9, -15],
              [-1, -9]
            ],
            [
              [3340, 5552],
              [18, -22],
              [17, -38],
              [1, -31],
              [10, -1],
              [15, -29],
              [11, -21]
            ],
            [
              [3412, 5410],
              [-4, -53],
              [-17, -15],
              [1, -14],
              [-5, -31],
              [13, -42],
              [9, -1],
              [3, -33],
              [17, -51]
            ],
            [
              [3313, 5365],
              [-19, 45],
              [7, 16],
              [0, 27],
              [17, 10],
              [7, 11],
              [-10, 22],
              [3, 21],
              [22, 35]
            ],
            [
              [2574, 5825],
              [-5, 18],
              [-8, 5]
            ],
            [
              [2561, 5848],
              [2, 24],
              [-4, 6],
              [-6, 4],
              [-12, -7],
              [-1, 8],
              [-8, 10],
              [-6, 12],
              [-8, 5]
            ],
            [
              [2549, 5987],
              [3, -3],
              [6, 11],
              [8, 1],
              [3, -5],
              [4, 3],
              [13, -6],
              [13, 2],
              [9, 6],
              [3, 7],
              [9, -3],
              [6, -4],
              [8, 1],
              [5, 5],
              [13, -8],
              [4, -1],
              [9, -11],
              [8, -13],
              [10, -9],
              [7, -17]
            ],
            [
              [2690, 5943],
              [-9, 2],
              [-4, -8],
              [-10, -8],
              [-7, 0],
              [-6, -8],
              [-6, 3],
              [-4, 9],
              [-3, -2],
              [-4, -14],
              [-3, 1],
              [0, -12],
              [-10, -17],
              [-5, -7],
              [-3, -7],
              [-8, 12],
              [-6, -16],
              [-6, 1],
              [-6, -2],
              [0, -29],
              [-4, 0],
              [-3, -14],
              [-9, -2]
            ],
            [
              [5522, 7770],
              [7, -23],
              [9, -17],
              [-11, -22]
            ],
            [
              [5515, 7577],
              [-3, -10]
            ],
            [
              [5512, 7567],
              [-26, 22],
              [-16, 21],
              [-26, 18],
              [-23, 43],
              [6, 5],
              [-13, 25],
              [-1, 19],
              [-17, 10],
              [-9, -26],
              [-8, 20],
              [0, 21],
              [1, 1]
            ],
            [
              [5380, 7746],
              [20, -2],
              [5, 9],
              [9, -9],
              [11, -1],
              [0, 16],
              [10, 6],
              [2, 24],
              [23, 16]
            ],
            [
              [5460, 7805],
              [8, -7],
              [21, -26],
              [23, -11],
              [10, 9]
            ],
            [
              [3008, 6124],
              [-19, 10],
              [-13, -5],
              [-17, 5],
              [-13, -11],
              [-15, 18],
              [3, 19],
              [25, -8],
              [21, -5],
              [10, 13],
              [-12, 26],
              [0, 23],
              [-18, 9],
              [7, 16],
              [17, -3],
              [24, -9]
            ],
            [
              [5471, 7900],
              [14, -15],
              [10, -6],
              [24, 7],
              [2, 12],
              [11, 2],
              [14, 9],
              [3, -4],
              [13, 8],
              [6, 13],
              [9, 4],
              [30, -18],
              [6, 6]
            ],
            [
              [5613, 7918],
              [15, -16],
              [2, -16]
            ],
            [
              [5630, 7886],
              [-17, -12],
              [-13, -40],
              [-17, -40],
              [-22, -11]
            ],
            [
              [5561, 7783],
              [-17, 2],
              [-22, -15]
            ],
            [
              [5460, 7805],
              [-6, 20],
              [-4, 0]
            ],
            [
              [8352, 4453],
              [-11, -2],
              [-37, 42],
              [26, 11],
              [14, -18],
              [10, -17],
              [-2, -16]
            ],
            [
              [8471, 4532],
              [2, -11],
              [1, -18]
            ],
            [
              [8474, 4503],
              [-18, -45],
              [-24, -13],
              [-3, 8],
              [2, 20],
              [12, 36],
              [28, 23]
            ],
            [
              [8274, 4579],
              [10, -16],
              [17, 5],
              [7, -25],
              [-32, -12],
              [-19, -8],
              [-15, 1],
              [10, 34],
              [15, 0],
              [7, 21]
            ],
            [
              [8413, 4579],
              [-4, -32],
              [-42, -17],
              [-37, 7],
              [0, 22],
              [22, 12],
              [18, -18],
              [18, 5],
              [25, 21]
            ],
            [
              [8017, 4657],
              [53, -6],
              [6, 25],
              [51, -29],
              [10, -38],
              [42, -11],
              [34, -35],
              [-31, -23],
              [-31, 24],
              [-25, -1],
              [-29, 4],
              [-26, 11],
              [-32, 22],
              [-21, 6],
              [-11, -7],
              [-51, 24],
              [-5, 25],
              [-25, 5],
              [19, 56],
              [34, -3],
              [22, -23],
              [12, -5],
              [4, -21]
            ],
            [
              [8741, 4690],
              [-14, -40],
              [-3, 45],
              [5, 21],
              [6, 20],
              [7, -17],
              [-1, -29]
            ],
            [
              [8534, 4853],
              [-11, -19],
              [-19, 10],
              [-5, 26],
              [28, 3],
              [7, -20]
            ],
            [
              [8623, 4875],
              [10, -45],
              [-23, 24],
              [-23, 5],
              [-16, -4],
              [-19, 2],
              [6, 33],
              [35, 2],
              [30, -17]
            ],
            [
              [8916, 4904],
              [0, -193],
              [1, -192]
            ],
            [
              [8917, 4519],
              [-25, 48],
              [-28, 12],
              [-7, -17],
              [-35, -1],
              [12, 48],
              [17, 16],
              [-7, 64],
              [-14, 50],
              [-53, 50],
              [-23, 5],
              [-42, 54],
              [-8, -28],
              [-11, -5],
              [-6, 21],
              [0, 26],
              [-21, 29],
              [29, 21],
              [20, -1],
              [-2, 16],
              [-41, 0],
              [-11, 35],
              [-25, 11],
              [-11, 29],
              [37, 14],
              [14, 20],
              [45, -25],
              [4, -22],
              [8, -95],
              [29, -35],
              [23, 62],
              [32, 36],
              [25, 0],
              [23, -21],
              [21, -21],
              [30, -11]
            ],
            [
              [8478, 5141],
              [-22, -58],
              [-21, -12],
              [-27, 12],
              [-46, -3],
              [-24, -8],
              [-4, -45],
              [24, -53],
              [15, 27],
              [52, 20],
              [-2, -27],
              [-12, 9],
              [-12, -35],
              [-25, -23],
              [27, -76],
              [-5, -20],
              [25, -68],
              [-1, -39],
              [-14, -17],
              [-11, 20],
              [13, 49],
              [-27, -23],
              [-7, 16],
              [3, 23],
              [-20, 35],
              [3, 57],
              [-19, -18],
              [2, -69],
              [1, -84],
              [-17, -9],
              [-12, 18],
              [8, 54],
              [-4, 57],
              [-12, 1],
              [-9, 40],
              [12, 39],
              [4, 47],
              [14, 89],
              [5, 24],
              [24, 44],
              [22, -18],
              [35, -8],
              [32, 3],
              [27, 43],
              [5, -14]
            ],
            [
              [8574, 5124],
              [-2, -51],
              [-14, 6],
              [-4, -36],
              [11, -32],
              [-8, -7],
              [-11, 38],
              [-8, 75],
              [6, 47],
              [9, 22],
              [2, -32],
              [16, -5],
              [3, -25]
            ],
            [
              [8045, 5176],
              [5, -39],
              [19, -34],
              [18, 12],
              [18, -4],
              [16, 30],
              [13, 5],
              [26, -17],
              [23, 13],
              [14, 82],
              [11, 21],
              [10, 67],
              [32, 0],
              [24, -10]
            ],
            [
              [8274, 5302],
              [-16, -53],
              [20, -56],
              [-5, -28],
              [32, -54],
              [-33, -7],
              [-10, -40],
              [2, -54],
              [-27, -40],
              [-1, -59],
              [-10, -91],
              [-5, 21],
              [-31, -26],
              [-11, 36],
              [-20, 3],
              [-14, 19],
              [-33, -21],
              [-10, 29],
              [-18, -4],
              [-23, 7],
              [-4, 79],
              [-14, 17],
              [-13, 50],
              [-4, 52],
              [3, 55],
              [16, 39]
            ],
            [
              [7939, 4712],
              [-31, -1],
              [-24, 49],
              [-35, 48],
              [-12, 36],
              [-21, 48],
              [-14, 44],
              [-21, 83],
              [-24, 49],
              [-9, 51],
              [-10, 46],
              [-25, 37],
              [-14, 51],
              [-21, 33],
              [-29, 65],
              [-3, 30],
              [18, -2],
              [43, -12],
              [25, -57],
              [21, -40],
              [16, -25],
              [26, -63],
              [28, -1],
              [23, -41],
              [16, -49],
              [22, -27],
              [-12, -49],
              [16, -20],
              [10, -2],
              [5, -41],
              [10, -33],
              [20, -5],
              [14, -37],
              [-7, -74],
              [-1, -91]
            ],
            [
              [7252, 6841],
              [-17, -27],
              [-11, -55],
              [27, -23],
              [26, -29],
              [36, -33],
              [38, -8],
              [16, -30],
              [22, -5],
              [33, -14],
              [23, 1],
              [4, 23],
              [-4, 38],
              [2, 25]
            ],
            [
              [7703, 6727],
              [2, -22],
              [-10, -11],
              [2, -36],
              [-19, 10],
              [-36, -41],
              [0, -33],
              [-15, -50],
              [-1, -29],
              [-13, -48],
              [-21, 13],
              [-1, -61],
              [-7, -20],
              [3, -25],
              [-14, -14]
            ],
            [
              [7472, 6360],
              [-4, -21],
              [-19, 1],
              [-34, -13],
              [2, -44],
              [-15, -35],
              [-40, -40],
              [-31, -69],
              [-21, -38],
              [-28, -38],
              [0, -27],
              [-13, -15],
              [-26, -21],
              [-12, -3],
              [-9, -45],
              [6, -77],
              [1, -49],
              [-11, -56],
              [0, -101],
              [-15, -2],
              [-12, -46],
              [8, -19],
              [-25, -17],
              [-10, -40],
              [-11, -17],
              [-26, 55],
              [-13, 83],
              [-11, 60],
              [-9, 28],
              [-15, 56],
              [-7, 74],
              [-5, 37],
              [-25, 81],
              [-12, 115],
              [-8, 75],
              [0, 72],
              [-5, 55],
              [-41, -35],
              [-19, 7],
              [-36, 71],
              [13, 22],
              [-8, 23],
              [-33, 50]
            ],
            [
              [6893, 6457],
              [19, 40],
              [61, -1],
              [-6, 51],
              [-15, 30],
              [-4, 46],
              [-18, 26],
              [31, 62],
              [32, -4],
              [29, 61],
              [18, 60],
              [27, 60],
              [-1, 42],
              [24, 34],
              [-23, 29],
              [-9, 40],
              [-10, 52],
              [14, 25],
              [42, -14],
              [31, 9],
              [26, 49]
            ],
            [
              [4827, 8240],
              [5, -42],
              [-21, -53],
              [-49, -35],
              [-40, 9],
              [23, 62],
              [-15, 60],
              [38, 46],
              [21, 28]
            ],
            [
              [6497, 7255],
              [25, 12],
              [19, 33],
              [19, -1],
              [12, 11],
              [20, -6],
              [31, -30],
              [22, -6],
              [31, -53],
              [21, -2],
              [3, -49]
            ],
            [
              [6690, 6820],
              [14, -31],
              [11, -36],
              [27, -26],
              [1, -52],
              [13, -10],
              [2, -27],
              [-40, -30],
              [-10, -69]
            ],
            [
              [6708, 6539],
              [-53, 18],
              [-30, 13],
              [-31, 8],
              [-12, 73],
              [-13, 10],
              [-22, -11],
              [-28, -28],
              [-34, 20],
              [-28, 45],
              [-27, 17],
              [-18, 56],
              [-21, 79],
              [-15, -10],
              [-17, 20],
              [-11, -24]
            ],
            [
              [6348, 6825],
              [-15, 32],
              [0, 31],
              [-9, 0],
              [5, 43],
              [-15, 45],
              [-34, 32],
              [-19, 56],
              [6, 46],
              [14, 21],
              [-2, 34],
              [-18, 18],
              [-18, 70]
            ],
            [
              [6243, 7253],
              [-15, 48],
              [5, 18],
              [-8, 68],
              [19, 17]
            ],
            [
              [6357, 7321],
              [9, -43],
              [26, -13],
              [20, -29],
              [39, -10],
              [44, 15],
              [2, 14]
            ],
            [
              [6348, 6825],
              [-16, 3]
            ],
            [
              [6332, 6828],
              [-19, 5],
              [-20, -56]
            ],
            [
              [6293, 6777],
              [-52, 4],
              [-78, 119],
              [-41, 41],
              [-34, 16]
            ],
            [
              [6088, 6957],
              [-11, 72]
            ],
            [
              [6077, 7029],
              [61, 62],
              [11, 71],
              [-3, 43],
              [16, 15],
              [14, 37]
            ],
            [
              [6176, 7257],
              [12, 9],
              [32, -8],
              [10, -15],
              [13, 10]
            ],
            [
              [4597, 8984],
              [-7, -39],
              [31, -40],
              [-36, -45],
              [-80, -41],
              [-24, -10],
              [-36, 8],
              [-78, 19],
              [28, 26],
              [-61, 29],
              [49, 12],
              [-1, 17],
              [-58, 14],
              [19, 38],
              [42, 9],
              [43, -40],
              [42, 32],
              [35, -17],
              [45, 32],
              [47, -4]
            ],
            [
              [5992, 6990],
              [-5, -19]
            ],
            [
              [5987, 6971],
              [-10, 8],
              [-6, -39],
              [7, -7],
              [-7, -8],
              [-1, -15],
              [13, 8]
            ],
            [
              [5983, 6918],
              [0, -23],
              [-14, -95]
            ],
            [
              [5951, 6902],
              [8, 19],
              [-2, 4],
              [8, 27],
              [5, 45],
              [4, 15],
              [1, 0]
            ],
            [
              [5975, 7012],
              [9, 0],
              [3, 11],
              [7, 0]
            ],
            [
              [5994, 7023],
              [1, -24],
              [-4, -9],
              [1, 0]
            ],
            [
              [5431, 7316],
              [-10, -46],
              [4, -19],
              [-6, -30],
              [-21, 22],
              [-14, 7],
              [-39, 30],
              [4, 30],
              [32, -6],
              [28, 7],
              [22, 5]
            ],
            [
              [5255, 7492],
              [17, -42],
              [-4, -78],
              [-13, 4],
              [-11, -20],
              [-10, 16],
              [-2, 71],
              [-6, 34],
              [15, -3],
              [14, 18]
            ],
            [
              [5383, 7805],
              [-3, -29],
              [7, -25]
            ],
            [
              [5387, 7751],
              [-22, 8],
              [-23, -20],
              [1, -30],
              [-3, -17],
              [9, -30],
              [26, -29],
              [14, -49],
              [31, -48],
              [22, 0],
              [7, -13],
              [-8, -11],
              [25, -22],
              [20, -18],
              [24, -30],
              [3, -11],
              [-5, -22],
              [-16, 28],
              [-24, 10],
              [-12, -39],
              [20, -21],
              [-3, -31],
              [-11, -4],
              [-15, -50],
              [-12, -5],
              [0, 18],
              [6, 32],
              [6, 12],
              [-11, 35],
              [-8, 29],
              [-12, 8],
              [-8, 25],
              [-18, 11],
              [-12, 24],
              [-21, 4],
              [-21, 26],
              [-26, 39],
              [-19, 34],
              [-8, 58],
              [-14, 7],
              [-23, 20],
              [-12, -8],
              [-16, -28],
              [-12, -4]
            ],
            [
              [2845, 6150],
              [19, -5],
              [14, -15],
              [5, -16],
              [-19, -1],
              [-9, -10],
              [-15, 10],
              [-16, 21],
              [3, 14],
              [12, 4],
              [6, -2]
            ],
            [
              [5992, 6990],
              [31, -24],
              [54, 63]
            ],
            [
              [6088, 6957],
              [-5, -8],
              [-56, -30],
              [28, -59],
              [-9, -10],
              [-5, -20],
              [-21, -8],
              [-7, -21],
              [-12, -19],
              [-31, 10]
            ],
            [
              [5970, 6792],
              [-1, 8]
            ],
            [
              [5983, 6918],
              [4, 17],
              [0, 36]
            ],
            [
              [8739, 7075],
              [4, -20],
              [-16, -36],
              [-11, 19],
              [-15, -14],
              [-7, -34],
              [-18, 16],
              [0, 28],
              [15, 36],
              [16, -7],
              [12, 25],
              [20, -13]
            ],
            [
              [8915, 7252],
              [-10, -47],
              [4, -30],
              [-14, -42],
              [-35, -27],
              [-49, -4],
              [-40, -67],
              [-19, 22],
              [-1, 44],
              [-48, -13],
              [-33, -27],
              [-32, -2],
              [28, -43],
              [-19, -101],
              [-18, -24],
              [-13, 23],
              [7, 53],
              [-18, 17],
              [-11, 41],
              [26, 18],
              [15, 37],
              [28, 30],
              [20, 41],
              [55, 17],
              [30, -12],
              [29, 105],
              [19, -28],
              [40, 59],
              [16, 23],
              [18, 72],
              [-5, 67],
              [11, 37],
              [30, 11],
              [15, -82],
              [-1, -48],
              [-25, -59],
              [0, -61]
            ],
            [
              [8997, 7667],
              [19, -12],
              [20, 25],
              [6, -67],
              [-41, -16],
              [-25, -59],
              [-43, 41],
              [-15, -65],
              [-31, -1],
              [-4, 59],
              [14, 46],
              [29, 3],
              [8, 82],
              [9, 46],
              [32, -62],
              [22, -20]
            ],
            [
              [6970, 7554],
              [-15, -10],
              [-37, -42],
              [-12, -42],
              [-11, 0],
              [-7, 28],
              [-36, 2],
              [-5, 48],
              [-14, 0],
              [2, 60],
              [-33, 43],
              [-48, -5],
              [-32, -8],
              [-27, 53],
              [-22, 22],
              [-43, 43],
              [-6, 5],
              [-71, -35],
              [1, -218]
            ],
            [
              [6554, 7498],
              [-14, -3],
              [-20, 46],
              [-18, 17],
              [-32, -12],
              [-12, -20]
            ],
            [
              [6458, 7526],
              [-2, 14],
              [7, 25],
              [-5, 21],
              [-32, 20],
              [-13, 53],
              [-15, 15],
              [-1, 19],
              [27, -6],
              [1, 44],
              [23, 9],
              [25, -9],
              [5, 58],
              [-5, 36],
              [-28, -2],
              [-24, 14],
              [-32, -26],
              [-26, -12]
            ],
            [
              [6363, 7799],
              [-14, 9],
              [3, 31],
              [-18, 39],
              [-20, -2],
              [-24, 40],
              [16, 45],
              [-8, 12],
              [22, 65],
              [29, -34],
              [3, 43],
              [58, 64],
              [43, 2],
              [61, -41],
              [33, -24],
              [30, 25],
              [44, 1],
              [35, -30],
              [8, 17],
              [39, -2],
              [7, 28],
              [-45, 40],
              [27, 29],
              [-5, 16],
              [26, 15],
              [-20, 41],
              [13, 20],
              [104, 21],
              [13, 14],
              [70, 22],
              [25, 24],
              [50, -12],
              [9, -61],
              [29, 14],
              [35, -20],
              [-2, -32],
              [27, 3],
              [69, 56],
              [-10, -19],
              [35, -46],
              [62, -150],
              [15, 31],
              [39, -34],
              [39, 16],
              [16, -11],
              [13, -34],
              [20, -12],
              [11, -25],
              [36, 8],
              [15, -36]
            ],
            [
              [7229, 7559],
              [-17, 9],
              [-14, 21],
              [-42, 6],
              [-46, 2],
              [-10, -6],
              [-39, 24],
              [-16, -12],
              [-4, -35],
              [-46, 21],
              [-18, -9],
              [-7, -26]
            ],
            [
              [6155, 4958],
              [-20, -24],
              [-7, -24],
              [-10, -4],
              [-4, -42],
              [-9, -24],
              [-5, -39],
              [-12, -20]
            ],
            [
              [6088, 4781],
              [-40, 59],
              [-1, 35],
              [-101, 120],
              [-5, 6]
            ],
            [
              [5941, 5001],
              [0, 63],
              [8, 24],
              [14, 39],
              [10, 43],
              [-13, 68],
              [-3, 30],
              [-13, 41]
            ],
            [
              [5944, 5309],
              [17, 35],
              [19, 39]
            ],
            [
              [6162, 5289],
              [-24, -67],
              [0, -215],
              [17, -49]
            ],
            [
              [7046, 7387],
              [-53, -9],
              [-34, 19],
              [-30, -4],
              [3, 34],
              [30, -10],
              [10, 18]
            ],
            [
              [6972, 7435],
              [21, -6],
              [36, 43],
              [-33, 31],
              [-20, -15],
              [-21, 22],
              [24, 39],
              [-9, 5]
            ],
            [
              [7849, 5777],
              [-7, 72],
              [18, 49],
              [36, 11],
              [26, -8]
            ],
            [
              [7922, 5901],
              [23, -23],
              [12, 40],
              [25, -21]
            ],
            [
              [7982, 5897],
              [6, -40],
              [-3, -71],
              [-47, -45],
              [13, -36],
              [-30, -4],
              [-24, -24]
            ],
            [
              [7897, 5677],
              [-23, 9],
              [-11, 30],
              [-14, 61]
            ],
            [
              [8564, 7339],
              [24, -70],
              [7, -38],
              [0, -68],
              [-10, -33],
              [-25, -11],
              [-22, -25],
              [-25, -5],
              [-3, 32],
              [5, 45],
              [-13, 61],
              [21, 10],
              [-19, 51]
            ],
            [
              [8504, 7288],
              [2, 5],
              [12, -2],
              [11, 27],
              [20, 2],
              [11, 4],
              [4, 15]
            ],
            [
              [5557, 7574],
              [5, 13]
            ],
            [
              [5562, 7587],
              [7, 4],
              [4, 20],
              [5, 3],
              [4, -8],
              [5, -4],
              [3, -10],
              [5, -2],
              [5, -11],
              [4, 0],
              [-3, -14],
              [-3, -7],
              [1, -5]
            ],
            [
              [5599, 7553],
              [-6, -2],
              [-17, -9],
              [-1, -12],
              [-4, 0]
            ],
            [
              [6332, 6828],
              [6, -26],
              [-3, -13],
              [9, -45]
            ],
            [
              [6344, 6744],
              [-19, -1],
              [-7, 28],
              [-25, 6]
            ],
            [
              [7922, 5901],
              [9, 26],
              [1, 50],
              [-22, 52],
              [-2, 58],
              [-21, 48],
              [-21, 4],
              [-6, -20],
              [-16, -2],
              [-8, 10],
              [-30, -35],
              [0, 53],
              [7, 62],
              [-19, 3],
              [-2, 36],
              [-12, 18]
            ],
            [
              [7780, 6264],
              [6, 21],
              [24, 39]
            ],
            [
              [7837, 6385],
              [17, -47],
              [12, -54],
              [34, 0],
              [11, -52],
              [-18, -15],
              [-8, -21],
              [34, -36],
              [23, -70],
              [17, -52],
              [21, -41],
              [7, -41],
              [-5, -59]
            ],
            [
              [5975, 7012],
              [10, 49],
              [14, 41],
              [0, 2]
            ],
            [
              [5999, 7104],
              [13, -3],
              [4, -23],
              [-15, -22],
              [-7, -33]
            ],
            [
              [4785, 5315],
              [-7, 0],
              [-29, 28],
              [-25, 45],
              [-24, 32],
              [-18, 38]
            ],
            [
              [4682, 5458],
              [6, 19],
              [2, 17],
              [12, 33],
              [13, 27]
            ],
            [
              [5412, 6408],
              [-20, -22],
              [-15, 33],
              [-44, 25]
            ],
            [
              [5263, 6848],
              [13, 14],
              [3, 25],
              [-3, 24],
              [19, 23],
              [8, 19],
              [14, 17],
              [2, 45]
            ],
            [
              [5319, 7015],
              [32, -20],
              [12, 5],
              [23, -10],
              [37, -26],
              [13, -53],
              [25, -11],
              [39, -25],
              [30, -29],
              [13, 15],
              [13, 27],
              [-6, 45],
              [9, 29],
              [20, 28],
              [19, 8],
              [37, -12],
              [10, -27],
              [10, 0],
              [9, -10],
              [28, -7],
              [6, -19]
            ],
            [
              [5694, 6357],
              [0, -118],
              [-32, 0],
              [0, -25]
            ],
            [
              [5662, 6214],
              [-111, 113],
              [-111, 113],
              [-28, -32]
            ],
            [
              [7271, 5502],
              [-4, -62],
              [-12, -16],
              [-24, -14],
              [-13, 47],
              [-5, 85],
              [13, 96],
              [19, -33],
              [13, -42],
              [13, -61]
            ],
            [
              [5804, 3347],
              [10, -18],
              [-9, -29],
              [-4, -19],
              [-16, -9],
              [-5, -19],
              [-10, -6],
              [-21, 46],
              [15, 37],
              [15, 23],
              [13, 12],
              [12, -18]
            ],
            [
              [5631, 8267],
              [-2, 15],
              [3, 16],
              [-13, 10],
              [-29, 10]
            ],
            [
              [5590, 8318],
              [-6, 50]
            ],
            [
              [5584, 8368],
              [32, 18],
              [47, -4],
              [27, 6],
              [4, -12],
              [15, -4],
              [26, -29]
            ],
            [
              [5652, 8242],
              [-7, 19],
              [-14, 6]
            ],
            [
              [5584, 8368],
              [1, 44],
              [14, 37],
              [26, 20],
              [22, -44],
              [22, 1],
              [6, 46]
            ],
            [
              [5757, 8453],
              [14, -14],
              [2, -28],
              [9, -35]
            ],
            [
              [4759, 6691],
              [-4, 0],
              [0, -31],
              [-17, -2],
              [-9, -14],
              [-13, 0],
              [-10, 8],
              [-23, -6],
              [-9, -46],
              [-9, -5],
              [-13, -74],
              [-38, -64],
              [-9, -81],
              [-12, -27],
              [-3, -21],
              [-63, -5]
            ],
            [
              [4527, 6323],
              [1, 27],
              [11, 17],
              [9, 30],
              [-2, 20],
              [10, 42],
              [15, 38],
              [9, 9],
              [8, 35],
              [0, 31],
              [10, 37],
              [19, 21],
              [18, 60],
              [0, 1],
              [14, 23],
              [26, 6],
              [22, 41],
              [14, 16],
              [23, 49],
              [-7, 73],
              [10, 51],
              [4, 31],
              [18, 40],
              [28, 27],
              [21, 25],
              [18, 61],
              [9, 36],
              [20, 0],
              [17, -25],
              [26, 4],
              [29, -13],
              [12, -1]
            ],
            [
              [5739, 7906],
              [6, 9],
              [19, 6],
              [20, -19],
              [12, -2],
              [12, -16],
              [-2, -20],
              [11, -9],
              [4, -25],
              [9, -15],
              [-2, -9],
              [5, -6],
              [-7, -4],
              [-16, 1],
              [-3, 9],
              [-6, -5],
              [2, -11],
              [-7, -19],
              [-5, -20],
              [-7, -6]
            ],
            [
              [5784, 7745],
              [-5, 27],
              [3, 25],
              [-1, 26],
              [-16, 35],
              [-9, 25],
              [-9, 17],
              [-8, 6]
            ],
            [
              [6376, 4321],
              [7, -25],
              [7, -39],
              [4, -71],
              [7, -28],
              [-2, -28],
              [-5, -18],
              [-10, 35],
              [-5, -18],
              [5, -43],
              [-2, -25],
              [-8, -14],
              [-1, -50],
              [-11, -69],
              [-14, -81],
              [-17, -112],
              [-11, -82],
              [-12, -69],
              [-23, -14],
              [-24, -25],
              [-16, 15],
              [-22, 21],
              [-8, 31],
              [-2, 53],
              [-10, 47],
              [-2, 42],
              [5, 43],
              [13, 10],
              [0, 20],
              [13, 45],
              [2, 37],
              [-6, 28],
              [-5, 38],
              [-2, 54],
              [9, 33],
              [4, 38],
              [14, 2],
              [15, 12],
              [11, 10],
              [12, 1],
              [16, 34],
              [23, 36],
              [8, 30],
              [-4, 25],
              [12, -7],
              [15, 41],
              [1, 36],
              [9, 26],
              [10, -25]
            ],
            [
              [2301, 6586],
              [-10, -52],
              [-5, -43],
              [-2, -79],
              [-3, -29],
              [5, -32],
              [9, -29],
              [5, -45],
              [19, -44],
              [6, -34],
              [11, -29],
              [29, -16],
              [12, -25],
              [24, 17],
              [21, 6],
              [21, 11],
              [18, 10],
              [17, 24],
              [7, 34],
              [2, 50],
              [5, 17],
              [19, 16],
              [29, 13],
              [25, -2],
              [17, 5],
              [6, -12],
              [-1, -29],
              [-15, -35],
              [-6, -36],
              [5, -10],
              [-4, -26],
              [-7, -46],
              [-7, 15],
              [-6, -1]
            ],
            [
              [2438, 5916],
              [-32, 64],
              [-14, 19],
              [-23, 16],
              [-15, -5],
              [-22, -22],
              [-14, -6],
              [-20, 16],
              [-21, 11],
              [-26, 27],
              [-21, 8],
              [-31, 28],
              [-23, 28],
              [-7, 16],
              [-16, 3],
              [-28, 19],
              [-12, 27],
              [-30, 34],
              [-14, 37],
              [-6, 29],
              [9, 5],
              [-3, 17],
              [7, 16],
              [0, 20],
              [-10, 27],
              [-2, 23],
              [-9, 30],
              [-25, 59],
              [-28, 46],
              [-13, 37],
              [-24, 24],
              [-5, 14],
              [4, 37],
              [-14, 13],
              [-17, 29],
              [-7, 41],
              [-14, 5],
              [-17, 31],
              [-13, 29],
              [-1, 19],
              [-15, 44],
              [-10, 45],
              [1, 23],
              [-20, 23],
              [-10, -2],
              [-15, 16],
              [-5, -24],
              [5, -28],
              [2, -45],
              [10, -24],
              [21, -41],
              [4, -14],
              [4, -4],
              [4, -20],
              [5, 1],
              [6, -38],
              [8, -15],
              [6, -21],
              [17, -30],
              [10, -55],
              [8, -26],
              [8, -28],
              [1, -31],
              [13, -2],
              [12, -27],
              [10, -26],
              [-1, -11],
              [-12, -21],
              [-5, 0],
              [-7, 36],
              [-18, 33],
              [-20, 29],
              [-14, 15],
              [1, 43],
              [-5, 32],
              [-13, 19],
              [-19, 26],
              [-4, -8],
              [-7, 16],
              [-17, 14],
              [-16, 34],
              [2, 5],
              [11, -4],
              [11, 22],
              [1, 27],
              [-22, 42],
              [-16, 17],
              [-10, 36],
              [-11, 39],
              [-12, 47],
              [-12, 54]
            ],
            [
              [1746, 6980],
              [32, 4],
              [35, 7],
              [-2, -12],
              [41, -29],
              [64, -41],
              [55, 0],
              [22, 0],
              [0, 24],
              [48, 0],
              [10, -20],
              [15, -19],
              [16, -26],
              [9, -31],
              [7, -32],
              [15, -18],
              [23, -18],
              [17, 47],
              [23, 1],
              [19, -24],
              [14, -40],
              [10, -35],
              [16, -34],
              [6, -41],
              [8, -28],
              [22, -18],
              [20, -13],
              [10, 2]
            ],
            [
              [5599, 7553],
              [9, 4],
              [13, 1]
            ],
            [
              [4661, 5921],
              [10, 11],
              [4, 35],
              [9, 1],
              [20, -16],
              [15, 11],
              [11, -4],
              [4, 13],
              [112, 1],
              [6, 42],
              [-5, 7],
              [-13, 255],
              [-14, 255],
              [43, 1]
            ],
            [
              [5118, 6189],
              [0, -136],
              [-15, -39],
              [-2, -37],
              [-25, -9],
              [-38, -5],
              [-10, -21],
              [-18, -3]
            ],
            [
              [4680, 5793],
              [1, 18],
              [-2, 23],
              [-11, 16],
              [-5, 34],
              [-2, 37]
            ],
            [
              [7737, 5644],
              [-3, 44],
              [9, 45],
              [-10, 35],
              [3, 65],
              [-12, 30],
              [-9, 71],
              [-5, 75],
              [-12, 49],
              [-18, -30],
              [-32, -42],
              [-15, 5],
              [-17, 14],
              [9, 73],
              [-6, 56],
              [-21, 68],
              [3, 21],
              [-16, 7],
              [-20, 49]
            ],
            [
              [7780, 6264],
              [-16, -14],
              [-16, -26],
              [-20, -2],
              [-12, -64],
              [-12, -11],
              [14, -52],
              [17, -43],
              [12, -39],
              [-11, -51],
              [-9, -11],
              [6, -30],
              [19, -47],
              [3, -33],
              [0, -27],
              [11, -54],
              [-16, -55],
              [-13, -61]
            ],
            [
              [5538, 7532],
              [-6, 4],
              [-8, 19],
              [-12, 12]
            ],
            [
              [5533, 7629],
              [8, -10],
              [4, -9],
              [9, -6],
              [10, -12],
              [-2, -5]
            ],
            [
              [7437, 7970],
              [29, 10],
              [53, 51],
              [42, 28],
              [24, -18],
              [29, -1],
              [19, -28],
              [28, -2],
              [40, -15],
              [27, 41],
              [-11, 35],
              [28, 61],
              [31, -24],
              [26, -7],
              [32, -15],
              [6, -44],
              [39, -25],
              [26, 11],
              [36, 7],
              [27, -7],
              [28, -29],
              [16, -30],
              [26, 1],
              [35, -10],
              [26, 15],
              [36, 9],
              [41, 42],
              [17, -6],
              [14, -20],
              [33, 5]
            ],
            [
              [5959, 4377],
              [21, 5],
              [34, -17],
              [7, 8],
              [19, 1],
              [10, 18],
              [17, -1],
              [30, 23],
              [22, 34]
            ],
            [
              [6119, 4448],
              [5, -26],
              [-1, -59],
              [3, -52],
              [1, -92],
              [5, -29],
              [-8, -43],
              [-11, -41],
              [-18, -36],
              [-25, -23],
              [-31, -28],
              [-32, -64],
              [-10, -11],
              [-20, -42],
              [-11, -13],
              [-3, -42],
              [14, -45],
              [5, -35],
              [0, -17],
              [5, 3],
              [-1, -58],
              [-4, -28],
              [6, -10],
              [-4, -25],
              [-11, -21],
              [-23, -20],
              [-34, -32],
              [-12, -21],
              [3, -25],
              [7, -4],
              [-3, -31]
            ],
            [
              [5911, 3478],
              [-21, 0]
            ],
            [
              [5890, 3478],
              [-2, 26],
              [-4, 27]
            ],
            [
              [5884, 3531],
              [-3, 21],
              [5, 66],
              [-7, 42],
              [-13, 83]
            ],
            [
              [5866, 3743],
              [29, 67],
              [7, 43],
              [5, 5],
              [3, 35],
              [-5, 17],
              [1, 44],
              [6, 41],
              [0, 75],
              [-15, 19],
              [-13, 4],
              [-6, 15],
              [-13, 12],
              [-23, -1],
              [-2, 22]
            ],
            [
              [5840, 4141],
              [-2, 42],
              [84, 49]
            ],
            [
              [5922, 4232],
              [16, -28],
              [8, 5],
              [11, -15],
              [1, -23],
              [-6, -28],
              [2, -42],
              [19, -36],
              [8, 41],
              [12, 12],
              [-2, 76],
              [-12, 43],
              [-10, 19],
              [-10, -1],
              [-7, 77],
              [7, 45]
            ],
            [
              [4661, 5921],
              [-18, 41],
              [-17, 43],
              [-18, 16],
              [-13, 17],
              [-16, -1],
              [-13, -12],
              [-14, 5],
              [-10, -19]
            ],
            [
              [4542, 6011],
              [-2, 32],
              [8, 29],
              [3, 55],
              [-3, 59],
              [-3, 29],
              [2, 30],
              [-7, 28],
              [-14, 25]
            ],
            [
              [4526, 6298],
              [6, 20],
              [108, -1],
              [-5, 86],
              [7, 30],
              [26, 5],
              [-1, 152],
              [91, -4],
              [0, 90]
            ],
            [
              [5922, 4232],
              [-15, 15],
              [9, 55],
              [9, 21],
              [-6, 49],
              [6, 48],
              [5, 16],
              [-7, 50],
              [-14, 26]
            ],
            [
              [5909, 4512],
              [28, -11],
              [5, -16],
              [10, -28],
              [7, -80]
            ],
            [
              [7836, 5425],
              [7, -5],
              [16, -36],
              [12, -40],
              [2, -39],
              [-3, -27],
              [2, -21],
              [2, -35],
              [10, -16],
              [11, -52],
              [-1, -20],
              [-19, -4],
              [-27, 44],
              [-32, 47],
              [-4, 30],
              [-16, 39],
              [-4, 49],
              [-10, 32],
              [4, 43],
              [-7, 25]
            ],
            [
              [7779, 5439],
              [5, 11],
              [23, -26],
              [2, -30],
              [18, 7],
              [9, 24]
            ],
            [
              [8045, 5176],
              [21, -20],
              [21, 11],
              [6, 50],
              [12, 11],
              [33, 13],
              [20, 47],
              [14, 37]
            ],
            [
              [8206, 5379],
              [22, 41],
              [14, 47],
              [11, 0],
              [14, -30],
              [1, -26],
              [19, -16],
              [23, -18],
              [-2, -23],
              [-19, -3],
              [5, -29],
              [-20, -20]
            ],
            [
              [5453, 3369],
              [-20, 45],
              [-11, 43],
              [-6, 58],
              [-7, 42],
              [-9, 91],
              [-1, 71],
              [-3, 32],
              [-11, 25],
              [-15, 48],
              [-14, 71],
              [-6, 37],
              [-23, 58],
              [-2, 45]
            ],
            [
              [5644, 4022],
              [23, 14],
              [18, -4],
              [11, -13],
              [0, -5]
            ],
            [
              [5552, 3594],
              [0, -218],
              [-25, -30],
              [-15, -4],
              [-17, 11],
              [-13, 4],
              [-4, 25],
              [-11, 17],
              [-14, -30]
            ],
            [
              [9604, 3812],
              [23, -36],
              [14, -28],
              [-10, -14],
              [-16, 16],
              [-19, 27],
              [-18, 31],
              [-19, 42],
              [-4, 20],
              [12, -1],
              [16, -20],
              [12, -20],
              [9, -17]
            ],
            [
              [5412, 6408],
              [7, -92],
              [10, -15],
              [1, -19],
              [11, -20],
              [-6, -25],
              [-11, -120],
              [-1, -77],
              [-35, -56],
              [-12, -78],
              [11, -22],
              [0, -38],
              [18, -1],
              [-3, -28]
            ],
            [
              [5393, 5795],
              [-5, -1],
              [-19, 64],
              [-6, 3],
              [-22, -33],
              [-21, 17],
              [-15, 3],
              [-8, -8],
              [-17, 2],
              [-16, -25],
              [-14, -2],
              [-34, 31],
              [-13, -15],
              [-14, 1],
              [-10, 23],
              [-28, 22],
              [-30, -7],
              [-7, -13],
              [-4, -34],
              [-8, -24],
              [-2, -53]
            ],
            [
              [5236, 5339],
              [-29, -21],
              [-11, 3],
              [-10, -13],
              [-23, 1],
              [-15, 37],
              [-9, 43],
              [-19, 39],
              [-21, -1],
              [-25, 0]
            ],
            [
              [2619, 5713],
              [-10, 18],
              [-13, 24],
              [-6, 20],
              [-12, 19],
              [-13, 26],
              [3, 9],
              [4, -9],
              [2, 5]
            ],
            [
              [2690, 5943],
              [-2, -5],
              [-2, -13],
              [3, -22],
              [-6, -20],
              [-3, -24],
              [-1, -26],
              [1, -15],
              [1, -27],
              [-4, -6],
              [-3, -25],
              [2, -15],
              [-6, -16],
              [2, -16],
              [4, -9]
            ],
            [
              [5092, 8091],
              [14, 16],
              [24, 87],
              [38, 25],
              [23, -2]
            ],
            [
              [5863, 9167],
              [-47, -24],
              [-22, -5]
            ],
            [
              [5573, 9140],
              [-17, -2],
              [-4, -39],
              [-53, 9],
              [-7, -33],
              [-27, 1],
              [-18, -42],
              [-28, -66],
              [-43, -83],
              [10, -20],
              [-10, -24],
              [-27, 1],
              [-18, -55],
              [2, -79],
              [17, -29],
              [-9, -70],
              [-23, -40],
              [-12, -34]
            ],
            [
              [5306, 8535],
              [-19, 36],
              [-55, -69],
              [-37, -13],
              [-38, 30],
              [-10, 63],
              [-9, 137],
              [26, 38],
              [73, 49],
              [55, 61],
              [51, 82],
              [66, 115],
              [47, 44],
              [76, 74],
              [61, 26],
              [46, -3],
              [42, 49],
              [51, -3],
              [50, 12],
              [87, -43],
              [-36, -16],
              [30, -37]
            ],
            [
              [5686, 9657],
              [-62, -24],
              [-49, 13],
              [19, 16],
              [-16, 19],
              [57, 11],
              [11, -22],
              [40, -13]
            ],
            [
              [5506, 9766],
              [92, -44],
              [-70, -23],
              [-15, -44],
              [-25, -11],
              [-13, -49],
              [-34, -2],
              [-59, 36],
              [25, 21],
              [-42, 17],
              [-54, 50],
              [-21, 46],
              [75, 21],
              [16, -20],
              [39, 0],
              [11, 21],
              [40, 2],
              [35, -21]
            ],
            [
              [5706, 9808],
              [55, -21],
              [-41, -32],
              [-81, -7],
              [-82, 10],
              [-5, 16],
              [-40, 1],
              [-30, 27],
              [86, 17],
              [40, -14],
              [28, 17],
              [70, -14]
            ],
            [
              [9805, 2640],
              [6, -24],
              [20, 24],
              [8, -25],
              [0, -25],
              [-10, -27],
              [-18, -44],
              [-14, -24],
              [10, -28],
              [-22, -1],
              [-23, -22],
              [-8, -39],
              [-16, -60],
              [-21, -26],
              [-14, -17],
              [-26, 1],
              [-18, 20],
              [-30, 4],
              [-5, 22],
              [15, 43],
              [35, 59],
              [18, 11],
              [20, 22],
              [24, 31],
              [16, 31],
              [13, 44],
              [10, 15],
              [5, 33],
              [19, 27],
              [6, -25]
            ],
            [
              [9849, 2922],
              [20, -63],
              [1, 41],
              [13, -16],
              [4, -45],
              [22, -19],
              [19, -5],
              [16, 22],
              [14, -6],
              [-7, -53],
              [-8, -34],
              [-22, 1],
              [-7, -18],
              [3, -25],
              [-4, -11],
              [-11, -32],
              [-14, -41],
              [-21, -23],
              [-5, 15],
              [-12, 9],
              [16, 48],
              [-9, 33],
              [-30, 23],
              [1, 22],
              [20, 20],
              [5, 46],
              [-1, 38],
              [-12, 40],
              [1, 10],
              [-13, 25],
              [-22, 52],
              [-12, 42],
              [11, 4],
              [15, -33],
              [21, -15],
              [8, -52]
            ],
            [
              [6475, 6041],
              [-9, 41],
              [-22, 98]
            ],
            [
              [6444, 6180],
              [83, 59],
              [19, 118],
              [-13, 42]
            ],
            [
              [6566, 6530],
              [12, -40],
              [16, -22],
              [20, -8],
              [17, -10],
              [12, -34],
              [8, -20],
              [10, -7],
              [0, -13],
              [-10, -36],
              [-5, -16],
              [-12, -19],
              [-10, -41],
              [-13, 3],
              [-5, -14],
              [-5, -30],
              [4, -39],
              [-3, -7],
              [-13, 0],
              [-17, -22],
              [-3, -29],
              [-6, -12],
              [-18, 0],
              [-10, -15],
              [0, -24],
              [-14, -16],
              [-15, 5],
              [-19, -19],
              [-12, -4]
            ],
            [
              [6557, 6597],
              [8, 20],
              [3, -5],
              [-2, -25],
              [-4, -10]
            ],
            [
              [6893, 6457],
              [-20, 15],
              [-9, 43],
              [-21, 45],
              [-51, -12],
              [-45, -1],
              [-39, -8]
            ],
            [
              [2836, 5484],
              [-9, 17],
              [-6, 32],
              [7, 16],
              [-7, 4],
              [-5, 20],
              [-14, 16],
              [-12, -4],
              [-6, -20],
              [-11, -15],
              [-6, -2],
              [-3, -13],
              [13, -32],
              [-7, -7],
              [-4, -9],
              [-13, -3],
              [-5, 35],
              [-4, -10],
              [-9, 4],
              [-5, 24],
              [-12, 3],
              [-7, 7],
              [-12, 0],
              [-1, -13],
              [-3, 9]
            ],
            [
              [2707, 5623],
              [10, -22],
              [-1, -12],
              [11, -3],
              [3, 5],
              [8, -14],
              [13, 4],
              [12, 15],
              [17, 12],
              [9, 17],
              [16, -3],
              [-1, -6],
              [15, -2],
              [12, -10],
              [10, -18],
              [10, -16]
            ],
            [
              [3045, 3974],
              [-28, 33],
              [-2, 25],
              [-55, 59],
              [-50, 65],
              [-22, 36],
              [-11, 49],
              [4, 17],
              [-23, 77],
              [-28, 109],
              [-26, 118],
              [-11, 27],
              [-9, 43],
              [-21, 39],
              [-20, 24],
              [9, 26],
              [-14, 57],
              [9, 41],
              [22, 37]
            ],
            [
              [8510, 5555],
              [2, -40],
              [2, -33],
              [-9, -54],
              [-11, 60],
              [-13, -30],
              [9, -43],
              [-8, -28],
              [-32, 35],
              [-8, 42],
              [8, 28],
              [-17, 28],
              [-9, -24],
              [-13, 2],
              [-21, -33],
              [-4, 17],
              [11, 50],
              [17, 17],
              [15, 22],
              [10, -27],
              [21, 17],
              [5, 26],
              [19, 1],
              [-1, 46],
              [22, -28],
              [3, -30],
              [2, -21]
            ],
            [
              [8443, 5665],
              [-10, -20],
              [-9, -37],
              [-8, -17],
              [-17, 40],
              [5, 16],
              [7, 17],
              [3, 36],
              [16, 4],
              [-5, -40],
              [21, 57],
              [-3, -56]
            ],
            [
              [8291, 5608],
              [-37, -56],
              [14, 41],
              [20, 37],
              [16, 41],
              [15, 58],
              [5, -48],
              [-18, -33],
              [-15, -40]
            ],
            [
              [8385, 5760],
              [16, -18],
              [18, 0],
              [0, -25],
              [-13, -25],
              [-18, -18],
              [-1, 28],
              [2, 30],
              [-4, 28]
            ],
            [
              [8485, 5776],
              [8, -66],
              [-21, 16],
              [0, -20],
              [7, -37],
              [-13, -13],
              [-1, 42],
              [-9, 3],
              [-4, 36],
              [16, -5],
              [0, 22],
              [-17, 45],
              [27, -1],
              [7, -22]
            ],
            [
              [8375, 5830],
              [-7, -51],
              [-12, 29],
              [-15, 45],
              [24, -2],
              [10, -21]
            ],
            [
              [8369, 6151],
              [17, -17],
              [9, 15],
              [2, -15],
              [-4, -24],
              [9, -43],
              [-7, -49],
              [-16, -19],
              [-5, -48],
              [7, -47],
              [14, -7],
              [13, 7],
              [34, -32],
              [-2, -32],
              [9, -15],
              [-3, -27],
              [-22, 29],
              [-10, 31],
              [-7, -22],
              [-18, 36],
              [-25, -9],
              [-14, 13],
              [1, 25],
              [9, 15],
              [-8, 13],
              [-4, -21],
              [-14, 34],
              [-4, 26],
              [-1, 56],
              [11, -19],
              [3, 92],
              [9, 54],
              [17, 0]
            ],
            [
              [9329, 4655],
              [-8, -6],
              [-12, 22],
              [-12, 38],
              [-6, 45],
              [4, 6],
              [3, -18],
              [8, -13],
              [14, -38],
              [13, -20],
              [-4, -16]
            ],
            [
              [9221, 4734],
              [-15, -5],
              [-4, -17],
              [-15, -14],
              [-15, -14],
              [-14, 0],
              [-23, 18],
              [-16, 16],
              [2, 18],
              [25, -8],
              [15, 4],
              [5, 29],
              [4, 1],
              [2, -31],
              [16, 4],
              [8, 20],
              [16, 21],
              [-4, 35],
              [17, 1],
              [6, -9],
              [-1, -33],
              [-9, -36]
            ],
            [
              [8916, 4904],
              [48, -41],
              [51, -34],
              [19, -30],
              [16, -30],
              [4, -34],
              [46, -37],
              [7, -31],
              [-25, -7],
              [6, -39],
              [25, -39],
              [18, -62],
              [15, 2],
              [-1, -27],
              [22, -10],
              [-9, -11],
              [30, -25],
              [-3, -17],
              [-18, -4],
              [-7, 16],
              [-24, 6],
              [-28, 9],
              [-22, 38],
              [-16, 32],
              [-14, 52],
              [-36, 26],
              [-24, -17],
              [-17, -20],
              [4, -43],
              [-22, -20],
              [-16, 9],
              [-28, 3]
            ],
            [
              [9253, 4792],
              [-9, -16],
              [-5, 35],
              [-6, 23],
              [-13, 19],
              [-16, 25],
              [-20, 18],
              [8, 14],
              [15, -17],
              [9, -13],
              [12, -14],
              [11, -25],
              [11, -19],
              [3, -30]
            ],
            [
              [5392, 8233],
              [19, 18],
              [43, 27],
              [35, 20],
              [28, -10],
              [2, -14],
              [27, -1]
            ],
            [
              [5546, 8273],
              [34, -7],
              [51, 1]
            ],
            [
              [5653, 8105],
              [14, -52],
              [-3, -17],
              [-14, -6],
              [-25, -50],
              [7, -26],
              [-6, 3]
            ],
            [
              [5626, 7957],
              [-26, 23],
              [-20, -8],
              [-13, 6],
              [-17, -13],
              [-14, 21],
              [-11, -8],
              [-2, 4]
            ],
            [
              [3159, 6151],
              [14, -5],
              [5, -12],
              [-7, -15],
              [-21, 1],
              [-17, -2],
              [-1, 25],
              [4, 9],
              [23, -1]
            ],
            [
              [8628, 7562],
              [4, -10]
            ],
            [
              [8632, 7552],
              [-11, 3],
              [-12, -20],
              [-8, -20],
              [1, -42],
              [-14, -13],
              [-5, -11],
              [-11, -17],
              [-18, -10],
              [-12, -16],
              [-1, -25],
              [-3, -7],
              [11, -9],
              [15, -26]
            ],
            [
              [8504, 7288],
              [-13, 11],
              [-4, -11],
              [-8, -5],
              [-1, 11],
              [-7, 5],
              [-8, 10],
              [8, 26],
              [7, 7],
              [-3, 11],
              [7, 31],
              [-2, 10],
              [-16, 7],
              [-13, 15]
            ],
            [
              [4792, 7249],
              [-11, -15],
              [-14, 8],
              [-15, -6],
              [5, 46],
              [-3, 36],
              [-12, 6],
              [-7, 22],
              [2, 39],
              [11, 21],
              [2, 24],
              [6, 36],
              [-1, 25],
              [-5, 21],
              [-1, 20]
            ],
            [
              [6411, 6520],
              [-2, 43],
              [7, 31],
              [8, 6],
              [8, -18],
              [1, -35],
              [-6, -35]
            ],
            [
              [6427, 6512],
              [-8, -4],
              [-8, 12]
            ],
            [
              [5630, 7886],
              [12, 13],
              [17, -7],
              [18, 0],
              [13, -14],
              [10, 9],
              [20, 5],
              [7, 14],
              [12, 0]
            ],
            [
              [5784, 7745],
              [12, -11],
              [13, 9],
              [13, -10]
            ],
            [
              [5822, 7733],
              [0, -15],
              [-13, -13],
              [-9, 6],
              [-7, -71]
            ],
            [
              [5629, 7671],
              [-5, 10],
              [6, 10],
              [-7, 7],
              [-8, -13],
              [-17, 17],
              [-2, 25],
              [-17, 14],
              [-3, 18],
              [-15, 24]
            ],
            [
              [8989, 8056],
              [28, -105],
              [-41, 19],
              [-17, -85],
              [27, -61],
              [-1, -41],
              [-21, 36],
              [-18, -46],
              [-5, 50],
              [3, 57],
              [-3, 64],
              [6, 45],
              [2, 79],
              [-17, 58],
              [3, 80],
              [25, 28],
              [-11, 27],
              [13, 8],
              [7, -39],
              [10, -57],
              [-1, -58],
              [11, -59]
            ],
            [
              [5546, 8273],
              [6, 26],
              [38, 19]
            ],
            [
              [0, 9132],
              [68, -45],
              [73, -59],
              [-3, -37],
              [19, -15],
              [-6, 43],
              [75, -8],
              [55, -56],
              [-28, -26],
              [-46, -6],
              [0, -57],
              [-11, -13],
              [-26, 2],
              [-22, 21],
              [-36, 17],
              [-7, 26],
              [-28, 9],
              [-31, -7],
              [-16, 20],
              [6, 22],
              [-33, -14],
              [13, -28],
              [-16, -25]
            ],
            [
              [0, 8896],
              [0, 236]
            ],
            [
              [0, 9282],
              [9999, -40],
              [-30, -3],
              [-5, 19],
              [-9964, 24]
            ],
            [
              [0, 9282],
              [4, 3],
              [23, 0],
              [40, -17],
              [-2, -8],
              [-29, -14],
              [-36, -4],
              [0, 40]
            ],
            [
              [8988, 9383],
              [-42, -1],
              [-57, 7],
              [-5, 3],
              [27, 23],
              [34, 6],
              [40, -23],
              [3, -15]
            ],
            [
              [9186, 9493],
              [-32, -23],
              [-44, 5],
              [-52, 23],
              [7, 20],
              [51, -9],
              [70, -16]
            ],
            [
              [9029, 9522],
              [-22, -44],
              [-102, 1],
              [-46, -14],
              [-55, 39],
              [15, 40],
              [37, 11],
              [73, -2],
              [100, -31]
            ],
            [
              [6598, 9235],
              [-17, -5],
              [-91, 8],
              [-7, 26],
              [-50, 16],
              [-4, 32],
              [28, 13],
              [-1, 32],
              [55, 50],
              [-25, 7],
              [66, 52],
              [-7, 27],
              [62, 31],
              [91, 38],
              [93, 11],
              [48, 22],
              [54, 8],
              [19, -23],
              [-19, -19],
              [-98, -29],
              [-85, -28],
              [-86, -57],
              [-42, -57],
              [-43, -57],
              [5, -49],
              [54, -49]
            ],
            [
              [0, 8896],
              [9963, -26],
              [-36, 4],
              [25, -31],
              [17, -49],
              [13, -16],
              [3, -24],
              [-7, -16],
              [-52, 13],
              [-78, -44],
              [-25, -7],
              [-42, -42],
              [-40, -36],
              [-11, -27],
              [-39, 41],
              [-73, -46],
              [-12, 22],
              [-27, -26],
              [-37, 8],
              [-9, -38],
              [-33, -58],
              [1, -24],
              [31, -13],
              [-4, -86],
              [-25, -2],
              [-12, -49],
              [11, -26],
              [-48, -30],
              [-10, -67],
              [-41, -15],
              [-9, -60],
              [-40, -55],
              [-10, 41],
              [-12, 86],
              [-15, 131],
              [13, 82],
              [23, 35],
              [2, 28],
              [43, 13],
              [50, 75],
              [47, 60],
              [50, 48],
              [23, 83],
              [-34, -5],
              [-17, -49],
              [-70, -65],
              [-23, 73],
              [-72, -20],
              [-69, -99],
              [23, -36],
              [-62, -16],
              [-43, -6],
              [2, 43],
              [-43, 9],
              [-35, -29],
              [-85, 10],
              [-91, -18],
              [-90, -115],
              [-106, -139],
              [43, -8],
              [14, -37],
              [27, -13],
              [18, 30],
              [30, -4],
              [40, -65],
              [1, -50],
              [-21, -59],
              [-3, -71],
              [-12, -94],
              [-42, -86],
              [-9, -41],
              [-38, -69],
              [-38, -68],
              [-18, -35],
              [-37, -34],
              [-17, -1],
              [-17, 29],
              [-38, -44],
              [-4, -19]
            ],
            [
              [6363, 7799],
              [-12, -35],
              [-27, -10],
              [-28, -61],
              [25, -56],
              [-2, -40],
              [30, -70]
            ],
            [
              [6109, 7624],
              [-35, 49],
              [-32, 23],
              [-24, 34],
              [20, 10],
              [23, 49],
              [-15, 24],
              [41, 24],
              [-1, 13],
              [-25, -10]
            ],
            [
              [6061, 7840],
              [1, 26],
              [14, 17],
              [27, 4],
              [5, 20],
              [-7, 33],
              [12, 30],
              [-1, 18],
              [-41, 19],
              [-16, -1],
              [-17, 28],
              [-21, -9],
              [-35, 20],
              [0, 12],
              [-10, 26],
              [-22, 3],
              [-2, 18],
              [7, 12],
              [-18, 33],
              [-29, -5],
              [-8, 3],
              [-7, -14],
              [-11, 3]
            ],
            [
              [5777, 8571],
              [31, 33],
              [-29, 28]
            ],
            [
              [5863, 9167],
              [29, 20],
              [46, -35],
              [76, -14],
              [105, -67],
              [21, -28],
              [2, -40],
              [-31, -31],
              [-45, -15],
              [-124, 44],
              [-21, -7],
              [45, -43],
              [2, -28],
              [2, -60],
              [36, -18],
              [22, -15],
              [3, 28],
              [-17, 26],
              [18, 22],
              [67, -37],
              [24, 15],
              [-19, 43],
              [65, 58],
              [25, -4],
              [26, -20],
              [16, 40],
              [-23, 35],
              [14, 36],
              [-21, 36],
              [78, -18],
              [16, -34],
              [-35, -7],
              [0, -33],
              [22, -20],
              [43, 13],
              [7, 38],
              [58, 28],
              [97, 50],
              [20, -3],
              [-27, -35],
              [35, -7],
              [19, 21],
              [52, 1],
              [42, 25],
              [31, -36],
              [32, 39],
              [-29, 35],
              [14, 19],
              [82, -18],
              [39, -18],
              [100, -68],
              [19, 31],
              [-28, 31],
              [-1, 13],
              [-34, 6],
              [10, 28],
              [-15, 46],
              [-1, 19],
              [51, 53],
              [18, 54],
              [21, 11],
              [74, -15],
              [5, -33],
              [-26, -48],
              [17, -19],
              [9, -41],
              [-6, -81],
              [31, -36],
              [-12, -40],
              [-55, -84],
              [32, -8],
              [11, 21],
              [31, 15],
              [7, 29],
              [24, 29],
              [-16, 33],
              [13, 39],
              [-31, 5],
              [-6, 33],
              [22, 59],
              [-36, 48],
              [50, 40],
              [-7, 42],
              [14, 2],
              [15, -33],
              [-11, -57],
              [29, -11],
              [-12, 43],
              [46, 23],
              [58, 3],
              [51, -34],
              [-25, 49],
              [-2, 63],
              [48, 12],
              [67, -2],
              [60, 7],
              [-23, 31],
              [33, 39],
              [31, 2],
              [54, 29],
              [74, 8],
              [9, 16],
              [73, 6],
              [23, -14],
              [62, 32],
              [51, -1],
              [8, 25],
              [26, 25],
              [66, 25],
              [48, -19],
              [-38, -15],
              [63, -9],
              [7, -29],
              [25, 14],
              [82, -1],
              [62, -29],
              [23, -22],
              [-7, -30],
              [-31, -18],
              [-73, -33],
              [-21, -17],
              [35, -8],
              [41, -15],
              [25, 11],
              [14, -38],
              [12, 15],
              [44, 10],
              [90, -10],
              [6, -28],
              [116, -9],
              [2, 46],
              [59, -11],
              [44, 1],
              [45, -32],
              [13, -37],
              [-17, -25],
              [35, -47],
              [44, -24],
              [27, 62],
              [44, -26],
              [48, 16],
              [53, -18],
              [21, 16],
              [45, -8],
              [-20, 55],
              [37, 25],
              [251, -38],
              [24, -35],
              [72, -45],
              [112, 11],
              [56, -10],
              [23, -24],
              [-4, -44],
              [35, -16],
              [37, 12],
              [49, 1],
              [52, -11],
              [53, 6],
              [49, -52],
              [34, 19],
              [-23, 37],
              [13, 27],
              [88, -17],
              [58, 4],
              [80, -29],
              [-9960, -25]
            ],
            [
              [7918, 9684],
              [-157, -23],
              [51, 77],
              [23, 7],
              [21, -4],
              [70, -33],
              [-8, -24]
            ],
            [
              [6420, 9816],
              [-37, -8],
              [-25, -4],
              [-4, -10],
              [-33, -10],
              [-30, 14],
              [16, 19],
              [-62, 2],
              [54, 10],
              [43, 1],
              [5, -16],
              [16, 14],
              [26, 10],
              [42, -13],
              [-11, -9]
            ],
            [
              [7775, 9718],
              [-60, -8],
              [-78, 17],
              [-46, 23],
              [-21, 42],
              [-38, 12],
              [72, 40],
              [60, 14],
              [54, -30],
              [64, -57],
              [-7, -53]
            ],
            [
              [5844, 4990],
              [11, -33],
              [-1, -35],
              [-8, -7]
            ],
            [
              [5821, 4978],
              [7, -6],
              [16, 18]
            ],
            [
              [4526, 6298],
              [1, 25]
            ],
            [
              [6188, 6023],
              [-4, 26],
              [-8, 17],
              [-2, 24],
              [-15, 21],
              [-15, 50],
              [-7, 48],
              [-20, 40],
              [-12, 10],
              [-18, 56],
              [-4, 41],
              [2, 35],
              [-16, 66],
              [-13, 23],
              [-15, 12],
              [-10, 34],
              [2, 13],
              [-8, 31],
              [-8, 13],
              [-11, 44],
              [-17, 48],
              [-14, 40],
              [-14, 0],
              [5, 33],
              [1, 20],
              [3, 24]
            ],
            [
              [6344, 6744],
              [11, -51],
              [14, -13],
              [5, -21],
              [18, -25],
              [2, -24],
              [-3, -20],
              [4, -20],
              [8, -16],
              [4, -20],
              [4, -14]
            ],
            [
              [6427, 6512],
              [5, -22]
            ],
            [
              [6444, 6180],
              [-80, -23],
              [-26, -26],
              [-20, -62],
              [-13, -10],
              [-7, 20],
              [-11, -3],
              [-27, 6],
              [-5, 5],
              [-32, -1],
              [-7, -5],
              [-12, 15],
              [-7, -29],
              [3, -25],
              [-12, -19]
            ],
            [
              [5943, 5617],
              [-4, 1],
              [0, 29],
              [-3, 20],
              [-14, 24],
              [-4, 42],
              [4, 44],
              [-13, 4],
              [-2, -13],
              [-17, -3],
              [7, -17],
              [2, -36],
              [-15, -32],
              [-14, -43],
              [-14, -6],
              [-23, 34],
              [-11, -12],
              [-3, -17],
              [-14, -11],
              [-1, -12],
              [-28, 0],
              [-3, 12],
              [-20, 2],
              [-10, -10],
              [-8, 5],
              [-14, 34],
              [-5, 17],
              [-20, -9],
              [-8, -27],
              [-7, -53],
              [-10, -11],
              [-8, -6]
            ],
            [
              [5663, 5567],
              [-2, 2]
            ],
            [
              [5635, 5716],
              [0, 14],
              [-10, 17],
              [-1, 35],
              [-5, 23],
              [-10, -4],
              [3, 22],
              [7, 25],
              [-3, 24],
              [9, 18],
              [-6, 14],
              [7, 36],
              [13, 44],
              [24, -4],
              [-1, 234]
            ],
            [
              [6023, 6357],
              [9, -58],
              [-6, -10],
              [4, -61],
              [11, -71],
              [10, -14],
              [15, -22]
            ],
            [
              [5943, 5624],
              [0, -7]
            ],
            [
              [5943, 5617],
              [0, -46]
            ],
            [
              [5944, 5309],
              [-17, -28],
              [-20, 1],
              [-22, -14],
              [-18, 13],
              [-11, -16]
            ],
            [
              [5682, 5544],
              [-19, 23]
            ],
            [
              [4535, 5861],
              [-11, 46],
              [-14, 21],
              [12, 11],
              [14, 41],
              [6, 31]
            ],
            [
              [4536, 5789],
              [-4, 45]
            ],
            [
              [9502, 4438],
              [8, -20],
              [-19, 0],
              [-11, 37],
              [17, -15],
              [5, -2]
            ],
            [
              [9467, 4474],
              [-11, -1],
              [-17, 6],
              [-5, 9],
              [1, 23],
              [19, -9],
              [9, -12],
              [4, -16]
            ],
            [
              [9490, 4490],
              [-4, -11],
              [-21, 52],
              [-5, 35],
              [9, 0],
              [10, -47],
              [11, -29]
            ],
            [
              [9440, 4565],
              [1, -12],
              [-22, 25],
              [-15, 21],
              [-10, 20],
              [4, 6],
              [13, -14],
              [23, -27],
              [6, -19]
            ],
            [
              [9375, 4623],
              [-5, -3],
              [-13, 14],
              [-11, 24],
              [1, 10],
              [17, -25],
              [11, -20]
            ],
            [
              [4682, 5458],
              [-8, 5],
              [-20, 24],
              [-14, 31],
              [-5, 22],
              [-3, 43]
            ],
            [
              [2561, 5848],
              [-3, -14],
              [-16, 1],
              [-10, 6],
              [-12, 12],
              [-15, 3],
              [-8, 13]
            ],
            [
              [6198, 5735],
              [9, -11],
              [5, -25],
              [13, -24],
              [14, -1],
              [26, 16],
              [30, 7],
              [25, 18],
              [13, 4],
              [10, 11],
              [16, 2]
            ],
            [
              [6359, 5732],
              [0, -1],
              [0, -25],
              [0, -59],
              [0, -31],
              [-13, -36],
              [-19, -50]
            ],
            [
              [6359, 5732],
              [9, 1],
              [13, 9],
              [14, 6],
              [14, 20],
              [10, 0],
              [1, -16],
              [-3, -35],
              [0, -31],
              [-6, -21],
              [-7, -64],
              [-14, -66],
              [-17, -75],
              [-24, -87],
              [-23, -66],
              [-33, -81],
              [-28, -48],
              [-42, -58],
              [-25, -45],
              [-31, -72],
              [-6, -31],
              [-6, -14]
            ],
            [
              [3412, 5410],
              [34, -11],
              [2, 10],
              [23, 4],
              [30, -15]
            ],
            [
              [3489, 5306],
              [10, -35],
              [-4, -25]
            ],
            [
              [5626, 7957],
              [-8, -15],
              [-5, -24]
            ],
            [
              [5380, 7746],
              [7, 5]
            ],
            [
              [5663, 8957],
              [-47, -17],
              [-27, -41],
              [4, -36],
              [-44, -48],
              [-54, -50],
              [-20, -84],
              [20, -41],
              [26, -33],
              [-25, -67],
              [-29, -14],
              [-11, -99],
              [-15, -55],
              [-34, 6],
              [-16, -47],
              [-32, -3],
              [-9, 56],
              [-23, 67],
              [-21, 84]
            ],
            [
              [5890, 3478],
              [-5, -26],
              [-17, -6],
              [-16, 32],
              [0, 20],
              [7, 22],
              [3, 17],
              [8, 5],
              [14, -11]
            ],
            [
              [5999, 7104],
              [-2, 45],
              [7, 25]
            ],
            [
              [6004, 7174],
              [7, 13],
              [7, 13],
              [2, 33],
              [9, -12],
              [31, 17],
              [14, -12],
              [23, 1],
              [32, 22],
              [15, -1],
              [32, 9]
            ],
            [
              [5051, 5420],
              [-22, -12]
            ],
            [
              [7849, 5777],
              [-25, 28],
              [-24, -2],
              [4, 47],
              [-24, 0],
              [-2, -65],
              [-15, -87],
              [-10, -52],
              [2, -43],
              [18, -2],
              [12, -53],
              [5, -52],
              [15, -33],
              [17, -7],
              [14, -31]
            ],
            [
              [7779, 5439],
              [-11, 23],
              [-4, 29],
              [-15, 34],
              [-14, 28],
              [-4, -35],
              [-5, 33],
              [3, 37],
              [8, 56]
            ],
            [
              [6883, 7252],
              [16, 60],
              [-6, 44],
              [-20, 14],
              [7, 26],
              [23, -3],
              [13, 33],
              [9, 38],
              [37, 13],
              [-6, -27],
              [4, -17],
              [12, 2]
            ],
            [
              [6497, 7255],
              [-5, 42],
              [4, 62],
              [-22, 20],
              [8, 40],
              [-19, 4],
              [6, 49],
              [26, -14],
              [25, 19],
              [-20, 35],
              [-8, 34],
              [-23, -15],
              [-3, -43],
              [-8, 38]
            ],
            [
              [6554, 7498],
              [31, 1],
              [-4, 29],
              [24, 21],
              [23, 34],
              [37, -31],
              [3, -47],
              [11, -12],
              [30, 2],
              [9, -10],
              [14, -61],
              [32, -41],
              [18, -28],
              [29, -29],
              [37, -25],
              [-1, -36]
            ],
            [
              [8471, 4532],
              [3, 14],
              [24, 13],
              [19, 2],
              [9, 8],
              [10, -8],
              [-10, -16],
              [-29, -25],
              [-23, -17]
            ],
            [
              [3286, 5693],
              [16, 8],
              [6, -2],
              [-1, -44],
              [-23, -7],
              [-5, 6],
              [8, 16],
              [-1, 23]
            ],
            [
              [5233, 7240],
              [31, 24],
              [19, -7],
              [-1, -30],
              [24, 22],
              [2, -12],
              [-14, -29],
              [0, -27],
              [9, -15],
              [-3, -51],
              [-19, -29],
              [6, -33],
              [14, -1],
              [7, -28],
              [11, -9]
            ],
            [
              [6004, 7174],
              [-11, 27],
              [11, 22],
              [-17, -5],
              [-23, 13],
              [-19, -34],
              [-43, -6],
              [-22, 31],
              [-30, 2],
              [-6, -24],
              [-20, -7],
              [-26, 31],
              [-31, -1],
              [-16, 59],
              [-21, 33],
              [14, 46],
              [-18, 28],
              [31, 56],
              [43, 3],
              [12, 45],
              [53, -8],
              [33, 38],
              [32, 17],
              [46, 1],
              [49, -42],
              [40, -22],
              [32, 9],
              [24, -6],
              [33, 31]
            ],
            [
              [5777, 7539],
              [3, -23],
              [25, -19],
              [-5, -14],
              [-33, -3],
              [-12, -19],
              [-23, -31],
              [-9, 27],
              [0, 12]
            ],
            [
              [8382, 6499],
              [-17, -95],
              [-12, -49],
              [-14, 50],
              [-4, 44],
              [17, 58],
              [22, 45],
              [13, -18],
              [-5, -35]
            ],
            [
              [6088, 4781],
              [-12, -73],
              [1, -33],
              [18, -22],
              [1, -15],
              [-8, -36],
              [2, -18],
              [-2, -28],
              [10, -37],
              [11, -58],
              [10, -13]
            ],
            [
              [5909, 4512],
              [-15, 18],
              [-18, 10],
              [-11, 10],
              [-12, 15]
            ],
            [
              [5844, 4990],
              [10, 8],
              [31, -1],
              [56, 4]
            ],
            [
              [6061, 7840],
              [-22, -5],
              [-18, -19],
              [-26, -3],
              [-24, -22],
              [1, -37],
              [14, -14],
              [28, 4],
              [-5, -21],
              [-31, -11],
              [-37, -34],
              [-16, 12],
              [6, 28],
              [-30, 17],
              [5, 12],
              [26, 19],
              [-8, 14],
              [-43, 15],
              [-2, 22],
              [-25, -8],
              [-11, -32],
              [-21, -44]
            ],
            [
              [3517, 3063],
              [-12, -38],
              [-31, -32],
              [-21, 11],
              [-15, -6],
              [-26, 25],
              [-18, -1],
              [-17, 32]
            ],
            [
              [679, 6185],
              [-4, -10],
              [-7, 8],
              [1, 17],
              [-4, 21],
              [1, 7],
              [5, 10],
              [-2, 11],
              [1, 6],
              [3, -1],
              [10, -10],
              [5, -5],
              [5, -8],
              [7, -21],
              [-1, -3],
              [-11, -13],
              [-9, -9]
            ],
            [
              [664, 6277],
              [-9, -4],
              [-5, 12],
              [-3, 5],
              [0, 4],
              [3, 5],
              [9, -6],
              [8, -9],
              [-3, -7]
            ],
            [
              [646, 6309],
              [-1, -7],
              [-15, 2],
              [2, 7],
              [14, -2]
            ],
            [
              [621, 6317],
              [-2, -3],
              [-2, 1],
              [-9, 2],
              [-4, 13],
              [-1, 2],
              [7, 8],
              [3, -3],
              [8, -20]
            ],
            [
              [574, 6356],
              [-4, -6],
              [-9, 11],
              [1, 4],
              [5, 6],
              [6, -1],
              [1, -14]
            ],
            [
              [3135, 7724],
              [5, -19],
              [-30, -29],
              [-29, -20],
              [-29, -18],
              [-15, -35],
              [-4, -13],
              [-1, -31],
              [10, -32],
              [11, -1],
              [-3, 21],
              [8, -13],
              [-2, -17],
              [-19, -9],
              [-13, 1],
              [-20, -10],
              [-12, -3],
              [-17, -3],
              [-23, -17],
              [41, 11],
              [8, -11],
              [-39, -18],
              [-17, 0],
              [0, 7],
              [-8, -16],
              [8, -3],
              [-6, -43],
              [-20, -45],
              [-2, 15],
              [-6, 3],
              [-9, 15],
              [5, -32],
              [7, -10],
              [1, -23],
              [-9, -23],
              [-16, -47],
              [-2, 3],
              [8, 40],
              [-14, 22],
              [-3, 49],
              [-5, -25],
              [5, -38],
              [-18, 10],
              [19, -19],
              [1, -57],
              [8, -4],
              [3, -20],
              [4, -59],
              [-17, -44],
              [-29, -18],
              [-18, -34],
              [-14, -4],
              [-14, -22],
              [-4, -20],
              [-31, -38],
              [-16, -28],
              [-13, -35],
              [-4, -42],
              [5, -41],
              [9, -51],
              [13, -41],
              [0, -26],
              [13, -69],
              [-1, -39],
              [-1, -23],
              [-7, -36],
              [-8, -8],
              [-14, 7],
              [-4, 26],
              [-11, 14],
              [-15, 51],
              [-13, 45],
              [-4, 23],
              [6, 39],
              [-8, 33],
              [-22, 49],
              [-10, 9],
              [-28, -27],
              [-5, 3],
              [-14, 28],
              [-17, 14],
              [-32, -7],
              [-24, 7],
              [-21, -5],
              [-12, -9],
              [5, -15],
              [0, -24],
              [5, -12],
              [-5, -8],
              [-10, 9],
              [-11, -11],
              [-20, 2],
              [-20, 31],
              [-25, -8],
              [-20, 14],
              [-17, -4],
              [-24, -14],
              [-25, -44],
              [-27, -25],
              [-16, -28],
              [-6, -27],
              [0, -41],
              [1, -28],
              [5, -20]
            ],
            [
              [1746, 6980],
              [-4, 30],
              [-18, 34],
              [-13, 7],
              [-3, 17],
              [-16, 3],
              [-10, 16],
              [-26, 6],
              [-7, 9],
              [-3, 32],
              [-27, 60],
              [-23, 82],
              [1, 14],
              [-13, 19],
              [-21, 50],
              [-4, 48],
              [-15, 32],
              [6, 49],
              [-1, 51],
              [-8, 45],
              [10, 56],
              [4, 53],
              [3, 54],
              [-5, 79],
              [-9, 51],
              [-8, 27],
              [4, 12],
              [40, -20],
              [15, -56],
              [7, 15],
              [-5, 49],
              [-9, 48]
            ],
            [
              [750, 8432],
              [-28, -23],
              [-14, 15],
              [-4, 28],
              [25, 21],
              [15, 9],
              [18, -4],
              [12, -18],
              [-24, -28]
            ],
            [
              [401, 8597],
              [-18, -9],
              [-18, 11],
              [-17, 16],
              [28, 10],
              [22, -6],
              [3, -22]
            ],
            [
              [230, 8826],
              [17, -12],
              [17, 6],
              [23, -15],
              [27, -8],
              [-2, -7],
              [-21, -12],
              [-21, 13],
              [-11, 11],
              [-24, -4],
              [-7, 5],
              [2, 23]
            ],
            [
              [1374, 8295],
              [-15, 22],
              [-25, 19],
              [-8, 52],
              [-36, 47],
              [-15, 56],
              [-26, 4],
              [-44, 2],
              [-33, 17],
              [-57, 61],
              [-27, 11],
              [-49, 21],
              [-38, -5],
              [-55, 27],
              [-33, 25],
              [-30, -12],
              [5, -41],
              [-15, -4],
              [-32, -12],
              [-25, -20],
              [-30, -13],
              [-4, 35],
              [12, 58],
              [30, 18],
              [-8, 15],
              [-35, -33],
              [-19, -39],
              [-40, -42],
              [20, -29],
              [-26, -42],
              [-30, -25],
              [-28, -18],
              [-7, -26],
              [-43, -31],
              [-9, -28],
              [-32, -25],
              [-20, 5],
              [-25, -17],
              [-29, -20],
              [-23, -20],
              [-47, -16],
              [-5, 9],
              [31, 28],
              [27, 18],
              [29, 33],
              [35, 6],
              [14, 25],
              [38, 35],
              [6, 12],
              [21, 21],
              [5, 44],
              [14, 35],
              [-32, -18],
              [-9, 11],
              [-15, -22],
              [-18, 30],
              [-8, -21],
              [-10, 29],
              [-28, -23],
              [-17, 0],
              [-3, 35],
              [5, 21],
              [-17, 22],
              [-37, -12],
              [-23, 28],
              [-19, 14],
              [0, 34],
              [-22, 25],
              [11, 34],
              [23, 33],
              [10, 30],
              [22, 4],
              [19, -9],
              [23, 28],
              [20, -5],
              [21, 19],
              [-5, 27],
              [-16, 10],
              [21, 23],
              [-17, -1],
              [-30, -13],
              [-8, -13],
              [-22, 13],
              [-39, -6],
              [-41, 14],
              [-12, 24],
              [-35, 34],
              [39, 25],
              [62, 29],
              [23, 0],
              [-4, -30],
              [59, 2],
              [-23, 37],
              [-34, 23],
              [-20, 29],
              [-26, 25],
              [-38, 19],
              [15, 31],
              [49, 2],
              [35, 27],
              [7, 29],
              [28, 28],
              [28, 6],
              [52, 27],
              [26, -4],
              [42, 31],
              [42, -12],
              [21, -27],
              [12, 11],
              [47, -3],
              [-2, -14],
              [43, -10],
              [28, 6],
              [59, -18],
              [53, -6],
              [21, -8],
              [37, 10],
              [42, -18],
              [31, -8]
            ],
            [
              [3018, 5753],
              [-1, -14],
              [-16, -7],
              [9, -26],
              [0, -31],
              [-12, -35],
              [10, -47],
              [12, 4],
              [6, 43],
              [-8, 21],
              [-2, 45],
              [35, 24],
              [-4, 27],
              [10, 19],
              [10, -41],
              [19, -1],
              [18, -33],
              [1, -20],
              [25, 0],
              [30, 6],
              [16, -27],
              [21, -7],
              [16, 18],
              [0, 15],
              [34, 4],
              [34, 1],
              [-24, -18],
              [10, -28],
              [22, -4],
              [21, -29],
              [4, -48],
              [15, 2],
              [11, -14]
            ],
            [
              [8001, 6331],
              [-37, -51],
              [-24, -56],
              [-6, -41],
              [22, -62],
              [25, -77],
              [26, -37],
              [17, -47],
              [12, -109],
              [-3, -104],
              [-24, -39],
              [-31, -38],
              [-23, -49],
              [-35, -55],
              [-10, 37],
              [8, 40],
              [-21, 34]
            ],
            [
              [9661, 4085],
              [-9, -8],
              [-9, 26],
              [1, 16],
              [17, -34]
            ],
            [
              [9641, 4175],
              [4, -47],
              [-7, 7],
              [-6, -3],
              [-4, 16],
              [0, 45],
              [13, -18]
            ],
            [
              [6475, 6041],
              [-21, -16],
              [-5, -26],
              [-1, -20],
              [-27, -25],
              [-45, -28],
              [-24, -41],
              [-13, -3],
              [-8, 3],
              [-16, -25],
              [-18, -11],
              [-23, -3],
              [-7, -3],
              [-6, -16],
              [-8, -4],
              [-4, -15],
              [-14, 1],
              [-9, -8],
              [-19, 3],
              [-7, 35],
              [1, 32],
              [-5, 17],
              [-5, 44],
              [-8, 24],
              [5, 3],
              [-2, 27],
              [3, 12],
              [-1, 25]
            ],
            [
              [5817, 3752],
              [11, 0],
              [14, -10],
              [9, 7],
              [15, -6]
            ],
            [
              [5911, 3478],
              [-7, -43],
              [-3, -49],
              [-7, -27],
              [-19, -30],
              [-5, -8],
              [-12, -30],
              [-8, -31],
              [-16, -42],
              [-31, -61],
              [-20, -36],
              [-21, -26],
              [-29, -23],
              [-14, -3],
              [-3, -17],
              [-17, 9],
              [-14, -11],
              [-30, 11],
              [-17, -7],
              [-12, 3],
              [-28, -23],
              [-24, -10],
              [-17, -22],
              [-13, -1],
              [-11, 21],
              [-10, 1],
              [-12, 26],
              [-1, -8],
              [-4, 16],
              [0, 34],
              [-9, 40],
              [9, 11],
              [0, 45],
              [-19, 55],
              [-14, 50],
              [0, 1],
              [-20, 76]
            ],
            [
              [5840, 4141],
              [-21, -8],
              [-15, -23],
              [-4, -21],
              [-10, -4],
              [-24, -49],
              [-15, -38],
              [-10, -2],
              [-9, 7],
              [-31, 7]
            ]
          ],
          "transform": {
            "scale": [0.036003600360036005, 0.016927109510951093],
            "translate": [-180, -85.609038]
          }
        };
        Datamap2.prototype.abwTopo = "__ABW__";
        Datamap2.prototype.afgTopo = "__AFG__";
        Datamap2.prototype.agoTopo = "__AGO__";
        Datamap2.prototype.aiaTopo = "__AIA__";
        Datamap2.prototype.albTopo = "__ALB__";
        Datamap2.prototype.aldTopo = "__ALD__";
        Datamap2.prototype.andTopo = "__AND__";
        Datamap2.prototype.areTopo = "__ARE__";
        Datamap2.prototype.argTopo = "__ARG__";
        Datamap2.prototype.armTopo = "__ARM__";
        Datamap2.prototype.asmTopo = "__ASM__";
        Datamap2.prototype.ataTopo = "__ATA__";
        Datamap2.prototype.atcTopo = "__ATC__";
        Datamap2.prototype.atfTopo = "__ATF__";
        Datamap2.prototype.atgTopo = "__ATG__";
        Datamap2.prototype.ausTopo = "__AUS__";
        Datamap2.prototype.autTopo = "__AUT__";
        Datamap2.prototype.azeTopo = "__AZE__";
        Datamap2.prototype.bdiTopo = "__BDI__";
        Datamap2.prototype.belTopo = "__BEL__";
        Datamap2.prototype.benTopo = "__BEN__";
        Datamap2.prototype.bfaTopo = "__BFA__";
        Datamap2.prototype.bgdTopo = "__BGD__";
        Datamap2.prototype.bgrTopo = "__BGR__";
        Datamap2.prototype.bhrTopo = "__BHR__";
        Datamap2.prototype.bhsTopo = "__BHS__";
        Datamap2.prototype.bihTopo = "__BIH__";
        Datamap2.prototype.bjnTopo = "__BJN__";
        Datamap2.prototype.blmTopo = "__BLM__";
        Datamap2.prototype.blrTopo = "__BLR__";
        Datamap2.prototype.blzTopo = "__BLZ__";
        Datamap2.prototype.bmuTopo = "__BMU__";
        Datamap2.prototype.bolTopo = "__BOL__";
        Datamap2.prototype.braTopo = "__BRA__";
        Datamap2.prototype.brbTopo = "__BRB__";
        Datamap2.prototype.brnTopo = "__BRN__";
        Datamap2.prototype.btnTopo = "__BTN__";
        Datamap2.prototype.norTopo = "__NOR__";
        Datamap2.prototype.bwaTopo = "__BWA__";
        Datamap2.prototype.cafTopo = "__CAF__";
        Datamap2.prototype.canTopo = "__CAN__";
        Datamap2.prototype.cheTopo = "__CHE__";
        Datamap2.prototype.chlTopo = "__CHL__";
        Datamap2.prototype.chnTopo = "__CHN__";
        Datamap2.prototype.civTopo = "__CIV__";
        Datamap2.prototype.clpTopo = "__CLP__";
        Datamap2.prototype.cmrTopo = "__CMR__";
        Datamap2.prototype.codTopo = "__COD__";
        Datamap2.prototype.cogTopo = "__COG__";
        Datamap2.prototype.cokTopo = "__COK__";
        Datamap2.prototype.colTopo = "__COL__";
        Datamap2.prototype.comTopo = "__COM__";
        Datamap2.prototype.cpvTopo = "__CPV__";
        Datamap2.prototype.criTopo = "__CRI__";
        Datamap2.prototype.csiTopo = "__CSI__";
        Datamap2.prototype.cubTopo = "__CUB__";
        Datamap2.prototype.cuwTopo = "__CUW__";
        Datamap2.prototype.cymTopo = "__CYM__";
        Datamap2.prototype.cynTopo = "__CYN__";
        Datamap2.prototype.cypTopo = "__CYP__";
        Datamap2.prototype.czeTopo = "__CZE__";
        Datamap2.prototype.deuTopo = "__DEU__";
        Datamap2.prototype.djiTopo = "__DJI__";
        Datamap2.prototype.dmaTopo = "__DMA__";
        Datamap2.prototype.dnkTopo = "__DNK__";
        Datamap2.prototype.domTopo = "__DOM__";
        Datamap2.prototype.dzaTopo = "__DZA__";
        Datamap2.prototype.ecuTopo = "__ECU__";
        Datamap2.prototype.egyTopo = "__EGY__";
        Datamap2.prototype.eriTopo = "__ERI__";
        Datamap2.prototype.esbTopo = "__ESB__";
        Datamap2.prototype.espTopo = "__ESP__";
        Datamap2.prototype.estTopo = "__EST__";
        Datamap2.prototype.ethTopo = "__ETH__";
        Datamap2.prototype.finTopo = "__FIN__";
        Datamap2.prototype.fjiTopo = "__FJI__";
        Datamap2.prototype.flkTopo = "__FLK__";
        Datamap2.prototype.fraTopo = "__FRA__";
        Datamap2.prototype.froTopo = "__FRO__";
        Datamap2.prototype.fsmTopo = "__FSM__";
        Datamap2.prototype.gabTopo = "__GAB__";
        Datamap2.prototype.psxTopo = "__PSX__";
        Datamap2.prototype.gbrTopo = "__GBR__";
        Datamap2.prototype.geoTopo = "__GEO__";
        Datamap2.prototype.ggyTopo = "__GGY__";
        Datamap2.prototype.ghaTopo = "__GHA__";
        Datamap2.prototype.gibTopo = "__GIB__";
        Datamap2.prototype.ginTopo = "__GIN__";
        Datamap2.prototype.gmbTopo = "__GMB__";
        Datamap2.prototype.gnbTopo = "__GNB__";
        Datamap2.prototype.gnqTopo = "__GNQ__";
        Datamap2.prototype.grcTopo = "__GRC__";
        Datamap2.prototype.grdTopo = "__GRD__";
        Datamap2.prototype.grlTopo = "__GRL__";
        Datamap2.prototype.gtmTopo = "__GTM__";
        Datamap2.prototype.gumTopo = "__GUM__";
        Datamap2.prototype.guyTopo = "__GUY__";
        Datamap2.prototype.hkgTopo = "__HKG__";
        Datamap2.prototype.hmdTopo = "__HMD__";
        Datamap2.prototype.hndTopo = "__HND__";
        Datamap2.prototype.hrvTopo = "__HRV__";
        Datamap2.prototype.htiTopo = "__HTI__";
        Datamap2.prototype.hunTopo = "__HUN__";
        Datamap2.prototype.idnTopo = "__IDN__";
        Datamap2.prototype.imnTopo = "__IMN__";
        Datamap2.prototype.indTopo = "__IND__";
        Datamap2.prototype.ioaTopo = "__IOA__";
        Datamap2.prototype.iotTopo = "__IOT__";
        Datamap2.prototype.irlTopo = "__IRL__";
        Datamap2.prototype.irnTopo = "__IRN__";
        Datamap2.prototype.irqTopo = "__IRQ__";
        Datamap2.prototype.islTopo = "__ISL__";
        Datamap2.prototype.isrTopo = "__ISR__";
        Datamap2.prototype.itaTopo = "__ITA__";
        Datamap2.prototype.jamTopo = "__JAM__";
        Datamap2.prototype.jeyTopo = "__JEY__";
        Datamap2.prototype.jorTopo = "__JOR__";
        Datamap2.prototype.jpnTopo = "__JPN__";
        Datamap2.prototype.kabTopo = "__KAB__";
        Datamap2.prototype.kasTopo = "__KAS__";
        Datamap2.prototype.kazTopo = "__KAZ__";
        Datamap2.prototype.kenTopo = "__KEN__";
        Datamap2.prototype.kgzTopo = "__KGZ__";
        Datamap2.prototype.khmTopo = "__KHM__";
        Datamap2.prototype.kirTopo = "__KIR__";
        Datamap2.prototype.knaTopo = "__KNA__";
        Datamap2.prototype.korTopo = "__KOR__";
        Datamap2.prototype.kosTopo = "__KOS__";
        Datamap2.prototype.kwtTopo = "__KWT__";
        Datamap2.prototype.laoTopo = "__LAO__";
        Datamap2.prototype.lbnTopo = "__LBN__";
        Datamap2.prototype.lbrTopo = "__LBR__";
        Datamap2.prototype.lbyTopo = "__LBY__";
        Datamap2.prototype.lcaTopo = "__LCA__";
        Datamap2.prototype.lieTopo = "__LIE__";
        Datamap2.prototype.lkaTopo = "__LKA__";
        Datamap2.prototype.lsoTopo = "__LSO__";
        Datamap2.prototype.ltuTopo = "__LTU__";
        Datamap2.prototype.luxTopo = "__LUX__";
        Datamap2.prototype.lvaTopo = "__LVA__";
        Datamap2.prototype.macTopo = "__MAC__";
        Datamap2.prototype.mafTopo = "__MAF__";
        Datamap2.prototype.marTopo = "__MAR__";
        Datamap2.prototype.mcoTopo = "__MCO__";
        Datamap2.prototype.mdaTopo = "__MDA__";
        Datamap2.prototype.mdgTopo = "__MDG__";
        Datamap2.prototype.mdvTopo = "__MDV__";
        Datamap2.prototype.mexTopo = "__MEX__";
        Datamap2.prototype.mhlTopo = "__MHL__";
        Datamap2.prototype.mkdTopo = "__MKD__";
        Datamap2.prototype.mliTopo = "__MLI__";
        Datamap2.prototype.mltTopo = "__MLT__";
        Datamap2.prototype.mmrTopo = "__MMR__";
        Datamap2.prototype.mneTopo = "__MNE__";
        Datamap2.prototype.mngTopo = "__MNG__";
        Datamap2.prototype.mnpTopo = "__MNP__";
        Datamap2.prototype.mozTopo = "__MOZ__";
        Datamap2.prototype.mrtTopo = "__MRT__";
        Datamap2.prototype.msrTopo = "__MSR__";
        Datamap2.prototype.musTopo = "__MUS__";
        Datamap2.prototype.mwiTopo = "__MWI__";
        Datamap2.prototype.mysTopo = "__MYS__";
        Datamap2.prototype.namTopo = "__NAM__";
        Datamap2.prototype.nclTopo = "__NCL__";
        Datamap2.prototype.nerTopo = "__NER__";
        Datamap2.prototype.nfkTopo = "__NFK__";
        Datamap2.prototype.ngaTopo = "__NGA__";
        Datamap2.prototype.nicTopo = "__NIC__";
        Datamap2.prototype.niuTopo = "__NIU__";
        Datamap2.prototype.nldTopo = "__NLD__";
        Datamap2.prototype.nplTopo = "__NPL__";
        Datamap2.prototype.nruTopo = "__NRU__";
        Datamap2.prototype.nulTopo = "__NUL__";
        Datamap2.prototype.nzlTopo = "__NZL__";
        Datamap2.prototype.omnTopo = "__OMN__";
        Datamap2.prototype.pakTopo = "__PAK__";
        Datamap2.prototype.panTopo = "__PAN__";
        Datamap2.prototype.pcnTopo = "__PCN__";
        Datamap2.prototype.perTopo = "__PER__";
        Datamap2.prototype.pgaTopo = "__PGA__";
        Datamap2.prototype.phlTopo = "__PHL__";
        Datamap2.prototype.plwTopo = "__PLW__";
        Datamap2.prototype.pngTopo = "__PNG__";
        Datamap2.prototype.polTopo = "__POL__";
        Datamap2.prototype.priTopo = "__PRI__";
        Datamap2.prototype.prkTopo = "__PRK__";
        Datamap2.prototype.prtTopo = "__PRT__";
        Datamap2.prototype.pryTopo = "__PRY__";
        Datamap2.prototype.pyfTopo = "__PYF__";
        Datamap2.prototype.qatTopo = "__QAT__";
        Datamap2.prototype.rouTopo = "__ROU__";
        Datamap2.prototype.rusTopo = "__RUS__";
        Datamap2.prototype.rwaTopo = "__RWA__";
        Datamap2.prototype.sahTopo = "__SAH__";
        Datamap2.prototype.sauTopo = "__SAU__";
        Datamap2.prototype.scrTopo = "__SCR__";
        Datamap2.prototype.sdnTopo = "__SDN__";
        Datamap2.prototype.sdsTopo = "__SDS__";
        Datamap2.prototype.senTopo = "__SEN__";
        Datamap2.prototype.serTopo = "__SER__";
        Datamap2.prototype.sgpTopo = "__SGP__";
        Datamap2.prototype.sgsTopo = "__SGS__";
        Datamap2.prototype.shnTopo = "__SHN__";
        Datamap2.prototype.slbTopo = "__SLB__";
        Datamap2.prototype.sleTopo = "__SLE__";
        Datamap2.prototype.slvTopo = "__SLV__";
        Datamap2.prototype.smrTopo = "__SMR__";
        Datamap2.prototype.solTopo = "__SOL__";
        Datamap2.prototype.somTopo = "__SOM__";
        Datamap2.prototype.spmTopo = "__SPM__";
        Datamap2.prototype.srbTopo = "__SRB__";
        Datamap2.prototype.stpTopo = "__STP__";
        Datamap2.prototype.surTopo = "__SUR__";
        Datamap2.prototype.svkTopo = "__SVK__";
        Datamap2.prototype.svnTopo = "__SVN__";
        Datamap2.prototype.sweTopo = "__SWE__";
        Datamap2.prototype.swzTopo = "__SWZ__";
        Datamap2.prototype.sxmTopo = "__SXM__";
        Datamap2.prototype.sycTopo = "__SYC__";
        Datamap2.prototype.syrTopo = "__SYR__";
        Datamap2.prototype.tcaTopo = "__TCA__";
        Datamap2.prototype.tcdTopo = "__TCD__";
        Datamap2.prototype.tgoTopo = "__TGO__";
        Datamap2.prototype.thaTopo = "__THA__";
        Datamap2.prototype.tjkTopo = "__TJK__";
        Datamap2.prototype.tkmTopo = "__TKM__";
        Datamap2.prototype.tlsTopo = "__TLS__";
        Datamap2.prototype.tonTopo = "__TON__";
        Datamap2.prototype.ttoTopo = "__TTO__";
        Datamap2.prototype.tunTopo = "__TUN__";
        Datamap2.prototype.turTopo = "__TUR__";
        Datamap2.prototype.tuvTopo = "__TUV__";
        Datamap2.prototype.twnTopo = "__TWN__";
        Datamap2.prototype.tzaTopo = "__TZA__";
        Datamap2.prototype.ugaTopo = "__UGA__";
        Datamap2.prototype.ukrTopo = "__UKR__";
        Datamap2.prototype.umiTopo = "__UMI__";
        Datamap2.prototype.uryTopo = "__URY__";
        Datamap2.prototype.usaTopo = { "type": "Topology", "transform": { "scale": [0.03514630243024302, 0.005240860686068607], "translate": [-178.123152, 18.948267] }, "objects": { "usa": { "type": "GeometryCollection", "geometries": [{ "type": "Polygon", "id": "AL", "arcs": [[0, 1, 2, 3, 4]], "properties": { "name": "Alabama" } }, { "type": "MultiPolygon", "id": "AK", "arcs": [[[5]], [[6]], [[7]], [[8]], [[9]], [[10]], [[11]], [[12]], [[13]], [[14]], [[15]], [[16]], [[17]], [[18]], [[19]], [[20]], [[21]], [[22]], [[23]], [[24]], [[25]], [[26]], [[27]], [[28]], [[29]], [[30]], [[31]], [[32]], [[33]], [[34]], [[35]], [[36]], [[37]], [[38]], [[39]], [[40]], [[41]], [[42]], [[43]]], "properties": { "name": "Alaska" } }, { "type": "Polygon", "id": "AZ", "arcs": [[44, 45, 46, 47, 48]], "properties": { "name": "Arizona" } }, { "type": "Polygon", "id": "AR", "arcs": [[49, 50, 51, 52, 53, 54]], "properties": { "name": "Arkansas" } }, { "type": "Polygon", "id": "CA", "arcs": [[55, -47, 56, 57]], "properties": { "name": "California" } }, { "type": "Polygon", "id": "CO", "arcs": [[58, 59, 60, 61, 62, 63]], "properties": { "name": "Colorado" } }, { "type": "Polygon", "id": "CT", "arcs": [[64, 65, 66, 67]], "properties": { "name": "Connecticut" } }, { "type": "Polygon", "id": "DE", "arcs": [[68, 69, 70, 71]], "properties": { "name": "Delaware" } }, { "type": "Polygon", "id": "DC", "arcs": [[72, 73]], "properties": { "name": "District of Columbia" } }, { "type": "Polygon", "id": "FL", "arcs": [[74, 75, -2]], "properties": { "name": "Florida" } }, { "type": "Polygon", "id": "GA", "arcs": [[76, 77, -75, -1, 78, 79]], "properties": { "name": "Georgia" } }, { "type": "MultiPolygon", "id": "HI", "arcs": [[[80]], [[81]], [[82]], [[83]], [[84]]], "properties": { "name": "Hawaii" } }, { "type": "Polygon", "id": "ID", "arcs": [[85, 86, 87, 88, 89, 90, 91]], "properties": { "name": "Idaho" } }, { "type": "Polygon", "id": "IL", "arcs": [[92, 93, 94, 95, 96, 97]], "properties": { "name": "Illinois" } }, { "type": "Polygon", "id": "IN", "arcs": [[98, 99, -95, 100, 101]], "properties": { "name": "Indiana" } }, { "type": "Polygon", "id": "IA", "arcs": [[102, -98, 103, 104, 105, 106]], "properties": { "name": "Iowa" } }, { "type": "Polygon", "id": "KS", "arcs": [[107, 108, -60, 109]], "properties": { "name": "Kansas" } }, { "type": "Polygon", "id": "KY", "arcs": [[110, 111, 112, 113, -96, -100, 114]], "properties": { "name": "Kentucky" } }, { "type": "Polygon", "id": "LA", "arcs": [[115, 116, 117, -52]], "properties": { "name": "Louisiana" } }, { "type": "Polygon", "id": "ME", "arcs": [[118, 119]], "properties": { "name": "Maine" } }, { "type": "MultiPolygon", "id": "MD", "arcs": [[[120]], [[-71, 121, 122, 123, 124, -74, 125, 126, 127]]], "properties": { "name": "Maryland" } }, { "type": "Polygon", "id": "MA", "arcs": [[128, 129, 130, 131, -68, 132, 133, 134]], "properties": { "name": "Massachusetts" } }, { "type": "MultiPolygon", "id": "MI", "arcs": [[[-102, 135, 136]], [[137]], [[138, 139]], [[140]]], "properties": { "name": "Michigan" } }, { "type": "Polygon", "id": "MN", "arcs": [[-107, 141, 142, 143, 144]], "properties": { "name": "Minnesota" } }, { "type": "Polygon", "id": "MS", "arcs": [[-4, 145, -116, -51, 146]], "properties": { "name": "Mississippi" } }, { "type": "Polygon", "id": "MO", "arcs": [[-97, -114, 147, -55, 148, -108, 149, -104]], "properties": { "name": "Missouri" } }, { "type": "Polygon", "id": "MT", "arcs": [[150, 151, -92, 152, 153]], "properties": { "name": "Montana" } }, { "type": "Polygon", "id": "NE", "arcs": [[-105, -150, -110, -59, 154, 155]], "properties": { "name": "Nebraska" } }, { "type": "Polygon", "id": "NV", "arcs": [[156, -48, -56, 157, -88]], "properties": { "name": "Nevada" } }, { "type": "Polygon", "id": "NH", "arcs": [[-135, 158, 159, -120, 160]], "properties": { "name": "New Hampshire" } }, { "type": "Polygon", "id": "NJ", "arcs": [[161, -69, 162, 163]], "properties": { "name": "New Jersey" } }, { "type": "Polygon", "id": "NM", "arcs": [[164, 165, 166, -45, -62]], "properties": { "name": "New Mexico" } }, { "type": "Polygon", "id": "NY", "arcs": [[-133, -67, 167, -164, 168, 169, 170]], "properties": { "name": "New York" } }, { "type": "Polygon", "id": "NC", "arcs": [[171, 172, -80, 173, 174]], "properties": { "name": "North Carolina" } }, { "type": "Polygon", "id": "ND", "arcs": [[175, -154, 176, -143]], "properties": { "name": "North Dakota" } }, { "type": "Polygon", "id": "OH", "arcs": [[177, -115, -99, -137, 178, 179]], "properties": { "name": "Ohio" } }, { "type": "Polygon", "id": "OK", "arcs": [[-149, -54, 180, -165, -61, -109]], "properties": { "name": "Oklahoma" } }, { "type": "Polygon", "id": "OR", "arcs": [[-89, -158, -58, 181, 182]], "properties": { "name": "Oregon" } }, { "type": "Polygon", "id": "PA", "arcs": [[-163, -72, -128, 183, -180, 184, -169]], "properties": { "name": "Pennsylvania" } }, { "type": "MultiPolygon", "id": "RI", "arcs": [[[185, -130]], [[186, -65, -132]]], "properties": { "name": "Rhode Island" } }, { "type": "Polygon", "id": "SC", "arcs": [[187, -77, -173]], "properties": { "name": "South Carolina" } }, { "type": "Polygon", "id": "SD", "arcs": [[-142, -106, -156, 188, -151, -176]], "properties": { "name": "South Dakota" } }, { "type": "Polygon", "id": "TN", "arcs": [[189, -174, -79, -5, -147, -50, -148, -113]], "properties": { "name": "Tennessee" } }, { "type": "Polygon", "id": "TX", "arcs": [[-53, -118, 190, -166, -181]], "properties": { "name": "Texas" } }, { "type": "Polygon", "id": "UT", "arcs": [[191, -63, -49, -157, -87]], "properties": { "name": "Utah" } }, { "type": "Polygon", "id": "VT", "arcs": [[-134, -171, 192, -159]], "properties": { "name": "Vermont" } }, { "type": "MultiPolygon", "id": "VA", "arcs": [[[193, -123]], [[120]], [[-126, -73, -125, 194, -175, -190, -112, 195]]], "properties": { "name": "Virginia" } }, { "type": "MultiPolygon", "id": "WA", "arcs": [[[-183, 196, -90]], [[197]], [[198]]], "properties": { "name": "Washington" } }, { "type": "Polygon", "id": "WV", "arcs": [[-184, -127, -196, -111, -178]], "properties": { "name": "West Virginia" } }, { "type": "Polygon", "id": "WI", "arcs": [[199, -93, -103, -145, 200, -140]], "properties": { "name": "Wisconsin" } }, { "type": "Polygon", "id": "WY", "arcs": [[-189, -155, -64, -192, -86, -152]], "properties": { "name": "Wyoming" } }] } }, "arcs": [[[2632, 3060], [5, -164], [7, -242], [4, -53], [3, -30], [-2, -19], [4, -11], [-5, -25], [0, -24], [-2, -32], [2, -57], [-2, -51], [3, -52]], [[2649, 2300], [-14, -1], [-59, 0], [-1, -25], [6, -37], [-1, -31], [2, -16], [-4, -28]], [[2578, 2162], [-4, -6], [-7, 31], [-1, 47], [-2, 6], [-3, -36], [-1, -34], [-7, 9]], [[2553, 2179], [-2, 291], [6, 363], [4, 209], [-3, 20]], [[2558, 3062], [24, 1], [50, -3]], [[1324, 6901], [1, 32], [6, -19], [-1, -32], [-8, 4], [2, 15]], [[1317, 6960], [5, -23], [-3, -33], [-2, 11], [0, 45]], [[1285, 7153], [6, 5], [3, -8], [-1, -28], [-6, -6], [-5, 17], [3, 20]], [[1267, 7137], [12, -7], [3, -36], [13, -41], [4, -25], [0, -21], [3, -4], [1, -27], [5, -27], [0, -25], [3, 8], [2, -19], [1, -74], [-3, -17], [-7, 3], [-3, 38], [-2, -3], [-6, 28], [-2, -10], [-5, 10], [1, -28], [5, 7], [3, -10], [-2, -39], [-5, 4], [-9, 49], [-2, 25], [1, 26], [-7, -2], [0, 20], [5, 2], [5, 18], [-2, 31], [-6, 7], [-1, 50], [-2, 25], [-4, -18], [-2, 28], [4, 14], [-3, 32], [2, 8]], [[1263, 6985], [5, -12], [4, 15], [4, -7], [-4, -28], [-6, 8], [-3, 24]], [[1258, 7247], [-4, 19], [5, 13], [15, -18], [7, 1], [5, -36], [9, -29], [-1, -22], [-5, -11], [-6, 5], [-5, -14], [-6, 9], [-7, -9], [-1, 45], [0, 30], [-5, 1], [-1, 16]], [[1252, 7162], [-4, 14], [-4, 32], [0, 24], [3, 11], [4, -11], [0, 20], [12, -35], [1, -33], [-4, -5], [-3, -37], [3, -11], [-3, -43], [-5, 9], [0, -27], [-3, 13], [-2, 54], [5, 25]], [[1207, 7331], [8, 38], [3, -16], [7, -13], [6, -2], [0, -30], [6, -99], [0, -85], [-1, -22], [-4, 13], [-10, 84], [-7, 25], [3, 20], [-3, 48], [-8, 39]], [[1235, 7494], [10, -15], [5, 2], [0, -14], [8, -52], [-5, 8], [-2, -18], [6, -27], [2, -48], [-6, -13], [-2, -16], [-10, -35], [-3, 1], [-1, 37], [2, 22], [-1, 32], [-3, 40], [0, 21], [-2, 51], [-4, 22], [-1, 38], [7, -36]], [[1203, 7324], [4, 0], [4, -35], [-2, -24], [-6, -5], [0, 38], [0, 26]], [[1207, 7331], [-5, 7], [-3, 26], [-6, 18], [-5, 37], [-6, 17], [1, 30], [4, 10], [1, 26], [3, -11], [8, -1], [6, 17], [8, -23], [-5, -26], [2, -9], [4, 28], [10, -9], [5, -21], [-3, -38], [3, -3], [3, -50], [-7, -7], [-14, 41], [0, -42], [-4, -17]], [[883, 7871], [-12, -48], [-1, -19], [-9, -12], [2, 29], [10, 30], [7, 34], [3, -14]], [[870, 7943], [-2, -39], [-4, -41], [-6, 14], [5, 47], [7, 19]], [[863, 9788], [3, -8], [15, -9], [8, 5], [10, 0], [12, -7], [7, 4], [7, -15], [12, -18], [16, -4], [5, 10], [11, 6], [4, 14], [12, 2], [0, -9], [7, 5], [15, -15], [9, -24], [10, -11], [2, -11], [8, -2], [8, -18], [1, -11], [5, 9], [6, -7], [0, -1783], [13, -16], [2, 17], [14, -24], [8, 30], [18, 4], [-3, -52], [4, -17], [10, -17], [2, -27], [29, -101], [4, -63], [6, 17], [12, 31], [7, 1], [3, 23], [0, 34], [5, 0], [1, 31], [9, 7], [13, 26], [13, -45], [-1, -27], [3, -27], [7, -7], [10, -40], [-1, -12], [4, -22], [12, -25], [19, -110], [3, -29], [6, -29], [8, -65], [9, -55], [-3, -23], [9, -9], [-2, -33], [7, -14], [1, -38], [7, 2], [14, -40], [9, -7], [5, -19], [4, -5], [1, -19], [9, -5], [3, -23], [-4, -43], [1, -36], [4, -58], [-4, -15], [-6, -53], [-10, -39], [-3, 20], [-4, -6], [-3, 39], [1, 17], [-3, 20], [7, 21], [-2, 7], [-7, -26], [-3, 17], [-4, -10], [-12, 42], [4, 46], [-8, -15], [0, -23], [-6, 17], [-1, 22], [4, 24], [-1, 24], [-6, -19], [-6, 42], [-3, -8], [-2, 36], [5, 23], [6, 0], [-2, 28], [3, 36], [-5, -1], [-9, 32], [-6, 37], [-15, 27], [0, 77], [-4, 9], [1, 31], [-5, 9], [-8, 42], [-2, 22], [-12, 7], [-14, 56], [-6, 132], [-3, -30], [1, -27], [6, -53], [-1, -8], [3, -43], [0, -28], [-6, 6], [-4, 31], [-6, 6], [-8, -9], [0, 45], [-5, 38], [-5, -12], [-17, 40], [-2, -11], [10, -13], [7, -31], [3, -1], [1, -25], [4, -30], [-10, -16], [-5, 10], [0, -26], [-8, 20], [-2, 14], [-5, 0], [-13, 38], [-10, 33], [-1, 20], [-5, 30], [-14, 21], [-9, 21], [-14, 26], [-9, 24], [1, 26], [2, -9], [3, 17], [-3, 38], [4, 21], [-2, 9], [-7, -40], [-14, -26], [-18, 10], [-14, 24], [-1, 18], [-7, -4], [-7, 14], [-17, 12], [-9, 1], [-21, -10], [-8, -7], [-10, 27], [-12, 12], [-3, 17], [-2, 28], [-8, -2], [-3, -25], [-15, 34], [-2, 14], [-15, -27], [-7, -32], [-3, 30], [3, 17], [4, -5], [14, 22], [-2, 17], [-6, -8], [-3, 22], [-6, 3], [-6, 55], [-3, -13], [-8, -8], [-3, 8], [-3, -18], [-11, 6], [-1, -20], [-7, -5], [-3, 7], [2, 36], [-3, -1], [-5, -38], [7, -12], [1, -27], [4, -30], [-3, -31], [-5, 10], [-2, -15], [6, -7], [3, -41], [-8, -9], [-4, 9], [-7, -12], [-3, 10], [-9, -2], [0, 16], [-4, -10], [-3, -20], [-3, 18], [-5, -25], [2, -12], [-6, -15], [-6, -2], [-3, -20], [-6, -17], [-4, 6], [-5, -21], [-4, 1], [-8, -43], [-9, -3], [-3, 14], [-5, -23], [-11, 17], [2, 33], [8, 11], [4, -2], [2, 13], [8, 25], [0, 21], [-11, -28], [-9, 16], [-1, 12], [5, 48], [8, 34], [1, 29], [2, 5], [1, 30], [-4, 34], [10, 12], [19, 48], [4, -19], [6, -5], [9, 20], [-10, 26], [-4, 20], [-7, -2], [-5, 9], [-2, -8], [-9, -14], [-4, -26], [-9, -6], [-9, -30], [-1, -20], [-7, -11], [-2, -22], [-5, -13], [-2, -39], [-10, -25], [5, -20], [-4, -29], [-9, -5], [-1, -38], [-8, -13], [-3, 15], [-4, -29], [-5, -1], [1, -21], [-11, -13], [-2, -57], [12, -3], [10, -16], [3, -19], [-4, -30], [-7, -19], [-6, -1], [0, -17], [-4, -6], [1, -21], [-4, -31], [-9, -29], [-5, 0], [-5, -11], [-5, 2], [-4, -11], [2, -16], [-7, -8], [-2, -23], [-5, 14], [-5, -45], [-9, 4], [1, -24], [-6, 6], [-3, -11], [0, -32], [-6, -50], [-10, -6], [-7, -23], [-2, -13], [-5, 18], [-8, -48], [-2, 13], [-5, -4], [-1, -27], [-5, -10], [-6, 4], [-4, -27], [8, -9], [-9, -60], [-25, -20], [-6, -54], [-2, 12], [1, 33], [-5, 6], [-6, -13], [-1, -14], [-10, -22], [-4, -25], [-1, 18], [-2, -21], [-6, 14], [-10, -33], [-8, 2], [1, 25], [-4, 24], [-3, -20], [1, -21], [-11, -64], [-3, 16], [-1, -24], [-8, 4], [-1, 38], [-4, 8], [-2, -14], [4, -16], [-2, -27], [-5, -13], [-5, 29], [-5, 2], [-1, -11], [5, -17], [-9, -27], [6, -7], [0, -13], [-5, 9], [-7, -25], [-15, 1], [-7, -16], [0, -13], [-8, -15], [-6, 6], [-2, 35], [6, 12], [4, 43], [6, 1], [13, 28], [10, 1], [4, -27], [3, 20], [-1, 23], [6, 10], [7, 0], [8, 50], [10, 45], [12, 40], [15, 18], [6, -9], [6, 12], [1, -17], [-3, -19], [4, -14], [1, 23], [7, 2], [2, -15], [5, -5], [0, 18], [-8, 15], [0, 11], [5, 49], [6, 28], [9, 27], [15, 24], [10, 35], [5, -13], [4, 5], [-1, 22], [1, 21], [8, 44], [11, 28], [8, 38], [0, 21], [7, 148], [11, 40], [-1, 31], [-27, -45], [-8, 6], [-2, 18], [-5, 9], [-1, 21], [-4, -10], [-3, -32], [5, -41], [-6, -18], [-5, 7], [-9, 64], [-6, 33], [-4, 0], [-2, -24], [-3, -4], [-4, 19], [-5, 4], [-2, 32], [-16, -37], [-13, -26], [-1, -14], [-11, -22], [-6, 20], [5, 23], [-1, 54], [-4, 57], [7, 24], [-6, 49], [-5, 27], [-4, 39], [-6, 17], [-2, -34], [-7, -8], [-12, -22], [-14, -9], [-7, 2], [-7, 12], [-1, 30], [-5, 9], [-9, 42], [-8, 8], [-8, 46], [6, 21], [1, 39], [-5, -8], [0, 24], [2, 19], [-6, 18], [0, -19], [-7, 8], [-1, 32], [-6, 4], [-3, 22], [0, 27], [-5, -12], [-1, 26], [7, 6], [-6, 30], [10, 2], [0, 35], [2, 24], [18, 77], [4, 23], [3, -5], [-2, 33], [7, 55], [6, 22], [11, 9], [8, -9], [12, -33], [8, 4], [11, 32], [11, 49], [6, 6], [1, -13], [13, 0], [12, 10], [11, 52], [0, 12], [-5, 48], [-1, 28], [-8, 31], [-3, 26], [8, -7], [8, 22], [0, 20], [-10, 39], [-8, -30], [-7, 5], [-6, -17], [-8, -4], [-2, -11], [-9, -17], [-2, -28], [-5, -12], [-2, 34], [-5, 7], [-4, -26], [-2, 12], [-10, 19], [-20, -1], [-14, -21], [-6, -3], [-11, 13], [-22, 14], [-6, 12], [-3, 19], [2, 26], [-8, 22], [2, 24], [5, 12], [-2, 31], [-8, 0], [-6, 8], [-13, 6], [-7, 16], [-10, 16], [-1, 19], [16, 27], [20, 43], [15, 27], [8, -15], [8, -3], [2, 21], [-5, 3], [-1, 18], [20, 29], [22, 22], [12, 2], [7, -7], [-4, -32], [2, -22], [-3, -15], [4, -26], [8, 5], [10, -5], [11, 6], [4, -10], [7, -2], [7, 10], [8, -11], [9, 42], [5, 2], [5, -8], [2, 24], [-12, 11], [-11, -9], [1, 31], [-8, 34], [-10, 10], [-2, 30], [7, 8], [9, -31], [-1, -24], [4, -18], [10, -22], [2, 23], [-11, 30], [5, 54], [-4, 10], [-11, -12], [-11, 3], [-2, 10], [-6, -10], [-24, 23], [0, 24], [-7, 54], [-6, 19], [-9, 17], [-19, 46], [-9, 18], [-8, 4], [-13, 31], [-12, 18], [-1, 6], [9, 10], [4, 29], [1, 59], [25, -4], [31, 13], [8, 11], [12, 29], [12, 45], [3, 45], [5, 38], [10, 33], [5, 24], [13, 38], [2, -10], [11, -3], [16, 20], [10, 21], [24, 64], [9, 4], [1, -10], [9, 7], [9, -2], [18, 9], [17, 28], [17, 58], [7, 13], [2, -10], [26, -24], [2, -17], [-9, -22], [-4, -1], [0, -29], [14, 9], [0, 16], [6, 14], [2, -8], [5, 33], [13, -30], [-2, -23], [8, -6], [5, -14], [7, 22], [13, 1], [7, 7], [18, -7], [10, -8], [-5, -45], [17, -12], [2, -11], [16, -20], [1, 9], [12, 13], [11, -1], [0, -11], [7, -1], [7, 15], [11, 2], [9, -6], [11, -16], [5, 3], [7, -22], [4, 9], [7, -7], [5, -13]], [[717, 7456], [-1, -8], [-9, 13], [7, 49], [6, 4], [4, 45], [5, -40], [4, 14], [8, -22], [0, -31], [-11, -4], [-5, -13], [-8, -7]], [[688, 7363], [8, 25], [-8, 6], [0, 22], [6, 14], [5, -10], [0, -22], [3, 15], [0, 32], [5, -15], [1, 21], [5, -12], [5, 0], [5, 11], [7, -20], [0, -55], [9, 4], [-6, -37], [-11, 15], [4, -24], [-3, -20], [-6, 10], [0, -38], [-8, -10], [-3, -16], [-5, 15], [-6, -40], [-4, -4], [-5, -18], [-2, 43], [-6, -23], [-1, 13], [-6, 14], [0, 39], [-6, 15], [4, 45], [11, 28], [7, -2], [1, -21]], [[671, 7185], [-6, -39], [-2, 6], [8, 33]], [[640, 7055], [4, -2], [-1, -40], [-8, 6], [-1, 13], [6, 23]], [[519, 6933], [-2, -41], [-9, -33], [5, 51], [2, -5], [4, 28]], [[501, 6947], [5, 0], [0, -20], [-5, -23], [-5, 15], [-3, -14], [-2, 35], [2, 12], [8, -5]], [[451, 6875], [1, -16], [-3, -11], [-3, 18], [5, 9]], [[447, 8527], [-4, -19], [-2, 16], [6, 3]], [[436, 6781], [6, -7], [-1, -16], [-5, 1], [0, 22]], [[358, 6745], [2, -22], [-5, -10], [-1, 23], [4, 9]], [[352, 6718], [-8, -21], [-2, 14], [3, 19], [7, -12]], [[335, 7902], [6, 7], [2, -14], [5, 3], [6, -12], [1, -54], [-3, -18], [-7, -11], [-2, -18], [-11, 20], [-5, -1], [-10, 28], [-4, 0], [-6, 15], [-3, 25], [4, 7], [10, -7], [5, 20], [5, 2], [3, 14], [4, -6]], [[334, 6690], [5, -14], [-10, -36], [1, -6], [12, 26], [0, -15], [-5, -17], [-8, -12], [-1, -18], [-8, -18], [-7, -1], [-5, -18], [-9, -16], [-5, 17], [9, 20], [3, -3], [8, 16], [-2, 19], [4, 20], [6, -9], [1, 12], [-7, 4], [-4, 14], [4, 23], [11, 13], [2, -26], [5, 25]], [[266, 6527], [10, 37], [1, 16], [4, 17], [7, 9], [3, -10], [1, -25], [-12, -27], [-6, -40], [-6, -13], [-2, 36]], [[238, 6477], [2, -19], [-8, -1], [-1, 13], [7, 7]], [[227, 7303], [-4, -18], [-1, 18], [5, 0]], [[212, 6440], [2, -18], [-5, -13], [-1, 19], [4, 12]], [[182, 8542], [22, -28], [13, 24], [6, -2], [5, -14], [2, -23], [11, -12], [4, -12], [15, -5], [8, -8], [-4, -28], [-7, 6], [-8, -5], [-4, -13], [-4, -28], [-5, 26], [-6, 18], [-6, 2], [-3, 20], [-15, 25], [-6, 1], [-11, -22], [-7, 11], [-4, 23], [4, 44]], [[162, 6381], [0, -22], [-5, -4], [1, 19], [4, 7]], [[128, 6335], [4, -8], [10, 1], [1, -7], [-13, -9], [-2, 23]], [[108, 6360], [0, 19], [4, 7], [6, -19], [-2, -17], [-4, 1], [1, -20], [-5, -2], [-12, -21], [-6, 6], [2, 15], [7, -2], [9, 33]], [[47, 6279], [5, 3], [0, -24], [-6, 3], [-8, -28], [-4, 37], [4, 1], [0, 29], [5, 1], [0, -21], [4, -1]], [[28, 6296], [3, -9], [-2, -32], [-5, -10], [0, 20], [4, 31]], [[0, 6291], [5, -1], [4, -23], [-4, -27], [-5, 51]], [[9993, 6496], [6, -13], [0, -19], [-11, -12], [-8, 31], [0, 15], [13, -2]], [[1966, 3444], [-1, -1081]], [[1965, 2363], [-57, 0], [-34, 71], [-73, 150], [3, 43]], [[1804, 2627], [6, 8], [1, 16], [-1, 36], [-4, 1], [-2, 71], [6, 27], [0, 28], [-1, 45], [4, 34], [4, 12], [4, 25], [-6, 27], [-4, 51], [-5, 31], [0, 24]], [[1806, 3063], [2, 26], [0, 36], [-3, 36], [-2, 112], [11, 7], [3, -23], [3, 1], [3, 33], [0, 153]], [[1823, 3444], [101, 2], [42, -2]], [[2515, 3253], [-1, -35], [-4, -11], [-1, -29], [-5, -31], [0, -46], [-3, -34], [-3, -5]], [[2498, 3062], [2, -17], [-4, -14], [-2, -33], [-3, -8], [0, -38], [-5, -10], [0, -13], [-6, -31], [2, -21], [-5, -30], [-5, -59], [5, -25], [-2, -16], [1, -39], [-2, -26]], [[2474, 2682], [-69, 3], [-13, 0]], [[2392, 2685], [0, 101], [-4, 8], [-5, -9], [-3, 18]], [[2380, 2803], [1, 335], [-5, 211]], [[2376, 3349], [4, 0], [123, -1], [2, -36], [-4, -23], [-4, -36], [18, 0]], [[1654, 4398], [0, -331], [0, -241], [36, -171], [35, -169], [27, -137], [20, -101], [34, -185]], [[1804, 2627], [-38, -18], [-30, -16], [-4, 25], [0, 40], [-2, 47], [-4, 33], [-9, 46], [-12, 43], [-2, -12], [-4, 8], [1, 18], [-5, 39], [-7, -8], [-12, 28], [-2, 23], [-8, 28], [-9, -1], [-7, 13], [-10, -6], [-5, 26], [1, 53], [-1, 8], [1, 38], [-8, 28], [0, 39], [-3, 2], [-4, 33], [-4, 8], [-1, 20], [-11, 79], [-5, 23], [-1, 61], [2, -5], [2, 37], [-4, 33], [-5, -4], [-7, 30], [-2, 24], [0, 23], [-3, 31], [0, 50], [5, 0], [-2, 70], [-2, -7], [-1, -35], [-5, -7], [-7, 26], [-1, 45], [-4, 35], [-6, 22], [-3, 25], [-9, 50], [2, 14], [-4, 64], [2, 35], [-3, 54], [-7, 52], [-7, 29], [-2, 35], [7, 83], [2, 29], [-2, 22], [3, 57], [-2, 52], [-3, 13], [1, 42]], [[1534, 4399], [28, 1], [24, 1], [38, -3], [30, 0]], [[2107, 4208], [57, 0], [0, -191]], [[2164, 4017], [1, -574]], [[2165, 3443], [-28, 1]], [[2137, 3444], [-38, -1], [-72, 0], [-15, 1], [-46, 0]], [[1966, 3444], [0, 223], [-1, 21], [0, 162], [0, 357]], [[1965, 4207], [32, 1], [63, -1], [47, 1]], [[3025, 4400], [0, -113], [-2, -18]], [[3023, 4269], [-2, 3], [-12, -14], [-15, 4], [-7, -26], [-7, -9], [-8, -22]], [[2972, 4205], [-2, 22], [7, 21], [-2, 16], [2, 144]], [[2977, 4408], [12, -2], [36, -3], [0, -3]], [[2922, 3980], [-2, -23]], [[2920, 3957], [-3, -13], [0, -30], [5, -29], [1, -47], [6, -49], [3, -2], [1, -66]], [[2933, 3721], [-19, 2], [-2, 241]], [[2912, 3964], [5, 21], [5, -5]], [[2876, 3786], [-2, 27]], [[2874, 3813], [2, 12], [4, -19], [-4, -20]], [[2649, 2300], [4, -55], [39, -13], [37, -14], [1, -41], [4, 1], [1, 39], [-1, 35], [2, 15], [7, -16], [8, -7]], [[2751, 2244], [1, -83], [4, -93], [8, -122], [13, -131], [-2, -9], [1, -61], [5, -68], [8, -137], [2, -42], [0, -44], [-3, -158], [-3, -3], [-3, -49], [1, -16], [-5, -36], [-2, 9], [-6, -15], [-9, -8], [-2, 20], [1, 29], [-7, 85], [-5, 15], [-4, -11], [-3, 47], [-1, 38], [-6, 43], [-2, 28], [1, 41], [-3, 8], [1, -24], [-3, -7], [-9, 104], [-4, 26], [9, 76], [-6, -4], [-4, -24], [-3, 38], [5, 104], [1, 87], [-4, 21], [-1, 28], [-5, 6], [-7, 46], [-5, 19], [0, 28], [-4, 11], [-3, 31], [-11, 42], [-9, -10], [0, -29], [-3, 5], [-12, -35], [-12, -9], [0, 21], [-3, 25], [-15, 57], [-10, 24], [-10, 6], [-8, -4], [-17, -18]], [[2703, 3063], [-6, -41], [0, -20], [9, -40], [3, 3], [5, -42], [1, -22], [4, -40], [7, -24], [3, -35], [8, -33], [0, -22], [5, -35], [7, -29], [2, -32], [1, -40], [3, -14], [5, -51], [0, -33], [7, -16]], [[2767, 2497], [-7, -65], [-2, -34], [-3, -29], [0, -30], [-3, -14], [-1, -81]], [[2632, 3060], [37, 1]], [[2669, 3061], [20, -1], [14, 3]], [[640, 0], [-7, 17], [-1, 16], [1, 43], [-5, 73], [4, 24], [2, 34], [-2, 22], [1, 23], [8, -27], [9, -20], [5, -29], [0, -26], [8, -40], [-5, -34], [-8, -15], [-7, -25], [-3, -36]], [[613, 397], [3, -26], [4, 11], [9, -30], [-1, -27], [-9, -14], [-2, 6], [-1, 33], [-5, 7], [-1, 19], [3, 21]], [[602, 432], [-3, -20], [-7, 0], [2, 22], [8, -2]], [[574, 525], [3, -45], [-2, -26], [-6, -5], [-4, 54], [4, 1], [5, 21]], [[531, 626], [3, -2], [2, -20], [-1, -28], [-4, -18], [-9, 22], [1, 31], [8, 15]], [[1908, 4871], [0, -472]], [[1908, 4399], [-31, -1], [-54, 0]], [[1823, 4398], [-85, 1]], [[1738, 4399], [0, 349], [4, 62], [-2, 16], [-6, 3], [-2, 26], [6, 68], [3, 6], [3, 29], [-1, 17], [4, 23], [1, 34], [6, 56], [-2, 26], [-7, 14], [-4, 32]], [[1741, 5160], [0, 34], [-3, 33], [0, 16], [0, 255], [0, 236]], [[1738, 5734], [28, 0]], [[1766, 5734], [0, -195], [9, -54], [1, -52], [5, -23], [6, -8], [0, -14], [11, -51], [1, -21], [8, -20], [0, -12], [8, 1], [-4, -71], [-1, -45], [3, -29], [-5, -21], [2, -20], [-1, -21], [6, -20], [7, 26], [3, 21], [5, -19], [-1, -15], [3, -37], [5, -39], [3, -13], [0, -37], [3, -16], [6, -2], [4, -61], [3, -11], [3, 18], [9, -1], [7, 17], [3, -10], [7, 9], [2, -11], [5, 8], [7, 39], [4, -33], [5, -20]], [[2489, 4496], [53, -3], [28, 0]], [[2570, 4493], [-1, -37], [4, -43], [5, -70]], [[2578, 4343], [0, -450], [-3, -35], [3, -40], [1, -34], [-4, -27], [-1, -25], [-5, -41], [-3, -3], [0, -24], [-2, -9], [-1, -45], [0, -13]], [[2563, 3597], [-3, -27], [2, -34], [-11, -17], [-1, -20], [2, -25], [-3, -16], [-11, 29], [-3, -2], [-4, -33], [1, -11]], [[2532, 3441], [-5, 2], [-6, 55], [2, 12], [-2, 37], [0, 29], [-9, 41], [-3, -4], [-3, 25], [-9, 38], [0, 31], [5, 49], [-1, 18], [3, 23], [-4, 13], [-6, 9], [-3, -18], [-3, 11], [-1, 63], [-10, 41], [-9, 49], [-3, 58], [-1, 39], [3, 27]], [[2467, 4089], [0, 35], [8, 21], [1, 29], [4, 19], [0, 33], [-4, 27], [2, 34], [11, 9], [9, 24], [0, 29], [4, 13], [1, 37], [0, 24], [-7, 18], [-1, 20], [-6, 35]], [[2655, 4340], [0, -228], [0, -266]], [[2655, 3846], [-2, -9], [2, -52], [-5, -1], [-5, -18], [-8, 9], [1, -38], [-5, -16], [-2, -24], [-5, -9], [-3, -48], [-3, -13], [-6, 18], [-1, 22], [-7, -24], [1, -21], [-7, -7], [-1, 19], [-8, -19], [-2, -20], [-7, 28], [-4, -6], [-2, 13], [-3, -13], [-7, -2], [-3, -18]], [[2578, 4343], [3, -12], [8, 0], [9, 22]], [[2598, 4353], [23, 0], [34, 0], [0, -13]], [[2473, 4685], [0, -28], [4, -19], [-3, -23], [1, -43], [2, -30], [10, -22], [2, -24]], [[2467, 4089], [-3, 7], [-6, 38], [-3, -1], [-40, -5], [-39, -2], [-33, 3]], [[2343, 4129], [-3, 25], [2, 49], [-3, 43], [0, 48], [-5, 17], [-1, 26], [2, 23], [-2, 33], [-4, 13], [-5, 86]], [[2324, 4492], [-5, 41], [2, 29], [1, 37], [2, 14], [-3, 19], [1, 33], [-2, 16], [4, 4]], [[2324, 4685], [144, 0], [5, 0]], [[2356, 4017], [3, -18], [9, -14], [-6, -56], [4, -18], [4, -45], [6, -10], [0, -412]], [[2376, 3444], [-156, 0], [-55, -1]], [[2164, 4017], [5, 0], [187, 0]], [[2718, 3716], [-1, -57], [4, -37], [4, -28], [2, -22], [5, -22], [4, -3]], [[2736, 3547], [-11, -51], [-11, -29], [0, -14], [-4, -13], [0, -16], [-6, -8], [-1, -21], [-16, -27]], [[2687, 3368], [0, -3], [-24, 2], [-22, 6], [-5, -2], [-32, 8], [-36, -5], [-6, 9], [1, -35], [-36, 2], [-3, -2]], [[2524, 3348], [1, 24], [5, -8], [2, 77]], [[2655, 3846], [11, 0], [5, -40], [1, -17], [9, -7], [6, -26], [5, 13], [10, -14], [4, 19], [4, 6], [1, -32], [3, -6], [4, -26]], [[2474, 2682], [3, -22], [-2, -9], [-1, -38], [5, -24], [0, -57], [-3, -44], [-7, -27], [-2, -43], [-2, 4], [-1, -70], [-3, -2], [2, -37], [-2, -14], [54, 0], [-3, -63], [4, -41], [1, -32], [4, -20]], [[2521, 2143], [-9, -26], [0, -19], [7, -12], [3, 30], [6, -30], [-1, -24], [-3, -11], [-7, 10], [1, -18], [-2, -27], [5, -24], [9, -7], [3, -29], [3, -4], [-5, -32], [-5, 6], [-4, 33], [-10, 18], [0, 33], [-6, -11], [1, -27], [-3, -25], [-3, -4], [-3, 28], [-7, 1], [-2, -29], [-4, -9], [-5, 18], [-4, 2], [-3, 47], [-7, 21], [-2, -3], [-3, 40], [-7, -5], [0, 24], [-8, -23], [1, -18], [-5, -17], [-9, 8], [-10, 27], [-7, 11], [-16, -9], [-2, -8]], [[2398, 2049], [-2, 19], [6, 68], [-2, 37], [2, 20], [-1, 26], [3, 19], [3, 50], [0, 40], [-8, 78], [0, 41], [-7, 42], [0, 196]], [[3046, 5029], [12, 26], [-2, 13], [5, 30], [4, 13], [-1, 12], [5, 18], [-1, 33], [2, 50], [5, 17], [1, 53], [22, 147], [6, -7], [0, -35], [4, -13], [9, 21], [6, 0], [4, 14], [8, -31], [4, -25], [1, -214], [-1, -51], [10, -14], [-2, -22], [3, -21], [-2, -18], [4, -30], [5, 7], [5, -68], [-6, -31], [-3, 12], [-3, -21], [-4, 5], [0, -18], [-6, 2], [-8, -40], [-2, 28], [-3, 2], [1, -30], [-6, -15], [-2, 24], [-3, -12], [-7, 0], [0, 28], [-5, -6], [1, -20], [-4, -42], [1, -12], [-6, -23], [-5, 9], [-3, -24], [-4, -3], [-4, -20], [-4, 4], [-1, 21], [-7, -34], [2, -21], [-5, -7], [0, -18], [-5, -22], [-5, -50]], [[3056, 4600], [-3, 14], [0, 19], [-4, 22], [-2, 250], [-1, 124]], [[2904, 3626], [2, 0], [-1, 0], [-1, 0]], [[2933, 3721], [-6, -80]], [[2927, 3641], [-4, -3], [-8, -12]], [[2915, 3626], [-6, -8], [0, 31], [-2, 13], [3, 13], [-4, 32], [-2, -14], [-6, 3], [-2, 35], [2, 0], [0, 45], [2, 18], [-2, 60], [3, 36], [5, 6], [0, 37], [-3, -5], [0, -18], [-8, -25], [-2, -21], [0, -56], [-3, -26], [1, -44], [4, -30], [-1, -23], [3, -23], [-2, -16], [-6, 30], [-10, 15], [-2, 29], [-6, -16], [-2, 23], [5, 29]], [[2874, 3756], [2, 30]], [[2874, 3813], [-4, 18], [-6, 10], [0, 28], [-3, 15], [-4, 4]], [[2857, 3888], [-4, 53], [-4, 0], [-5, 18], [-3, -15], [-5, 1], [-1, -21], [-8, 14], [-6, -28], [-3, 6], [-6, -33], [-6, -17], [1, 98]], [[2807, 3964], [105, 0]], [[3053, 4565], [1, -34], [-1, -27], [-5, -25], [0, -29], [6, -4], [4, -31], [0, -24], [3, -6], [0, -22], [8, -19], [9, 18], [-2, -26], [-13, -23], [-5, -1], [-3, 18], [-5, -6], [0, -13], [-5, -9]], [[3045, 4302], [-3, 35]], [[3042, 4337], [0, 6]], [[3042, 4343], [-3, 14], [-2, 45], [-4, 0], [-8, -2]], [[2977, 4408], [0, 7], [6, 126]], [[2983, 4541], [23, -3]], [[3006, 4538], [34, -7], [3, 18], [7, 19], [3, -3]], [[2598, 4353], [5, 25], [4, 43], [4, 26], [3, 36], [1, 52], [0, 57], [-9, 111], [3, 42], [-2, 50], [6, 51], [2, 43], [-1, 23], [5, 9], [0, 31], [8, 9], [5, 34], [0, -69], [3, -3], [3, 35], [1, 58], [2, 15], [8, 9], [-3, 41], [5, 35], [7, 2], [7, -22], [7, -3], [3, -28], [6, -2], [9, -25], [3, 1], [4, -41], [-3, -21], [3, -29], [2, -32], [-2, -71], [-6, -18], [-1, -37], [-7, -12], [-4, -44], [2, -17], [6, -15], [6, 24], [6, 49], [10, 19], [5, -15], [3, -27], [3, -80], [0, -39], [3, -48], [-3, -69], [-4, -11], [-1, 25], [-3, -7], [-3, -58], [-6, -21], [-2, -44], [-7, -37], [0, -16]], [[2694, 4347], [-39, -7]], [[2635, 5110], [1, -23], [-4, -4], [1, 33], [2, -6]], [[2496, 5270], [11, 20], [5, 23], [12, 9], [8, 29], [4, 1], [3, 20], [9, 28], [4, 24], [7, 15], [6, -13], [-11, -59], [-2, -19], [0, -36], [5, 27], [10, -4], [8, -19], [7, -52], [3, -10], [7, 9], [2, -12], [7, -6], [16, 44], [8, 4], [10, -2], [7, 15], [6, 1], [1, -54], [5, -7], [6, 8], [2, -12], [4, 16], [8, 5], [1, -67], [3, -28], [6, -8], [1, 19], [5, 0], [3, -20], [-3, -14], [-15, 12], [-8, -8], [-8, 23], [-2, -21], [1, -18], [-4, 4], [-5, 27], [-9, 15], [-5, 1], [-4, -25], [-8, -6], [-8, 5], [-3, -10], [-1, -21], [-9, -18], [1, 25], [-4, 5], [-2, -26], [-6, -1], [-3, -11], [-5, -45], [-8, -58], [1, -5]], [[2576, 4989], [-4, 20], [2, 27], [-7, 4], [3, 26], [0, 34], [-5, 23], [-4, 24], [-12, 19], [-4, -7], [-12, 29], [-29, 38], [-3, 33], [-5, 11]], [[2541, 5539], [-7, -24], [-4, -3], [1, 19], [18, 45], [-4, -31], [-4, -6]], [[2324, 4685], [0, 343], [-7, 22], [-5, 36], [8, 41], [1, 22]], [[2321, 5149], [-1, 76], [-4, 20], [-2, 42], [0, 51], [-1, 8], [-1, 123], [-5, 65], [-3, 36], [0, 77], [1, 27], [-3, 60]], [[2302, 5734], [59, 0], [0, 73], [5, -2], [4, -14], [4, -100], [3, -11], [9, -3], [1, -10], [11, -4], [1, -21], [10, 5], [0, 9], [7, 10], [6, -4], [8, -16], [2, -19], [4, 2], [4, -43], [2, 18], [7, 8], [1, -18], [9, -12], [0, -17], [4, -14], [8, 8], [5, 18], [8, 12], [2, -28], [5, 6], [6, -6], [6, 4], [8, -24], [7, 4], [0, -10], [-10, -24], [-13, -19], [-9, -20], [-12, -49], [-5, -31], [-8, -34], [-13, -46], [2, -16]], [[2450, 5296], [-2, 9], [-6, -16], [0, -113], [-2, -11], [-8, -16], [-6, -41], [-1, -27], [3, -2], [4, -24], [-3, -29], [0, -33], [-2, -70], [8, -34], [6, -3], [3, -21], [8, -21], [2, -25], [8, -33], [5, -7], [5, -42], [-1, -30], [2, -22]], [[2553, 2179], [-3, -8], [-7, 4], [-3, 12], [-7, -8], [-9, -22], [-3, -14]], [[2498, 3062], [53, 0], [7, 0]], [[2524, 3348], [-2, 0], [-2, 0], [1, -47], [-6, -48]], [[2376, 3349], [0, 95]], [[2356, 4017], [-7, 50], [-6, 62]], [[2108, 5151], [0, -181], [-1, 0]], [[2107, 4970], [-53, 1], [-90, 0], [-56, 0], [0, -100]], [[1766, 5734], [130, -1], [58, 1], [154, 0]], [[2108, 5734], [0, -217], [0, -366]], [[2107, 4208], [0, 382]], [[2107, 4590], [21, 0], [49, -1], [88, 0], [1, -10], [15, -34], [4, 19], [4, -4], [13, 0], [15, -36], [2, -27], [5, -5]], [[1823, 4398], [0, -954]], [[1654, 4398], [37, -1], [47, 2]], [[3006, 4538], [-2, 14], [0, 28], [3, 11], [-1, 27], [3, 81], [5, 37], [2, 43], [3, 16], [-1, 47], [10, 17], [5, 33], [-3, 31], [4, 32], [0, 18]], [[3034, 4973], [4, 49], [6, -5], [2, 12]], [[3056, 4600], [-3, -35]], [[2962, 4152], [-5, -13], [-2, -29], [8, -14], [0, -22], [-3, -103], [-9, -76], [-6, -22], [-5, -48], [-3, 31], [-8, 16], [-10, 42], [-1, 28], [0, 4], [2, 11]], [[2922, 3980], [8, 15], [0, 15], [9, 31], [2, 17], [-9, 39], [0, 24], [-3, 6], [-1, 22], [5, 33], [-3, 20], [7, 40], [2, 21], [4, 13]], [[2943, 4276], [13, -41], [9, -28], [-3, -55]], [[2137, 3444], [0, -95]], [[2137, 3349], [-1, 0], [0, -474], [0, -193], [0, -192], [-101, 0], [-1, -18], [3, -22]], [[2037, 2450], [-48, 0], [0, -87], [-24, 0]], [[2972, 4205], [13, -15], [2, 11], [10, 0], [6, 6], [8, 31], [1, -22], [5, -10], [-11, -28], [-22, -42], [-9, -8], [-6, 2], [-5, -9], [-2, 31]], [[2943, 4276], [-2, 14], [-4, 1], [-5, 32], [1, 29], [-4, 22], [-2, -2], [-3, 27], [-125, 0], [0, 48], [0, 3]], [[2799, 4450], [17, 54], [3, 26], [5, 18], [-2, 32], [-2, 7], [-2, 52], [17, 22], [15, -1], [6, -5], [6, -21], [4, 8], [12, -1], [8, 14], [8, 34], [5, 1], [0, 52], [3, 31], [-7, 21], [2, 24], [11, 32], [4, 28], [14, 64], [13, 32], [19, -5], [23, 4]], [[2981, 4973], [1, -39], [-2, -36], [3, -34], [-1, -37], [-3, -39], [2, -52], [-1, -16], [4, -31], [-1, -132], [0, -16]], [[2909, 3359], [4, -77], [-8, 8], [-1, -10], [-10, -11], [-1, -11], [-7, -3], [0, -13], [8, 9], [1, -8], [9, 9], [3, -18], [5, 8], [2, -46], [-2, -22], [-3, -2], [-8, -47], [-9, -2], [-2, -33], [4, -32], [4, -6], [-6, -54], [-6, 7], [-9, -6], [-6, -11], [-10, -37], [-7, -48], [-4, -60], [-6, 13], [-11, -12]], [[2833, 2844], [-32, 181], [-32, 4], [1, 21], [-5, 33], [-3, -12], [0, 20], [-35, 10], [-8, -8], [-6, -17], [-10, -13]], [[2669, 3061], [1, 45], [5, 4], [3, 31], [7, 29], [7, 1], [7, 29], [8, 10], [6, 43], [4, 13], [1, -19], [11, 37], [5, -8], [4, 36], [5, 9], [1, 45]], [[2744, 3366], [20, -5], [19, -3], [23, -1], [103, 2]], [[2321, 5149], [-213, 2]], [[2108, 5734], [194, 0]], [[2777, 4138], [-4, -10], [2, -21], [0, -29], [-4, -46], [-3, -70], [-11, -62], [-3, -8], [-4, 12], [-3, -27], [-3, 1], [-4, -36], [1, -22], [-3, -18], [-4, 29], [-5, -46], [1, -29], [-3, -11], [-1, -25], [-8, -4]], [[2694, 4347], [11, -26], [3, -15], [3, 14], [6, -30], [4, -9], [14, 25], [7, -6], [9, 36], [12, 34], [14, 24]], [[2777, 4394], [0, -256]], [[2380, 2803], [-11, 21], [-3, 22], [-7, 18], [-2, -16], [-8, 1], [-1, 10], [-7, -19], [-3, 11], [-6, -10], [-5, -29], [-2, 17], [-6, 14], [-7, 0], [-2, 21], [-7, -42], [-2, 24], [-3, -8], [-3, 16], [-7, 15], [-5, -25], [-2, 26], [-4, 3], [-2, 21], [-6, 8], [-3, -18], [-3, 16], [-5, -2], [-6, 17], [-6, -2], [-2, 36], [-9, 2], [-4, -6], [-6, 37], [-2, -3], [0, 370], [-52, 0], [-34, 0]], [[1534, 4399], [-4, 22], [-2, 61], [0, 43], [-4, 33], [3, 32], [2, 51], [4, 54], [2, 48], [3, 162], [0, 22], [3, 71], [1, 99], [-2, 54], [1, 32], [12, 29]], [[1553, 5212], [5, -22], [4, 5], [3, 2], [6, -20], [3, -23], [1, -57], [15, -21], [12, 30], [8, 3], [9, -10], [1, -13], [16, 27], [3, -9], [9, 5], [7, 19], [12, 17], [12, 4], [4, 12], [58, -1]], [[2807, 3964], [-30, 0], [0, 174]], [[2777, 4394], [5, 11], [17, 45]], [[3045, 4302], [-6, -4], [3, 39]], [[3042, 4343], [-4, 3], [-3, -28], [-1, -40], [-11, -9]], [[2833, 2844], [-5, -10], [-6, -31], [-6, -49], [-1, -40], [-5, -31], [-6, 0], [-2, -23], [-6, -25], [-4, -28], [-6, -11], [-6, -29], [-1, -14], [-6, -16], [-6, -40]], [[2107, 4590], [0, 380]], [[2687, 3368], [57, -2]], [[2398, 2049], [-5, -1], [-14, -26], [-6, 15], [-1, 31], [-3, -22], [-3, 5], [-1, -27], [3, -11], [0, -36], [-5, -37], [-9, -47], [-17, -51], [-2, 9], [-5, -13], [0, 12], [-7, -9], [-3, 24], [-2, -5], [7, -49], [-5, -16], [-5, 10], [-1, -35], [-7, -35], [-6, -66], [-4, -69], [-3, 5], [-1, -25], [3, 6], [-2, -50], [-2, -2], [0, -28], [3, -16], [1, -57], [3, -20], [0, -37], [3, -32], [-9, -20], [-3, 25], [-7, 10], [-9, -3], [-8, 32], [-5, 3], [-5, 25], [-6, 8], [-4, 24], [-2, 58], [-5, 34], [0, 30], [-2, 31], [1, 27], [-4, 30], [-3, 4], [-5, 27], [-1, 34], [-5, 32], [-6, 26], [-3, 57], [-2, 16], [-4, 46], [-1, 38], [-4, 27], [-6, 24], [-1, 16], [-6, 15], [-4, 42], [-13, 9], [-7, -2], [-7, 15], [-1, -20], [-7, -6], [-5, -40], [-3, -64], [-2, -1], [-4, -37], [-5, -1], [-7, 29], [-17, 47], [-4, 25], [-6, 24], [-5, 54], [-1, 49], [-4, 40], [-2, 35], [-3, 22], [-11, 32], [-6, 44], [-4, 15], [-6, 38], [-7, 20], [-5, 50], [-4, 11]], [[1908, 4399], [0, -192], [57, 0]], [[2981, 4973], [30, -2], [23, 2]], [[2927, 3641], [-4, -32], [-3, -12], [-3, -44], [-6, -71], [-5, -15], [-1, 27], [2, 58], [8, 74]], [[2874, 3756], [-4, -8], [-2, -28], [1, -19], [8, 6], [1, -31], [10, -12], [3, -24], [8, -26], [-4, -54], [4, -41], [-4, -20], [-1, -24], [4, -15], [-4, -23], [-6, 30], [-1, -10], [5, -22], [14, -5], [3, -71]], [[2736, 3547], [-1, -16], [4, -32], [5, -16], [4, 1], [5, 25], [4, -20], [7, 11], [13, 36], [1, -11], [5, 17], [0, 34], [4, 30], [5, 29], [2, 34], [6, 36], [2, 44], [5, -27], [4, -8], [3, 16], [6, 68], [4, -17], [13, 77], [2, 57], [15, -64], [3, 37]], [[1553, 5212], [-5, 7], [-4, -12], [-6, 17], [1, 26], [4, 14], [-6, 40], [-4, 103], [-2, 14], [-3, 73], [-6, 28], [-2, 56], [3, 38], [6, -18], [11, -24], [8, 1], [8, -9], [8, 9], [3, -16], [7, 1], [5, -42], [3, 3], [1, -56], [2, -52], [3, 6], [-3, 43], [1, 43], [4, 44], [-3, 18], [-1, 31], [-3, 35], [2, 25], [-2, 29], [-5, 4], [-4, 22], [1, 21], [163, 0]], [[1576, 5602], [4, 9], [0, -39], [-5, 15], [1, 15]], [[1568, 5655], [3, 25], [4, -30], [-1, -27], [-7, 8], [1, 24]], [[2576, 4989], [-1, -23], [-6, -4], [-4, -44], [-2, -30], [3, -6], [5, 20], [4, 38], [6, 15], [5, 48], [6, 10], [-1, -25], [-4, -23], [-8, -79], [-2, -44], [0, -32], [-3, -10], [-2, -43], [1, -37], [-3, -24], [-3, -59], [0, -47], [4, -42], [-1, -55]], [[2450, 5296], [6, -2], [20, 33], [8, 17], [2, -13], [-4, -25], [9, -33], [5, -3]]] };
        Datamap2.prototype.usgTopo = "__USG__";
        Datamap2.prototype.uzbTopo = "__UZB__";
        Datamap2.prototype.vatTopo = "__VAT__";
        Datamap2.prototype.vctTopo = "__VCT__";
        Datamap2.prototype.venTopo = "__VEN__";
        Datamap2.prototype.vgbTopo = "__VGB__";
        Datamap2.prototype.virTopo = "__VIR__";
        Datamap2.prototype.vnmTopo = "__VNM__";
        Datamap2.prototype.vutTopo = "__VUT__";
        Datamap2.prototype.wlfTopo = "__WLF__";
        Datamap2.prototype.wsbTopo = "__WSB__";
        Datamap2.prototype.wsmTopo = "__WSM__";
        Datamap2.prototype.yemTopo = "__YEM__";
        Datamap2.prototype.zafTopo = "__ZAF__";
        Datamap2.prototype.zmbTopo = "__ZMB__";
        Datamap2.prototype.zweTopo = "__ZWE__";
        Datamap2.prototype.latLngToXY = function(lat, lng) {
          return this.projection([lng, lat]);
        };
        Datamap2.prototype.addLayer = function(className, id, first) {
          var layer;
          if (first) {
            layer = this.svg.insert("g", ":first-child");
          } else {
            layer = this.svg.append("g");
          }
          return layer.attr("id", id || "").attr("class", className || "");
        };
        Datamap2.prototype.updateChoropleth = function(data, options) {
          var svg2 = this.svg;
          var that = this;
          if (options && options.reset === true) {
            svg2.selectAll(".datamaps-subunit").attr("data-info", function() {
              return "{}";
            }).transition().style("fill", this.options.fills.defaultFill);
          }
          for (var subunit in data) {
            if (data.hasOwnProperty(subunit)) {
              var color2;
              var subunitData = data[subunit];
              if (!subunit) {
                continue;
              } else if (typeof subunitData === "string") {
                color2 = subunitData;
              } else if (typeof subunitData.color === "string") {
                color2 = subunitData.color;
              } else if (typeof subunitData.fillColor === "string") {
                color2 = subunitData.fillColor;
              } else {
                color2 = this.options.fills[subunitData.fillKey];
              }
              if (subunitData === Object(subunitData)) {
                this.options.data[subunit] = defaults2(subunitData, this.options.data[subunit] || {});
                var geo = this.svg.select("." + subunit).attr("data-info", JSON.stringify(this.options.data[subunit]));
              }
              svg2.selectAll("." + subunit).transition().style("fill", color2);
            }
          }
        };
        Datamap2.prototype.updatePopup = function(element, d5, options) {
          var self2 = this;
          element.on("mousemove", null);
          element.on("mousemove", function() {
            var position = d33.mouse(self2.options.element);
            d33.select(self2.svg[0][0].parentNode).select(".datamaps-hoverover").style("top", position[1] + 30 + "px").html(function() {
              var data = JSON.parse(element.attr("data-info"));
              try {
                return options.popupTemplate(d5, data);
              } catch (e3) {
                return "";
              }
            }).style("left", position[0] + "px");
          });
          d33.select(self2.svg[0][0].parentNode).select(".datamaps-hoverover").style("display", "block");
        };
        Datamap2.prototype.addPlugin = function(name, pluginFn) {
          var self2 = this;
          if (typeof Datamap2.prototype[name] === "undefined") {
            Datamap2.prototype[name] = function(data, options, callback2, createNewLayer) {
              var layer;
              if (typeof createNewLayer === "undefined") {
                createNewLayer = false;
              }
              if (typeof options === "function") {
                callback2 = options;
                options = void 0;
              }
              options = defaults2(options || {}, self2.options[name + "Config"]);
              if (!createNewLayer && this.options[name + "Layer"]) {
                layer = this.options[name + "Layer"];
                options = options || this.options[name + "Options"];
              } else {
                layer = this.addLayer(name);
                this.options[name + "Layer"] = layer;
                this.options[name + "Options"] = options;
              }
              pluginFn.apply(this, [layer, data, options]);
              if (callback2) {
                callback2(layer);
              }
            };
          }
        };
        if (typeof exports === "object") {
          d33 = require_d3();
          topojson = require_topojson();
          module.exports = Datamap2;
        } else if (typeof define === "function" && define.amd) {
          define("datamaps", ["require", "d3", "topojson"], function(require2) {
            d33 = require2("d3");
            topojson = require2("topojson");
            return Datamap2;
          });
        } else {
          window.Datamap = window.Datamaps = Datamap2;
        }
        if (window.jQuery) {
          window.jQuery.fn.datamaps = function(options, callback2) {
            options = options || {};
            options.element = this[0];
            var datamap = new Datamap2(options);
            if (typeof callback2 === "function") {
              callback2(datamap, options);
            }
            return this;
          };
        }
      })();
    }
  });

  // js/dashboard.js
  var import_react94 = __toESM(require_react());
  var import_client = __toESM(require_client());
  var import_url_search_params_polyfill = __toESM(require_url_search_params_polyfill());

  // node_modules/@tanstack/history/dist/esm/index.js
  var pushStateEvent = "pushstate";
  var popStateEvent = "popstate";
  var beforeUnloadEvent = "beforeunload";
  var beforeUnloadListener = (event) => {
    event.preventDefault();
    return event.returnValue = "";
  };
  var stopBlocking = () => {
    removeEventListener(beforeUnloadEvent, beforeUnloadListener, {
      capture: true
    });
  };
  function createHistory(opts) {
    let location = opts.getLocation();
    const subscribers = /* @__PURE__ */ new Set();
    let blockers = [];
    const notify = () => {
      location = opts.getLocation();
      subscribers.forEach((subscriber) => subscriber());
    };
    const tryNavigation = async (task, navigateOpts) => {
      var _a10;
      var _a9;
      const ignoreBlocker = (_a10 = navigateOpts == null ? void 0 : navigateOpts.ignoreBlocker) != null ? _a10 : false;
      if (!ignoreBlocker && typeof document !== "undefined" && blockers.length) {
        for (const blocker of blockers) {
          const allowed = await blocker();
          if (!allowed) {
            (_a9 = opts.onBlocked) == null ? void 0 : _a9.call(opts, notify);
            return;
          }
        }
      }
      task();
    };
    return {
      get location() {
        return location;
      },
      subscribers,
      subscribe: (cb) => {
        subscribers.add(cb);
        return () => {
          subscribers.delete(cb);
        };
      },
      push: (path, state, navigateOpts) => {
        state = assignKey(state);
        tryNavigation(() => {
          opts.pushState(path, state);
          notify();
        }, navigateOpts);
      },
      replace: (path, state, navigateOpts) => {
        state = assignKey(state);
        tryNavigation(() => {
          opts.replaceState(path, state);
          notify();
        }, navigateOpts);
      },
      go: (index2, navigateOpts) => {
        tryNavigation(() => {
          opts.go(index2);
          notify();
        }, navigateOpts);
      },
      back: (navigateOpts) => {
        tryNavigation(() => {
          opts.back();
          notify();
        }, navigateOpts);
      },
      forward: (navigateOpts) => {
        tryNavigation(() => {
          opts.forward();
          notify();
        }, navigateOpts);
      },
      createHref: (str) => opts.createHref(str),
      block: (blocker) => {
        blockers.push(blocker);
        if (blockers.length === 1) {
          addEventListener(beforeUnloadEvent, beforeUnloadListener, {
            capture: true
          });
        }
        return () => {
          blockers = blockers.filter((b2) => b2 !== blocker);
          if (!blockers.length) {
            stopBlocking();
          }
        };
      },
      flush: () => {
        var _a9;
        return (_a9 = opts.flush) == null ? void 0 : _a9.call(opts);
      },
      destroy: () => {
        var _a9;
        return (_a9 = opts.destroy) == null ? void 0 : _a9.call(opts);
      },
      notify
    };
  }
  function assignKey(state) {
    if (!state) {
      state = {};
    }
    return __spreadProps(__spreadValues({}, state), {
      key: createRandomKey()
    });
  }
  function createBrowserHistory(opts) {
    var _a9, _b2, _c;
    const win = (_a9 = opts == null ? void 0 : opts.window) != null ? _a9 : typeof document !== "undefined" ? window : void 0;
    const originalPushState = win.history.pushState;
    const originalReplaceState = win.history.replaceState;
    const createHref = (_b2 = opts == null ? void 0 : opts.createHref) != null ? _b2 : (path) => path;
    const parseLocation = (_c = opts == null ? void 0 : opts.parseLocation) != null ? _c : () => parseHref(
      `${win.location.pathname}${win.location.search}${win.location.hash}`,
      win.history.state
    );
    let currentLocation = parseLocation();
    let rollbackLocation;
    const getLocation = () => currentLocation;
    let next;
    let scheduled;
    const flush = () => {
      if (!next) {
        return;
      }
      const caller = next.isPush ? originalPushState : originalReplaceState;
      caller.call(win.history, next.state, "", next.href);
      next = void 0;
      scheduled = void 0;
      rollbackLocation = void 0;
    };
    const queueHistoryAction = (type, destHref, state) => {
      const href = createHref(destHref);
      if (!scheduled) {
        rollbackLocation = currentLocation;
      }
      currentLocation = parseHref(destHref, state);
      next = {
        href,
        state,
        isPush: (next == null ? void 0 : next.isPush) || type === "push"
      };
      if (!scheduled) {
        if (false) {
          flush();
          return;
        }
        scheduled = Promise.resolve().then(() => flush());
      }
    };
    const onPushPop = () => {
      currentLocation = parseLocation();
      history2.notify();
    };
    const history2 = createHistory({
      getLocation,
      pushState: (href, state) => queueHistoryAction("push", href, state),
      replaceState: (href, state) => queueHistoryAction("replace", href, state),
      back: () => win.history.back(),
      forward: () => win.history.forward(),
      go: (n2) => win.history.go(n2),
      createHref: (href) => createHref(href),
      flush,
      destroy: () => {
        win.history.pushState = originalPushState;
        win.history.replaceState = originalReplaceState;
        win.removeEventListener(pushStateEvent, onPushPop);
        win.removeEventListener(popStateEvent, onPushPop);
      },
      onBlocked: (onUpdate) => {
        if (rollbackLocation && currentLocation !== rollbackLocation) {
          currentLocation = rollbackLocation;
          onUpdate();
        }
      }
    });
    win.addEventListener(pushStateEvent, onPushPop);
    win.addEventListener(popStateEvent, onPushPop);
    win.history.pushState = function(...args) {
      const res = originalPushState.apply(win.history, args);
      onPushPop();
      return res;
    };
    win.history.replaceState = function(...args) {
      const res = originalReplaceState.apply(win.history, args);
      onPushPop();
      return res;
    };
    return history2;
  }
  function createMemoryHistory(opts = {
    initialEntries: ["/"]
  }) {
    var _a9;
    const entries = opts.initialEntries;
    let index2 = (_a9 = opts.initialIndex) != null ? _a9 : entries.length - 1;
    let currentState = {
      key: createRandomKey()
    };
    const getLocation = () => parseHref(entries[index2], currentState);
    return createHistory({
      getLocation,
      pushState: (path, state) => {
        currentState = state;
        entries.splice;
        if (index2 < entries.length - 1) {
          entries.splice(index2 + 1);
        }
        entries.push(path);
        index2 = Math.max(entries.length - 1, 0);
      },
      replaceState: (path, state) => {
        currentState = state;
        entries[index2] = path;
      },
      back: () => {
        currentState = assignKey(currentState);
        index2 = Math.max(index2 - 1, 0);
      },
      forward: () => {
        currentState = assignKey(currentState);
        index2 = Math.min(index2 + 1, entries.length - 1);
      },
      go: (n2) => {
        currentState = assignKey(currentState);
        index2 = Math.min(Math.max(index2 + n2, 0), entries.length - 1);
      },
      createHref: (path) => path
    });
  }
  function parseHref(href, state) {
    const hashIndex = href.indexOf("#");
    const searchIndex = href.indexOf("?");
    return {
      href,
      pathname: href.substring(
        0,
        hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length
      ),
      hash: hashIndex > -1 ? href.substring(hashIndex) : "",
      search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? void 0 : hashIndex) : "",
      state: state || {}
    };
  }
  function createRandomKey() {
    return (Math.random() + 1).toString(36).substring(7);
  }

  // node_modules/tiny-invariant/dist/esm/tiny-invariant.js
  var isProduction = false;
  var prefix = "Invariant failed";
  function invariant(condition, message) {
    if (condition) {
      return;
    }
    if (isProduction) {
      throw new Error(prefix);
    }
    var provided = typeof message === "function" ? message() : message;
    var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
    throw new Error(value);
  }

  // node_modules/tiny-warning/dist/tiny-warning.esm.js
  var isProduction2 = false;
  function warning(condition, message) {
    if (!isProduction2) {
      if (condition) {
        return;
      }
      var text = "Warning: " + message;
      if (typeof console !== "undefined") {
        console.warn(text);
      }
      try {
        throw Error(text);
      } catch (x3) {
      }
    }
  }
  var tiny_warning_esm_default = warning;

  // node_modules/@tanstack/react-router/dist/esm/useRouter.js
  var React2 = __toESM(require_react(), 1);

  // node_modules/@tanstack/react-router/dist/esm/routerContext.js
  var React = __toESM(require_react(), 1);
  var routerContext = React.createContext(null);
  function getRouterContext() {
    if (typeof document === "undefined") {
      return routerContext;
    }
    if (window.__TSR_ROUTER_CONTEXT__) {
      return window.__TSR_ROUTER_CONTEXT__;
    }
    window.__TSR_ROUTER_CONTEXT__ = routerContext;
    return routerContext;
  }

  // node_modules/@tanstack/react-router/dist/esm/useRouter.js
  function useRouter(opts) {
    var _a9;
    const value = React2.useContext(getRouterContext());
    tiny_warning_esm_default(
      !(((_a9 = opts == null ? void 0 : opts.warn) != null ? _a9 : true) && !value),
      "useRouter must be used inside a <RouterProvider> component!"
    );
    return value;
  }

  // node_modules/@tanstack/react-store/dist/esm/index.js
  var import_with_selector = __toESM(require_with_selector(), 1);

  // node_modules/@tanstack/store/dist/esm/index.js
  var Store = class {
    constructor(initialState, options) {
      this.listeners = /* @__PURE__ */ new Set();
      this._batching = false;
      this._flushing = 0;
      this.subscribe = (listener) => {
        var _a9, _b2;
        this.listeners.add(listener);
        const unsub = (_b2 = (_a9 = this.options) == null ? void 0 : _a9.onSubscribe) == null ? void 0 : _b2.call(_a9, listener, this);
        return () => {
          this.listeners.delete(listener);
          unsub == null ? void 0 : unsub();
        };
      };
      this.setState = (updater) => {
        var _a9, _b2, _c;
        const previous = this.state;
        this.state = ((_a9 = this.options) == null ? void 0 : _a9.updateFn) ? this.options.updateFn(previous)(updater) : updater(previous);
        (_c = (_b2 = this.options) == null ? void 0 : _b2.onUpdate) == null ? void 0 : _c.call(_b2);
        this._flush();
      };
      this._flush = () => {
        if (this._batching) return;
        const flushId = ++this._flushing;
        this.listeners.forEach((listener) => {
          if (this._flushing !== flushId) return;
          listener();
        });
      };
      this.batch = (cb) => {
        if (this._batching) return cb();
        this._batching = true;
        cb();
        this._batching = false;
        this._flush();
      };
      this.state = initialState;
      this.options = options;
    }
  };

  // node_modules/@tanstack/react-store/dist/esm/index.js
  function useStore(store, selector = (d5) => d5) {
    const slice = (0, import_with_selector.useSyncExternalStoreWithSelector)(
      store.subscribe,
      () => store.state,
      () => store.state,
      selector,
      shallow
    );
    return slice;
  }
  function shallow(objA, objB) {
    if (Object.is(objA, objB)) {
      return true;
    }
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
      return false;
    }
    const keysA = Object.keys(objA);
    if (keysA.length !== Object.keys(objB).length) {
      return false;
    }
    for (let i5 = 0; i5 < keysA.length; i5++) {
      if (!Object.prototype.hasOwnProperty.call(objB, keysA[i5]) || !Object.is(objA[keysA[i5]], objB[keysA[i5]])) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@tanstack/react-router/dist/esm/root.js
  var rootRouteId = "__root__";

  // node_modules/@tanstack/react-router/dist/esm/qss.js
  function encode(obj, pfx) {
    let k, i5, tmp, str = "";
    for (k in obj) {
      if ((tmp = obj[k]) !== void 0) {
        if (Array.isArray(tmp)) {
          for (i5 = 0; i5 < tmp.length; i5++) {
            str && (str += "&");
            str += encodeURIComponent(k) + "=" + encodeURIComponent(tmp[i5]);
          }
        } else {
          str && (str += "&");
          str += encodeURIComponent(k) + "=" + encodeURIComponent(tmp);
        }
      }
    }
    return (pfx || "") + str;
  }
  function toValue(mix) {
    if (!mix) return "";
    const str = decodeURIComponent(mix);
    if (str === "false") return false;
    if (str === "true") return true;
    return +str * 0 === 0 && +str + "" === str ? +str : str;
  }
  function decode(str, pfx) {
    let tmp, k;
    const out = {}, arr = (pfx ? str.substr(pfx.length) : str).split("&");
    while (tmp = arr.shift()) {
      const equalIndex = tmp.indexOf("=");
      if (equalIndex !== -1) {
        k = tmp.slice(0, equalIndex);
        const value = tmp.slice(equalIndex + 1);
        if (out[k] !== void 0) {
          out[k] = [].concat(out[k], toValue(value));
        } else {
          out[k] = toValue(value);
        }
      } else {
        k = tmp;
        out[k] = "";
      }
    }
    return out;
  }

  // node_modules/@tanstack/react-router/dist/esm/searchParams.js
  var defaultParseSearch = parseSearchWith(JSON.parse);
  var defaultStringifySearch = stringifySearchWith(
    JSON.stringify,
    JSON.parse
  );
  function parseSearchWith(parser) {
    return (searchStr) => {
      if (searchStr.substring(0, 1) === "?") {
        searchStr = searchStr.substring(1);
      }
      const query = decode(searchStr);
      for (const key in query) {
        const value = query[key];
        if (typeof value === "string") {
          try {
            query[key] = parser(value);
          } catch (err) {
          }
        }
      }
      return query;
    };
  }
  function stringifySearchWith(stringify, parser) {
    function stringifyValue(val) {
      if (typeof val === "object" && val !== null) {
        try {
          return stringify(val);
        } catch (err) {
        }
      } else if (typeof val === "string" && typeof parser === "function") {
        try {
          parser(val);
          return stringify(val);
        } catch (err) {
        }
      }
      return val;
    }
    return (search) => {
      search = __spreadValues({}, search);
      Object.keys(search).forEach((key) => {
        const val = search[key];
        if (typeof val === "undefined" || val === void 0) {
          delete search[key];
        } else {
          search[key] = stringifyValue(val);
        }
      });
      const searchStr = encode(search).toString();
      return searchStr ? `?${searchStr}` : "";
    };
  }

  // node_modules/@tanstack/react-router/dist/esm/utils.js
  var React3 = __toESM(require_react(), 1);
  function last(arr) {
    return arr[arr.length - 1];
  }
  function isFunction(d5) {
    return typeof d5 === "function";
  }
  function functionalUpdate(updater, previous) {
    if (isFunction(updater)) {
      return updater(previous);
    }
    return updater;
  }
  function pick(parent, keys) {
    return keys.reduce((obj, key) => {
      obj[key] = parent[key];
      return obj;
    }, {});
  }
  function replaceEqualDeep(prev, _next) {
    if (prev === _next) {
      return prev;
    }
    const next = _next;
    const array = isPlainArray(prev) && isPlainArray(next);
    if (array || isPlainObject(prev) && isPlainObject(next)) {
      const prevItems = array ? prev : Object.keys(prev);
      const prevSize = prevItems.length;
      const nextItems = array ? next : Object.keys(next);
      const nextSize = nextItems.length;
      const copy = array ? [] : {};
      let equalItems = 0;
      for (let i5 = 0; i5 < nextSize; i5++) {
        const key = array ? i5 : nextItems[i5];
        if ((!array && prevItems.includes(key) || array) && prev[key] === void 0 && next[key] === void 0) {
          copy[key] = void 0;
          equalItems++;
        } else {
          copy[key] = replaceEqualDeep(prev[key], next[key]);
          if (copy[key] === prev[key] && prev[key] !== void 0) {
            equalItems++;
          }
        }
      }
      return prevSize === nextSize && equalItems === prevSize ? prev : copy;
    }
    return next;
  }
  function isPlainObject(o10) {
    if (!hasObjectPrototype(o10)) {
      return false;
    }
    const ctor = o10.constructor;
    if (typeof ctor === "undefined") {
      return true;
    }
    const prot = ctor.prototype;
    if (!hasObjectPrototype(prot)) {
      return false;
    }
    if (!prot.hasOwnProperty("isPrototypeOf")) {
      return false;
    }
    return true;
  }
  function hasObjectPrototype(o10) {
    return Object.prototype.toString.call(o10) === "[object Object]";
  }
  function isPlainArray(value) {
    return Array.isArray(value) && value.length === Object.keys(value).length;
  }
  function deepEqual(a3, b2, partial = false) {
    if (a3 === b2) {
      return true;
    }
    if (typeof a3 !== typeof b2) {
      return false;
    }
    if (isPlainObject(a3) && isPlainObject(b2)) {
      const aKeys = Object.keys(a3).filter((key) => a3[key] !== void 0);
      const bKeys = Object.keys(b2).filter((key) => b2[key] !== void 0);
      if (!partial && aKeys.length !== bKeys.length) {
        return false;
      }
      return !bKeys.some(
        (key) => !(key in a3) || !deepEqual(a3[key], b2[key], partial)
      );
    }
    if (Array.isArray(a3) && Array.isArray(b2)) {
      if (a3.length !== b2.length) {
        return false;
      }
      return !a3.some((item, index2) => !deepEqual(item, b2[index2], partial));
    }
    return false;
  }
  var useLayoutEffect2 = typeof window !== "undefined" ? React3.useLayoutEffect : React3.useEffect;
  function createControlledPromise(onResolve) {
    let resolveLoadPromise;
    let rejectLoadPromise;
    const controlledPromise = new Promise((resolve2, reject) => {
      resolveLoadPromise = resolve2;
      rejectLoadPromise = reject;
    });
    controlledPromise.status = "pending";
    controlledPromise.resolve = (value) => {
      controlledPromise.status = "resolved";
      controlledPromise.value = value;
      resolveLoadPromise(value);
      onResolve == null ? void 0 : onResolve(value);
    };
    controlledPromise.reject = (e3) => {
      controlledPromise.status = "rejected";
      rejectLoadPromise(e3);
    };
    return controlledPromise;
  }
  function usePrevious(value) {
    const ref = React3.useRef({
      value,
      prev: null
    });
    const current = ref.current.value;
    if (value !== current) {
      ref.current = {
        value,
        prev: current
      };
    }
    return ref.current.prev;
  }

  // node_modules/@tanstack/react-router/dist/esm/path.js
  function joinPaths(paths) {
    return cleanPath(paths.filter(Boolean).join("/"));
  }
  function cleanPath(path) {
    return path.replace(/\/{2,}/g, "/");
  }
  function trimPathLeft(path) {
    return path === "/" ? path : path.replace(/^\/{1,}/, "");
  }
  function trimPathRight(path) {
    return path === "/" ? path : path.replace(/\/{1,}$/, "");
  }
  function trimPath(path) {
    return trimPathRight(trimPathLeft(path));
  }
  function removeTrailingSlash(value, basepath) {
    if (value.endsWith("/") && value !== "/" && value !== `${basepath}/`) {
      return value.slice(0, -1);
    }
    return value;
  }
  function exactPathTest(pathName1, pathName2, basepath) {
    return removeTrailingSlash(pathName1, basepath) === removeTrailingSlash(pathName2, basepath);
  }
  function resolvePath({
    basepath,
    base,
    to: to2,
    trailingSlash = "never"
  }) {
    var _a9, _b2;
    base = base.replace(new RegExp(`^${basepath}`), "/");
    to2 = to2.replace(new RegExp(`^${basepath}`), "/");
    let baseSegments = parsePathname(base);
    const toSegments = parsePathname(to2);
    if (baseSegments.length > 1 && ((_a9 = last(baseSegments)) == null ? void 0 : _a9.value) === "/") {
      baseSegments.pop();
    }
    toSegments.forEach((toSegment, index2) => {
      if (toSegment.value === "/") {
        if (!index2) {
          baseSegments = [toSegment];
        } else if (index2 === toSegments.length - 1) {
          baseSegments.push(toSegment);
        } else ;
      } else if (toSegment.value === "..") {
        baseSegments.pop();
      } else if (toSegment.value === ".") ;
      else {
        baseSegments.push(toSegment);
      }
    });
    if (baseSegments.length > 1) {
      if (((_b2 = last(baseSegments)) == null ? void 0 : _b2.value) === "/") {
        if (trailingSlash === "never") {
          baseSegments.pop();
        }
      } else if (trailingSlash === "always") {
        baseSegments.push({ type: "pathname", value: "/" });
      }
    }
    const joined = joinPaths([basepath, ...baseSegments.map((d5) => d5.value)]);
    return cleanPath(joined);
  }
  function parsePathname(pathname) {
    if (!pathname) {
      return [];
    }
    pathname = cleanPath(pathname);
    const segments = [];
    if (pathname.slice(0, 1) === "/") {
      pathname = pathname.substring(1);
      segments.push({
        type: "pathname",
        value: "/"
      });
    }
    if (!pathname) {
      return segments;
    }
    const split = pathname.split("/").filter(Boolean);
    segments.push(
      ...split.map((part) => {
        if (part === "$" || part === "*") {
          return {
            type: "wildcard",
            value: part
          };
        }
        if (part.charAt(0) === "$") {
          return {
            type: "param",
            value: part
          };
        }
        return {
          type: "pathname",
          value: decodeURIComponent(part)
        };
      })
    );
    if (pathname.slice(-1) === "/") {
      pathname = pathname.substring(1);
      segments.push({
        type: "pathname",
        value: "/"
      });
    }
    return segments;
  }
  function interpolatePath({
    path,
    params,
    leaveWildcards,
    leaveParams
  }) {
    const interpolatedPathSegments = parsePathname(path);
    const encodedParams = {};
    for (const [key, value] of Object.entries(params)) {
      const isValueString = typeof value === "string";
      if (["*", "_splat"].includes(key)) {
        encodedParams[key] = isValueString ? encodeURI(value) : value;
      } else {
        encodedParams[key] = isValueString ? encodeURIComponent(value) : value;
      }
    }
    return joinPaths(
      interpolatedPathSegments.map((segment) => {
        var _a9;
        if (segment.type === "wildcard") {
          const value = encodedParams._splat;
          if (leaveWildcards) return `${segment.value}${value != null ? value : ""}`;
          return value;
        }
        if (segment.type === "param") {
          if (leaveParams) {
            const value = encodedParams[segment.value];
            return `${segment.value}${value != null ? value : ""}`;
          }
          return (_a9 = encodedParams[segment.value.substring(1)]) != null ? _a9 : "undefined";
        }
        return segment.value;
      })
    );
  }
  function matchPathname(basepath, currentPathname, matchLocation) {
    const pathParams = matchByPath(basepath, currentPathname, matchLocation);
    if (matchLocation.to && !pathParams) {
      return;
    }
    return pathParams != null ? pathParams : {};
  }
  function removeBasepath(basepath, pathname) {
    switch (true) {
      case basepath === "/":
        return pathname;
      case pathname === basepath:
        return "";
      case pathname.length < basepath.length:
        return pathname;
      case pathname[basepath.length] !== "/":
        return pathname;
      case pathname.startsWith(basepath):
        return pathname.slice(basepath.length);
      default:
        return pathname;
    }
  }
  function matchByPath(basepath, from2, matchLocation) {
    var _a9;
    from2 = removeBasepath(basepath, from2);
    const to2 = removeBasepath(basepath, `${(_a9 = matchLocation.to) != null ? _a9 : "$"}`);
    const baseSegments = parsePathname(from2);
    const routeSegments = parsePathname(to2);
    if (!from2.startsWith("/")) {
      baseSegments.unshift({
        type: "pathname",
        value: "/"
      });
    }
    if (!to2.startsWith("/")) {
      routeSegments.unshift({
        type: "pathname",
        value: "/"
      });
    }
    const params = {};
    const isMatch = (() => {
      for (let i5 = 0; i5 < Math.max(baseSegments.length, routeSegments.length); i5++) {
        const baseSegment = baseSegments[i5];
        const routeSegment = routeSegments[i5];
        const isLastBaseSegment = i5 >= baseSegments.length - 1;
        const isLastRouteSegment = i5 >= routeSegments.length - 1;
        if (routeSegment) {
          if (routeSegment.type === "wildcard") {
            if (baseSegment == null ? void 0 : baseSegment.value) {
              const _splat = decodeURI(
                joinPaths(baseSegments.slice(i5).map((d5) => d5.value))
              );
              params["*"] = _splat;
              params["_splat"] = _splat;
              return true;
            }
            return false;
          }
          if (routeSegment.type === "pathname") {
            if (routeSegment.value === "/" && !(baseSegment == null ? void 0 : baseSegment.value)) {
              return true;
            }
            if (baseSegment) {
              if (matchLocation.caseSensitive) {
                if (routeSegment.value !== baseSegment.value) {
                  return false;
                }
              } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {
                return false;
              }
            }
          }
          if (!baseSegment) {
            return false;
          }
          if (routeSegment.type === "param") {
            if (baseSegment.value === "/") {
              return false;
            }
            if (baseSegment.value.charAt(0) !== "$") {
              params[routeSegment.value.substring(1)] = decodeURIComponent(
                baseSegment.value
              );
            }
          }
        }
        if (!isLastBaseSegment && isLastRouteSegment) {
          params["**"] = joinPaths(baseSegments.slice(i5 + 1).map((d5) => d5.value));
          return !!matchLocation.fuzzy && (routeSegment == null ? void 0 : routeSegment.value) !== "/";
        }
      }
      return true;
    })();
    return isMatch ? params : void 0;
  }

  // node_modules/@tanstack/react-router/dist/esm/redirects.js
  function isRedirect(obj) {
    return !!(obj == null ? void 0 : obj.isRedirect);
  }
  function isResolvedRedirect(obj) {
    return !!(obj == null ? void 0 : obj.isRedirect) && obj.href;
  }

  // node_modules/@tanstack/react-router/dist/esm/not-found.js
  var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);

  // node_modules/@tanstack/react-router/dist/esm/CatchBoundary.js
  var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
  var React4 = __toESM(require_react(), 1);
  function CatchBoundary(props) {
    var _a9;
    const errorComponent = (_a9 = props.errorComponent) != null ? _a9 : ErrorComponent;
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      CatchBoundaryImpl,
      {
        getResetKey: props.getResetKey,
        onCatch: props.onCatch,
        children: ({ error, reset }) => {
          if (error) {
            return React4.createElement(errorComponent, {
              error,
              reset
            });
          }
          return props.children;
        }
      }
    );
  }
  var CatchBoundaryImpl = class extends React4.Component {
    constructor() {
      super(...arguments);
      this.state = { error: null };
    }
    static getDerivedStateFromProps(props) {
      return { resetKey: props.getResetKey() };
    }
    static getDerivedStateFromError(error) {
      return { error };
    }
    reset() {
      this.setState({ error: null });
    }
    componentDidUpdate(prevProps, prevState) {
      if (prevState.error && prevState.resetKey !== this.state.resetKey) {
        this.reset();
      }
    }
    componentDidCatch(error, errorInfo) {
      if (this.props.onCatch) {
        this.props.onCatch(error, errorInfo);
      }
    }
    render() {
      return this.props.children({
        error: this.state.resetKey !== this.props.getResetKey() ? null : this.state.error,
        reset: () => {
          this.reset();
        }
      });
    }
  };
  function ErrorComponent({ error }) {
    const [show, setShow] = React4.useState(true);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { padding: ".5rem", maxWidth: "100%" }, children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: ".5rem" }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", { style: { fontSize: "1rem" }, children: "Something went wrong!" }),
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
          "button",
          {
            style: {
              appearance: "none",
              fontSize: ".6em",
              border: "1px solid currentColor",
              padding: ".1rem .2rem",
              fontWeight: "bold",
              borderRadius: ".25rem"
            },
            onClick: () => setShow((d5) => !d5),
            children: show ? "Hide Error" : "Show Error"
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: { height: ".25rem" } }),
      show ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "pre",
        {
          style: {
            fontSize: ".7em",
            border: "1px solid red",
            borderRadius: ".25rem",
            padding: ".3rem",
            color: "red",
            overflow: "auto"
          },
          children: error.message ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("code", { children: error.message }) : null
        }
      ) }) : null
    ] });
  }

  // node_modules/@tanstack/react-router/dist/esm/useRouterState.js
  function useRouterState(opts) {
    const contextRouter = useRouter({
      warn: (opts == null ? void 0 : opts.router) === void 0
    });
    return useStore(((opts == null ? void 0 : opts.router) || contextRouter).__store, opts == null ? void 0 : opts.select);
  }

  // node_modules/@tanstack/react-router/dist/esm/not-found.js
  function isNotFound(obj) {
    return !!(obj == null ? void 0 : obj.isNotFound);
  }
  function CatchNotFound(props) {
    const resetKey = useRouterState({
      select: (s7) => `not-found-${s7.location.pathname}-${s7.status}`
    });
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
      CatchBoundary,
      {
        getResetKey: () => resetKey,
        onCatch: (error, errorInfo) => {
          var _a9;
          if (isNotFound(error)) {
            (_a9 = props.onCatch) == null ? void 0 : _a9.call(props, error, errorInfo);
          } else {
            throw error;
          }
        },
        errorComponent: ({ error }) => {
          var _a9;
          return (_a9 = props.fallback) == null ? void 0 : _a9.call(props, error);
        },
        children: props.children
      }
    );
  }
  function DefaultGlobalNotFound() {
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { children: "Not Found" });
  }

  // node_modules/@tanstack/react-router/dist/esm/router.js
  var componentTypes = [
    "component",
    "errorComponent",
    "pendingComponent",
    "notFoundComponent"
  ];
  function createRouter(options) {
    return new Router(options);
  }
  var Router = class {
    /**
     * @deprecated Use the `createRouter` function instead
     */
    constructor(options) {
      var _g, _h;
      this.tempLocationKey = `${Math.round(
        Math.random() * 1e7
      )}`;
      this.resetNextScroll = true;
      this.shouldViewTransition = void 0;
      this.subscribers = /* @__PURE__ */ new Set();
      this.startReactTransition = (fn2) => fn2();
      this.update = (newOptions) => {
        var _a9, _b2;
        if (newOptions.notFoundRoute) {
          console.warn(
            "The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info."
          );
        }
        const previousOptions = this.options;
        this.options = __spreadValues(__spreadValues({}, this.options), newOptions);
        this.isServer = (_a9 = this.options.isServer) != null ? _a9 : typeof document === "undefined";
        if (!this.basepath || newOptions.basepath && newOptions.basepath !== previousOptions.basepath) {
          if (newOptions.basepath === void 0 || newOptions.basepath === "" || newOptions.basepath === "/") {
            this.basepath = "/";
          } else {
            this.basepath = `/${trimPath(newOptions.basepath)}`;
          }
        }
        if (
          // eslint-disable-next-line ts/no-unnecessary-condition
          !this.history || this.options.history && this.options.history !== this.history
        ) {
          this.history = (_b2 = this.options.history) != null ? _b2 : this.isServer ? createMemoryHistory({
            initialEntries: [this.basepath || "/"]
          }) : createBrowserHistory();
          this.latestLocation = this.parseLocation();
        }
        if (this.options.routeTree !== this.routeTree) {
          this.routeTree = this.options.routeTree;
          this.buildRouteTree();
        }
        if (!this.__store) {
          this.__store = new Store(getInitialRouterState(this.latestLocation), {
            onUpdate: () => {
              this.__store.state = __spreadProps(__spreadValues({}, this.state), {
                cachedMatches: this.state.cachedMatches.filter(
                  (d5) => !["redirected"].includes(d5.status)
                )
              });
            }
          });
        }
      };
      this.buildRouteTree = () => {
        this.routesById = {};
        this.routesByPath = {};
        const notFoundRoute = this.options.notFoundRoute;
        if (notFoundRoute) {
          notFoundRoute.init({ originalIndex: 99999999999 });
          this.routesById[notFoundRoute.id] = notFoundRoute;
        }
        const recurseRoutes = (childRoutes) => {
          childRoutes.forEach((childRoute, i5) => {
            childRoute.init({ originalIndex: i5 });
            const existingRoute = this.routesById[childRoute.id];
            invariant(
              !existingRoute,
              `Duplicate routes found with id: ${String(childRoute.id)}`
            );
            this.routesById[childRoute.id] = childRoute;
            if (!childRoute.isRoot && childRoute.path) {
              const trimmedFullPath = trimPathRight(childRoute.fullPath);
              if (!this.routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith("/")) {
                this.routesByPath[trimmedFullPath] = childRoute;
              }
            }
            const children = childRoute.children;
            if (children == null ? void 0 : children.length) {
              recurseRoutes(children);
            }
          });
        };
        recurseRoutes([this.routeTree]);
        const scoredRoutes = [];
        const routes = Object.values(this.routesById);
        routes.forEach((d5, i5) => {
          var _a9;
          if (d5.isRoot || !d5.path) {
            return;
          }
          const trimmed = trimPathLeft(d5.fullPath);
          const parsed = parsePathname(trimmed);
          while (parsed.length > 1 && ((_a9 = parsed[0]) == null ? void 0 : _a9.value) === "/") {
            parsed.shift();
          }
          const scores = parsed.map((segment) => {
            if (segment.value === "/") {
              return 0.75;
            }
            if (segment.type === "param") {
              return 0.5;
            }
            if (segment.type === "wildcard") {
              return 0.25;
            }
            return 1;
          });
          scoredRoutes.push({ child: d5, trimmed, parsed, index: i5, scores });
        });
        this.flatRoutes = scoredRoutes.sort((a3, b2) => {
          const minLength = Math.min(a3.scores.length, b2.scores.length);
          for (let i5 = 0; i5 < minLength; i5++) {
            if (a3.scores[i5] !== b2.scores[i5]) {
              return b2.scores[i5] - a3.scores[i5];
            }
          }
          if (a3.scores.length !== b2.scores.length) {
            return b2.scores.length - a3.scores.length;
          }
          for (let i5 = 0; i5 < minLength; i5++) {
            if (a3.parsed[i5].value !== b2.parsed[i5].value) {
              return a3.parsed[i5].value > b2.parsed[i5].value ? 1 : -1;
            }
          }
          return a3.index - b2.index;
        }).map((d5, i5) => {
          d5.child.rank = i5;
          return d5.child;
        });
      };
      this.subscribe = (eventType, fn2) => {
        const listener = {
          eventType,
          fn: fn2
        };
        this.subscribers.add(listener);
        return () => {
          this.subscribers.delete(listener);
        };
      };
      this.emit = (routerEvent) => {
        this.subscribers.forEach((listener) => {
          if (listener.eventType === routerEvent.type) {
            listener.fn(routerEvent);
          }
        });
      };
      this.parseLocation = (previousLocation) => {
        const parse2 = ({
          pathname,
          search,
          hash: hash3,
          state
        }) => {
          var _a9;
          const parsedSearch = this.options.parseSearch(search);
          const searchStr = this.options.stringifySearch(parsedSearch);
          return {
            pathname,
            searchStr,
            search: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),
            hash: (_a9 = hash3.split("#").reverse()[0]) != null ? _a9 : "",
            href: `${pathname}${searchStr}${hash3}`,
            state: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.state, state)
          };
        };
        const location = parse2(this.history.location);
        const { __tempLocation, __tempKey } = location.state;
        if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {
          const parsedTempLocation = parse2(__tempLocation);
          parsedTempLocation.state.key = location.state.key;
          delete parsedTempLocation.state.__tempLocation;
          return __spreadProps(__spreadValues({}, parsedTempLocation), {
            maskedLocation: location
          });
        }
        return location;
      };
      this.resolvePathWithBase = (from2, path) => {
        const resolvedPath = resolvePath({
          basepath: this.basepath,
          base: from2,
          to: cleanPath(path),
          trailingSlash: this.options.trailingSlash
        });
        return resolvedPath;
      };
      this.matchRoutes = (pathname, locationSearch, opts) => {
        let routeParams = {};
        const foundRoute = this.flatRoutes.find((route) => {
          var _a9;
          const matchedParams = matchPathname(
            this.basepath,
            trimPathRight(pathname),
            {
              to: route.fullPath,
              caseSensitive: (_a9 = route.options.caseSensitive) != null ? _a9 : this.options.caseSensitive,
              fuzzy: true
            }
          );
          if (matchedParams) {
            routeParams = matchedParams;
            return true;
          }
          return false;
        });
        let routeCursor = foundRoute || this.routesById[rootRouteId];
        const matchedRoutes = [routeCursor];
        let isGlobalNotFound = false;
        if (
          // If we found a route, and it's not an index route and we have left over path
          foundRoute ? foundRoute.path !== "/" && routeParams["**"] : (
            // Or if we didn't find a route and we have left over path
            trimPathRight(pathname)
          )
        ) {
          if (this.options.notFoundRoute) {
            matchedRoutes.push(this.options.notFoundRoute);
          } else {
            isGlobalNotFound = true;
          }
        }
        while (routeCursor.parentRoute) {
          routeCursor = routeCursor.parentRoute;
          matchedRoutes.unshift(routeCursor);
        }
        const globalNotFoundRouteId = (() => {
          if (!isGlobalNotFound) {
            return void 0;
          }
          if (this.options.notFoundMode !== "root") {
            for (let i5 = matchedRoutes.length - 1; i5 >= 0; i5--) {
              const route = matchedRoutes[i5];
              if (route.children) {
                return route.id;
              }
            }
          }
          return rootRouteId;
        })();
        const parseErrors = matchedRoutes.map((route) => {
          var _a10;
          var _a9;
          let parsedParamsError;
          const parseParams = (_a10 = (_a9 = route.options.params) == null ? void 0 : _a9.parse) != null ? _a10 : route.options.parseParams;
          if (parseParams) {
            try {
              const parsedParams = parseParams(routeParams);
              Object.assign(routeParams, parsedParams);
            } catch (err) {
              parsedParamsError = new PathParamError(err.message, {
                cause: err
              });
              if (opts == null ? void 0 : opts.throwOnError) {
                throw parsedParamsError;
              }
              return parsedParamsError;
            }
          }
          return;
        });
        const matches = [];
        matchedRoutes.forEach((route, index2) => {
          var _a10;
          var _a9, _b2, _c, _d, _e, _f, _g2, _h2, _i, _j;
          const parentMatch = matches[index2 - 1];
          const [preMatchSearch, searchError] = (() => {
            var _a11, _b3;
            const parentSearch = (_a11 = parentMatch == null ? void 0 : parentMatch.search) != null ? _a11 : locationSearch;
            try {
              const validator = typeof route.options.validateSearch === "object" ? route.options.validateSearch.parse : route.options.validateSearch;
              const search = (_b3 = validator == null ? void 0 : validator(parentSearch)) != null ? _b3 : {};
              return [
                __spreadValues(__spreadValues({}, parentSearch), search),
                void 0
              ];
            } catch (err) {
              const searchParamError = new SearchParamError(err.message, {
                cause: err
              });
              if (opts == null ? void 0 : opts.throwOnError) {
                throw searchParamError;
              }
              return [parentSearch, searchParamError];
            }
          })();
          const loaderDeps = (_a10 = (_b2 = (_a9 = route.options).loaderDeps) == null ? void 0 : _b2.call(_a9, {
            search: preMatchSearch
          })) != null ? _a10 : "";
          const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : "";
          const interpolatedPath = interpolatePath({
            path: route.fullPath,
            params: routeParams
          });
          const matchId = interpolatePath({
            path: route.id,
            params: routeParams,
            leaveWildcards: true
          }) + loaderDepsHash;
          const existingMatch = this.getMatch(matchId);
          const cause = this.state.matches.find((d5) => d5.id === matchId) ? "stay" : "enter";
          let match;
          if (existingMatch) {
            match = __spreadProps(__spreadValues({}, existingMatch), {
              cause,
              params: routeParams
            });
          } else {
            const status = route.options.loader || route.options.beforeLoad || route.lazyFn ? "pending" : "success";
            match = {
              id: matchId,
              index: index2,
              routeId: route.id,
              params: routeParams,
              pathname: joinPaths([this.basepath, interpolatedPath]),
              updatedAt: Date.now(),
              search: {},
              searchError: void 0,
              status,
              isFetching: false,
              error: void 0,
              paramsError: parseErrors[index2],
              routeContext: void 0,
              context: void 0,
              abortController: new AbortController(),
              fetchCount: 0,
              cause,
              loaderDeps,
              invalid: false,
              preload: false,
              links: (_d = (_c = route.options).links) == null ? void 0 : _d.call(_c),
              scripts: (_f = (_e = route.options).scripts) == null ? void 0 : _f.call(_e),
              staticData: route.options.staticData || {},
              loadPromise: createControlledPromise()
            };
          }
          if (match.status === "success") {
            match.meta = (_h2 = (_g2 = route.options).meta) == null ? void 0 : _h2.call(_g2, {
              matches,
              match,
              params: match.params,
              loaderData: match.loaderData
            });
            match.headers = (_j = (_i = route.options).headers) == null ? void 0 : _j.call(_i, {
              loaderData: match.loaderData
            });
          }
          if (!(opts == null ? void 0 : opts.preload)) {
            match.globalNotFound = globalNotFoundRouteId === route.id;
          }
          match.search = replaceEqualDeep(match.search, preMatchSearch);
          match.searchError = searchError;
          matches.push(match);
        });
        return matches;
      };
      this.cancelMatch = (id) => {
        const match = this.getMatch(id);
        if (!match) return;
        match.abortController.abort();
        clearTimeout(match.pendingTimeout);
      };
      this.cancelMatches = () => {
        var _a9;
        (_a9 = this.state.pendingMatches) == null ? void 0 : _a9.forEach((match) => {
          this.cancelMatch(match.id);
        });
      };
      this.buildLocation = (opts) => {
        const build = (dest = {}, matches) => {
          var _a10, _b3, _c2, _d;
          var _a9, _b2, _c;
          const fromMatches = dest._fromLocation != null ? this.matchRoutes(
            dest._fromLocation.pathname,
            dest.fromSearch || dest._fromLocation.search
          ) : this.state.matches;
          const fromMatch = dest.from != null ? fromMatches.find(
            (d5) => matchPathname(this.basepath, trimPathRight(d5.pathname), {
              to: dest.from,
              caseSensitive: false,
              fuzzy: false
            })
          ) : void 0;
          const fromPath = (fromMatch == null ? void 0 : fromMatch.pathname) || this.latestLocation.pathname;
          invariant(
            dest.from == null || fromMatch != null,
            "Could not find match for from: " + dest.from
          );
          const fromSearch = ((_a9 = last(fromMatches)) == null ? void 0 : _a9.search) || this.latestLocation.search;
          const stayingMatches = matches == null ? void 0 : matches.filter(
            (d5) => fromMatches.find((e3) => e3.routeId === d5.routeId)
          );
          const fromRouteByFromPathRouteId = this.routesById[(_b2 = stayingMatches == null ? void 0 : stayingMatches.find((d5) => d5.pathname === fromPath)) == null ? void 0 : _b2.routeId];
          let pathname = dest.to ? this.resolvePathWithBase(fromPath, `${dest.to}`) : this.resolvePathWithBase(
            fromPath,
            (_a10 = fromRouteByFromPathRouteId == null ? void 0 : fromRouteByFromPathRouteId.to) != null ? _a10 : fromPath
          );
          const prevParams = __spreadValues({}, (_c = last(fromMatches)) == null ? void 0 : _c.params);
          let nextParams = ((_b3 = dest.params) != null ? _b3 : true) === true ? prevParams : __spreadValues(__spreadValues({}, prevParams), functionalUpdate(dest.params, prevParams));
          if (Object.keys(nextParams).length > 0) {
            matches == null ? void 0 : matches.map((d5) => {
              var _a11;
              var _a22;
              const route = this.looseRoutesById[d5.routeId];
              return (_a11 = (_a22 = route == null ? void 0 : route.options.params) == null ? void 0 : _a22.stringify) != null ? _a11 : route.options.stringifyParams;
            }).filter(Boolean).forEach((fn2) => {
              nextParams = __spreadValues(__spreadValues({}, nextParams), fn2(nextParams));
            });
          }
          pathname = interpolatePath({
            path: pathname,
            params: nextParams != null ? nextParams : {},
            leaveWildcards: false,
            leaveParams: opts.leaveParams
          });
          const preSearchFilters = (_c2 = stayingMatches == null ? void 0 : stayingMatches.map(
            (match) => {
              var _a11;
              return (_a11 = this.looseRoutesById[match.routeId].options.preSearchFilters) != null ? _a11 : [];
            }
          ).flat().filter(Boolean)) != null ? _c2 : [];
          const postSearchFilters = (_d = stayingMatches == null ? void 0 : stayingMatches.map(
            (match) => {
              var _a11;
              return (_a11 = this.looseRoutesById[match.routeId].options.postSearchFilters) != null ? _a11 : [];
            }
          ).flat().filter(Boolean)) != null ? _d : [];
          const preFilteredSearch = preSearchFilters.length ? preSearchFilters.reduce((prev, next) => next(prev), fromSearch) : fromSearch;
          const destSearch = dest.search === true ? preFilteredSearch : dest.search ? functionalUpdate(dest.search, preFilteredSearch) : preSearchFilters.length ? preFilteredSearch : {};
          const postFilteredSearch = postSearchFilters.length ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;
          const search = replaceEqualDeep(fromSearch, postFilteredSearch);
          const searchStr = this.options.stringifySearch(search);
          const hash3 = dest.hash === true ? this.latestLocation.hash : dest.hash ? functionalUpdate(dest.hash, this.latestLocation.hash) : void 0;
          const hashStr = hash3 ? `#${hash3}` : "";
          let nextState = dest.state === true ? this.latestLocation.state : dest.state ? functionalUpdate(dest.state, this.latestLocation.state) : {};
          nextState = replaceEqualDeep(this.latestLocation.state, nextState);
          return {
            pathname,
            search,
            searchStr,
            state: nextState,
            hash: hash3 != null ? hash3 : "",
            href: `${pathname}${searchStr}${hashStr}`,
            unmaskOnReload: dest.unmaskOnReload
          };
        };
        const buildWithMatches = (dest = {}, maskedDest) => {
          var _a9;
          const next = build(dest);
          let maskedNext = maskedDest ? build(maskedDest) : void 0;
          if (!maskedNext) {
            let params = {};
            const foundMask = (_a9 = this.options.routeMasks) == null ? void 0 : _a9.find((d5) => {
              const match = matchPathname(this.basepath, next.pathname, {
                to: d5.from,
                caseSensitive: false,
                fuzzy: false
              });
              if (match) {
                params = match;
                return true;
              }
              return false;
            });
            if (foundMask) {
              const _a10 = foundMask, { from: from2 } = _a10, maskProps = __objRest(_a10, ["from"]);
              maskedDest = __spreadProps(__spreadValues(__spreadValues({}, pick(opts, ["from"])), maskProps), {
                params
              });
              maskedNext = build(maskedDest);
            }
          }
          const nextMatches = this.matchRoutes(next.pathname, next.search);
          const maskedMatches = maskedNext ? this.matchRoutes(maskedNext.pathname, maskedNext.search) : void 0;
          const maskedFinal = maskedNext ? build(maskedDest, maskedMatches) : void 0;
          const final = build(dest, nextMatches);
          if (maskedFinal) {
            final.maskedLocation = maskedFinal;
          }
          return final;
        };
        if (opts.mask) {
          return buildWithMatches(opts, __spreadValues(__spreadValues({}, pick(opts, ["from"])), opts.mask));
        }
        return buildWithMatches(opts);
      };
      this.commitLocation = (_a9) => {
        var _b2 = _a9, {
          viewTransition,
          ignoreBlocker
        } = _b2, next = __objRest(_b2, [
          "viewTransition",
          "ignoreBlocker"
        ]);
        var _b3, _c, _d;
        const isSameState = () => {
          next.state.key = this.latestLocation.state.key;
          const isEqual2 = deepEqual(next.state, this.latestLocation.state);
          delete next.state.key;
          return isEqual2;
        };
        const isSameUrl = this.latestLocation.href === next.href;
        const previousCommitPromise = this.commitLocationPromise;
        this.commitLocationPromise = createControlledPromise(() => {
          previousCommitPromise == null ? void 0 : previousCommitPromise.resolve();
        });
        if (isSameUrl && isSameState()) {
          this.load();
        } else {
          let _a10 = next, { maskedLocation } = _a10, nextHistory = __objRest(_a10, ["maskedLocation"]);
          if (maskedLocation) {
            nextHistory = __spreadProps(__spreadValues({}, maskedLocation), {
              state: __spreadProps(__spreadValues({}, maskedLocation.state), {
                __tempKey: void 0,
                __tempLocation: __spreadProps(__spreadValues({}, nextHistory), {
                  search: nextHistory.searchStr,
                  state: __spreadProps(__spreadValues({}, nextHistory.state), {
                    __tempKey: void 0,
                    __tempLocation: void 0,
                    key: void 0
                  })
                })
              })
            });
            if ((_c = (_b3 = nextHistory.unmaskOnReload) != null ? _b3 : this.options.unmaskOnReload) != null ? _c : false) {
              nextHistory.state.__tempKey = this.tempLocationKey;
            }
          }
          this.shouldViewTransition = viewTransition;
          this.history[next.replace ? "replace" : "push"](
            nextHistory.href,
            nextHistory.state,
            { ignoreBlocker }
          );
        }
        this.resetNextScroll = (_d = next.resetScroll) != null ? _d : true;
        if (!this.history.subscribers.size) {
          this.load();
        }
        return this.commitLocationPromise;
      };
      this.buildAndCommitLocation = (_c = {}) => {
        var _d = _c, {
          replace,
          resetScroll,
          viewTransition,
          ignoreBlocker
        } = _d, rest = __objRest(_d, [
          "replace",
          "resetScroll",
          "viewTransition",
          "ignoreBlocker"
        ]);
        const location = this.buildLocation(rest);
        return this.commitLocation(__spreadProps(__spreadValues({}, location), {
          viewTransition,
          replace,
          resetScroll,
          ignoreBlocker
        }));
      };
      this.navigate = (_e) => {
        var _f = _e, { from: from2, to: to2, __isRedirect } = _f, rest = __objRest(_f, ["from", "to", "__isRedirect"]);
        const toString = String(to2);
        let isExternal;
        try {
          new URL(`${toString}`);
          isExternal = true;
        } catch (e3) {
        }
        invariant(
          !isExternal,
          "Attempting to navigate to external url with router.navigate!"
        );
        return this.buildAndCommitLocation(__spreadProps(__spreadValues({}, rest), {
          from: from2,
          to: to2
          // to: toString,
        }));
      };
      this.load = async () => {
        this.latestLocation = this.parseLocation(this.latestLocation);
        this.__store.setState((s7) => __spreadProps(__spreadValues({}, s7), {
          loadedAt: Date.now()
        }));
        let redirect;
        let notFound;
        const loadPromise = new Promise((resolve2) => {
          this.startReactTransition(async () => {
            var _a9;
            try {
              const next = this.latestLocation;
              const prevLocation = this.state.resolvedLocation;
              const pathDidChange = prevLocation.href !== next.href;
              this.cancelMatches();
              let pendingMatches;
              this.__store.batch(() => {
                pendingMatches = this.matchRoutes(next.pathname, next.search);
                this.__store.setState((s7) => __spreadProps(__spreadValues({}, s7), {
                  status: "pending",
                  isLoading: true,
                  location: next,
                  pendingMatches,
                  // If a cached moved to pendingMatches, remove it from cachedMatches
                  cachedMatches: s7.cachedMatches.filter((d5) => {
                    return !pendingMatches.find((e3) => e3.id === d5.id);
                  })
                }));
              });
              if (!this.state.redirect) {
                this.emit({
                  type: "onBeforeNavigate",
                  fromLocation: prevLocation,
                  toLocation: next,
                  pathChanged: pathDidChange
                });
              }
              this.emit({
                type: "onBeforeLoad",
                fromLocation: prevLocation,
                toLocation: next,
                pathChanged: pathDidChange
              });
              await this.loadMatches({
                matches: pendingMatches,
                location: next,
                // eslint-disable-next-line ts/require-await
                onReady: async () => {
                  this.startViewTransition(async () => {
                    let exitingMatches;
                    let enteringMatches;
                    let stayingMatches;
                    this.__store.batch(() => {
                      this.__store.setState((s7) => {
                        const previousMatches = s7.matches;
                        const newMatches = s7.pendingMatches || s7.matches;
                        exitingMatches = previousMatches.filter(
                          (match) => !newMatches.find((d5) => d5.id === match.id)
                        );
                        enteringMatches = newMatches.filter(
                          (match) => !previousMatches.find((d5) => d5.id === match.id)
                        );
                        stayingMatches = previousMatches.filter(
                          (match) => newMatches.find((d5) => d5.id === match.id)
                        );
                        return __spreadProps(__spreadValues({}, s7), {
                          isLoading: false,
                          matches: newMatches,
                          pendingMatches: void 0,
                          cachedMatches: [
                            ...s7.cachedMatches,
                            ...exitingMatches.filter((d5) => d5.status !== "error")
                          ]
                        });
                      });
                      this.cleanCache();
                    });
                    [
                      [exitingMatches, "onLeave"],
                      [enteringMatches, "onEnter"],
                      [stayingMatches, "onStay"]
                    ].forEach(([matches, hook]) => {
                      matches.forEach((match) => {
                        var _a22, _b2;
                        (_b2 = (_a22 = this.looseRoutesById[match.routeId].options)[hook]) == null ? void 0 : _b2.call(_a22, match);
                      });
                    });
                  });
                }
              });
            } catch (err) {
              if (isResolvedRedirect(err)) {
                redirect = err;
                if (!this.isServer) {
                  this.navigate(__spreadProps(__spreadValues({}, err), { replace: true, __isRedirect: true }));
                }
              } else if (isNotFound(err)) {
                notFound = err;
              }
              this.__store.setState((s7) => __spreadProps(__spreadValues({}, s7), {
                statusCode: redirect ? redirect.statusCode : notFound ? 404 : s7.matches.some((d5) => d5.status === "error") ? 500 : 200,
                redirect
              }));
            }
            if (this.latestLoadPromise === loadPromise) {
              (_a9 = this.commitLocationPromise) == null ? void 0 : _a9.resolve();
              this.latestLoadPromise = void 0;
              this.commitLocationPromise = void 0;
            }
            resolve2();
          });
        });
        this.latestLoadPromise = loadPromise;
        await loadPromise;
        while (this.latestLoadPromise && loadPromise !== this.latestLoadPromise) {
          await this.latestLoadPromise;
        }
      };
      this.startViewTransition = (fn2) => {
        var _a10;
        var _a9, _b2;
        const shouldViewTransition = (_a10 = this.shouldViewTransition) != null ? _a10 : this.options.defaultViewTransition;
        delete this.shouldViewTransition;
        ((_b2 = (_a9 = shouldViewTransition && typeof document !== "undefined" ? document : void 0) == null ? void 0 : _a9.startViewTransition) == null ? void 0 : _b2.call(_a9, fn2)) || fn2();
      };
      this.updateMatch = (id, updater) => {
        var _a9;
        let updated;
        const isPending = (_a9 = this.state.pendingMatches) == null ? void 0 : _a9.find((d5) => d5.id === id);
        const isMatched = this.state.matches.find((d5) => d5.id === id);
        const matchesKey = isPending ? "pendingMatches" : isMatched ? "matches" : "cachedMatches";
        this.__store.setState((s7) => {
          var _a22;
          return __spreadProps(__spreadValues({}, s7), {
            [matchesKey]: (_a22 = s7[matchesKey]) == null ? void 0 : _a22.map(
              (d5) => d5.id === id ? updated = updater(d5) : d5
            )
          });
        });
        return updated;
      };
      this.getMatch = (matchId) => {
        var _a9;
        return [
          ...this.state.cachedMatches,
          ...(_a9 = this.state.pendingMatches) != null ? _a9 : [],
          ...this.state.matches
        ].find((d5) => d5.id === matchId);
      };
      this.loadMatches = async ({
        location,
        matches,
        preload,
        onReady,
        updateMatch = this.updateMatch
      }) => {
        let firstBadMatchIndex;
        let rendered = false;
        const triggerOnReady = async () => {
          if (!rendered) {
            rendered = true;
            await (onReady == null ? void 0 : onReady());
          }
        };
        if (!this.isServer && !this.state.matches.length) {
          triggerOnReady();
        }
        const handleRedirectAndNotFound = (match, err) => {
          var _a9, _b2, _c;
          if (isResolvedRedirect(err)) throw err;
          if (isRedirect(err) || isNotFound(err)) {
            updateMatch(match.id, (prev) => __spreadProps(__spreadValues({}, prev), {
              status: isRedirect(err) ? "redirected" : isNotFound(err) ? "notFound" : "error",
              isFetching: false,
              error: err,
              beforeLoadPromise: void 0,
              loaderPromise: void 0
            }));
            if (!err.routeId) {
              err.routeId = match.routeId;
            }
            (_a9 = match.beforeLoadPromise) == null ? void 0 : _a9.resolve();
            (_b2 = match.loaderPromise) == null ? void 0 : _b2.resolve();
            (_c = match.loadPromise) == null ? void 0 : _c.resolve();
            if (isRedirect(err)) {
              rendered = true;
              err = this.resolveRedirect(__spreadProps(__spreadValues({}, err), { _fromLocation: location }));
              throw err;
            } else if (isNotFound(err)) {
              this._handleNotFound(matches, err, {
                updateMatch
              });
              throw err;
            }
          }
        };
        try {
          await new Promise((resolveAll, rejectAll) => {
            ;
            (async () => {
              var _a10, _b3, _c2;
              var _a9, _b2, _c;
              try {
                const handleSerialError = (index2, err, routerCode) => {
                  var _a22, _b22;
                  const { id: matchId, routeId } = matches[index2];
                  const route = this.looseRoutesById[routeId];
                  if (err instanceof Promise) {
                    throw err;
                  }
                  err.routerCode = routerCode;
                  firstBadMatchIndex = firstBadMatchIndex != null ? firstBadMatchIndex : index2;
                  handleRedirectAndNotFound(this.getMatch(matchId), err);
                  try {
                    (_b22 = (_a22 = route.options).onError) == null ? void 0 : _b22.call(_a22, err);
                  } catch (errorHandlerErr) {
                    err = errorHandlerErr;
                    handleRedirectAndNotFound(this.getMatch(matchId), err);
                  }
                  updateMatch(matchId, (prev) => {
                    var _a32;
                    (_a32 = prev.beforeLoadPromise) == null ? void 0 : _a32.resolve();
                    return __spreadProps(__spreadValues({}, prev), {
                      error: err,
                      status: "error",
                      isFetching: false,
                      updatedAt: Date.now(),
                      abortController: new AbortController(),
                      beforeLoadPromise: void 0
                    });
                  });
                };
                for (const [index2, { id: matchId, routeId }] of matches.entries()) {
                  const existingMatch = this.getMatch(matchId);
                  if (
                    // If we are in the middle of a load, either of these will be present
                    // (not to be confused with `loadPromise`, which is always defined)
                    existingMatch.beforeLoadPromise || existingMatch.loaderPromise
                  ) {
                    await existingMatch.beforeLoadPromise;
                  } else {
                    try {
                      updateMatch(matchId, (prev) => __spreadProps(__spreadValues({}, prev), {
                        loadPromise: createControlledPromise(() => {
                          var _a22;
                          (_a22 = prev.loadPromise) == null ? void 0 : _a22.resolve();
                        }),
                        beforeLoadPromise: createControlledPromise()
                      }));
                      const route = this.looseRoutesById[routeId];
                      const abortController2 = new AbortController();
                      const parentMatchId = (_a9 = matches[index2 - 1]) == null ? void 0 : _a9.id;
                      const getParentContext = () => {
                        var _a11, _b4, _c3;
                        if (!parentMatchId) {
                          return (_a11 = this.options.context) != null ? _a11 : {};
                        }
                        return (_c3 = (_b4 = this.getMatch(parentMatchId).context) != null ? _b4 : this.options.context) != null ? _c3 : {};
                      };
                      const pendingMs = (_a10 = route.options.pendingMs) != null ? _a10 : this.options.defaultPendingMs;
                      const shouldPending = !!(onReady && !this.isServer && !preload && (route.options.loader || route.options.beforeLoad) && typeof pendingMs === "number" && pendingMs !== Infinity && ((_b3 = route.options.pendingComponent) != null ? _b3 : this.options.defaultPendingComponent));
                      let pendingTimeout;
                      if (shouldPending) {
                        pendingTimeout = setTimeout(() => {
                          try {
                            triggerOnReady();
                          } catch (e3) {
                          }
                        }, pendingMs);
                      }
                      const { paramsError, searchError } = this.getMatch(matchId);
                      if (paramsError) {
                        handleSerialError(index2, paramsError, "PARSE_PARAMS");
                      }
                      if (searchError) {
                        handleSerialError(index2, searchError, "VALIDATE_SEARCH");
                      }
                      const parentContext = getParentContext();
                      updateMatch(matchId, (prev) => __spreadProps(__spreadValues({}, prev), {
                        isFetching: "beforeLoad",
                        fetchCount: prev.fetchCount + 1,
                        routeContext: replaceEqualDeep(
                          prev.routeContext,
                          parentContext
                        ),
                        context: replaceEqualDeep(prev.context, parentContext),
                        abortController: abortController2,
                        pendingTimeout
                      }));
                      const { search, params, routeContext, cause } = this.getMatch(matchId);
                      const beforeLoadFnContext = {
                        search,
                        abortController: abortController2,
                        params,
                        preload: !!preload,
                        context: routeContext,
                        location,
                        navigate: (opts) => this.navigate(__spreadProps(__spreadValues({}, opts), { _fromLocation: location })),
                        buildLocation: this.buildLocation,
                        cause: preload ? "preload" : cause
                      };
                      const beforeLoadContext = (_c2 = await ((_c = (_b2 = route.options).beforeLoad) == null ? void 0 : _c.call(_b2, beforeLoadFnContext))) != null ? _c2 : {};
                      if (isRedirect(beforeLoadContext) || isNotFound(beforeLoadContext)) {
                        handleSerialError(index2, beforeLoadContext, "BEFORE_LOAD");
                      }
                      updateMatch(matchId, (prev) => {
                        const routeContext2 = __spreadValues(__spreadValues({}, prev.routeContext), beforeLoadContext);
                        return __spreadProps(__spreadValues({}, prev), {
                          routeContext: replaceEqualDeep(
                            prev.routeContext,
                            routeContext2
                          ),
                          context: replaceEqualDeep(prev.context, routeContext2),
                          abortController: abortController2
                        });
                      });
                    } catch (err) {
                      handleSerialError(index2, err, "BEFORE_LOAD");
                    }
                    updateMatch(matchId, (prev) => {
                      var _a22;
                      (_a22 = prev.beforeLoadPromise) == null ? void 0 : _a22.resolve();
                      return __spreadProps(__spreadValues({}, prev), {
                        beforeLoadPromise: void 0,
                        isFetching: false
                      });
                    });
                  }
                }
                const validResolvedMatches = matches.slice(0, firstBadMatchIndex);
                const matchPromises = [];
                validResolvedMatches.forEach(({ id: matchId, routeId }, index2) => {
                  matchPromises.push(
                    (async () => {
                      var _a11, _b4, _c3, _d;
                      const { loaderPromise: prevLoaderPromise } = this.getMatch(matchId);
                      if (prevLoaderPromise) {
                        await prevLoaderPromise;
                      } else {
                        const parentMatchPromise = matchPromises[index2 - 1];
                        const route = this.looseRoutesById[routeId];
                        const getLoaderContext = () => {
                          const {
                            params,
                            loaderDeps,
                            abortController: abortController2,
                            context,
                            cause
                          } = this.getMatch(matchId);
                          return {
                            params,
                            deps: loaderDeps,
                            preload: !!preload,
                            parentMatchPromise,
                            abortController: abortController2,
                            context,
                            location,
                            navigate: (opts) => this.navigate(__spreadProps(__spreadValues({}, opts), { _fromLocation: location })),
                            cause: preload ? "preload" : cause,
                            route
                          };
                        };
                        const age = Date.now() - this.getMatch(matchId).updatedAt;
                        const staleAge = preload ? (_b4 = (_a11 = route.options.preloadStaleTime) != null ? _a11 : this.options.defaultPreloadStaleTime) != null ? _b4 : 3e4 : (_d = (_c3 = route.options.staleTime) != null ? _c3 : this.options.defaultStaleTime) != null ? _d : 0;
                        const shouldReloadOption = route.options.shouldReload;
                        const shouldReload = typeof shouldReloadOption === "function" ? shouldReloadOption(getLoaderContext()) : shouldReloadOption;
                        updateMatch(matchId, (prev) => __spreadProps(__spreadValues({}, prev), {
                          loaderPromise: createControlledPromise(),
                          preload: !!preload && !this.state.matches.find((d5) => d5.id === matchId)
                        }));
                        const runLoader = async () => {
                          var _a22, _b22, _c22, _d2, _e, _f, _g2, _h2;
                          try {
                            const potentialPendingMinPromise = async () => {
                              const latestMatch = this.getMatch(matchId);
                              if (latestMatch.minPendingPromise) {
                                await latestMatch.minPendingPromise;
                              }
                            };
                            try {
                              route._lazyPromise = route._lazyPromise || (route.lazyFn ? route.lazyFn().then((lazyRoute) => {
                                Object.assign(
                                  route.options,
                                  lazyRoute.options
                                );
                              }) : Promise.resolve());
                              const componentsPromise = this.getMatch(matchId).componentsPromise || route._lazyPromise.then(
                                () => Promise.all(
                                  componentTypes.map(async (type) => {
                                    const component = route.options[type];
                                    if (component == null ? void 0 : component.preload) {
                                      await component.preload();
                                    }
                                  })
                                )
                              );
                              updateMatch(matchId, (prev) => __spreadProps(__spreadValues({}, prev), {
                                isFetching: "loader",
                                componentsPromise
                              }));
                              await route._lazyPromise;
                              let loaderData = await ((_b22 = (_a22 = route.options).loader) == null ? void 0 : _b22.call(_a22, getLoaderContext()));
                              if (this.serializeLoaderData) {
                                loaderData = this.serializeLoaderData(loaderData, {
                                  router: this,
                                  match: this.getMatch(matchId)
                                });
                              }
                              handleRedirectAndNotFound(
                                this.getMatch(matchId),
                                loaderData
                              );
                              await potentialPendingMinPromise();
                              const meta = (_d2 = (_c22 = route.options).meta) == null ? void 0 : _d2.call(_c22, {
                                matches,
                                match: this.getMatch(matchId),
                                params: this.getMatch(matchId).params,
                                loaderData
                              });
                              const headers = (_f = (_e = route.options).headers) == null ? void 0 : _f.call(_e, {
                                loaderData
                              });
                              updateMatch(matchId, (prev) => __spreadProps(__spreadValues({}, prev), {
                                error: void 0,
                                status: "success",
                                isFetching: false,
                                updatedAt: Date.now(),
                                loaderData,
                                meta,
                                headers
                              }));
                            } catch (e3) {
                              let error = e3;
                              await potentialPendingMinPromise();
                              handleRedirectAndNotFound(this.getMatch(matchId), e3);
                              try {
                                (_h2 = (_g2 = route.options).onError) == null ? void 0 : _h2.call(_g2, e3);
                              } catch (onErrorError) {
                                error = onErrorError;
                                handleRedirectAndNotFound(
                                  this.getMatch(matchId),
                                  onErrorError
                                );
                              }
                              updateMatch(matchId, (prev) => __spreadProps(__spreadValues({}, prev), {
                                error,
                                status: "error",
                                isFetching: false
                              }));
                            }
                            await this.getMatch(matchId).componentsPromise;
                          } catch (err) {
                            handleRedirectAndNotFound(this.getMatch(matchId), err);
                          }
                        };
                        const { status, invalid } = this.getMatch(matchId);
                        if (status === "success" && (invalid || (shouldReload != null ? shouldReload : age > staleAge))) {
                          ;
                          (async () => {
                            try {
                              await runLoader();
                            } catch (err) {
                            }
                          })();
                        } else if (status !== "success") {
                          await runLoader();
                        }
                        const { loaderPromise, loadPromise } = this.getMatch(matchId);
                        loaderPromise == null ? void 0 : loaderPromise.resolve();
                        loadPromise == null ? void 0 : loadPromise.resolve();
                      }
                      updateMatch(matchId, (prev) => __spreadProps(__spreadValues({}, prev), {
                        isFetching: false,
                        loaderPromise: void 0
                      }));
                    })()
                  );
                });
                await Promise.all(matchPromises);
                resolveAll();
              } catch (err) {
                rejectAll(err);
              }
            })();
          });
          await triggerOnReady();
        } catch (err) {
          if (isRedirect(err) || isNotFound(err)) {
            if (isNotFound(err) && !preload) {
              await triggerOnReady();
            }
            throw err;
          }
        }
        return matches;
      };
      this.invalidate = () => {
        const invalidate = (d5) => __spreadValues(__spreadProps(__spreadValues({}, d5), {
          invalid: true
        }), d5.status === "error" ? { status: "pending", error: void 0 } : {});
        this.__store.setState((s7) => {
          var _a9;
          return __spreadProps(__spreadValues({}, s7), {
            matches: s7.matches.map(invalidate),
            cachedMatches: s7.cachedMatches.map(invalidate),
            pendingMatches: (_a9 = s7.pendingMatches) == null ? void 0 : _a9.map(invalidate)
          });
        });
        return this.load();
      };
      this.resolveRedirect = (err) => {
        const redirect = err;
        if (!redirect.href) {
          redirect.href = this.buildLocation(redirect).href;
        }
        return redirect;
      };
      this.cleanCache = () => {
        this.__store.setState((s7) => {
          return __spreadProps(__spreadValues({}, s7), {
            cachedMatches: s7.cachedMatches.filter((d5) => {
              var _a9, _b2, _c;
              const route = this.looseRoutesById[d5.routeId];
              if (!route.options.loader) {
                return false;
              }
              const gcTime = (_c = d5.preload ? (_a9 = route.options.preloadGcTime) != null ? _a9 : this.options.defaultPreloadGcTime : (_b2 = route.options.gcTime) != null ? _b2 : this.options.defaultGcTime) != null ? _c : 5 * 60 * 1e3;
              return d5.status !== "error" && Date.now() - d5.updatedAt < gcTime;
            })
          });
        });
      };
      this.preloadRoute = async (opts) => {
        var _a9, _b2;
        const next = this.buildLocation(opts);
        let matches = this.matchRoutes(next.pathname, next.search, {
          throwOnError: true,
          preload: true
        });
        const loadedMatchIds = Object.fromEntries(
          [
            ...this.state.matches,
            ...(_a9 = this.state.pendingMatches) != null ? _a9 : [],
            ...this.state.cachedMatches
          ].map((d5) => [d5.id, true])
        );
        this.__store.batch(() => {
          matches.forEach((match) => {
            if (!loadedMatchIds[match.id]) {
              this.__store.setState((s7) => __spreadProps(__spreadValues({}, s7), {
                cachedMatches: [...s7.cachedMatches, match]
              }));
            }
          });
        });
        const activeMatchIds = new Set(
          [...this.state.matches, ...(_b2 = this.state.pendingMatches) != null ? _b2 : []].map(
            (d5) => d5.id
          )
        );
        try {
          matches = await this.loadMatches({
            matches,
            location: next,
            preload: true,
            updateMatch: (id, updater) => {
              if (activeMatchIds.has(id)) {
                matches = matches.map((d5) => d5.id === id ? updater(d5) : d5);
              } else {
                this.updateMatch(id, updater);
              }
            }
          });
          return matches;
        } catch (err) {
          if (isRedirect(err)) {
            return await this.preloadRoute(__spreadProps(__spreadValues({}, err), {
              _fromLocation: next
            }));
          }
          console.error(err);
          return void 0;
        }
      };
      this.matchRoute = (location, opts) => {
        var _a9;
        const matchLocation = __spreadProps(__spreadValues({}, location), {
          to: location.to ? this.resolvePathWithBase(location.from || "", location.to) : void 0,
          params: location.params || {},
          leaveParams: true
        });
        const next = this.buildLocation(matchLocation);
        if ((opts == null ? void 0 : opts.pending) && this.state.status !== "pending") {
          return false;
        }
        const pending = (opts == null ? void 0 : opts.pending) === void 0 ? !this.state.isLoading : opts.pending;
        const baseLocation = pending ? this.latestLocation : this.state.resolvedLocation;
        const match = matchPathname(this.basepath, baseLocation.pathname, __spreadProps(__spreadValues({}, opts), {
          to: next.pathname
        }));
        if (!match) {
          return false;
        }
        if (location.params) {
          if (!deepEqual(match, location.params, true)) {
            return false;
          }
        }
        if (match && ((_a9 = opts == null ? void 0 : opts.includeSearch) != null ? _a9 : true)) {
          return deepEqual(baseLocation.search, next.search, true) ? match : false;
        }
        return match;
      };
      this.dehydrate = () => {
        var _a10;
        var _a9;
        const pickError = (_a10 = (_a9 = this.options.errorSerializer) == null ? void 0 : _a9.serialize) != null ? _a10 : defaultSerializeError;
        return {
          state: {
            dehydratedMatches: this.state.matches.map((d5) => {
              return __spreadProps(__spreadValues({}, pick(d5, ["id", "status", "updatedAt"])), {
                // If an error occurs server-side during SSRing,
                // send a small subset of the error to the client
                error: d5.error ? {
                  data: pickError(d5.error),
                  __isServerError: true
                } : void 0
                // NOTE: We don't send the loader data here, because
                // there is a potential that it needs to be streamed.
                // Instead, we render it next to the route match in the HTML
                // which gives us the potential to stream it via suspense.
              });
            })
          },
          manifest: this.manifest
        };
      };
      this.hydrate = () => {
        var _a9, _b2, _c;
        let ctx;
        if (typeof document !== "undefined") {
          ctx = this.options.transformer.parse((_a9 = window.__TSR__) == null ? void 0 : _a9.dehydrated);
        }
        invariant(
          ctx,
          "Expected to find a dehydrated data on window.__TSR__.dehydrated... but we did not. Please file an issue!"
        );
        this.dehydratedData = ctx.payload;
        (_c = (_b2 = this.options).hydrate) == null ? void 0 : _c.call(_b2, ctx.payload);
        const dehydratedState = ctx.router.state;
        const matches = this.matchRoutes(
          this.state.location.pathname,
          this.state.location.search
        ).map((match) => {
          const dehydratedMatch = dehydratedState.dehydratedMatches.find(
            (d5) => d5.id === match.id
          );
          invariant(
            dehydratedMatch,
            `Could not find a client-side match for dehydrated match with id: ${match.id}!`
          );
          return __spreadValues(__spreadValues({}, match), dehydratedMatch);
        });
        this.__store.setState((s7) => {
          return __spreadProps(__spreadValues({}, s7), {
            matches
          });
        });
        this.manifest = ctx.router.manifest;
      };
      this.injectedHtml = [];
      this.injectHtml = (html) => {
        const cb = () => {
          this.injectedHtml = this.injectedHtml.filter((d5) => d5 !== cb);
          return html;
        };
        this.injectedHtml.push(cb);
      };
      this.streamedKeys = /* @__PURE__ */ new Set();
      this.getStreamedValue = (key) => {
        var _a9;
        if (this.isServer) {
          return void 0;
        }
        const streamedValue = (_a9 = window.__TSR__) == null ? void 0 : _a9.streamedValues[key];
        if (!streamedValue) {
          return;
        }
        if (!streamedValue.parsed) {
          streamedValue.parsed = this.options.transformer.parse(streamedValue.value);
        }
        return streamedValue.parsed;
      };
      this.streamValue = (key, value) => {
        var _a9;
        tiny_warning_esm_default(
          !this.streamedKeys.has(key),
          "Key has already been streamed: " + key
        );
        this.streamedKeys.add(key);
        const children = `__TSR__.streamedValues['${key}'] = { value: ${(_a9 = this.serializer) == null ? void 0 : _a9.call(this, this.options.transformer.stringify(value))}}`;
        this.injectHtml(
          `<script class='tsr-once'>${children}${true ? `; console.info(\`Injected From Server:
        ${children}\`)` : ""}; __TSR__.cleanScripts()<\/script>`
        );
      };
      this._handleNotFound = (matches, err, {
        updateMatch = this.updateMatch
      } = {}) => {
        const matchesByRouteId = Object.fromEntries(
          matches.map((match2) => [match2.routeId, match2])
        );
        let routeCursor = (err.global ? this.looseRoutesById[rootRouteId] : this.looseRoutesById[err.routeId]) || this.looseRoutesById[rootRouteId];
        while (!routeCursor.options.notFoundComponent && !this.options.defaultNotFoundComponent && routeCursor.id !== rootRouteId) {
          routeCursor = routeCursor.parentRoute;
          invariant(
            routeCursor,
            "Found invalid route tree while trying to find not-found handler."
          );
        }
        const match = matchesByRouteId[routeCursor.id];
        invariant(match, "Could not find match for route: " + routeCursor.id);
        updateMatch(match.id, (prev) => __spreadProps(__spreadValues({}, prev), {
          status: "notFound",
          error: err,
          isFetching: false
        }));
        if (err.routerCode === "BEFORE_LOAD" && routeCursor.parentRoute) {
          err.routeId = routeCursor.parentRoute.id;
          this._handleNotFound(matches, err, {
            updateMatch
          });
        }
      };
      this.hasNotFoundMatch = () => {
        return this.__store.state.matches.some(
          (d5) => d5.status === "notFound" || d5.globalNotFound
        );
      };
      this.update(__spreadProps(__spreadValues({
        defaultPreloadDelay: 50,
        defaultPendingMs: 1e3,
        defaultPendingMinMs: 500,
        context: void 0
      }, options), {
        stringifySearch: (_g = options.stringifySearch) != null ? _g : defaultStringifySearch,
        parseSearch: (_h = options.parseSearch) != null ? _h : defaultParseSearch
      }));
      if (typeof document !== "undefined") {
        window.__TSR__ROUTER__ = this;
      }
    }
    get state() {
      return this.__store.state;
    }
    get looseRoutesById() {
      return this.routesById;
    }
  };
  var SearchParamError = class extends Error {
  };
  var PathParamError = class extends Error {
  };
  function getInitialRouterState(location) {
    return {
      loadedAt: 0,
      isLoading: false,
      isTransitioning: false,
      status: "idle",
      resolvedLocation: __spreadValues({}, location),
      location,
      matches: [],
      pendingMatches: [],
      cachedMatches: [],
      statusCode: 200
    };
  }
  function defaultSerializeError(err) {
    if (err instanceof Error) {
      const obj = {
        name: err.name,
        message: err.message
      };
      if (true) {
        obj.stack = err.stack;
      }
      return obj;
    }
    return {
      data: err
    };
  }

  // node_modules/@tanstack/react-router/dist/esm/isServerSideError.js
  function isServerSideError(error) {
    if (!(typeof error === "object" && error && "data" in error)) return false;
    if (!("__isServerError" in error && error.__isServerError)) return false;
    if (!(typeof error.data === "object" && error.data)) return false;
    return error.__isServerError === true;
  }
  function defaultDeserializeError(serializedData) {
    if ("name" in serializedData && "message" in serializedData) {
      const error = new Error(serializedData.message);
      error.name = serializedData.name;
      if (true) {
        error.stack = serializedData.stack;
      }
      return error;
    }
    return serializedData.data;
  }

  // node_modules/@tanstack/react-router/dist/esm/useMatch.js
  var React6 = __toESM(require_react(), 1);

  // node_modules/@tanstack/react-router/dist/esm/matchContext.js
  var React5 = __toESM(require_react(), 1);
  var matchContext = React5.createContext(void 0);

  // node_modules/@tanstack/react-router/dist/esm/useMatch.js
  function useMatch(opts) {
    const nearestMatchId = React6.useContext(matchContext);
    const matchSelection = useRouterState({
      select: (state) => {
        var _a9;
        const match = state.matches.find(
          (d5) => opts.from ? opts.from === d5.routeId : d5.id === nearestMatchId
        );
        invariant(
          !(((_a9 = opts.shouldThrow) != null ? _a9 : true) && !match),
          `Could not find ${opts.from ? `an active match from "${opts.from}"` : "a nearest match!"}`
        );
        if (match === void 0) {
          return void 0;
        }
        return opts.select ? opts.select(match) : match;
      }
    });
    return matchSelection;
  }

  // node_modules/@tanstack/react-router/dist/esm/useLoaderDeps.js
  function useLoaderDeps(opts) {
    return useMatch(__spreadProps(__spreadValues({}, opts), {
      select: (s7) => {
        return typeof opts.select === "function" ? opts.select(s7.loaderDeps) : s7.loaderDeps;
      }
    }));
  }

  // node_modules/@tanstack/react-router/dist/esm/useLoaderData.js
  function useLoaderData(opts) {
    return useMatch(__spreadProps(__spreadValues({}, opts), {
      select: (s7) => {
        return typeof opts.select === "function" ? opts.select(s7.loaderData) : s7.loaderData;
      }
    }));
  }

  // node_modules/@tanstack/react-router/dist/esm/useParams.js
  function useParams(opts) {
    return useMatch(__spreadProps(__spreadValues({}, opts), {
      select: (match) => {
        return opts.select ? opts.select(match.params) : match.params;
      }
    }));
  }

  // node_modules/@tanstack/react-router/dist/esm/useSearch.js
  function useSearch(opts) {
    return useMatch(__spreadProps(__spreadValues({}, opts), {
      select: (match) => {
        return opts.select ? opts.select(match.search) : match.search;
      }
    }));
  }

  // node_modules/@tanstack/react-router/dist/esm/useNavigate.js
  var React7 = __toESM(require_react(), 1);
  function useNavigate(_defaultOpts) {
    const router = useRouter();
    return React7.useCallback(
      (options) => {
        return router.navigate(__spreadValues({}, options));
      },
      [router]
    );
  }

  // node_modules/@tanstack/react-router/dist/esm/route.js
  var Route = class {
    /**
     * @deprecated Use the `createRoute` function instead.
     */
    constructor(options) {
      this.init = (opts) => {
        var _a9, _b2;
        this.originalIndex = opts.originalIndex;
        const options2 = this.options;
        const isRoot = !(options2 == null ? void 0 : options2.path) && !(options2 == null ? void 0 : options2.id);
        this.parentRoute = (_b2 = (_a9 = this.options) == null ? void 0 : _a9.getParentRoute) == null ? void 0 : _b2.call(_a9);
        if (isRoot) {
          this.path = rootRouteId;
        } else {
          invariant(
            this.parentRoute,
            `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`
          );
        }
        let path = isRoot ? rootRouteId : options2.path;
        if (path && path !== "/") {
          path = trimPathLeft(path);
        }
        const customId = (options2 == null ? void 0 : options2.id) || path;
        let id = isRoot ? rootRouteId : joinPaths([
          this.parentRoute.id === rootRouteId ? "" : this.parentRoute.id,
          customId
        ]);
        if (path === rootRouteId) {
          path = "/";
        }
        if (id !== rootRouteId) {
          id = joinPaths(["/", id]);
        }
        const fullPath = id === rootRouteId ? "/" : joinPaths([this.parentRoute.fullPath, path]);
        this.path = path;
        this.id = id;
        this.fullPath = fullPath;
        this.to = fullPath;
      };
      this.updateLoader = (options2) => {
        Object.assign(this.options, options2);
        return this;
      };
      this.update = (options2) => {
        Object.assign(this.options, options2);
        return this;
      };
      this.lazy = (lazyFn2) => {
        this.lazyFn = lazyFn2;
        return this;
      };
      this.useMatch = (opts) => {
        return useMatch(__spreadProps(__spreadValues({}, opts), { from: this.id }));
      };
      this.useRouteContext = (opts) => {
        return useMatch(__spreadProps(__spreadValues({}, opts), {
          from: this.id,
          select: (d5) => (opts == null ? void 0 : opts.select) ? opts.select(d5.context) : d5.context
        }));
      };
      this.useSearch = (opts) => {
        return useSearch(__spreadProps(__spreadValues({}, opts), { from: this.id }));
      };
      this.useParams = (opts) => {
        return useParams(__spreadProps(__spreadValues({}, opts), { from: this.id }));
      };
      this.useLoaderDeps = (opts) => {
        return useLoaderDeps(__spreadProps(__spreadValues({}, opts), { from: this.id }));
      };
      this.useLoaderData = (opts) => {
        return useLoaderData(__spreadProps(__spreadValues({}, opts), { from: this.id }));
      };
      this.useNavigate = () => {
        return useNavigate({ from: this.id });
      };
      this.options = options || {};
      this.isRoot = !(options == null ? void 0 : options.getParentRoute);
      invariant(
        !((options == null ? void 0 : options.id) && (options == null ? void 0 : options.path)),
        `Route cannot have both an 'id' and a 'path' option.`
      );
      this.$$typeof = Symbol.for("react.memo");
    }
    addChildren(children) {
      this.children = Array.isArray(children) ? children : Object.values(children);
      return this;
    }
  };
  function createRoute(options) {
    return new Route(options);
  }
  var RootRoute = class extends Route {
    /**
     * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.
     */
    constructor(options) {
      super(options);
    }
    addChildren(children) {
      return super.addChildren(children);
    }
  };
  function createRootRoute(options) {
    return new RootRoute(options);
  }

  // node_modules/@tanstack/react-router/dist/esm/link.js
  var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
  var React8 = __toESM(require_react(), 1);
  var import_react_dom = __toESM(require_react_dom(), 1);
  var preloadWarning = "Error preloading route! \u261D\uFE0F";
  function useLinkProps(options) {
    var _b2, _c;
    const router = useRouter();
    const [isTransitioning, setIsTransitioning] = React8.useState(false);
    const _a9 = options, {
      activeProps: activeProps = () => ({ className: "active" }),
      inactiveProps = () => ({}),
      activeOptions,
      hash: hash3,
      search,
      params,
      to: to2,
      state,
      mask,
      preload: userPreload,
      preloadDelay: userPreloadDelay,
      replace,
      startTransition,
      resetScroll,
      viewTransition,
      children: children,
      target,
      disabled,
      style,
      className,
      onClick,
      onFocus,
      onMouseEnter,
      onMouseLeave,
      onTouchStart,
      ignoreBlocker
    } = _a9, rest = __objRest(_a9, [
      // custom props
      "activeProps",
      "inactiveProps",
      "activeOptions",
      "hash",
      "search",
      "params",
      "to",
      "state",
      "mask",
      "preload",
      "preloadDelay",
      "replace",
      "startTransition",
      "resetScroll",
      "viewTransition",
      // element props
      "children",
      "target",
      "disabled",
      "style",
      "className",
      "onClick",
      "onFocus",
      "onMouseEnter",
      "onMouseLeave",
      "onTouchStart",
      "ignoreBlocker"
    ]);
    let type = "internal";
    try {
      new URL(`${to2}`);
      type = "external";
    } catch (e3) {
    }
    const next = router.buildLocation(options);
    const preload = userPreload != null ? userPreload : router.options.defaultPreload;
    const preloadDelay = (_b2 = userPreloadDelay != null ? userPreloadDelay : router.options.defaultPreloadDelay) != null ? _b2 : 0;
    const isActive = useRouterState({
      select: (s7) => {
        var _a10;
        const currentPathSplit = removeTrailingSlash(
          s7.location.pathname,
          router.basepath
        ).split("/");
        const nextPathSplit = removeTrailingSlash(
          next.pathname,
          router.basepath
        ).split("/");
        const pathIsFuzzyEqual = nextPathSplit.every(
          (d5, i5) => d5 === currentPathSplit[i5]
        );
        const pathTest = (activeOptions == null ? void 0 : activeOptions.exact) ? exactPathTest(s7.location.pathname, next.pathname, router.basepath) : pathIsFuzzyEqual;
        const hashTest = (activeOptions == null ? void 0 : activeOptions.includeHash) ? s7.location.hash === next.hash : true;
        const searchTest = ((_a10 = activeOptions == null ? void 0 : activeOptions.includeSearch) != null ? _a10 : true) ? deepEqual(s7.location.search, next.search, !(activeOptions == null ? void 0 : activeOptions.exact)) : true;
        return pathTest && hashTest && searchTest;
      }
    });
    if (type === "external") {
      return __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues({}, rest), {
        type,
        href: to2
      }), children && { children }), target && { target }), disabled && { disabled }), style && { style }), className && { className }), onClick && { onClick }), onFocus && { onFocus }), onMouseEnter && { onMouseEnter }), onMouseLeave && { onMouseLeave }), onTouchStart && { onTouchStart });
    }
    const handleClick = (e3) => {
      if (!disabled && !isCtrlEvent(e3) && !e3.defaultPrevented && (!target || target === "_self") && e3.button === 0) {
        e3.preventDefault();
        (0, import_react_dom.flushSync)(() => {
          setIsTransitioning(true);
        });
        const unsub = router.subscribe("onResolved", () => {
          unsub();
          setIsTransitioning(false);
        });
        router.commitLocation(__spreadProps(__spreadValues({}, next), {
          replace,
          resetScroll,
          startTransition,
          viewTransition,
          ignoreBlocker
        }));
      }
    };
    const doPreload = () => {
      router.preloadRoute(options).catch((err) => {
        console.warn(err);
        console.warn(preloadWarning);
      });
    };
    const handleFocus = (e3) => {
      if (disabled) return;
      if (preload) {
        doPreload();
      }
    };
    const handleTouchStart = handleFocus;
    const handleEnter = (e3) => {
      if (disabled) return;
      const eventTarget = e3.target || {};
      if (preload) {
        if (eventTarget.preloadTimeout) {
          return;
        }
        eventTarget.preloadTimeout = setTimeout(() => {
          eventTarget.preloadTimeout = null;
          doPreload();
        }, preloadDelay);
      }
    };
    const handleLeave = (e3) => {
      if (disabled) return;
      const eventTarget = e3.target || {};
      if (eventTarget.preloadTimeout) {
        clearTimeout(eventTarget.preloadTimeout);
        eventTarget.preloadTimeout = null;
      }
    };
    const composeHandlers = (handlers) => (e3) => {
      var _a10;
      (_a10 = e3.persist) == null ? void 0 : _a10.call(e3);
      handlers.filter(Boolean).forEach((handler) => {
        if (e3.defaultPrevented) return;
        handler(e3);
      });
    };
    const resolvedActiveProps = isActive ? (_c = functionalUpdate(activeProps, {})) != null ? _c : {} : {};
    const resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {});
    const resolvedClassName = [
      className,
      resolvedActiveProps.className,
      resolvedInactiveProps.className
    ].filter(Boolean).join(" ");
    const resolvedStyle = __spreadValues(__spreadValues(__spreadValues({}, style), resolvedActiveProps.style), resolvedInactiveProps.style);
    return __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, resolvedActiveProps), resolvedInactiveProps), rest), {
      href: disabled ? void 0 : next.maskedLocation ? router.history.createHref(next.maskedLocation.href) : router.history.createHref(next.href),
      onClick: composeHandlers([onClick, handleClick]),
      onFocus: composeHandlers([onFocus, handleFocus]),
      onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
      onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
      onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
      disabled: !!disabled,
      target
    }), Object.keys(resolvedStyle).length && { style: resolvedStyle }), resolvedClassName && { className: resolvedClassName }), disabled && {
      role: "link",
      "aria-disabled": true
    }), isActive && { "data-status": "active", "aria-current": "page" }), isTransitioning && { "data-transitioning": "transitioning" });
  }
  var Link = React8.forwardRef((props, ref) => {
    const _a9 = props, { _asChild } = _a9, rest = __objRest(_a9, ["_asChild"]);
    const _b2 = useLinkProps(rest), { type } = _b2, linkProps = __objRest(_b2, ["type"]);
    const children = typeof rest.children === "function" ? rest.children({
      isActive: linkProps["data-status"] === "active"
    }) : rest.children;
    if (typeof _asChild === "undefined") {
      delete linkProps.disabled;
    }
    return React8.createElement(
      _asChild ? _asChild : "a",
      __spreadProps(__spreadValues({}, linkProps), {
        ref
      }),
      children
    );
  });
  function isCtrlEvent(e3) {
    return !!(e3.metaKey || e3.altKey || e3.ctrlKey || e3.shiftKey);
  }

  // node_modules/@tanstack/react-router/dist/esm/Matches.js
  var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
  var React11 = __toESM(require_react(), 1);

  // node_modules/@tanstack/react-router/dist/esm/Transitioner.js
  var React9 = __toESM(require_react(), 1);
  function Transitioner() {
    const router = useRouter();
    const mountLoadForRouter = React9.useRef({ router, mounted: false });
    const routerState = useRouterState({
      select: (s7) => pick(s7, ["isLoading", "location", "resolvedLocation", "isTransitioning"])
    });
    const [isTransitioning, startReactTransition_] = React9.useTransition();
    const hasPendingMatches = useRouterState({
      select: (s7) => s7.matches.some((d5) => d5.status === "pending")
    });
    const previousIsLoading = usePrevious(routerState.isLoading);
    const isAnyPending = routerState.isLoading || isTransitioning || hasPendingMatches;
    const previousIsAnyPending = usePrevious(isAnyPending);
    if (!router.isServer) {
      router.startReactTransition = startReactTransition_;
    }
    React9.useEffect(() => {
      const unsub = router.history.subscribe(router.load);
      const nextLocation = router.buildLocation({
        to: router.latestLocation.pathname,
        search: true,
        params: true,
        hash: true,
        state: true
      });
      if (trimPathRight(router.latestLocation.href) !== trimPathRight(nextLocation.href)) {
        router.commitLocation(__spreadProps(__spreadValues({}, nextLocation), { replace: true }));
      }
      return () => {
        unsub();
      };
    }, [router, router.history]);
    useLayoutEffect2(() => {
      var _a9;
      if (((_a9 = window.__TSR__) == null ? void 0 : _a9.dehydrated) || mountLoadForRouter.current.router === router && mountLoadForRouter.current.mounted) {
        return;
      }
      mountLoadForRouter.current = { router, mounted: true };
      const tryLoad = async () => {
        try {
          await router.load();
        } catch (err) {
          console.error(err);
        }
      };
      tryLoad();
    }, [router]);
    useLayoutEffect2(() => {
      if (previousIsLoading && !routerState.isLoading) {
        const toLocation = router.state.location;
        const fromLocation = router.state.resolvedLocation;
        const pathChanged = fromLocation.href !== toLocation.href;
        router.emit({
          type: "onLoad",
          // When the new URL has committed, when the new matches have been loaded into state.matches
          fromLocation,
          toLocation,
          pathChanged
        });
      }
    }, [previousIsLoading, router, routerState.isLoading]);
    useLayoutEffect2(() => {
      if (previousIsAnyPending && !isAnyPending) {
        const toLocation = router.state.location;
        const fromLocation = router.state.resolvedLocation;
        const pathChanged = fromLocation.href !== toLocation.href;
        router.emit({
          type: "onResolved",
          fromLocation,
          toLocation,
          pathChanged
        });
        router.__store.setState((s7) => __spreadProps(__spreadValues({}, s7), {
          status: "idle",
          resolvedLocation: s7.location
        }));
        if (document.querySelector) {
          if (router.state.location.hash !== "") {
            const el = document.getElementById(router.state.location.hash);
            if (el) {
              el.scrollIntoView();
            }
          }
        }
      }
    }, [isAnyPending, previousIsAnyPending, router]);
    return null;
  }

  // node_modules/@tanstack/react-router/dist/esm/Match.js
  var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
  var React10 = __toESM(require_react(), 1);

  // node_modules/@tanstack/react-router/dist/esm/SafeFragment.js
  var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
  function SafeFragment(props) {
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: props.children });
  }

  // node_modules/@tanstack/react-router/dist/esm/renderRouteNotFound.js
  var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
  function renderRouteNotFound(router, route, data) {
    if (!route.options.notFoundComponent) {
      if (router.options.defaultNotFoundComponent) {
        return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(router.options.defaultNotFoundComponent, { data });
      }
      if (true) {
        tiny_warning_esm_default(
          route.options.notFoundComponent,
          `A notFoundError was encountered on the route with ID "${route.id}", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<div>Not Found<div>)`
        );
      }
      return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(DefaultGlobalNotFound, {});
    }
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(route.options.notFoundComponent, { data });
  }

  // node_modules/@tanstack/react-router/dist/esm/Match.js
  function Match({ matchId }) {
    var _a10, _b3, _c, _d, _e, _f;
    var _a9, _b2;
    const router = useRouter();
    const routeId = useRouterState({
      select: (s7) => {
        var _a22;
        return (_a22 = s7.matches.find((d5) => d5.id === matchId)) == null ? void 0 : _a22.routeId;
      }
    });
    invariant(
      routeId,
      `Could not find routeId for matchId "${matchId}". Please file an issue!`
    );
    const route = router.routesById[routeId];
    const PendingComponent = (_a10 = route.options.pendingComponent) != null ? _a10 : router.options.defaultPendingComponent;
    const pendingElement = PendingComponent ? /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(PendingComponent, {}) : null;
    const routeErrorComponent = (_b3 = route.options.errorComponent) != null ? _b3 : router.options.defaultErrorComponent;
    const routeOnCatch = (_c = route.options.onCatch) != null ? _c : router.options.defaultOnCatch;
    const routeNotFoundComponent = route.isRoot ? (
      // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component
      (_d = route.options.notFoundComponent) != null ? _d : (_a9 = router.options.notFoundRoute) == null ? void 0 : _a9.options.component
    ) : route.options.notFoundComponent;
    const ResolvedSuspenseBoundary = (
      // If we're on the root route, allow forcefully wrapping in suspense
      (!route.isRoot || route.options.wrapInSuspense) && ((_f = (_e = route.options.wrapInSuspense) != null ? _e : PendingComponent) != null ? _f : (_b2 = route.options.errorComponent) == null ? void 0 : _b2.preload) ? React10.Suspense : SafeFragment
    );
    const ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary : SafeFragment;
    const ResolvedNotFoundBoundary = routeNotFoundComponent ? CatchNotFound : SafeFragment;
    const resetKey = useRouterState({
      select: (s7) => s7.loadedAt
    });
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ResolvedSuspenseBoundary, { fallback: pendingElement, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
      ResolvedCatchBoundary,
      {
        getResetKey: () => resetKey,
        errorComponent: routeErrorComponent || ErrorComponent,
        onCatch: (error, errorInfo) => {
          if (isNotFound(error)) throw error;
          tiny_warning_esm_default(false, `Error in route match: ${matchId}`);
          routeOnCatch == null ? void 0 : routeOnCatch(error, errorInfo);
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
          ResolvedNotFoundBoundary,
          {
            fallback: (error) => {
              if (!routeNotFoundComponent || error.routeId && error.routeId !== routeId || !error.routeId && !route.isRoot)
                throw error;
              return React10.createElement(routeNotFoundComponent, error);
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(MatchInner, { matchId })
          }
        )
      }
    ) }) });
  }
  function MatchInner({ matchId }) {
    var _a10, _b3, _c, _d, _e;
    var _a9, _b2;
    const router = useRouter();
    const routeId = useRouterState({
      select: (s7) => {
        var _a22;
        return (_a22 = s7.matches.find((d5) => d5.id === matchId)) == null ? void 0 : _a22.routeId;
      }
    });
    const route = router.routesById[routeId];
    const matchIndex = useRouterState({
      select: (s7) => {
        return s7.matches.findIndex((d5) => d5.id === matchId);
      }
    });
    const match = useRouterState({
      select: (s7) => {
        const match2 = s7.matches[matchIndex];
        return pick(match2, [
          "id",
          "status",
          "error",
          "loadPromise",
          "minPendingPromise"
        ]);
      }
    });
    const RouteErrorComponent = ((_a10 = route.options.errorComponent) != null ? _a10 : router.options.defaultErrorComponent) || ErrorComponent;
    if (match.status === "notFound") {
      let error;
      if (isServerSideError(match.error)) {
        const deserializeError = (_b3 = (_a9 = router.options.errorSerializer) == null ? void 0 : _a9.deserialize) != null ? _b3 : defaultDeserializeError;
        error = deserializeError(match.error.data);
      } else {
        error = match.error;
      }
      invariant(isNotFound(error), "Expected a notFound error");
      return renderRouteNotFound(router, route, error);
    }
    if (match.status === "redirected") {
      invariant(isRedirect(match.error), "Expected a redirect error");
      throw match.loadPromise;
    }
    if (match.status === "error") {
      if (router.isServer) {
        return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
          RouteErrorComponent,
          {
            error: match.error,
            info: {
              componentStack: ""
            }
          }
        );
      }
      if (isServerSideError(match.error)) {
        const deserializeError = (_c = (_b2 = router.options.errorSerializer) == null ? void 0 : _b2.deserialize) != null ? _c : defaultDeserializeError;
        throw deserializeError(match.error.data);
      } else {
        throw match.error;
      }
    }
    if (match.status === "pending") {
      const pendingMinMs = (_d = route.options.pendingMinMs) != null ? _d : router.options.defaultPendingMinMs;
      if (pendingMinMs && !match.minPendingPromise) {
        if (!router.isServer) {
          const minPendingPromise = createControlledPromise();
          Promise.resolve().then(() => {
            router.updateMatch(match.id, (prev) => __spreadProps(__spreadValues({}, prev), {
              minPendingPromise
            }));
          });
          setTimeout(() => {
            minPendingPromise.resolve();
            router.updateMatch(match.id, (prev) => __spreadProps(__spreadValues({}, prev), {
              minPendingPromise: void 0
            }));
          }, pendingMinMs);
        }
      }
      throw match.loadPromise;
    }
    const Comp = (_e = route.options.component) != null ? _e : router.options.defaultComponent;
    const out = Comp ? /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Comp, {}) : /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Outlet, {});
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [
      out,
      router.AfterEachMatch ? /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(router.AfterEachMatch, { match, matchIndex }) : null
    ] });
  }
  var Outlet = React10.memo(function Outlet2() {
    const router = useRouter();
    const matchId = React10.useContext(matchContext);
    const routeId = useRouterState({
      select: (s7) => {
        var _a9;
        return (_a9 = s7.matches.find((d5) => d5.id === matchId)) == null ? void 0 : _a9.routeId;
      }
    });
    const route = router.routesById[routeId];
    const { parentGlobalNotFound } = useRouterState({
      select: (s7) => {
        const matches = s7.matches;
        const parentMatch = matches.find((d5) => d5.id === matchId);
        invariant(
          parentMatch,
          `Could not find parent match for matchId "${matchId}"`
        );
        return {
          parentGlobalNotFound: parentMatch.globalNotFound
        };
      }
    });
    const childMatchId = useRouterState({
      select: (s7) => {
        var _a9;
        const matches = s7.matches;
        const index2 = matches.findIndex((d5) => d5.id === matchId);
        return (_a9 = matches[index2 + 1]) == null ? void 0 : _a9.id;
      }
    });
    if (parentGlobalNotFound) {
      return renderRouteNotFound(router, route, void 0);
    }
    if (!childMatchId) {
      return null;
    }
    const nextMatch = /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Match, { matchId: childMatchId });
    const pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(router.options.defaultPendingComponent, {}) : null;
    if (matchId === rootRouteId) {
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(React10.Suspense, { fallback: pendingElement, children: nextMatch });
    }
    return nextMatch;
  });

  // node_modules/@tanstack/react-router/dist/esm/Matches.js
  function Matches() {
    const router = useRouter();
    const pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(router.options.defaultPendingComponent, {}) : null;
    const ResolvedSuspense = !router.state.matches.length ? React11.Suspense : SafeFragment;
    const inner = /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(ResolvedSuspense, { fallback: pendingElement, children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Transitioner, {}),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(MatchesInner, {})
    ] });
    return router.options.InnerWrap ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(router.options.InnerWrap, { children: inner }) : inner;
  }
  function MatchesInner() {
    const matchId = useRouterState({
      select: (s7) => {
        var _a9;
        return (_a9 = s7.matches[0]) == null ? void 0 : _a9.id;
      }
    });
    const resetKey = useRouterState({
      select: (s7) => s7.loadedAt
    });
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      CatchBoundary,
      {
        getResetKey: () => resetKey,
        errorComponent: ErrorComponent,
        onCatch: (error) => {
          tiny_warning_esm_default(
            false,
            `The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!`
          );
          tiny_warning_esm_default(false, error.message || error.toString());
        },
        children: matchId ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Match, { matchId }) : null
      }
    ) });
  }

  // node_modules/@tanstack/react-router/dist/esm/RouterProvider.js
  var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
  function RouterContextProvider(_a9) {
    var _b2 = _a9, {
      router,
      children
    } = _b2, rest = __objRest(_b2, [
      "router",
      "children"
    ]);
    router.update(__spreadProps(__spreadValues(__spreadValues({}, router.options), rest), {
      context: __spreadValues(__spreadValues({}, router.options.context), rest.context)
    }));
    const routerContext2 = getRouterContext();
    const provider = /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(routerContext2.Provider, { value: router, children });
    if (router.options.Wrap) {
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(router.options.Wrap, { children: provider });
    }
    return provider;
  }
  function RouterProvider(_a9) {
    var _b2 = _a9, { router } = _b2, rest = __objRest(_b2, ["router"]);
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(RouterContextProvider, __spreadProps(__spreadValues({ router }, rest), { children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(Matches, {}) }));
  }

  // node_modules/@tanstack/react-router/dist/esm/useLocation.js
  function useLocation(opts) {
    return useRouterState({
      select: (state) => (opts == null ? void 0 : opts.select) ? opts.select(state.location) : state.location
    });
  }

  // js/dashboard/router.js
  var import_react92 = __toESM(require_react());

  // js/dashboard/index.js
  var import_react73 = __toESM(require_react());

  // js/dashboard/historical.js
  var import_react71 = __toESM(require_react());

  // js/dashboard/datepicker.js
  var import_react26 = __toESM(require_react());
  var import_react_flatpickr2 = __toESM(require_build());

  // node_modules/@heroicons/react/20/solid/esm/AdjustmentsVerticalIcon.js
  var React12 = __toESM(require_react(), 1);
  function AdjustmentsVerticalIcon(_a9, svgRef) {
    var _b2 = _a9, {
      title,
      titleId
    } = _b2, props = __objRest(_b2, [
      "title",
      "titleId"
    ]);
    return /* @__PURE__ */ React12.createElement("svg", Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props), title ? /* @__PURE__ */ React12.createElement("title", {
      id: titleId
    }, title) : null, /* @__PURE__ */ React12.createElement("path", {
      d: "M17 2.75a.75.75 0 00-1.5 0v5.5a.75.75 0 001.5 0v-5.5zM17 15.75a.75.75 0 00-1.5 0v1.5a.75.75 0 001.5 0v-1.5zM3.75 15a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5a.75.75 0 01.75-.75zM4.5 2.75a.75.75 0 00-1.5 0v5.5a.75.75 0 001.5 0v-5.5zM10 11a.75.75 0 01.75.75v5.5a.75.75 0 01-1.5 0v-5.5A.75.75 0 0110 11zM10.75 2.75a.75.75 0 00-1.5 0v1.5a.75.75 0 001.5 0v-1.5zM10 6a2 2 0 100 4 2 2 0 000-4zM3.75 10a2 2 0 100 4 2 2 0 000-4zM16.25 10a2 2 0 100 4 2 2 0 000-4z"
    }));
  }
  var ForwardRef = React12.forwardRef(AdjustmentsVerticalIcon);
  var AdjustmentsVerticalIcon_default = ForwardRef;

  // node_modules/@heroicons/react/20/solid/esm/BarsArrowUpIcon.js
  var React13 = __toESM(require_react(), 1);
  function BarsArrowUpIcon(_a9, svgRef) {
    var _b2 = _a9, {
      title,
      titleId
    } = _b2, props = __objRest(_b2, [
      "title",
      "titleId"
    ]);
    return /* @__PURE__ */ React13.createElement("svg", Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props), title ? /* @__PURE__ */ React13.createElement("title", {
      id: titleId
    }, title) : null, /* @__PURE__ */ React13.createElement("path", {
      fillRule: "evenodd",
      d: "M2 3.75A.75.75 0 012.75 3h11.5a.75.75 0 010 1.5H2.75A.75.75 0 012 3.75zM2 7.5a.75.75 0 01.75-.75h6.365a.75.75 0 010 1.5H2.75A.75.75 0 012 7.5zM14 7a.75.75 0 01.55.24l3.25 3.5a.75.75 0 11-1.1 1.02l-1.95-2.1v6.59a.75.75 0 01-1.5 0V9.66l-1.95 2.1a.75.75 0 11-1.1-1.02l3.25-3.5A.75.75 0 0114 7zM2 11.25a.75.75 0 01.75-.75H7A.75.75 0 017 12H2.75a.75.75 0 01-.75-.75z",
      clipRule: "evenodd"
    }));
  }
  var ForwardRef2 = React13.forwardRef(BarsArrowUpIcon);
  var BarsArrowUpIcon_default = ForwardRef2;

  // node_modules/@heroicons/react/20/solid/esm/ChevronDownIcon.js
  var React14 = __toESM(require_react(), 1);
  function ChevronDownIcon(_a9, svgRef) {
    var _b2 = _a9, {
      title,
      titleId
    } = _b2, props = __objRest(_b2, [
      "title",
      "titleId"
    ]);
    return /* @__PURE__ */ React14.createElement("svg", Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props), title ? /* @__PURE__ */ React14.createElement("title", {
      id: titleId
    }, title) : null, /* @__PURE__ */ React14.createElement("path", {
      fillRule: "evenodd",
      d: "M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z",
      clipRule: "evenodd"
    }));
  }
  var ForwardRef3 = React14.forwardRef(ChevronDownIcon);
  var ChevronDownIcon_default = ForwardRef3;

  // node_modules/@heroicons/react/20/solid/esm/Cog8ToothIcon.js
  var React15 = __toESM(require_react(), 1);
  function Cog8ToothIcon(_a9, svgRef) {
    var _b2 = _a9, {
      title,
      titleId
    } = _b2, props = __objRest(_b2, [
      "title",
      "titleId"
    ]);
    return /* @__PURE__ */ React15.createElement("svg", Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props), title ? /* @__PURE__ */ React15.createElement("title", {
      id: titleId
    }, title) : null, /* @__PURE__ */ React15.createElement("path", {
      fillRule: "evenodd",
      d: "M8.34 1.804A1 1 0 019.32 1h1.36a1 1 0 01.98.804l.295 1.473c.497.144.971.342 1.416.587l1.25-.834a1 1 0 011.262.125l.962.962a1 1 0 01.125 1.262l-.834 1.25c.245.445.443.919.587 1.416l1.473.294a1 1 0 01.804.98v1.361a1 1 0 01-.804.98l-1.473.295a6.95 6.95 0 01-.587 1.416l.834 1.25a1 1 0 01-.125 1.262l-.962.962a1 1 0 01-1.262.125l-1.25-.834a6.953 6.953 0 01-1.416.587l-.294 1.473a1 1 0 01-.98.804H9.32a1 1 0 01-.98-.804l-.295-1.473a6.957 6.957 0 01-1.416-.587l-1.25.834a1 1 0 01-1.262-.125l-.962-.962a1 1 0 01-.125-1.262l.834-1.25a6.957 6.957 0 01-.587-1.416l-1.473-.294A1 1 0 011 10.68V9.32a1 1 0 01.804-.98l1.473-.295c.144-.497.342-.971.587-1.416l-.834-1.25a1 1 0 01.125-1.262l.962-.962A1 1 0 015.38 3.03l1.25.834a6.957 6.957 0 011.416-.587l.294-1.473zM13 10a3 3 0 11-6 0 3 3 0 016 0z",
      clipRule: "evenodd"
    }));
  }
  var ForwardRef4 = React15.forwardRef(Cog8ToothIcon);
  var Cog8ToothIcon_default = ForwardRef4;

  // node_modules/@heroicons/react/20/solid/esm/MagnifyingGlassIcon.js
  var React16 = __toESM(require_react(), 1);
  function MagnifyingGlassIcon(_a9, svgRef) {
    var _b2 = _a9, {
      title,
      titleId
    } = _b2, props = __objRest(_b2, [
      "title",
      "titleId"
    ]);
    return /* @__PURE__ */ React16.createElement("svg", Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props), title ? /* @__PURE__ */ React16.createElement("title", {
      id: titleId
    }, title) : null, /* @__PURE__ */ React16.createElement("path", {
      fillRule: "evenodd",
      d: "M9 3.5a5.5 5.5 0 100 11 5.5 5.5 0 000-11zM2 9a7 7 0 1112.452 4.391l3.328 3.329a.75.75 0 11-1.06 1.06l-3.329-3.328A7 7 0 012 9z",
      clipRule: "evenodd"
    }));
  }
  var ForwardRef5 = React16.forwardRef(MagnifyingGlassIcon);
  var MagnifyingGlassIcon_default = ForwardRef5;

  // node_modules/@heroicons/react/20/solid/esm/PencilSquareIcon.js
  var React17 = __toESM(require_react(), 1);
  function PencilSquareIcon(_a9, svgRef) {
    var _b2 = _a9, {
      title,
      titleId
    } = _b2, props = __objRest(_b2, [
      "title",
      "titleId"
    ]);
    return /* @__PURE__ */ React17.createElement("svg", Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props), title ? /* @__PURE__ */ React17.createElement("title", {
      id: titleId
    }, title) : null, /* @__PURE__ */ React17.createElement("path", {
      d: "M5.433 13.917l1.262-3.155A4 4 0 017.58 9.42l6.92-6.918a2.121 2.121 0 013 3l-6.92 6.918c-.383.383-.84.685-1.343.886l-3.154 1.262a.5.5 0 01-.65-.65z"
    }), /* @__PURE__ */ React17.createElement("path", {
      d: "M3.5 5.75c0-.69.56-1.25 1.25-1.25H10A.75.75 0 0010 3H4.75A2.75 2.75 0 002 5.75v9.5A2.75 2.75 0 004.75 18h9.5A2.75 2.75 0 0017 15.25V10a.75.75 0 00-1.5 0v5.25c0 .69-.56 1.25-1.25 1.25h-9.5c-.69 0-1.25-.56-1.25-1.25v-9.5z"
    }));
  }
  var ForwardRef6 = React17.forwardRef(PencilSquareIcon);
  var PencilSquareIcon_default = ForwardRef6;

  // node_modules/@heroicons/react/20/solid/esm/TrashIcon.js
  var React18 = __toESM(require_react(), 1);
  function TrashIcon(_a9, svgRef) {
    var _b2 = _a9, {
      title,
      titleId
    } = _b2, props = __objRest(_b2, [
      "title",
      "titleId"
    ]);
    return /* @__PURE__ */ React18.createElement("svg", Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props), title ? /* @__PURE__ */ React18.createElement("title", {
      id: titleId
    }, title) : null, /* @__PURE__ */ React18.createElement("path", {
      fillRule: "evenodd",
      d: "M8.75 1A2.75 2.75 0 006 3.75v.443c-.795.077-1.584.176-2.365.298a.75.75 0 10.23 1.482l.149-.022.841 10.518A2.75 2.75 0 007.596 19h4.807a2.75 2.75 0 002.742-2.53l.841-10.52.149.023a.75.75 0 00.23-1.482A41.03 41.03 0 0014 4.193V3.75A2.75 2.75 0 0011.25 1h-2.5zM10 4c.84 0 1.673.025 2.5.075V3.75c0-.69-.56-1.25-1.25-1.25h-2.5c-.69 0-1.25.56-1.25 1.25v.325C8.327 4.025 9.16 4 10 4zM8.58 7.72a.75.75 0 00-1.5.06l.3 7.5a.75.75 0 101.5-.06l-.3-7.5zm4.34.06a.75.75 0 10-1.5-.06l-.3 7.5a.75.75 0 101.5.06l.3-7.5z",
      clipRule: "evenodd"
    }));
  }
  var ForwardRef7 = React18.forwardRef(TrashIcon);
  var TrashIcon_default = ForwardRef7;

  // node_modules/@heroicons/react/20/solid/esm/XMarkIcon.js
  var React19 = __toESM(require_react(), 1);
  function XMarkIcon(_a9, svgRef) {
    var _b2 = _a9, {
      title,
      titleId
    } = _b2, props = __objRest(_b2, [
      "title",
      "titleId"
    ]);
    return /* @__PURE__ */ React19.createElement("svg", Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props), title ? /* @__PURE__ */ React19.createElement("title", {
      id: titleId
    }, title) : null, /* @__PURE__ */ React19.createElement("path", {
      d: "M6.28 5.22a.75.75 0 00-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 101.06 1.06L10 11.06l3.72 3.72a.75.75 0 101.06-1.06L11.06 10l3.72-3.72a.75.75 0 00-1.06-1.06L10 8.94 6.28 5.22z"
    }));
  }
  var ForwardRef8 = React19.forwardRef(XMarkIcon);
  var XMarkIcon_default = ForwardRef8;

  // node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
  var import_react = __toESM(require_react(), 1);

  // node_modules/@headlessui/react/dist/utils/env.js
  var i = Object.defineProperty;
  var d = (t7, e3, n2) => e3 in t7 ? i(t7, e3, { enumerable: true, configurable: true, writable: true, value: n2 }) : t7[e3] = n2;
  var r = (t7, e3, n2) => (d(t7, typeof e3 != "symbol" ? e3 + "" : e3, n2), n2);
  var o = class {
    constructor() {
      r(this, "current", this.detect());
      r(this, "handoffState", "pending");
      r(this, "currentId", 0);
    }
    set(e3) {
      this.current !== e3 && (this.handoffState = "pending", this.currentId = 0, this.current = e3);
    }
    reset() {
      this.set(this.detect());
    }
    nextId() {
      return ++this.currentId;
    }
    get isServer() {
      return this.current === "server";
    }
    get isClient() {
      return this.current === "client";
    }
    detect() {
      return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
    }
    handoff() {
      this.handoffState === "pending" && (this.handoffState = "complete");
    }
    get isHandoffComplete() {
      return this.handoffState === "complete";
    }
  };
  var s = new o();

  // node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
  var l = (e3, f5) => {
    s.isServer ? (0, import_react.useEffect)(e3, f5) : (0, import_react.useLayoutEffect)(e3, f5);
  };

  // node_modules/@headlessui/react/dist/hooks/use-latest-value.js
  var import_react2 = __toESM(require_react(), 1);
  function s2(e3) {
    let r6 = (0, import_react2.useRef)(e3);
    return l(() => {
      r6.current = e3;
    }, [e3]), r6;
  }

  // node_modules/@headlessui/react/dist/hooks/use-disposables.js
  var import_react3 = __toESM(require_react(), 1);

  // node_modules/@headlessui/react/dist/utils/micro-task.js
  function t3(e3) {
    typeof queueMicrotask == "function" ? queueMicrotask(e3) : Promise.resolve().then(e3).catch((o10) => setTimeout(() => {
      throw o10;
    }));
  }

  // node_modules/@headlessui/react/dist/utils/disposables.js
  function m() {
    let a3 = [], i5 = [], r6 = { enqueue(e3) {
      i5.push(e3);
    }, addEventListener(e3, t7, n2, s7) {
      return e3.addEventListener(t7, n2, s7), r6.add(() => e3.removeEventListener(t7, n2, s7));
    }, requestAnimationFrame(...e3) {
      let t7 = requestAnimationFrame(...e3);
      return r6.add(() => cancelAnimationFrame(t7));
    }, nextFrame(...e3) {
      return r6.requestAnimationFrame(() => r6.requestAnimationFrame(...e3));
    }, setTimeout(...e3) {
      let t7 = setTimeout(...e3);
      return r6.add(() => clearTimeout(t7));
    }, microTask(...e3) {
      let t7 = { current: true };
      return t3(() => {
        t7.current && e3[0]();
      }), r6.add(() => {
        t7.current = false;
      });
    }, add(e3) {
      return a3.push(e3), () => {
        let t7 = a3.indexOf(e3);
        if (t7 >= 0) {
          let [n2] = a3.splice(t7, 1);
          n2();
        }
      };
    }, dispose() {
      for (let e3 of a3.splice(0)) e3();
    }, async workQueue() {
      for (let e3 of i5.splice(0)) await e3();
    }, style(e3, t7, n2) {
      let s7 = e3.style.getPropertyValue(t7);
      return Object.assign(e3.style, { [t7]: n2 }), this.add(() => {
        Object.assign(e3.style, { [t7]: s7 });
      });
    } };
    return r6;
  }

  // node_modules/@headlessui/react/dist/hooks/use-disposables.js
  function p() {
    let [e3] = (0, import_react3.useState)(m);
    return (0, import_react3.useEffect)(() => () => e3.dispose(), [e3]), e3;
  }

  // node_modules/@headlessui/react/dist/hooks/use-event.js
  var import_react4 = __toESM(require_react(), 1);
  var o3 = function(t7) {
    let e3 = s2(t7);
    return import_react4.default.useCallback((...r6) => e3.current(...r6), [e3]);
  };

  // node_modules/@headlessui/react/dist/hooks/use-id.js
  var import_react6 = __toESM(require_react(), 1);

  // node_modules/@headlessui/react/dist/hooks/use-server-handoff-complete.js
  var import_react5 = __toESM(require_react(), 1);
  function l2() {
    let [e3, f5] = (0, import_react5.useState)(s.isHandoffComplete);
    return e3 && s.isHandoffComplete === false && f5(false), (0, import_react5.useEffect)(() => {
      e3 !== true && f5(true);
    }, [e3]), (0, import_react5.useEffect)(() => s.handoff(), []), e3;
  }

  // node_modules/@headlessui/react/dist/hooks/use-id.js
  var o5;
  var I = (o5 = import_react6.default.useId) != null ? o5 : function() {
    let n2 = l2(), [e3, u4] = import_react6.default.useState(n2 ? () => s.nextId() : null);
    return l(() => {
      e3 === null && u4(s.nextId());
    }, [e3]), e3 != null ? "" + e3 : void 0;
  };

  // node_modules/@headlessui/react/dist/hooks/use-outside-click.js
  var import_react8 = __toESM(require_react(), 1);

  // node_modules/@headlessui/react/dist/utils/match.js
  function u(r6, n2, ...a3) {
    if (r6 in n2) {
      let e3 = n2[r6];
      return typeof e3 == "function" ? e3(...a3) : e3;
    }
    let t7 = new Error(`Tried to handle "${r6}" but there is no handler defined. Only defined handlers are: ${Object.keys(n2).map((e3) => `"${e3}"`).join(", ")}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t7, u), t7;
  }

  // node_modules/@headlessui/react/dist/utils/owner.js
  function e(r6) {
    return s.isServer ? null : r6 instanceof Node ? r6.ownerDocument : r6 != null && r6.hasOwnProperty("current") && r6.current instanceof Node ? r6.current.ownerDocument : document;
  }

  // node_modules/@headlessui/react/dist/utils/focus-management.js
  var f = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e3) => `${e3}:not([tabindex='-1'])`).join(",");
  var L = ((r6) => (r6[r6.First = 1] = "First", r6[r6.Previous = 2] = "Previous", r6[r6.Next = 4] = "Next", r6[r6.Last = 8] = "Last", r6[r6.WrapAround = 16] = "WrapAround", r6[r6.NoScroll = 32] = "NoScroll", r6))(L || {});
  var N = ((o10) => (o10[o10.Error = 0] = "Error", o10[o10.Overflow = 1] = "Overflow", o10[o10.Success = 2] = "Success", o10[o10.Underflow = 3] = "Underflow", o10))(N || {});
  var T = ((n2) => (n2[n2.Previous = -1] = "Previous", n2[n2.Next = 1] = "Next", n2))(T || {});
  function E(e3 = document.body) {
    return e3 == null ? [] : Array.from(e3.querySelectorAll(f)).sort((t7, n2) => Math.sign((t7.tabIndex || Number.MAX_SAFE_INTEGER) - (n2.tabIndex || Number.MAX_SAFE_INTEGER)));
  }
  var F = ((n2) => (n2[n2.Strict = 0] = "Strict", n2[n2.Loose = 1] = "Loose", n2))(F || {});
  function h(e3, t7 = 0) {
    var n2;
    return e3 === ((n2 = e(e3)) == null ? void 0 : n2.body) ? false : u(t7, { [0]() {
      return e3.matches(f);
    }, [1]() {
      let l6 = e3;
      for (; l6 !== null; ) {
        if (l6.matches(f)) return true;
        l6 = l6.parentElement;
      }
      return false;
    } });
  }
  function g(e3) {
    let t7 = e(e3);
    m().nextFrame(() => {
      t7 && !h(t7.activeElement, 0) && S(e3);
    });
  }
  function S(e3) {
    e3 == null || e3.focus({ preventScroll: true });
  }
  var H = ["textarea", "input"].join(",");
  function w(e3) {
    var t7, n2;
    return (n2 = (t7 = e3 == null ? void 0 : e3.matches) == null ? void 0 : t7.call(e3, H)) != null ? n2 : false;
  }
  function A(e3, t7 = (n2) => n2) {
    return e3.slice().sort((n2, l6) => {
      let o10 = t7(n2), i5 = t7(l6);
      if (o10 === null || i5 === null) return 0;
      let r6 = o10.compareDocumentPosition(i5);
      return r6 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : r6 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
    });
  }
  function v(e3, t7) {
    return I2(E(), t7, { relativeTo: e3 });
  }
  function I2(e3, t7, { sorted: n2 = true, relativeTo: l6 = null, skipElements: o10 = [] } = {}) {
    let i5 = Array.isArray(e3) ? e3.length > 0 ? e3[0].ownerDocument : document : e3.ownerDocument, r6 = Array.isArray(e3) ? n2 ? A(e3) : e3 : E(e3);
    o10.length > 0 && r6.length > 1 && (r6 = r6.filter((s7) => !o10.includes(s7))), l6 = l6 != null ? l6 : i5.activeElement;
    let d5 = (() => {
      if (t7 & 5) return 1;
      if (t7 & 10) return -1;
      throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
    })(), x3 = (() => {
      if (t7 & 1) return 0;
      if (t7 & 2) return Math.max(0, r6.indexOf(l6)) - 1;
      if (t7 & 4) return Math.max(0, r6.indexOf(l6)) + 1;
      if (t7 & 8) return r6.length - 1;
      throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
    })(), p3 = t7 & 32 ? { preventScroll: true } : {}, c3 = 0, a3 = r6.length, u4;
    do {
      if (c3 >= a3 || c3 + a3 <= 0) return 0;
      let s7 = x3 + c3;
      if (t7 & 16) s7 = (s7 + a3) % a3;
      else {
        if (s7 < 0) return 3;
        if (s7 >= a3) return 1;
      }
      u4 = r6[s7], u4 == null || u4.focus(p3), c3 += d5;
    } while (u4 !== i5.activeElement);
    return t7 & 6 && w(u4) && u4.select(), u4.hasAttribute("tabindex") || u4.setAttribute("tabindex", "0"), 2;
  }

  // node_modules/@headlessui/react/dist/hooks/use-document-event.js
  var import_react7 = __toESM(require_react(), 1);
  function d2(e3, r6, n2) {
    let o10 = s2(r6);
    (0, import_react7.useEffect)(() => {
      function t7(u4) {
        o10.current(u4);
      }
      return document.addEventListener(e3, t7, n2), () => document.removeEventListener(e3, t7, n2);
    }, [e3, n2]);
  }

  // node_modules/@headlessui/react/dist/hooks/use-outside-click.js
  function L2(m5, E4, c3 = true) {
    let i5 = (0, import_react8.useRef)(false);
    (0, import_react8.useEffect)(() => {
      requestAnimationFrame(() => {
        i5.current = c3;
      });
    }, [c3]);
    function f5(e3, o10) {
      if (!i5.current || e3.defaultPrevented) return;
      let l6 = function r6(t7) {
        return typeof t7 == "function" ? r6(t7()) : Array.isArray(t7) || t7 instanceof Set ? t7 : [t7];
      }(m5), n2 = o10(e3);
      if (n2 !== null && !!n2.getRootNode().contains(n2)) {
        for (let r6 of l6) {
          if (r6 === null) continue;
          let t7 = r6 instanceof HTMLElement ? r6 : r6.current;
          if (t7 != null && t7.contains(n2) || e3.composed && e3.composedPath().includes(t7)) return;
        }
        return !h(n2, F.Loose) && n2.tabIndex !== -1 && e3.preventDefault(), E4(e3, n2);
      }
    }
    let u4 = (0, import_react8.useRef)(null);
    d2("mousedown", (e3) => {
      var o10, l6;
      i5.current && (u4.current = ((l6 = (o10 = e3.composedPath) == null ? void 0 : o10.call(e3)) == null ? void 0 : l6[0]) || e3.target);
    }, true), d2("click", (e3) => {
      !u4.current || (f5(e3, () => u4.current), u4.current = null);
    }, true), d2("blur", (e3) => f5(e3, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
  }

  // node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
  var import_react9 = __toESM(require_react(), 1);
  function i2(t7) {
    var n2;
    if (t7.type) return t7.type;
    let e3 = (n2 = t7.as) != null ? n2 : "button";
    if (typeof e3 == "string" && e3.toLowerCase() === "button") return "button";
  }
  function s5(t7, e3) {
    let [n2, u4] = (0, import_react9.useState)(() => i2(t7));
    return l(() => {
      u4(i2(t7));
    }, [t7.type, t7.as]), l(() => {
      n2 || !e3.current || e3.current instanceof HTMLButtonElement && !e3.current.hasAttribute("type") && u4("button");
    }, [n2, e3]), n2;
  }

  // node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
  var import_react10 = __toESM(require_react(), 1);
  var u2 = Symbol();
  function y(...t7) {
    let n2 = (0, import_react10.useRef)(t7);
    (0, import_react10.useEffect)(() => {
      n2.current = t7;
    }, [t7]);
    let c3 = o3((e3) => {
      for (let o10 of n2.current) o10 != null && (typeof o10 == "function" ? o10(e3) : o10.current = e3);
    });
    return t7.every((e3) => e3 == null || (e3 == null ? void 0 : e3[u2])) ? void 0 : c3;
  }

  // node_modules/@headlessui/react/dist/hooks/use-tree-walker.js
  var import_react11 = __toESM(require_react(), 1);
  function F2({ container: e3, accept: t7, walk: r6, enabled: c3 = true }) {
    let o10 = (0, import_react11.useRef)(t7), l6 = (0, import_react11.useRef)(r6);
    (0, import_react11.useEffect)(() => {
      o10.current = t7, l6.current = r6;
    }, [t7, r6]), l(() => {
      if (!e3 || !c3) return;
      let n2 = e(e3);
      if (!n2) return;
      let f5 = o10.current, p3 = l6.current, d5 = Object.assign((i5) => f5(i5), { acceptNode: f5 }), u4 = n2.createTreeWalker(e3, NodeFilter.SHOW_ELEMENT, d5, false);
      for (; u4.nextNode(); ) p3(u4.currentNode);
    }, [e3, c3, o10, l6]);
  }

  // node_modules/@headlessui/react/dist/utils/calculate-active-index.js
  function f2(r6) {
    throw new Error("Unexpected object: " + r6);
  }
  var a2 = ((e3) => (e3[e3.First = 0] = "First", e3[e3.Previous = 1] = "Previous", e3[e3.Next = 2] = "Next", e3[e3.Last = 3] = "Last", e3[e3.Specific = 4] = "Specific", e3[e3.Nothing = 5] = "Nothing", e3))(a2 || {});
  function x(r6, n2) {
    let t7 = n2.resolveItems();
    if (t7.length <= 0) return null;
    let l6 = n2.resolveActiveIndex(), s7 = l6 != null ? l6 : -1, d5 = (() => {
      switch (r6.focus) {
        case 0:
          return t7.findIndex((e3) => !n2.resolveDisabled(e3));
        case 1: {
          let e3 = t7.slice().reverse().findIndex((i5, c3, u4) => s7 !== -1 && u4.length - c3 - 1 >= s7 ? false : !n2.resolveDisabled(i5));
          return e3 === -1 ? e3 : t7.length - 1 - e3;
        }
        case 2:
          return t7.findIndex((e3, i5) => i5 <= s7 ? false : !n2.resolveDisabled(e3));
        case 3: {
          let e3 = t7.slice().reverse().findIndex((i5) => !n2.resolveDisabled(i5));
          return e3 === -1 ? e3 : t7.length - 1 - e3;
        }
        case 4:
          return t7.findIndex((e3) => n2.resolveId(e3) === r6.id);
        case 5:
          return null;
        default:
          f2(r6);
      }
    })();
    return d5 === -1 ? l6 : d5;
  }

  // node_modules/@headlessui/react/dist/utils/render.js
  var import_react12 = __toESM(require_react(), 1);

  // node_modules/@headlessui/react/dist/utils/class-names.js
  function e2(...n2) {
    return n2.filter(Boolean).join(" ");
  }

  // node_modules/@headlessui/react/dist/utils/render.js
  var j = ((a3) => (a3[a3.None = 0] = "None", a3[a3.RenderStrategy = 1] = "RenderStrategy", a3[a3.Static = 2] = "Static", a3))(j || {});
  var w2 = ((e3) => (e3[e3.Unmount = 0] = "Unmount", e3[e3.Hidden = 1] = "Hidden", e3))(w2 || {});
  function X({ ourProps: r6, theirProps: t7, slot: e3, defaultTag: a3, features: s7, visible: n2 = true, name: l6 }) {
    let o10 = h2(t7, r6);
    if (n2) return m4(o10, e3, a3, l6);
    let u4 = s7 != null ? s7 : 0;
    if (u4 & 2) {
      let _a9 = o10, { static: i5 = false } = _a9, d5 = __objRest(_a9, ["static"]);
      if (i5) return m4(d5, e3, a3, l6);
    }
    if (u4 & 1) {
      let _b2 = o10, { unmount: i5 = true } = _b2, d5 = __objRest(_b2, ["unmount"]);
      return u(i5 ? 0 : 1, { [0]() {
        return null;
      }, [1]() {
        return m4(__spreadProps(__spreadValues({}, d5), { hidden: true, style: { display: "none" } }), e3, a3, l6);
      } });
    }
    return m4(o10, e3, a3, l6);
  }
  function m4(r6, t7 = {}, e3, a3) {
    var y2;
    let _a9 = T2(r6, ["unmount", "static"]), { as: s7 = e3, children: n2, refName: l6 = "ref" } = _a9, o10 = __objRest(_a9, ["as", "children", "refName"]), u4 = r6.ref !== void 0 ? { [l6]: r6.ref } : {}, i5 = typeof n2 == "function" ? n2(t7) : n2;
    o10.className && typeof o10.className == "function" && (o10.className = o10.className(t7));
    let d5 = {};
    if (t7) {
      let f5 = false, c3 = [];
      for (let [p3, F4] of Object.entries(t7)) typeof F4 == "boolean" && (f5 = true), F4 === true && c3.push(p3);
      f5 && (d5["data-headlessui-state"] = c3.join(" "));
    }
    if (s7 === import_react12.Fragment && Object.keys(P(o10)).length > 0) {
      if (!(0, import_react12.isValidElement)(i5) || Array.isArray(i5) && i5.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${a3} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(o10).map((p3) => `  - ${p3}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((p3) => `  - ${p3}`).join(`
`)].join(`
`));
      let f5 = e2((y2 = i5.props) == null ? void 0 : y2.className, o10.className), c3 = f5 ? { className: f5 } : {};
      return (0, import_react12.cloneElement)(i5, Object.assign({}, h2(i5.props, P(T2(o10, ["ref"]))), d5, u4, O(i5.ref, u4.ref), c3));
    }
    return (0, import_react12.createElement)(s7, Object.assign({}, T2(o10, ["ref"]), s7 !== import_react12.Fragment && u4, s7 !== import_react12.Fragment && d5), i5);
  }
  function O(...r6) {
    return { ref: r6.every((t7) => t7 == null) ? void 0 : (t7) => {
      for (let e3 of r6) e3 != null && (typeof e3 == "function" ? e3(t7) : e3.current = t7);
    } };
  }
  function h2(...r6) {
    var a3;
    if (r6.length === 0) return {};
    if (r6.length === 1) return r6[0];
    let t7 = {}, e3 = {};
    for (let s7 of r6) for (let n2 in s7) n2.startsWith("on") && typeof s7[n2] == "function" ? ((a3 = e3[n2]) != null || (e3[n2] = []), e3[n2].push(s7[n2])) : t7[n2] = s7[n2];
    if (t7.disabled || t7["aria-disabled"]) return Object.assign(t7, Object.fromEntries(Object.keys(e3).map((s7) => [s7, void 0])));
    for (let s7 in e3) Object.assign(t7, { [s7](n2, ...l6) {
      let o10 = e3[s7];
      for (let u4 of o10) {
        if ((n2 instanceof Event || (n2 == null ? void 0 : n2.nativeEvent) instanceof Event) && n2.defaultPrevented) return;
        u4(n2, ...l6);
      }
    } });
    return t7;
  }
  function V(r6) {
    var t7;
    return Object.assign((0, import_react12.forwardRef)(r6), { displayName: (t7 = r6.displayName) != null ? t7 : r6.name });
  }
  function P(r6) {
    let t7 = Object.assign({}, r6);
    for (let e3 in t7) t7[e3] === void 0 && delete t7[e3];
    return t7;
  }
  function T2(r6, t7 = []) {
    let e3 = Object.assign({}, r6);
    for (let a3 of t7) a3 in e3 && delete e3[a3];
    return e3;
  }

  // node_modules/@headlessui/react/dist/utils/bugs.js
  function r3(n2) {
    let e3 = n2.parentElement, l6 = null;
    for (; e3 && !(e3 instanceof HTMLFieldSetElement); ) e3 instanceof HTMLLegendElement && (l6 = e3), e3 = e3.parentElement;
    let t7 = (e3 == null ? void 0 : e3.getAttribute("disabled")) === "";
    return t7 && i4(l6) ? false : t7;
  }
  function i4(n2) {
    if (!n2) return false;
    let e3 = n2.previousElementSibling;
    for (; e3 !== null; ) {
      if (e3 instanceof HTMLLegendElement) return false;
      e3 = e3.previousElementSibling;
    }
    return true;
  }

  // node_modules/@headlessui/react/dist/internal/open-closed.js
  var import_react13 = __toESM(require_react(), 1);
  var o7 = (0, import_react13.createContext)(null);
  o7.displayName = "OpenClosedContext";
  var p2 = ((e3) => (e3[e3.Open = 0] = "Open", e3[e3.Closed = 1] = "Closed", e3))(p2 || {});
  function s6() {
    return (0, import_react13.useContext)(o7);
  }
  function C({ value: t7, children: n2 }) {
    return import_react13.default.createElement(o7.Provider, { value: t7 }, n2);
  }

  // node_modules/@headlessui/react/dist/components/keyboard.js
  var o8 = ((r6) => (r6.Space = " ", r6.Enter = "Enter", r6.Escape = "Escape", r6.Backspace = "Backspace", r6.Delete = "Delete", r6.ArrowLeft = "ArrowLeft", r6.ArrowUp = "ArrowUp", r6.ArrowRight = "ArrowRight", r6.ArrowDown = "ArrowDown", r6.Home = "Home", r6.End = "End", r6.PageUp = "PageUp", r6.PageDown = "PageDown", r6.Tab = "Tab", r6))(o8 || {});

  // node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js
  var import_react14 = __toESM(require_react(), 1);
  function t5(e3) {
    return [e3.screenX, e3.screenY];
  }
  function u3() {
    let e3 = (0, import_react14.useRef)([-1, -1]);
    return { wasMoved(r6) {
      let n2 = t5(r6);
      return e3.current[0] === n2[0] && e3.current[1] === n2[1] ? false : (e3.current = n2, true);
    }, update(r6) {
      e3.current = t5(r6);
    } };
  }

  // node_modules/@headlessui/react/dist/hooks/use-is-mounted.js
  var import_react15 = __toESM(require_react(), 1);
  function f3() {
    let e3 = (0, import_react15.useRef)(false);
    return l(() => (e3.current = true, () => {
      e3.current = false;
    }), []), e3;
  }

  // node_modules/@headlessui/react/dist/hooks/use-owner.js
  var import_react16 = __toESM(require_react(), 1);
  function n(...e3) {
    return (0, import_react16.useMemo)(() => e(...e3), [...e3]);
  }

  // node_modules/@headlessui/react/dist/components/menu/menu.js
  var import_react17 = __toESM(require_react(), 1);
  var pe = ((o10) => (o10[o10.Open = 0] = "Open", o10[o10.Closed = 1] = "Closed", o10))(pe || {});
  var de = ((o10) => (o10[o10.Pointer = 0] = "Pointer", o10[o10.Other = 1] = "Other", o10))(de || {});
  var me = ((e3) => (e3[e3.OpenMenu = 0] = "OpenMenu", e3[e3.CloseMenu = 1] = "CloseMenu", e3[e3.GoToItem = 2] = "GoToItem", e3[e3.Search = 3] = "Search", e3[e3.ClearSearch = 4] = "ClearSearch", e3[e3.RegisterItem = 5] = "RegisterItem", e3[e3.UnregisterItem = 6] = "UnregisterItem", e3))(me || {});
  function U(t7, i5 = (o10) => o10) {
    let o10 = t7.activeItemIndex !== null ? t7.items[t7.activeItemIndex] : null, s7 = A(i5(t7.items.slice()), (u4) => u4.dataRef.current.domRef.current), a3 = o10 ? s7.indexOf(o10) : null;
    return a3 === -1 && (a3 = null), { items: s7, activeItemIndex: a3 };
  }
  var fe = { [1](t7) {
    return t7.menuState === 1 ? t7 : __spreadProps(__spreadValues({}, t7), { activeItemIndex: null, menuState: 1 });
  }, [0](t7) {
    return t7.menuState === 0 ? t7 : __spreadProps(__spreadValues({}, t7), { menuState: 0 });
  }, [2]: (t7, i5) => {
    var a3;
    let o10 = U(t7), s7 = x(i5, { resolveItems: () => o10.items, resolveActiveIndex: () => o10.activeItemIndex, resolveId: (u4) => u4.id, resolveDisabled: (u4) => u4.dataRef.current.disabled });
    return __spreadProps(__spreadValues(__spreadValues({}, t7), o10), { searchQuery: "", activeItemIndex: s7, activationTrigger: (a3 = i5.trigger) != null ? a3 : 1 });
  }, [3]: (t7, i5) => {
    let s7 = t7.searchQuery !== "" ? 0 : 1, a3 = t7.searchQuery + i5.value.toLowerCase(), n2 = (t7.activeItemIndex !== null ? t7.items.slice(t7.activeItemIndex + s7).concat(t7.items.slice(0, t7.activeItemIndex + s7)) : t7.items).find((d5) => {
      var l6;
      return ((l6 = d5.dataRef.current.textValue) == null ? void 0 : l6.startsWith(a3)) && !d5.dataRef.current.disabled;
    }), e3 = n2 ? t7.items.indexOf(n2) : -1;
    return e3 === -1 || e3 === t7.activeItemIndex ? __spreadProps(__spreadValues({}, t7), { searchQuery: a3 }) : __spreadProps(__spreadValues({}, t7), { searchQuery: a3, activeItemIndex: e3, activationTrigger: 1 });
  }, [4](t7) {
    return t7.searchQuery === "" ? t7 : __spreadProps(__spreadValues({}, t7), { searchQuery: "", searchActiveItemIndex: null });
  }, [5]: (t7, i5) => {
    let o10 = U(t7, (s7) => [...s7, { id: i5.id, dataRef: i5.dataRef }]);
    return __spreadValues(__spreadValues({}, t7), o10);
  }, [6]: (t7, i5) => {
    let o10 = U(t7, (s7) => {
      let a3 = s7.findIndex((u4) => u4.id === i5.id);
      return a3 !== -1 && s7.splice(a3, 1), s7;
    });
    return __spreadProps(__spreadValues(__spreadValues({}, t7), o10), { activationTrigger: 1 });
  } };
  var G = (0, import_react17.createContext)(null);
  G.displayName = "MenuContext";
  function O2(t7) {
    let i5 = (0, import_react17.useContext)(G);
    if (i5 === null) {
      let o10 = new Error(`<${t7} /> is missing a parent <Menu /> component.`);
      throw Error.captureStackTrace && Error.captureStackTrace(o10, O2), o10;
    }
    return i5;
  }
  function Te(t7, i5) {
    return u(i5.type, fe, t7, i5);
  }
  var ye = import_react17.Fragment;
  var Ie = V(function(i5, o10) {
    let s7 = (0, import_react17.useReducer)(Te, { menuState: 1, buttonRef: (0, import_react17.createRef)(), itemsRef: (0, import_react17.createRef)(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: a3, itemsRef: u4, buttonRef: n2 }, e3] = s7, d5 = y(o10);
    L2([n2, u4], (R, A3) => {
      var g3;
      e3({ type: 1 }), h(A3, F.Loose) || (R.preventDefault(), (g3 = n2.current) == null || g3.focus());
    }, a3 === 0);
    let l6 = o3(() => {
      e3({ type: 1 });
    }), f5 = (0, import_react17.useMemo)(() => ({ open: a3 === 0, close: l6 }), [a3, l6]), M3 = i5, T4 = { ref: d5 };
    return import_react17.default.createElement(G.Provider, { value: s7 }, import_react17.default.createElement(C, { value: u(a3, { [0]: p2.Open, [1]: p2.Closed }) }, X({ ourProps: T4, theirProps: M3, slot: f5, defaultTag: ye, name: "Menu" })));
  });
  var ge = "button";
  var Me = V(function(i5, o10) {
    var g3;
    let s7 = I(), _a9 = i5, { id: a3 = `headlessui-menu-button-${s7}` } = _a9, u4 = __objRest(_a9, ["id"]), [n2, e3] = O2("Menu.Button"), d5 = y(n2.buttonRef, o10), l6 = p(), f5 = o3((c3) => {
      switch (c3.key) {
        case o8.Space:
        case o8.Enter:
        case o8.ArrowDown:
          c3.preventDefault(), c3.stopPropagation(), e3({ type: 0 }), l6.nextFrame(() => e3({ type: 2, focus: a2.First }));
          break;
        case o8.ArrowUp:
          c3.preventDefault(), c3.stopPropagation(), e3({ type: 0 }), l6.nextFrame(() => e3({ type: 2, focus: a2.Last }));
          break;
      }
    }), M3 = o3((c3) => {
      switch (c3.key) {
        case o8.Space:
          c3.preventDefault();
          break;
      }
    }), T4 = o3((c3) => {
      if (r3(c3.currentTarget)) return c3.preventDefault();
      i5.disabled || (n2.menuState === 0 ? (e3({ type: 1 }), l6.nextFrame(() => {
        var b2;
        return (b2 = n2.buttonRef.current) == null ? void 0 : b2.focus({ preventScroll: true });
      })) : (c3.preventDefault(), e3({ type: 0 })));
    }), R = (0, import_react17.useMemo)(() => ({ open: n2.menuState === 0 }), [n2]), A3 = { ref: d5, id: a3, type: s5(i5, n2.buttonRef), "aria-haspopup": "menu", "aria-controls": (g3 = n2.itemsRef.current) == null ? void 0 : g3.id, "aria-expanded": i5.disabled ? void 0 : n2.menuState === 0, onKeyDown: f5, onKeyUp: M3, onClick: T4 };
    return X({ ourProps: A3, theirProps: u4, slot: R, defaultTag: ge, name: "Menu.Button" });
  });
  var Re = "div";
  var be = j.RenderStrategy | j.Static;
  var Ae = V(function(i5, o10) {
    var b2, S2;
    let s7 = I(), _a9 = i5, { id: a3 = `headlessui-menu-items-${s7}` } = _a9, u4 = __objRest(_a9, ["id"]), [n2, e3] = O2("Menu.Items"), d5 = y(n2.itemsRef, o10), l6 = n(n2.itemsRef), f5 = p(), M3 = s6(), T4 = (() => M3 !== null ? M3 === p2.Open : n2.menuState === 0)();
    (0, import_react17.useEffect)(() => {
      let r6 = n2.itemsRef.current;
      !r6 || n2.menuState === 0 && r6 !== (l6 == null ? void 0 : l6.activeElement) && r6.focus({ preventScroll: true });
    }, [n2.menuState, n2.itemsRef, l6]), F2({ container: n2.itemsRef.current, enabled: n2.menuState === 0, accept(r6) {
      return r6.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : r6.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
    }, walk(r6) {
      r6.setAttribute("role", "none");
    } });
    let R = o3((r6) => {
      var h3, F4;
      switch (f5.dispose(), r6.key) {
        case o8.Space:
          if (n2.searchQuery !== "") return r6.preventDefault(), r6.stopPropagation(), e3({ type: 3, value: r6.key });
        case o8.Enter:
          if (r6.preventDefault(), r6.stopPropagation(), e3({ type: 1 }), n2.activeItemIndex !== null) {
            let { dataRef: p3 } = n2.items[n2.activeItemIndex];
            (F4 = (h3 = p3.current) == null ? void 0 : h3.domRef.current) == null || F4.click();
          }
          g(n2.buttonRef.current);
          break;
        case o8.ArrowDown:
          return r6.preventDefault(), r6.stopPropagation(), e3({ type: 2, focus: a2.Next });
        case o8.ArrowUp:
          return r6.preventDefault(), r6.stopPropagation(), e3({ type: 2, focus: a2.Previous });
        case o8.Home:
        case o8.PageUp:
          return r6.preventDefault(), r6.stopPropagation(), e3({ type: 2, focus: a2.First });
        case o8.End:
        case o8.PageDown:
          return r6.preventDefault(), r6.stopPropagation(), e3({ type: 2, focus: a2.Last });
        case o8.Escape:
          r6.preventDefault(), r6.stopPropagation(), e3({ type: 1 }), m().nextFrame(() => {
            var p3;
            return (p3 = n2.buttonRef.current) == null ? void 0 : p3.focus({ preventScroll: true });
          });
          break;
        case o8.Tab:
          r6.preventDefault(), r6.stopPropagation(), e3({ type: 1 }), m().nextFrame(() => {
            v(n2.buttonRef.current, r6.shiftKey ? L.Previous : L.Next);
          });
          break;
        default:
          r6.key.length === 1 && (e3({ type: 3, value: r6.key }), f5.setTimeout(() => e3({ type: 4 }), 350));
          break;
      }
    }), A3 = o3((r6) => {
      switch (r6.key) {
        case o8.Space:
          r6.preventDefault();
          break;
      }
    }), g3 = (0, import_react17.useMemo)(() => ({ open: n2.menuState === 0 }), [n2]), c3 = { "aria-activedescendant": n2.activeItemIndex === null || (b2 = n2.items[n2.activeItemIndex]) == null ? void 0 : b2.id, "aria-labelledby": (S2 = n2.buttonRef.current) == null ? void 0 : S2.id, id: a3, onKeyDown: R, onKeyUp: A3, role: "menu", tabIndex: 0, ref: d5 };
    return X({ ourProps: c3, theirProps: u4, slot: g3, defaultTag: Re, features: be, visible: T4, name: "Menu.Items" });
  });
  var ve = import_react17.Fragment;
  var Se = V(function(i5, o10) {
    let s7 = I(), _a9 = i5, { id: a3 = `headlessui-menu-item-${s7}`, disabled: u4 = false } = _a9, n2 = __objRest(_a9, ["id", "disabled"]), [e3, d5] = O2("Menu.Item"), l6 = e3.activeItemIndex !== null ? e3.items[e3.activeItemIndex].id === a3 : false, f5 = (0, import_react17.useRef)(null), M3 = y(o10, f5);
    l(() => {
      if (e3.menuState !== 0 || !l6 || e3.activationTrigger === 0) return;
      let p3 = m();
      return p3.requestAnimationFrame(() => {
        var v3, B;
        (B = (v3 = f5.current) == null ? void 0 : v3.scrollIntoView) == null || B.call(v3, { block: "nearest" });
      }), p3.dispose;
    }, [f5, l6, e3.menuState, e3.activationTrigger, e3.activeItemIndex]);
    let T4 = (0, import_react17.useRef)({ disabled: u4, domRef: f5 });
    l(() => {
      T4.current.disabled = u4;
    }, [T4, u4]), l(() => {
      var p3, v3;
      T4.current.textValue = (v3 = (p3 = f5.current) == null ? void 0 : p3.textContent) == null ? void 0 : v3.toLowerCase();
    }, [T4, f5]), l(() => (d5({ type: 5, id: a3, dataRef: T4 }), () => d5({ type: 6, id: a3 })), [T4, a3]);
    let R = o3(() => {
      d5({ type: 1 });
    }), A3 = o3((p3) => {
      if (u4) return p3.preventDefault();
      d5({ type: 1 }), g(e3.buttonRef.current);
    }), g3 = o3(() => {
      if (u4) return d5({ type: 2, focus: a2.Nothing });
      d5({ type: 2, focus: a2.Specific, id: a3 });
    }), c3 = u3(), b2 = o3((p3) => c3.update(p3)), S2 = o3((p3) => {
      !c3.wasMoved(p3) || u4 || l6 || d5({ type: 2, focus: a2.Specific, id: a3, trigger: 0 });
    }), r6 = o3((p3) => {
      !c3.wasMoved(p3) || u4 || !l6 || d5({ type: 2, focus: a2.Nothing });
    }), h3 = (0, import_react17.useMemo)(() => ({ active: l6, disabled: u4, close: R }), [l6, u4, R]);
    return X({ ourProps: { id: a3, ref: M3, role: "menuitem", tabIndex: u4 === true ? void 0 : -1, "aria-disabled": u4 === true ? true : void 0, disabled: void 0, onClick: A3, onFocus: g3, onPointerEnter: b2, onMouseEnter: b2, onPointerMove: S2, onMouseMove: S2, onPointerLeave: r6, onMouseLeave: r6 }, theirProps: n2, slot: h3, defaultTag: ve, name: "Menu.Item" });
  });
  var Ze = Object.assign(Ie, { Button: Me, Items: Ae, Item: Se });

  // node_modules/@headlessui/react/dist/components/transitions/transition.js
  var import_react18 = __toESM(require_react(), 1);

  // node_modules/@headlessui/react/dist/utils/once.js
  function l5(r6) {
    let e3 = { called: false };
    return (...t7) => {
      if (!e3.called) return e3.called = true, r6(...t7);
    };
  }

  // node_modules/@headlessui/react/dist/components/transitions/utils/transition.js
  function v2(t7, ...e3) {
    t7 && e3.length > 0 && t7.classList.add(...e3);
  }
  function f4(t7, ...e3) {
    t7 && e3.length > 0 && t7.classList.remove(...e3);
  }
  function F3(t7, e3) {
    let n2 = m();
    if (!t7) return n2.dispose;
    let { transitionDuration: a3, transitionDelay: i5 } = getComputedStyle(t7), [m5, d5] = [a3, i5].map((o10) => {
      let [r6 = 0] = o10.split(",").filter(Boolean).map((l6) => l6.includes("ms") ? parseFloat(l6) : parseFloat(l6) * 1e3).sort((l6, g3) => g3 - l6);
      return r6;
    });
    if (m5 + d5 !== 0) {
      let o10 = n2.addEventListener(t7, "transitionend", (r6) => {
        r6.target === r6.currentTarget && (e3(), o10());
      });
    } else e3();
    return n2.add(() => e3()), n2.dispose;
  }
  function M(t7, e3, n2, a3) {
    let i5 = n2 ? "enter" : "leave", m5 = m(), d5 = a3 !== void 0 ? l5(a3) : () => {
    };
    i5 === "enter" && (t7.removeAttribute("hidden"), t7.style.display = "");
    let u4 = u(i5, { enter: () => e3.enter, leave: () => e3.leave }), o10 = u(i5, { enter: () => e3.enterTo, leave: () => e3.leaveTo }), r6 = u(i5, { enter: () => e3.enterFrom, leave: () => e3.leaveFrom });
    return f4(t7, ...e3.enter, ...e3.enterTo, ...e3.enterFrom, ...e3.leave, ...e3.leaveFrom, ...e3.leaveTo, ...e3.entered), v2(t7, ...u4, ...r6), m5.nextFrame(() => {
      f4(t7, ...r6), v2(t7, ...o10), F3(t7, () => (f4(t7, ...u4), v2(t7, ...e3.entered), d5()));
    }), m5.dispose;
  }

  // node_modules/@headlessui/react/dist/hooks/use-transition.js
  function D({ container: i5, direction: t7, classes: o10, onStart: s7, onStop: u4 }) {
    let a3 = f3(), c3 = p(), r6 = s2(t7);
    l(() => {
      let e3 = m();
      c3.add(e3.dispose);
      let n2 = i5.current;
      if (!!n2 && r6.current !== "idle" && !!a3.current) return e3.dispose(), s7.current(r6.current), e3.add(M(n2, o10.current, r6.current === "enter", () => {
        e3.dispose(), u4.current(r6.current);
      })), e3.dispose;
    }, [t7]);
  }

  // node_modules/@headlessui/react/dist/components/transitions/transition.js
  function P3(i5 = "") {
    return i5.split(" ").filter((e3) => e3.trim().length > 1);
  }
  var A2 = (0, import_react18.createContext)(null);
  A2.displayName = "TransitionContext";
  var ge2 = ((s7) => (s7.Visible = "visible", s7.Hidden = "hidden", s7))(ge2 || {});
  function be2() {
    let i5 = (0, import_react18.useContext)(A2);
    if (i5 === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
    return i5;
  }
  function Ee() {
    let i5 = (0, import_react18.useContext)(M2);
    if (i5 === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
    return i5;
  }
  var M2 = (0, import_react18.createContext)(null);
  M2.displayName = "NestingContext";
  function I3(i5) {
    return "children" in i5 ? I3(i5.children) : i5.current.filter(({ el: e3 }) => e3.current !== null).filter(({ state: e3 }) => e3 === "visible").length > 0;
  }
  function ne(i5, e3) {
    let s7 = s2(i5), n2 = (0, import_react18.useRef)([]), m5 = f3(), y2 = p(), b2 = o3((l6, r6 = w2.Hidden) => {
      let t7 = n2.current.findIndex(({ el: o10 }) => o10 === l6);
      t7 !== -1 && (u(r6, { [w2.Unmount]() {
        n2.current.splice(t7, 1);
      }, [w2.Hidden]() {
        n2.current[t7].state = "hidden";
      } }), y2.microTask(() => {
        var o10;
        !I3(n2) && m5.current && ((o10 = s7.current) == null || o10.call(s7));
      }));
    }), E4 = o3((l6) => {
      let r6 = n2.current.find(({ el: t7 }) => t7 === l6);
      return r6 ? r6.state !== "visible" && (r6.state = "visible") : n2.current.push({ el: l6, state: "visible" }), () => b2(l6, w2.Unmount);
    }), S2 = (0, import_react18.useRef)([]), u4 = (0, import_react18.useRef)(Promise.resolve()), p3 = (0, import_react18.useRef)({ enter: [], leave: [], idle: [] }), d5 = o3((l6, r6, t7) => {
      S2.current.splice(0), e3 && (e3.chains.current[r6] = e3.chains.current[r6].filter(([o10]) => o10 !== l6)), e3 == null || e3.chains.current[r6].push([l6, new Promise((o10) => {
        S2.current.push(o10);
      })]), e3 == null || e3.chains.current[r6].push([l6, new Promise((o10) => {
        Promise.all(p3.current[r6].map(([f5, a3]) => a3)).then(() => o10());
      })]), r6 === "enter" ? u4.current = u4.current.then(() => e3 == null ? void 0 : e3.wait.current).then(() => t7(r6)) : t7(r6);
    }), v3 = o3((l6, r6, t7) => {
      Promise.all(p3.current[r6].splice(0).map(([o10, f5]) => f5)).then(() => {
        var o10;
        (o10 = S2.current.shift()) == null || o10();
      }).then(() => t7(r6));
    });
    return (0, import_react18.useMemo)(() => ({ children: n2, register: E4, unregister: b2, onStart: d5, onStop: v3, wait: u4, chains: p3 }), [E4, b2, n2, d5, v3, p3, u4]);
  }
  function Se2() {
  }
  var xe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
  function re(i5) {
    var s7;
    let e3 = {};
    for (let n2 of xe) e3[n2] = (s7 = i5[n2]) != null ? s7 : Se2;
    return e3;
  }
  function Pe(i5) {
    let e3 = (0, import_react18.useRef)(re(i5));
    return (0, import_react18.useEffect)(() => {
      e3.current = re(i5);
    }, [i5]), e3;
  }
  var He = "div";
  var ie = j.RenderStrategy;
  var oe = V(function(e3, s7) {
    let _a9 = e3, { beforeEnter: n2, afterEnter: m5, beforeLeave: y2, afterLeave: b2, enter: E4, enterFrom: S2, enterTo: u4, entered: p3, leave: d5, leaveFrom: v3, leaveTo: l6 } = _a9, r6 = __objRest(_a9, ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave", "enter", "enterFrom", "enterTo", "entered", "leave", "leaveFrom", "leaveTo"]), t7 = (0, import_react18.useRef)(null), o10 = y(t7, s7), f5 = r6.unmount ? w2.Unmount : w2.Hidden, { show: a3, appear: x3, initial: se } = be2(), [h3, _2] = (0, import_react18.useState)(a3 ? "visible" : "hidden"), K2 = Ee(), { register: D2, unregister: V2 } = K2, j2 = (0, import_react18.useRef)(null);
    (0, import_react18.useEffect)(() => D2(t7), [D2, t7]), (0, import_react18.useEffect)(() => {
      if (f5 === w2.Hidden && !!t7.current) {
        if (a3 && h3 !== "visible") {
          _2("visible");
          return;
        }
        return u(h3, { ["hidden"]: () => V2(t7), ["visible"]: () => D2(t7) });
      }
    }, [h3, t7, D2, V2, a3, f5]);
    let U2 = s2({ enter: P3(E4), enterFrom: P3(S2), enterTo: P3(u4), entered: P3(p3), leave: P3(d5), leaveFrom: P3(v3), leaveTo: P3(l6) }), L3 = Pe({ beforeEnter: n2, afterEnter: m5, beforeLeave: y2, afterLeave: b2 }), k = l2();
    (0, import_react18.useEffect)(() => {
      if (k && h3 === "visible" && t7.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
    }, [t7, h3, k]);
    let G2 = se && !x3, le = (() => !k || G2 || j2.current === a3 ? "idle" : a3 ? "enter" : "leave")(), ae = o3((C2) => u(C2, { enter: () => L3.current.beforeEnter(), leave: () => L3.current.beforeLeave(), idle: () => {
    } })), ue = o3((C2) => u(C2, { enter: () => L3.current.afterEnter(), leave: () => L3.current.afterLeave(), idle: () => {
    } })), w3 = ne(() => {
      _2("hidden"), V2(t7);
    }, K2);
    D({ container: t7, classes: U2, direction: le, onStart: s2((C2) => {
      w3.onStart(t7, C2, ae);
    }), onStop: s2((C2) => {
      w3.onStop(t7, C2, ue), C2 === "leave" && !I3(w3) && (_2("hidden"), V2(t7));
    }) }), (0, import_react18.useEffect)(() => {
      !G2 || (f5 === w2.Hidden ? j2.current = null : j2.current = a3);
    }, [a3, G2, h3]);
    let B = r6, de2 = { ref: o10 };
    return x3 && a3 && s.isServer && (B = __spreadProps(__spreadValues({}, B), { className: e2(r6.className, ...U2.current.enter, ...U2.current.enterFrom) })), import_react18.default.createElement(M2.Provider, { value: w3 }, import_react18.default.createElement(C, { value: u(h3, { ["visible"]: p2.Open, ["hidden"]: p2.Closed }) }, X({ ourProps: de2, theirProps: B, defaultTag: He, features: ie, visible: h3 === "visible", name: "Transition.Child" })));
  });
  var J2 = V(function(e3, s7) {
    let _a9 = e3, { show: n2, appear: m5 = false, unmount: y2 } = _a9, b2 = __objRest(_a9, ["show", "appear", "unmount"]), E4 = (0, import_react18.useRef)(null), S2 = y(E4, s7);
    l2();
    let u4 = s6();
    if (n2 === void 0 && u4 !== null && (n2 = u(u4, { [p2.Open]: true, [p2.Closed]: false })), ![true, false].includes(n2)) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
    let [p3, d5] = (0, import_react18.useState)(n2 ? "visible" : "hidden"), v3 = ne(() => {
      d5("hidden");
    }), [l6, r6] = (0, import_react18.useState)(true), t7 = (0, import_react18.useRef)([n2]);
    l(() => {
      l6 !== false && t7.current[t7.current.length - 1] !== n2 && (t7.current.push(n2), r6(false));
    }, [t7, n2]);
    let o10 = (0, import_react18.useMemo)(() => ({ show: n2, appear: m5, initial: l6 }), [n2, m5, l6]);
    (0, import_react18.useEffect)(() => {
      if (n2) d5("visible");
      else if (!I3(v3)) d5("hidden");
      else {
        let a3 = E4.current;
        if (!a3) return;
        let x3 = a3.getBoundingClientRect();
        x3.x === 0 && x3.y === 0 && x3.width === 0 && x3.height === 0 && d5("hidden");
      }
    }, [n2, v3]);
    let f5 = { unmount: y2 };
    return import_react18.default.createElement(M2.Provider, { value: v3 }, import_react18.default.createElement(A2.Provider, { value: o10 }, X({ ourProps: __spreadProps(__spreadValues({}, f5), { as: import_react18.Fragment, children: import_react18.default.createElement(oe, __spreadValues(__spreadValues({ ref: S2 }, f5), b2)) }), theirProps: {}, defaultTag: import_react18.Fragment, features: ie, visible: p3 === "visible", name: "Transition" })));
  });
  var Ne = V(function(e3, s7) {
    let n2 = (0, import_react18.useContext)(A2) !== null, m5 = s6() !== null;
    return import_react18.default.createElement(import_react18.default.Fragment, null, !n2 && m5 ? import_react18.default.createElement(J2, __spreadValues({ ref: s7 }, e3)) : import_react18.default.createElement(oe, __spreadValues({ ref: s7 }, e3)));
  });
  var Ke = Object.assign(J2, { Child: Ne, Root: J2 });

  // js/dashboard/util/date.js
  var import_dayjs = __toESM(require_dayjs_min());
  var import_utc = __toESM(require_utc());
  import_dayjs.default.extend(import_utc.default);
  function formatISO(date) {
    return date.format("YYYY-MM-DD");
  }
  function shiftMonths(date, months) {
    return date.add(months, "months");
  }
  function shiftDays(date, days) {
    return date.add(days, "days");
  }
  function formatMonthYYYY(date) {
    return date.format("MMMM YYYY");
  }
  function formatYear(date) {
    return `Year of ${date.year()}`;
  }
  function formatDay(date) {
    if (date.year() !== (0, import_dayjs.default)().year()) {
      return date.format("ddd, DD MMM YYYY");
    } else {
      return date.format("ddd, DD MMM");
    }
  }
  function formatDayShort(date, includeYear = false) {
    if (includeYear) {
      return date.format("D MMM YY");
    } else {
      return date.format("D MMM");
    }
  }
  function formatDateRange(site, from2, to2) {
    if (!from2 || !to2) return;
    if (typeof from2 === "string") from2 = parseUTCDate(from2);
    if (typeof to2 === "string") to2 = parseUTCDate(to2);
    if (from2.isSame(to2)) {
      return formatDay(from2);
    } else if (from2.isSame(to2, "year")) {
      const includeYear = !isThisYear(site, from2);
      return `${formatDayShort(from2, false)} - ${formatDayShort(to2, includeYear)}`;
    } else {
      return `${formatDayShort(from2, true)} - ${formatDayShort(to2, true)}`;
    }
  }
  function parseUTCDate(dateString) {
    return import_dayjs.default.utc(dateString);
  }
  function parseNaiveDate(dateString) {
    return (0, import_dayjs.default)(dateString);
  }
  function nowForSite(site) {
    return import_dayjs.default.utc().utcOffset(site.offset / 60);
  }
  function yesterday(site) {
    return nowForSite(site).subtract(1, "day");
  }
  function lastMonth(site) {
    return shiftMonths(nowForSite(site), -1);
  }
  function isSameDate(date1, date2) {
    return formatISO(date1) === formatISO(date2);
  }
  function isSameMonth(date1, date2) {
    return formatMonthYYYY(date1) === formatMonthYYYY(date2);
  }
  function isToday(site, date) {
    return isSameDate(date, nowForSite(site));
  }
  function isThisMonth(site, date) {
    return formatMonthYYYY(date) === formatMonthYYYY(nowForSite(site));
  }
  function isThisYear(site, date) {
    return date.year() === nowForSite(site).year();
  }
  function isBefore(date1, date2, period) {
    if (date1.year() !== date2.year()) {
      return date1.year() < date2.year();
    }
    if (period === "year") {
      return false;
    }
    if (date1.month() !== date2.month()) {
      return date1.month() < date2.month();
    }
    if (period === "month") {
      return false;
    }
    return date1.date() < date2.date();
  }
  function isAfter(date1, date2, period) {
    if (date1.year() !== date2.year()) {
      return date1.year() > date2.year();
    }
    if (period === "year") {
      return false;
    }
    if (date1.month() !== date2.month()) {
      return date1.month() > date2.month();
    }
    if (period === "month") {
      return false;
    }
    return date1.date() > date2.date();
  }

  // js/dashboard/query.js
  var import_react25 = __toESM(require_react());

  // js/dashboard/util/url.js
  var import_jsonurl = __toESM(require_jsonurl_min());
  function apiPath(site, path = "") {
    return `/api/stats/${encodeURIComponent(site.domain)}${path}/`;
  }
  function externalLinkForPage(domain, page) {
    const domainURL = new URL(`https://${domain}`);
    return `https://${domainURL.host}${page}`;
  }
  function isValidHttpUrl(string) {
    let url;
    try {
      url = new URL(string);
    } catch (_2) {
      return false;
    }
    return url.protocol === "http:" || url.protocol === "https:";
  }
  function trimURL(url, maxLength) {
    if (url.length <= maxLength) {
      return url;
    }
    const ellipsis = "...";
    if (isValidHttpUrl(url)) {
      const [protocol, restURL] = url.split("://");
      const parts = restURL.split("/");
      const host = parts.shift();
      if (host.length > maxLength - 5) {
        return `${protocol}://${host.substr(0, maxLength - 5)}${ellipsis}${restURL.slice(-maxLength + 5)}`;
      }
      let remainingLength = maxLength - host.length - 5;
      let trimmedURL = `${protocol}://${host}`;
      for (const part of parts) {
        if (part.length <= remainingLength) {
          trimmedURL += "/" + part;
          remainingLength -= part.length + 1;
        } else {
          const startTrim = Math.floor((remainingLength - 3) / 2);
          const endTrim = Math.ceil((remainingLength - 3) / 2);
          trimmedURL += `/${part.substr(0, startTrim)}...${part.slice(-endTrim)}`;
          break;
        }
      }
      return trimmedURL;
    } else {
      const leftSideLength = Math.floor(maxLength / 2);
      const rightSideLength = maxLength - leftSideLength;
      const leftSide = url.slice(0, leftSideLength);
      const rightSide = url.slice(-rightSideLength);
      return leftSide + ellipsis + rightSide;
    }
  }
  function encodeURIComponentPermissive(input) {
    return encodeURIComponent(input).replaceAll("%2C", ",").replaceAll("%3A", ":").replaceAll("%2F", "/");
  }
  function encodeSearchParamEntries([k, v3]) {
    return `${encodeURIComponentPermissive(k)}=${encodeURIComponentPermissive(v3)}`;
  }
  function isSearchEntryDefined([_key, value]) {
    return value !== void 0;
  }
  function stringifySearch(searchRecord) {
    const definedSearchEntries = Object.entries(searchRecord || {}).map(stringifySearchEntry).filter(isSearchEntryDefined);
    const encodedSearchEntries = definedSearchEntries.map(encodeSearchParamEntries);
    return encodedSearchEntries.length ? `?${encodedSearchEntries.join("&")}` : "";
  }
  function stringifySearchEntry([key, value]) {
    const isEmptyObjectOrArray = typeof value === "object" && value !== null && Object.entries(value).length === 0;
    if (value === void 0 || value === null || isEmptyObjectOrArray) {
      return [key, void 0];
    }
    return [key, import_jsonurl.default.stringify(value)];
  }
  function parseSearchFragment(searchStringFragment) {
    const fragmentWithEncodedEquals = searchStringFragment.replaceAll("=", "%3D");
    return import_jsonurl.default.parse(fragmentWithEncodedEquals);
  }
  var parseSearch = parseSearchWith(parseSearchFragment);

  // js/dashboard/util/storage.js
  var memStore = {};
  function testLocalStorageAvailability() {
    try {
      const testItem = "test";
      localStorage.setItem(testItem, testItem);
      localStorage.removeItem(testItem);
      return true;
    } catch (e3) {
      return false;
    }
  }
  var isLocalStorageAvailable = testLocalStorageAvailability();
  function setItem(key, value) {
    if (isLocalStorageAvailable) {
      window.localStorage.setItem(key, value);
    } else {
      memStore[key] = value;
    }
  }
  function getItem(key) {
    if (isLocalStorageAvailable) {
      return window.localStorage.getItem(key);
    } else {
      return memStore[key];
    }
  }
  var getDomainScopedStorageKey = (key, domain) => `${key}__${domain}`;

  // js/dashboard/comparison-input.js
  var import_react23 = __toESM(require_react());
  var import_classnames = __toESM(require_classnames());
  var import_react_flatpickr = __toESM(require_build());

  // js/dashboard/query-context.js
  var import_react22 = __toESM(require_react());

  // js/dashboard/custom-hooks.js
  var import_react19 = __toESM(require_react());
  function useMountedEffect(fn2, deps) {
    const mounted = (0, import_react19.useRef)(false);
    (0, import_react19.useEffect)(() => {
      if (mounted.current) {
        fn2();
      } else {
        mounted.current = true;
      }
    }, deps);
  }
  var DEBOUNCE_DELAY = 300;
  function useDebounce(fn2, delay = DEBOUNCE_DELAY) {
    const timerRef = (0, import_react19.useRef)(null);
    (0, import_react19.useEffect)(() => {
      return () => {
        if (timerRef.current) {
          clearTimeout(timerRef.current);
        }
      };
    }, []);
    return (0, import_react19.useCallback)((...args) => {
      clearTimeout(timerRef.current);
      timerRef.current = setTimeout(() => {
        fn2(...args);
      }, delay);
    }, [fn2, delay]);
  }

  // js/dashboard/util/filters.js
  var import_react20 = __toESM(require_react());
  var FILTER_MODAL_TO_FILTER_GROUP = {
    "page": ["page", "entry_page", "exit_page"],
    "source": ["source", "referrer"],
    "location": ["country", "region", "city"],
    "screen": ["screen"],
    "browser": ["browser", "browser_version"],
    "os": ["os", "os_version"],
    "utm": ["utm_medium", "utm_source", "utm_campaign", "utm_term", "utm_content"],
    "goal": ["goal"],
    "props": ["props"],
    "hostname": ["hostname"]
  };
  var FILTER_GROUP_TO_MODAL_TYPE = Object.fromEntries(
    Object.entries(FILTER_MODAL_TO_FILTER_GROUP).flatMap(([modalName, filterGroups]) => filterGroups.map((filterGroup) => [filterGroup, modalName]))
  );
  var NO_CONTAINS_OPERATOR = new Set(["goal", "screen"].concat(FILTER_MODAL_TO_FILTER_GROUP["location"]));
  var EVENT_PROPS_PREFIX = "props:";
  var FILTER_OPERATIONS = {
    is: "is",
    isNot: "is_not",
    contains: "contains",
    does_not_contain: "does_not_contain"
  };
  var FILTER_OPERATIONS_DISPLAY_NAMES = {
    [FILTER_OPERATIONS.is]: "is",
    [FILTER_OPERATIONS.isNot]: "is not",
    [FILTER_OPERATIONS.contains]: "contains",
    [FILTER_OPERATIONS.does_not_contain]: "does not contain"
  };
  var OPERATION_PREFIX = {
    [FILTER_OPERATIONS.isNot]: "!",
    [FILTER_OPERATIONS.contains]: "~",
    [FILTER_OPERATIONS.is]: ""
  };
  function supportsIsNot(filterName) {
    return !["goal", "prop_key"].includes(filterName);
  }
  function isFreeChoiceFilter(filterName) {
    return !NO_CONTAINS_OPERATOR.has(filterName);
  }
  var NON_ESCAPED_PIPE_REGEX;
  try {
    NON_ESCAPED_PIPE_REGEX = new RegExp("(?<!\\\\)\\|", "g");
  } catch (_e) {
    NON_ESCAPED_PIPE_REGEX = "|";
  }
  var ESCAPED_PIPE = "\\|";
  function getLabel(labels, filterKey, value) {
    if (["country", "region", "city"].includes(filterKey)) {
      return labels[value];
    } else {
      return value;
    }
  }
  function getPropertyKeyFromFilterKey(filterKey) {
    return filterKey.slice(EVENT_PROPS_PREFIX.length);
  }
  function getFiltersByKeyPrefix(query, prefix2) {
    return query.filters.filter(([_operation, filterKey, _clauses]) => filterKey.startsWith(prefix2));
  }
  function omitFiltersByKeyPrefix(query, prefix2) {
    return query.filters.filter(([_operation, filterKey, _clauses]) => !filterKey.startsWith(prefix2));
  }
  function replaceFilterByPrefix(query, prefix2, filter) {
    return omitFiltersByKeyPrefix(query, prefix2).concat([filter]);
  }
  function isFilteringOnFixedValue(query, filterKey, expectedValue) {
    const filters = query.filters.filter(([_operation, key]) => filterKey == key);
    if (filters.length == 1) {
      const [operation, _filterKey, clauses] = filters[0];
      return operation === FILTER_OPERATIONS.is && clauses.length === 1 && (!expectedValue || clauses[0] == expectedValue);
    }
    return false;
  }
  function hasGoalFilter(query) {
    return getFiltersByKeyPrefix(query, "goal").length > 0;
  }
  function isRealTimeDashboard(query) {
    return (query == null ? void 0 : query.period) === "realtime";
  }
  function useIsRealtimeDashboard() {
    const { query: { period } } = useQueryContext();
    return (0, import_react20.useMemo)(() => isRealTimeDashboard({ period }), [period]);
  }
  function getGoalFilter(query) {
    return getFiltersByKeyPrefix(query, "goal")[0] || null;
  }
  function formatFilterGroup(filterGroup) {
    if (filterGroup === "utm") {
      return "UTM tags";
    } else if (filterGroup === "location") {
      return "Location";
    } else if (filterGroup === "props") {
      return "Property";
    } else {
      return formattedFilters[filterGroup];
    }
  }
  function cleanLabels(filters, labels, mergedFilterKey, mergedLabels) {
    const filteredBy = Object.fromEntries(
      filters.flatMap(([_operation, filterKey, clauses]) => ["country", "region", "city"].includes(filterKey) ? clauses : []).map((value) => [value, true])
    );
    let result = __spreadValues({}, labels);
    for (const value in labels) {
      if (!filteredBy[value]) {
        delete result[value];
      }
    }
    if (mergedFilterKey && ["country", "region", "city"].includes(mergedFilterKey)) {
      result = __spreadValues(__spreadValues({}, result), mergedLabels);
    }
    return result;
  }
  var EVENT_FILTER_KEYS = /* @__PURE__ */ new Set(["name", "page", "goal", "hostname"]);
  function serializeApiFilters(filters) {
    const apiFilters = filters.map(([operation, filterKey, clauses]) => {
      let apiFilterKey = `visit:${filterKey}`;
      if (filterKey.startsWith(EVENT_PROPS_PREFIX) || EVENT_FILTER_KEYS.has(filterKey)) {
        apiFilterKey = `event:${filterKey}`;
      }
      return [operation, apiFilterKey, clauses];
    });
    return JSON.stringify(apiFilters);
  }
  function fetchSuggestions(apiPath2, query, input, additionalFilter) {
    const updatedQuery = queryForSuggestions(query, additionalFilter);
    return get(apiPath2, updatedQuery, { q: input.trim() });
  }
  function queryForSuggestions(query, additionalFilter) {
    let filters = query.filters;
    if (additionalFilter) {
      const [_operation, filterKey, clauses] = additionalFilter;
      if (clauses.length > 0) {
        filters = replaceFilterByPrefix(query, filterKey, additionalFilter);
      } else {
        filters = omitFiltersByKeyPrefix(query, filterKey);
      }
    }
    return __spreadProps(__spreadValues({}, query), { filters });
  }
  function getFilterGroup([_operation, filterKey, _clauses]) {
    return filterKey.startsWith(EVENT_PROPS_PREFIX) ? "props" : filterKey;
  }
  var formattedFilters = {
    "goal": "Goal",
    "props": "Property",
    "prop_key": "Property",
    "prop_value": "Value",
    "source": "Source",
    "utm_medium": "UTM Medium",
    "utm_source": "UTM Source",
    "utm_campaign": "UTM Campaign",
    "utm_content": "UTM Content",
    "utm_term": "UTM Term",
    "referrer": "Referrer URL",
    "screen": "Screen size",
    "browser": "Browser",
    "browser_version": "Browser Version",
    "os": "Operating System",
    "os_version": "Operating System Version",
    "country": "Country",
    "region": "Region",
    "city": "City",
    "page": "Page",
    "hostname": "Hostname",
    "entry_page": "Entry Page",
    "exit_page": "Exit Page"
  };
  function parseLegacyFilter(filterKey, rawValue) {
    const operation = Object.keys(OPERATION_PREFIX).find((operation2) => OPERATION_PREFIX[operation2] === rawValue[0]) || FILTER_OPERATIONS.is;
    const value = operation === FILTER_OPERATIONS.is ? rawValue : rawValue.substring(1);
    const clauses = value.split(NON_ESCAPED_PIPE_REGEX).filter((clause) => !!clause).map((val) => val.replaceAll(ESCAPED_PIPE, "|"));
    return [operation, filterKey, clauses];
  }
  function parseLegacyPropsFilter(rawValue) {
    return Object.entries(JSON.parse(rawValue)).map(([key, propVal]) => {
      return parseLegacyFilter(`${EVENT_PROPS_PREFIX}${key}`, propVal);
    });
  }

  // js/dashboard/api.js
  var abortController = new AbortController();
  var SHARED_LINK_AUTH = null;
  var ApiError = class extends Error {
    constructor(message, payload) {
      super(message);
      this.name = "ApiError";
      this.payload = payload;
    }
  };
  function serialize(obj) {
    var str = [];
    for (var p3 in obj)
      if (obj.hasOwnProperty(p3)) {
        str.push(encodeURIComponent(p3) + "=" + encodeURIComponent(obj[p3]));
      }
    return str.join("&");
  }
  function setSharedLinkAuth(auth) {
    SHARED_LINK_AUTH = auth;
  }
  function cancelAll() {
    abortController.abort();
    abortController = new AbortController();
  }
  function serializeQuery(query, extraQuery = []) {
    const queryObj = {};
    if (query.period) {
      queryObj.period = query.period;
    }
    if (query.date) {
      queryObj.date = formatISO(query.date);
    }
    if (query.from) {
      queryObj.from = formatISO(query.from);
    }
    if (query.to) {
      queryObj.to = formatISO(query.to);
    }
    if (query.filters) {
      queryObj.filters = serializeApiFilters(query.filters);
    }
    if (query.with_imported) {
      queryObj.with_imported = query.with_imported;
    }
    if (SHARED_LINK_AUTH) {
      queryObj.auth = SHARED_LINK_AUTH;
    }
    if (query.comparison) {
      queryObj.comparison = query.comparison;
      queryObj.compare_from = query.compare_from ? formatISO(query.compare_from) : void 0;
      queryObj.compare_to = query.compare_to ? formatISO(query.compare_to) : void 0;
      queryObj.match_day_of_week = query.match_day_of_week;
    }
    Object.assign(queryObj, ...extraQuery);
    return "?" + serialize(queryObj);
  }
  function get(url, query = {}, ...extraQuery) {
    const headers = SHARED_LINK_AUTH ? { "X-Shared-Link-Auth": SHARED_LINK_AUTH } : {};
    url = url + serializeQuery(query, extraQuery);
    return fetch(url, { signal: abortController.signal, headers }).then((response) => {
      if (!response.ok) {
        return response.json().then((payload) => {
          throw new ApiError(payload.error, payload);
        });
      }
      return response.json();
    });
  }
  function put(url, body) {
    return fetch(url, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
  }

  // js/dashboard/site-context.js
  var import_react21 = __toESM(require_react());
  function parseSiteFromDataset(dataset) {
    const site = {
      domain: dataset.domain,
      offset: dataset.offset,
      hasGoals: dataset.hasGoals === "true",
      hasProps: dataset.hasProps === "true",
      funnelsAvailable: dataset.funnelsAvailable === "true",
      propsAvailable: dataset.propsAvailable === "true",
      conversionsOptedOut: dataset.conversionsOptedOut === "true",
      funnelsOptedOut: dataset.funnelsOptedOut === "true",
      propsOptedOut: dataset.propsOptedOut === "true",
      revenueGoals: JSON.parse(dataset.revenueGoals),
      funnels: JSON.parse(dataset.funnels),
      statsBegin: dataset.statsBegin,
      nativeStatsBegin: dataset.nativeStatsBegin,
      embedded: dataset.embedded,
      background: dataset.background,
      isDbip: dataset.isDbip === "true",
      flags: JSON.parse(dataset.flags),
      validIntervalsByPeriod: JSON.parse(dataset.validIntervalsByPeriod),
      shared: !!dataset.sharedLinkAuth
    };
    return site;
  }
  var siteContextDefaultValue = {
    domain: "",
    offset: "0",
    hasGoals: false,
    hasProps: false,
    funnelsAvailable: false,
    propsAvailable: false,
    conversionsOptedOut: false,
    funnelsOptedOut: false,
    propsOptedOut: false,
    revenueGoals: [],
    funnels: [],
    statsBegin: "",
    nativeStatsBegin: "",
    embedded: "",
    background: "",
    isDbip: false,
    flags: {},
    validIntervalsByPeriod: null,
    shared: false
  };
  var SiteContext = (0, import_react21.createContext)(siteContextDefaultValue);
  var useSiteContext = () => {
    return (0, import_react21.useContext)(SiteContext);
  };
  var SiteContextProvider = ({ site, children }) => {
    return /* @__PURE__ */ import_react21.default.createElement(SiteContext.Provider, { value: site }, children);
  };
  var site_context_default = SiteContextProvider;

  // js/dashboard/query-context.js
  var queryContextDefaultValue = { query: {}, lastLoadTimestamp: /* @__PURE__ */ new Date() };
  var QueryContext = (0, import_react22.createContext)(queryContextDefaultValue);
  var useQueryContext = () => {
    return (0, import_react22.useContext)(QueryContext);
  };
  function QueryContextProvider({ children }) {
    const location = useLocation();
    const site = useSiteContext();
    const { search } = location;
    const query = (0, import_react22.useMemo)(() => {
      return parseQuery(search, site);
    }, [search, site]);
    const [lastLoadTimestamp, setLastLoadTimestamp] = (0, import_react22.useState)(/* @__PURE__ */ new Date());
    const updateLastLoadTimestamp = (0, import_react22.useCallback)(() => {
      setLastLoadTimestamp(/* @__PURE__ */ new Date());
    }, [setLastLoadTimestamp]);
    (0, import_react22.useEffect)(() => {
      document.addEventListener("tick", updateLastLoadTimestamp);
      return () => {
        document.removeEventListener("tick", updateLastLoadTimestamp);
      };
    }, [updateLastLoadTimestamp]);
    useMountedEffect(() => {
      cancelAll();
      updateLastLoadTimestamp();
    }, []);
    return /* @__PURE__ */ import_react22.default.createElement(QueryContext.Provider, { value: { query, lastLoadTimestamp } }, children);
  }

  // js/dashboard/comparison-input.js
  var COMPARISON_MODES = {
    "off": "Disable comparison",
    "previous_period": "Previous period",
    "year_over_year": "Year over year",
    "custom": "Custom period"
  };
  var DEFAULT_COMPARISON_MODE = "previous_period";
  var COMPARISON_DISABLED_PERIODS = ["realtime", "all"];
  var getMatchDayOfWeekStorageKey = (domain) => getDomainScopedStorageKey("comparison_match_day_of_week", domain);
  var storeMatchDayOfWeek = function(domain, matchDayOfWeek) {
    setItem(getMatchDayOfWeekStorageKey(domain), matchDayOfWeek.toString());
  };
  var getStoredMatchDayOfWeek = function(domain, fallbackValue) {
    const storedValue = getItem(getMatchDayOfWeekStorageKey(domain));
    if (storedValue === "true") {
      return true;
    }
    if (storedValue === "false") {
      return false;
    }
    return fallbackValue;
  };
  var getComparisonModeStorageKey = (domain) => getDomainScopedStorageKey("comparison_mode", domain);
  var getStoredComparisonMode = function(domain, fallbackValue) {
    const storedValue = getItem(getComparisonModeStorageKey(domain));
    if (Object.keys(COMPARISON_MODES).includes(storedValue)) {
      return storedValue;
    }
    return fallbackValue;
  };
  var storeComparisonMode = function(domain, mode) {
    if (mode == "custom") return;
    setItem(getComparisonModeStorageKey(domain), mode);
  };
  var isComparisonEnabled = function(mode) {
    return mode && mode !== "off";
  };
  var toggleComparisons = function(navigate, query, site) {
    if (COMPARISON_DISABLED_PERIODS.includes(query.period)) return;
    if (isComparisonEnabled(query.comparison)) {
      storeComparisonMode(site.domain, "off");
      navigateToQuery(navigate, query, { comparison: "off" });
    } else {
      const storedMode = getStoredComparisonMode(site.domain, null);
      const newMode = isComparisonEnabled(storedMode) ? storedMode : DEFAULT_COMPARISON_MODE;
      storeComparisonMode(site.domain, newMode);
      navigateToQuery(navigate, query, { comparison: newMode });
    }
  };
  function ComparisonModeOption({ label, value, isCurrentlySelected, updateMode, setUiMode }) {
    const click = () => {
      if (value == "custom") {
        setUiMode("datepicker");
      } else {
        updateMode(value);
      }
    };
    const render = ({ active }) => {
      const buttonClass = (0, import_classnames.default)("px-4 py-2 w-full text-left text-sm dark:text-white", {
        "bg-gray-100 text-gray-900 dark:bg-gray-900 dark:text-gray-100": active,
        "font-medium": !isCurrentlySelected,
        "font-bold": isCurrentlySelected
      });
      return /* @__PURE__ */ import_react23.default.createElement("button", { className: buttonClass }, label);
    };
    const disabled = isCurrentlySelected && value !== "custom";
    return /* @__PURE__ */ import_react23.default.createElement(Ze.Item, { key: value, onClick: click, disabled }, render);
  }
  function MatchDayOfWeekInput() {
    const navigate = useNavigate();
    const site = useSiteContext();
    const { query } = useQueryContext();
    const click = (matchDayOfWeek) => {
      storeMatchDayOfWeek(site.domain, matchDayOfWeek);
      navigateToQuery(navigate, query, { match_day_of_week: matchDayOfWeek });
    };
    const buttonClass = (hover, selected) => (0, import_classnames.default)("px-4 py-2 w-full text-left text-sm dark:text-white cursor-pointer", {
      "bg-gray-100 text-gray-900 dark:bg-gray-900 dark:text-gray-100": hover,
      "font-medium": !selected,
      "font-bold": selected
    });
    return /* @__PURE__ */ import_react23.default.createElement(import_react23.default.Fragment, null, /* @__PURE__ */ import_react23.default.createElement(Ze.Item, { key: "match_day_of_week", onClick: () => click(true) }, ({ active }) => /* @__PURE__ */ import_react23.default.createElement("button", { className: buttonClass(active, query.match_day_of_week) }, "Match day of the week")), /* @__PURE__ */ import_react23.default.createElement(Ze.Item, { key: "match_exact_date", onClick: () => click(false) }, ({ active }) => /* @__PURE__ */ import_react23.default.createElement("button", { className: buttonClass(active, !query.match_day_of_week) }, "Match exact date")));
  }
  function ComparisonInput() {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const navigate = useNavigate();
    const calendar = (0, import_react23.useRef)(null);
    const [uiMode, setUiMode] = (0, import_react23.useState)("menu");
    (0, import_react23.useEffect)(() => {
      let timeout = null;
      if (uiMode == "datepicker") {
        timeout = setTimeout(() => {
          var _a9;
          return (_a9 = calendar.current) == null ? void 0 : _a9.flatpickr.open();
        }, 100);
      }
      return () => timeout && clearTimeout(timeout);
    }, [uiMode]);
    if (COMPARISON_DISABLED_PERIODS.includes(query.period)) return null;
    if (!isComparisonEnabled(query.comparison)) return null;
    const updateMode = (mode, from2 = null, to2 = null) => {
      storeComparisonMode(site.domain, mode);
      navigateToQuery(navigate, query, { comparison: mode, compare_from: from2, compare_to: to2 });
    };
    const buildLabel = (site2, query2) => {
      if (query2.comparison == "custom") {
        return formatDateRange(site2, query2.compare_from, query2.compare_to);
      } else {
        return COMPARISON_MODES[query2.comparison];
      }
    };
    const flatpickrOptions = {
      mode: "range",
      showMonths: 1,
      maxDate: "today",
      minDate: site.statsBegin,
      animate: true,
      static: true,
      onClose: ([from2, to2], _dateStr, _instance) => {
        setUiMode("menu");
        if (from2 && to2) {
          [from2, to2] = [parseNaiveDate(from2), parseNaiveDate(to2)];
          updateMode("custom", formatISO(from2), formatISO(to2));
        }
      }
    };
    return /* @__PURE__ */ import_react23.default.createElement(import_react23.default.Fragment, null, /* @__PURE__ */ import_react23.default.createElement("span", { className: "hidden md:block pl-2 text-sm font-medium text-gray-800 dark:text-gray-200" }, "vs."), /* @__PURE__ */ import_react23.default.createElement("div", { className: "flex" }, /* @__PURE__ */ import_react23.default.createElement("div", { className: "min-w-32 md:w-48 md:relative" }, /* @__PURE__ */ import_react23.default.createElement(Ze, { as: "div", className: "relative inline-block pl-2 w-full" }, /* @__PURE__ */ import_react23.default.createElement(Ze.Button, { className: "bg-white text-gray-800 text-xs md:text-sm font-medium dark:bg-gray-800 dark:hover:bg-gray-900 dark:text-gray-200 hover:bg-gray-200 flex md:px-3 px-2 py-2 items-center justify-between leading-tight rounded shadow cursor-pointer w-full truncate" }, /* @__PURE__ */ import_react23.default.createElement("span", { className: "truncate" }, buildLabel(site, query)), /* @__PURE__ */ import_react23.default.createElement(ChevronDownIcon_default, { className: "hidden sm:inline-block h-4 w-4 md:h-5 md:w-5 text-gray-500 ml-2", "aria-hidden": "true" })), /* @__PURE__ */ import_react23.default.createElement(
      Ke,
      {
        as: import_react23.Fragment,
        enter: "transition ease-out duration-100",
        enterFrom: "opacity-0 scale-95",
        enterTo: "opacity-100 scale-100",
        leave: "transition ease-in duration-75",
        leaveFrom: "opacity-100 scale-100",
        leaveTo: "opacity-0 scale-95"
      },
      /* @__PURE__ */ import_react23.default.createElement(Ze.Items, { className: "py-1 text-left origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5 focus:outline-none z-10", static: true }, Object.keys(COMPARISON_MODES).map((key) => ComparisonModeOption({ label: COMPARISON_MODES[key], value: key, isCurrentlySelected: key == query.comparison, updateMode, setUiMode })), query.comparison !== "custom" && /* @__PURE__ */ import_react23.default.createElement("span", null, /* @__PURE__ */ import_react23.default.createElement("hr", { className: "my-1" }), /* @__PURE__ */ import_react23.default.createElement(MatchDayOfWeekInput, null)))
    ), uiMode == "datepicker" && /* @__PURE__ */ import_react23.default.createElement("div", { className: "h-0 md:absolute" }, /* @__PURE__ */ import_react23.default.createElement(import_react_flatpickr.default, { ref: calendar, options: flatpickrOptions, className: "invisible" }))))));
  }
  var comparison_input_default = ComparisonInput;

  // js/dashboard/query.js
  var import_dayjs2 = __toESM(require_dayjs_min());
  var import_utc2 = __toESM(require_utc());
  import_dayjs2.default.extend(import_utc2.default);
  var PERIODS = ["realtime", "day", "month", "7d", "30d", "6mo", "12mo", "year", "all", "custom"];
  function parseQuery(searchRecord, site) {
    var _a9, _b2, _c;
    const getValue = (k) => searchRecord[k];
    let period = getValue("period");
    const periodKey = `period__${site.domain}`;
    if (PERIODS.includes(period)) {
      if (period !== "custom" && period !== "realtime") {
        setItem(periodKey, period);
      }
    } else if (getItem(periodKey)) {
      period = getItem(periodKey);
    } else {
      period = "30d";
    }
    let comparison = (_a9 = getValue("comparison")) != null ? _a9 : getStoredComparisonMode(site.domain, null);
    if (COMPARISON_DISABLED_PERIODS.includes(period) || !isComparisonEnabled(comparison)) comparison = null;
    let matchDayOfWeek = (_b2 = getValue("match_day_of_week")) != null ? _b2 : getStoredMatchDayOfWeek(site.domain, true);
    return {
      period,
      comparison,
      compare_from: getValue("compare_from") ? import_dayjs2.default.utc(getValue("compare_from")) : void 0,
      compare_to: getValue("compare_to") ? import_dayjs2.default.utc(getValue("compare_to")) : void 0,
      date: getValue("date") ? import_dayjs2.default.utc(getValue("date")) : nowForSite(site),
      from: getValue("from") ? import_dayjs2.default.utc(getValue("from")) : void 0,
      to: getValue("to") ? import_dayjs2.default.utc(getValue("to")) : void 0,
      match_day_of_week: matchDayOfWeek === true,
      with_imported: (_c = getValue("with_imported")) != null ? _c : true,
      filters: getValue("filters") || [],
      labels: getValue("labels") || {}
    };
  }
  function addFilter(query, filter) {
    return __spreadProps(__spreadValues({}, query), { filters: [...query.filters, filter] });
  }
  function navigateToQuery(navigate, { period }, newPartialSearchRecord) {
    if (newPartialSearchRecord.period && newPartialSearchRecord.period !== period) {
      navigate({ search: (search) => __spreadProps(__spreadValues({}, search), { period }), replace: true });
    }
    navigate({ search: (search) => __spreadValues(__spreadValues({}, search), newPartialSearchRecord) });
  }
  var LEGACY_URL_PARAMETERS = {
    "goal": null,
    "source": null,
    "utm_medium": null,
    "utm_source": null,
    "utm_campaign": null,
    "utm_content": null,
    "utm_term": null,
    "referrer": null,
    "screen": null,
    "browser": null,
    "browser_version": null,
    "os": null,
    "os_version": null,
    "country": "country_labels",
    "region": "region_labels",
    "city": "city_labels",
    "page": null,
    "hostname": null,
    "entry_page": null,
    "exit_page": null
  };
  function filtersBackwardsCompatibilityRedirect(windowLocation) {
    const searchRecord = parseSearch(windowLocation.search);
    const getValue = (k) => searchRecord[k];
    if (getValue("filters")) {
      return;
    }
    const changedSearchRecordEntries = [];
    let filters = [];
    let labels = {};
    for (const [key, value] of Object.entries(searchRecord)) {
      if (LEGACY_URL_PARAMETERS.hasOwnProperty(key)) {
        const filter = parseLegacyFilter(key, value);
        filters.push(filter);
        const labelsKey = LEGACY_URL_PARAMETERS[key];
        if (labelsKey && getValue(labelsKey)) {
          const clauses = filter[2];
          const labelsValues = getValue(labelsKey).split("|").filter((label) => !!label);
          const newLabels = Object.fromEntries(clauses.map((clause, index2) => [clause, labelsValues[index2]]));
          labels = Object.assign(labels, newLabels);
        }
      } else {
        changedSearchRecordEntries.push([key, value]);
      }
    }
    if (getValue("props")) {
      filters.push(...parseLegacyPropsFilter(getValue("props")));
    }
    if (filters.length > 0) {
      changedSearchRecordEntries.push([["filters", filters], ["labels", labels]]);
      history.pushState({}, null, `${windowLocation.pathname}${stringifySearch(Object.fromEntries(changedSearchRecordEntries))}`);
    }
  }
  function revenueAvailable(query, site) {
    const revenueGoalsInFilter = site.revenueGoals.filter((rg) => {
      const goalFilters = getFiltersByKeyPrefix(query, "goal");
      return goalFilters.some(([_op, _key, clauses]) => {
        return clauses.includes(rg.event_name);
      });
    });
    const singleCurrency = revenueGoalsInFilter.every((rg) => {
      return rg.currency === revenueGoalsInFilter[0].currency;
    });
    return revenueGoalsInFilter.length > 0 && singleCurrency;
  }
  function QueryLink({ to: to2, search, className, children, onClick }) {
    const navigate = useNavigate();
    const { query } = useQueryContext();
    const handleClick = (0, import_react25.useCallback)((e3) => {
      e3.preventDefault();
      navigateToQuery(navigate, query, search);
      if (onClick) {
        onClick(e3);
      }
    }, [navigate, onClick, query, search]);
    return /* @__PURE__ */ import_react25.default.createElement(
      Link,
      {
        to: to2,
        search: (currentSearch) => __spreadValues(__spreadValues({}, currentSearch), search),
        className,
        onClick: handleClick
      },
      children
    );
  }
  function QueryButton({ search, disabled, className, children, onClick }) {
    const navigate = useNavigate();
    const { query } = useQueryContext();
    const handleClick = (0, import_react25.useCallback)((e3) => {
      e3.preventDefault();
      navigateToQuery(navigate, query, search);
      if (onClick) {
        onClick(e3);
      }
    }, [navigate, onClick, query, search]);
    return /* @__PURE__ */ import_react25.default.createElement(
      "button",
      {
        className,
        onClick: handleClick,
        type: "button",
        disabled
      },
      children
    );
  }

  // js/dashboard/keybinding.js
  function shouldIgnoreKeypress(event) {
    const modifierPressed = event.ctrlKey || event.metaKey || event.altKey || event.keyCode == 229;
    const isTyping = event.isComposing || event.target.tagName == "INPUT" || event.target.tagName == "TEXTAREA";
    return modifierPressed || isTyping;
  }
  function isKeyPressed(event, keybinding) {
    const keyPressed = event.key.toLowerCase() == keybinding.toLowerCase();
    return keyPressed && !shouldIgnoreKeypress(event);
  }

  // js/dashboard/datepicker.js
  var import_classnames2 = __toESM(require_classnames());
  function KeyBindHint({ children }) {
    return /* @__PURE__ */ import_react26.default.createElement("kbd", { className: "rounded border border-gray-200 px-2 font-mono font-normal text-xs text-gray-400" }, children);
  }
  function renderArrow(query, site, period, prevDate, nextDate) {
    const insertionDate = parseUTCDate(site.statsBegin);
    const disabledLeft = isBefore(
      parseUTCDate(prevDate),
      insertionDate,
      period
    );
    const disabledRight = isAfter(
      parseUTCDate(nextDate),
      nowForSite(site),
      period
    );
    const isComparing = isComparisonEnabled(query.comparison);
    const leftClass = (0, import_classnames2.default)("flex items-center px-1 sm:px-2 border-r border-gray-300 rounded-l dark:border-gray-500 dark:text-gray-100", {
      "bg-gray-300 dark:bg-gray-950": disabledLeft,
      "hover:bg-gray-100 dark:hover:bg-gray-900": !disabledLeft
    });
    const rightClass = (0, import_classnames2.default)("flex items-center px-1 sm:px-2 rounded-r dark:text-gray-100", {
      "bg-gray-300 dark:bg-gray-950": disabledRight,
      "hover:bg-gray-100 dark:hover:bg-gray-900": !disabledRight
    });
    const containerClass = (0, import_classnames2.default)("rounded shadow bg-white mr-2 sm:mr-4 cursor-pointer dark:bg-gray-800", {
      "hidden md:flex": isComparing,
      "flex": !isComparing
    });
    return /* @__PURE__ */ import_react26.default.createElement("div", { className: containerClass }, /* @__PURE__ */ import_react26.default.createElement(
      QueryButton,
      {
        search: { date: prevDate },
        className: leftClass,
        disabled: disabledLeft
      },
      /* @__PURE__ */ import_react26.default.createElement(
        "svg",
        {
          className: "feather h-4 w-4",
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        },
        /* @__PURE__ */ import_react26.default.createElement("polyline", { points: "15 18 9 12 15 6" })
      )
    ), /* @__PURE__ */ import_react26.default.createElement(
      QueryButton,
      {
        search: { date: nextDate },
        className: rightClass,
        disabled: disabledRight
      },
      /* @__PURE__ */ import_react26.default.createElement(
        "svg",
        {
          className: "feather h-4 w-4",
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        },
        /* @__PURE__ */ import_react26.default.createElement("polyline", { points: "9 18 15 12 9 6" })
      )
    ));
  }
  function DatePickerArrows() {
    const { query } = useQueryContext();
    const site = useSiteContext();
    if (query.period === "year") {
      const prevDate = formatISO(shiftMonths(query.date, -12));
      const nextDate = formatISO(shiftMonths(query.date, 12));
      return renderArrow(query, site, "year", prevDate, nextDate);
    } else if (query.period === "month") {
      const prevDate = formatISO(shiftMonths(query.date, -1));
      const nextDate = formatISO(shiftMonths(query.date, 1));
      return renderArrow(query, site, "month", prevDate, nextDate);
    } else if (query.period === "day") {
      const prevDate = formatISO(shiftDays(query.date, -1));
      const nextDate = formatISO(shiftDays(query.date, 1));
      return renderArrow(query, site, "day", prevDate, nextDate);
    }
    return null;
  }
  function DisplayPeriod() {
    const { query } = useQueryContext();
    const site = useSiteContext();
    if (query.period === "day") {
      if (isToday(site, query.date)) {
        return "Today";
      }
      return formatDay(query.date);
    }
    if (query.period === "7d") {
      return "Last 7 days";
    }
    if (query.period === "30d") {
      return "Last 30 days";
    }
    if (query.period === "month") {
      if (isThisMonth(site, query.date)) {
        return "Month to Date";
      }
      return formatMonthYYYY(query.date);
    }
    if (query.period === "6mo") {
      return "Last 6 months";
    }
    if (query.period === "12mo") {
      return "Last 12 months";
    }
    if (query.period === "year") {
      if (isThisYear(site, query.date)) {
        return "Year to Date";
      }
      return formatYear(query.date);
    }
    if (query.period === "all") {
      return "All time";
    }
    if (query.period === "custom") {
      return formatDateRange(site, query.from, query.to);
    }
    return "Realtime";
  }
  function DatePicker() {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const [open, setOpen] = (0, import_react26.useState)(false);
    const [mode, setMode] = (0, import_react26.useState)("menu");
    const dropDownNode = (0, import_react26.useRef)(null);
    const calendar = (0, import_react26.useRef)(null);
    const navigate = useNavigate();
    const handleKeydown = (0, import_react26.useCallback)((e3) => {
      if (shouldIgnoreKeypress(e3)) return true;
      const newSearch = {
        period: null,
        from: null,
        to: null,
        date: null
      };
      const insertionDate = parseUTCDate(site.statsBegin);
      if (e3.key === "ArrowLeft") {
        const prevDate = formatISO(shiftDays(query.date, -1));
        const prevMonth = formatISO(shiftMonths(query.date, -1));
        const prevYear = formatISO(shiftMonths(query.date, -12));
        if (query.period === "day" && !isBefore(parseUTCDate(prevDate), insertionDate, query.period)) {
          newSearch.period = "day";
          newSearch.date = prevDate;
        } else if (query.period === "month" && !isBefore(parseUTCDate(prevMonth), insertionDate, query.period)) {
          newSearch.period = "month";
          newSearch.date = prevMonth;
        } else if (query.period === "year" && !isBefore(parseUTCDate(prevYear), insertionDate, query.period)) {
          newSearch.period = "year";
          newSearch.date = prevYear;
        }
      } else if (e3.key === "ArrowRight") {
        const now = nowForSite(site);
        const nextDate = formatISO(shiftDays(query.date, 1));
        const nextMonth = formatISO(shiftMonths(query.date, 1));
        const nextYear = formatISO(shiftMonths(query.date, 12));
        if (query.period === "day" && !isAfter(parseUTCDate(nextDate), now, query.period)) {
          newSearch.period = "day";
          newSearch.date = nextDate;
        } else if (query.period === "month" && !isAfter(parseUTCDate(nextMonth), now, query.period)) {
          newSearch.period = "month";
          newSearch.date = nextMonth;
        } else if (query.period === "year" && !isAfter(parseUTCDate(nextYear), now, query.period)) {
          newSearch.period = "year";
          newSearch.date = nextYear;
        }
      }
      setOpen(false);
      const keybindings = {
        d: { date: null, period: "day" },
        e: { date: formatISO(shiftDays(nowForSite(site), -1)), period: "day" },
        r: { period: "realtime" },
        w: { date: null, period: "7d" },
        m: { date: null, period: "month" },
        y: { date: null, period: "year" },
        t: { date: null, period: "30d" },
        s: { date: null, period: "6mo" },
        l: { date: null, period: "12mo" },
        a: { date: null, period: "all" }
      };
      const redirect = keybindings[e3.key.toLowerCase()];
      if (redirect) {
        navigateToQuery(navigate, query, __spreadProps(__spreadValues(__spreadValues({}, newSearch), redirect), { keybindHint: e3.key.toUpperCase() }));
      } else if (e3.key.toLowerCase() === "x") {
        toggleComparisons(navigate, query, site);
      } else if (e3.key.toLowerCase() === "c") {
        setOpen(true);
        setMode("calendar");
      } else if (newSearch.date) {
        navigateToQuery(navigate, query, newSearch);
      }
    }, [query]);
    const handleClick = (0, import_react26.useCallback)((e3) => {
      if (dropDownNode.current && dropDownNode.current.contains(e3.target)) return;
      setOpen(false);
    });
    (0, import_react26.useEffect)(() => {
      if (mode === "calendar" && open) {
        openCalendar();
      }
    }, [mode]);
    (0, import_react26.useEffect)(() => {
      document.addEventListener("keydown", handleKeydown);
      return () => {
        document.removeEventListener("keydown", handleKeydown);
      };
    }, [handleKeydown]);
    (0, import_react26.useEffect)(() => {
      document.addEventListener("mousedown", handleClick, false);
      return () => {
        document.removeEventListener("mousedown", handleClick, false);
      };
    }, []);
    function setCustomDate([from2, to2], _dateStr, _instance) {
      if (from2 && to2) {
        [from2, to2] = [parseNaiveDate(from2), parseNaiveDate(to2)];
        if (from2.isSame(to2)) {
          navigateToQuery(navigate, query, { period: "day", date: formatISO(from2), from: null, to: null });
        } else {
          navigateToQuery(navigate, query, { period: "custom", date: null, from: formatISO(from2), to: formatISO(to2) });
        }
      }
      setOpen(false);
    }
    function toggle() {
      const newMode = mode === "calendar" && !open ? "menu" : mode;
      setOpen(!open);
      setMode(newMode);
    }
    function openCalendar() {
      calendar.current && calendar.current.flatpickr.open();
    }
    function renderLink(period, text, opts = {}) {
      let boldClass;
      if (query.period === "day" && period === "day") {
        boldClass = isSameDate(opts.date, query.date) ? "font-bold" : "";
      } else if (query.period === "month" && period === "month") {
        const linkDate = opts.date || nowForSite(site);
        boldClass = isSameMonth(linkDate, query.date) ? "font-bold" : "";
      } else {
        boldClass = query.period === period ? "font-bold" : "";
      }
      opts.date = opts.date ? formatISO(opts.date) : null;
      return /* @__PURE__ */ import_react26.default.createElement(
        QueryLink,
        {
          search: __spreadValues({ from: null, to: null, period }, opts),
          onClick: () => setOpen(false),
          className: `${boldClass} px-4 py-2 text-sm leading-tight hover:bg-gray-100 hover:text-gray-900
          dark:hover:bg-gray-900 dark:hover:text-gray-100 flex items-center justify-between`
        },
        text,
        opts.keybindHint ? /* @__PURE__ */ import_react26.default.createElement(KeyBindHint, null, opts.keybindHint) : null
      );
    }
    function renderDropDownContent() {
      if (mode === "menu") {
        return /* @__PURE__ */ import_react26.default.createElement(
          "div",
          {
            id: "datemenu",
            className: "absolute w-full left-0 right-0 md:w-56 md:absolute md:top-auto md:left-auto md:right-0 mt-2 origin-top-right z-10"
          },
          /* @__PURE__ */ import_react26.default.createElement(
            "div",
            {
              className: "rounded-md shadow-lg  bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5\n            font-medium text-gray-800 dark:text-gray-200 date-options"
            },
            /* @__PURE__ */ import_react26.default.createElement("div", { className: "py-1 border-b border-gray-200 dark:border-gray-500 date-option-group" }, renderLink("day", "Today", { keybindHint: "D", date: nowForSite(site) }), renderLink("day", "Yesterday", { keybindHint: "E", date: yesterday(site) }), renderLink("realtime", "Realtime", { keybindHint: "R" })),
            /* @__PURE__ */ import_react26.default.createElement("div", { className: "py-1 border-b border-gray-200 dark:border-gray-500 date-option-group" }, renderLink("7d", "Last 7 Days", { keybindHint: "W" }), renderLink("30d", "Last 30 Days", { keybindHint: "T" })),
            /* @__PURE__ */ import_react26.default.createElement("div", { className: "py-1 border-b border-gray-200 dark:border-gray-500 date-option-group" }, renderLink("month", "Month to Date", { keybindHint: "M" }), renderLink("month", "Last Month", { date: lastMonth(site) })),
            /* @__PURE__ */ import_react26.default.createElement("div", { className: "py-1 border-b border-gray-200 dark:border-gray-500 date-option-group" }, renderLink("year", "Year to Date", { keybindHint: "Y" }), renderLink("12mo", "Last 12 months", { keybindHint: "L" })),
            /* @__PURE__ */ import_react26.default.createElement("div", { className: "py-1 date-option-group" }, renderLink("all", "All time", { keybindHint: "A" }), /* @__PURE__ */ import_react26.default.createElement(
              "span",
              {
                onClick: () => setMode("calendar"),
                onKeyPress: () => setMode("calendar"),
                className: "px-4 py-2 text-sm leading-tight hover:bg-gray-100\n                  dark:hover:bg-gray-900 hover:text-gray-900 dark:hover:text-gray-100\n                  cursor-pointer flex items-center justify-between",
                tabIndex: "0",
                role: "button",
                "aria-haspopup": "true",
                "aria-expanded": "false",
                "aria-controls": "calendar"
              },
              "Custom Range",
              /* @__PURE__ */ import_react26.default.createElement(KeyBindHint, null, "C")
            )),
            !COMPARISON_DISABLED_PERIODS.includes(query.period) && /* @__PURE__ */ import_react26.default.createElement("div", { className: "py-1 date-option-group border-t border-gray-200 dark:border-gray-500" }, /* @__PURE__ */ import_react26.default.createElement(
              "span",
              {
                onClick: () => {
                  toggleComparisons(navigate, query, site);
                  setOpen(false);
                },
                className: "px-4 py-2 text-sm leading-tight hover:bg-gray-100 dark:hover:bg-gray-900 hover:text-gray-900 dark:hover:text-gray-100 cursor-pointer flex items-center justify-between"
              },
              isComparisonEnabled(query.comparison) ? "Disable comparison" : "Compare",
              /* @__PURE__ */ import_react26.default.createElement(KeyBindHint, null, "X")
            ))
          )
        );
      }
      if (mode === "calendar") {
        return /* @__PURE__ */ import_react26.default.createElement("div", { className: "h-0" }, /* @__PURE__ */ import_react26.default.createElement(
          import_react_flatpickr2.default,
          {
            id: "calendar",
            options: {
              mode: "range",
              maxDate: "today",
              minDate: site.statsBegin,
              showMonths: 1,
              static: true,
              animate: true
            },
            ref: calendar,
            className: "invisible",
            onClose: setCustomDate
          }
        ));
      }
    }
    function renderPicker() {
      return /* @__PURE__ */ import_react26.default.createElement(
        "div",
        {
          className: "min-w-32 md:w-48 md:relative",
          ref: dropDownNode
        },
        /* @__PURE__ */ import_react26.default.createElement(
          "div",
          {
            onClick: toggle,
            className: "flex items-center justify-between rounded bg-white dark:bg-gray-800 shadow px-2 md:px-3\n          py-2 leading-tight cursor-pointer text-xs md:text-sm text-gray-800\n          dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-900",
            tabIndex: "0",
            role: "button",
            "aria-haspopup": "true",
            "aria-expanded": "false",
            "aria-controls": "datemenu"
          },
          /* @__PURE__ */ import_react26.default.createElement("span", { className: "truncate mr-1 md:mr-2" }, /* @__PURE__ */ import_react26.default.createElement("span", { className: "font-medium" }, /* @__PURE__ */ import_react26.default.createElement(DisplayPeriod, null))),
          /* @__PURE__ */ import_react26.default.createElement(ChevronDownIcon_default, { className: "hidden sm:inline-block h-4 w-4 md:h-5 md:w-5 text-gray-500" })
        ),
        /* @__PURE__ */ import_react26.default.createElement(
          Ke,
          {
            show: open,
            as: import_react26.Fragment,
            enter: "transition ease-out duration-100",
            enterFrom: "opacity-0 scale-95",
            enterTo: "opacity-100 scale-100",
            leave: "transition ease-in duration-75",
            leaveFrom: "opacity-100 scale-100",
            leaveTo: "opacity-0 scale-95"
          },
          renderDropDownContent()
        )
      );
    }
    return /* @__PURE__ */ import_react26.default.createElement("div", { className: "flex ml-auto pl-2" }, /* @__PURE__ */ import_react26.default.createElement(DatePickerArrows, null), renderPicker());
  }
  var datepicker_default = DatePicker;

  // js/dashboard/site-switcher.js
  var import_react28 = __toESM(require_react());
  function Favicon({ domain, className }) {
    return /* @__PURE__ */ import_react28.default.createElement(
      "img",
      {
        src: `/favicon/sources/${encodeURIComponent(domain)}`,
        onError: (e3) => {
          e3.target.onerror = null;
          e3.target.src = "/favicon/sources/placeholder";
        },
        referrerPolicy: "no-referrer",
        className
      }
    );
  }
  var SiteSwitcher = class extends import_react28.default.Component {
    constructor() {
      super();
      this.handleClick = this.handleClick.bind(this);
      this.handleKeydown = this.handleKeydown.bind(this);
      this.populateSites = this.populateSites.bind(this);
      this.toggle = this.toggle.bind(this);
      this.siteSwitcherButton = import_react28.default.createRef();
      this.state = {
        open: false,
        sites: null,
        error: null,
        loading: true
      };
    }
    componentDidMount() {
      this.populateSites();
      this.siteSwitcherButton.current.addEventListener("click", this.toggle);
      document.addEventListener("keydown", this.handleKeydown);
      document.addEventListener("click", this.handleClick, false);
    }
    componentWillUnmount() {
      this.siteSwitcherButton.current.removeEventListener("click", this.toggle);
      document.removeEventListener("keydown", this.handleKeydown);
      document.removeEventListener("click", this.handleClick, false);
    }
    populateSites() {
      if (!this.props.loggedIn) return;
      fetch("/api/sites").then((response) => {
        if (!response.ok) {
          throw response;
        }
        return response.json();
      }).then(
        (sites) => this.setState({
          loading: false,
          sites: sites.data.map((s7) => s7.domain)
        })
      ).catch((e3) => this.setState({ loading: false, error: e3 }));
    }
    handleClick(e3) {
      if (this.dropDownNode && this.dropDownNode.contains(e3.target)) return;
      if (!this.state.open) return;
      this.setState({ open: false });
    }
    handleKeydown(e3) {
      if (!this.props.loggedIn) return;
      const { site } = this.props;
      const { sites } = this.state;
      if (e3.target.tagName === "INPUT") return true;
      if (e3.ctrlKey || e3.metaKey || e3.altKey || e3.isComposing || e3.keyCode === 229 || !sites)
        return;
      const siteNum = parseInt(e3.key);
      if (1 <= siteNum && siteNum <= 9 && siteNum <= sites.length && sites[siteNum - 1] !== site.domain) {
        window.location = `/${encodeURIComponent(sites[siteNum - 1])}`;
      }
    }
    toggle(e3) {
      e3.stopPropagation();
      e3.preventDefault();
      if (!this.props.loggedIn) return;
      this.setState((prevState) => ({
        open: !prevState.open
      }));
      if (this.props.loggedIn && !this.state.sites) {
        this.populateSites();
      }
    }
    renderSiteLink(domain, index2) {
      const extraClass = domain === this.props.site.domain ? "font-medium text-gray-900 dark:text-gray-100 cursor-default font-bold" : "hover:bg-gray-100 dark:hover:bg-gray-900 hover:text-gray-900 dark:hover:text-gray-100 focus:outline-none focus:bg-gray-100 dark:focus:bg-gray-900 focus:text-gray-900 dark:focus:text-gray-100";
      const showHotkey = this.props.loggedIn && this.state.sites.length > 1;
      return /* @__PURE__ */ import_react28.default.createElement(
        "a",
        {
          href: domain === this.props.site.domain ? null : `/${encodeURIComponent(domain)}`,
          key: domain,
          className: `flex items-center justify-between truncate px-4 py-2 md:text-sm leading-5 text-gray-700 dark:text-gray-300 ${extraClass}`
        },
        /* @__PURE__ */ import_react28.default.createElement("span", null, /* @__PURE__ */ import_react28.default.createElement(
          Favicon,
          {
            domain,
            className: "inline w-4 mr-2 align-middle"
          }
        ), /* @__PURE__ */ import_react28.default.createElement("span", { className: "truncate inline-block align-middle max-w-3xs pr-2" }, domain)),
        showHotkey && index2 < 9 ? /* @__PURE__ */ import_react28.default.createElement("span", null, index2 + 1) : null
      );
    }
    renderSettingsLink() {
      if (["owner", "admin", "super_admin"].includes(this.props.currentUserRole)) {
        return /* @__PURE__ */ import_react28.default.createElement(import_react28.default.Fragment, null, /* @__PURE__ */ import_react28.default.createElement("div", { className: "py-1" }, /* @__PURE__ */ import_react28.default.createElement(
          "a",
          {
            href: `/${encodeURIComponent(
              this.props.site.domain
            )}/settings/general`,
            className: "group flex items-center px-4 py-2 md:text-sm leading-5 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-900 hover:text-gray-900 dark:hover:text-gray-100 focus:outline-none focus:bg-gray-100 dark:focus:bg-gray-900 focus:text-gray-900 dark:focus:text-gray-100",
            role: "menuitem"
          },
          /* @__PURE__ */ import_react28.default.createElement(Cog8ToothIcon_default, { className: "mr-2 h-4 w-4 text-gray-500 dark:text-gray-200 group-hover:text-gray-600 dark:group-hover:text-gray-400 group-focus:text-gray-500 dark:group-focus:text-gray-200" }),
          "Site Settings"
        )), /* @__PURE__ */ import_react28.default.createElement("div", { className: "border-t border-gray-200 dark:border-gray-500" }));
      }
    }
    /**
     * Render a dropdown regardless of whether the user is logged in or not. In case they are not logged in (such as in an embed), the dropdown merely contains the current domain name.
     */
    renderDropdown() {
      if (this.state.loading) {
        return /* @__PURE__ */ import_react28.default.createElement("div", { className: "px-4 py-6" }, /* @__PURE__ */ import_react28.default.createElement("div", { className: "loading sm mx-auto" }, /* @__PURE__ */ import_react28.default.createElement("div", null)));
      } else if (this.state.error) {
        return /* @__PURE__ */ import_react28.default.createElement("div", { className: "mx-auto px-4 py-6 dark:text-gray-100" }, "Something went wrong, try again");
      } else if (!this.props.loggedIn) {
        return /* @__PURE__ */ import_react28.default.createElement(import_react28.default.Fragment, null, /* @__PURE__ */ import_react28.default.createElement("div", { className: "py-1" }, [this.props.site.domain].map(this.renderSiteLink.bind(this))));
      } else {
        return /* @__PURE__ */ import_react28.default.createElement(import_react28.default.Fragment, null, this.renderSettingsLink(), /* @__PURE__ */ import_react28.default.createElement("div", { className: "py-1" }, this.state.sites.map(this.renderSiteLink.bind(this))), /* @__PURE__ */ import_react28.default.createElement("div", { className: "border-t border-gray-200 dark:border-gray-500" }), /* @__PURE__ */ import_react28.default.createElement(
          "a",
          {
            href: "/sites",
            className: "flex px-4 py-2 md:text-sm leading-5 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-900 hover:text-gray-900 dark:hover:text-gray-100 focus:outline-none focus:bg-gray-100 dark:focus:bg-gray-900 focus:text-gray-900 dark:focus:text-gray-100",
            role: "menuitem"
          },
          "View All"
        ));
      }
    }
    render() {
      const hoverClass = this.props.loggedIn ? "hover:text-gray-500 dark:hover:text-gray-200 focus:border-blue-300 focus:ring " : "cursor-default";
      return /* @__PURE__ */ import_react28.default.createElement("div", { className: "relative inline-block text-left mr-2 sm:mr-4" }, /* @__PURE__ */ import_react28.default.createElement(
        "button",
        {
          ref: this.siteSwitcherButton,
          className: `inline-flex items-center md:text-lg w-full rounded-md py-2 leading-5 font-bold text-gray-700 dark:text-gray-300 focus:outline-none transition ease-in-out duration-150 ${hoverClass}`
        },
        /* @__PURE__ */ import_react28.default.createElement(
          Favicon,
          {
            domain: this.props.site.domain,
            className: "w-4 mr-1 md:mr-2 align-middle w-4 mr-2 align-middle"
          }
        ),
        /* @__PURE__ */ import_react28.default.createElement("span", { className: "hidden sm:inline-block" }, this.props.site.domain),
        this.props.loggedIn && /* @__PURE__ */ import_react28.default.createElement(ChevronDownIcon_default, { className: "-mr-1 ml-1 md:ml-2 h-5 w-5" })
      ), /* @__PURE__ */ import_react28.default.createElement(
        Ke,
        {
          show: this.state.open,
          enter: "transition ease-out duration-100",
          enterFrom: "opacity-0 scale-95",
          enterTo: "opacity-100 scale-100",
          leave: "transition ease-in duration-75",
          leaveFrom: "opacity-100 scale-100",
          leaveTo: "opacity-0 scale-95"
        },
        /* @__PURE__ */ import_react28.default.createElement(
          "div",
          {
            className: "origin-top-left absolute left-0 mt-2 w-64 rounded-md shadow-lg",
            ref: (node) => this.dropDownNode = node
          },
          /* @__PURE__ */ import_react28.default.createElement("div", { className: "rounded-md bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5" }, this.renderDropdown())
        )
      ));
    }
  };

  // js/dashboard/filters.js
  var import_react30 = __toESM(require_react());
  var import_classnames3 = __toESM(require_classnames());
  var WRAPSTATE = { unwrapped: 0, waiting: 1, wrapped: 2 };
  function removeFilter(filterIndex, navigate, query) {
    const newFilters = query.filters.filter((_filter, index2) => filterIndex != index2);
    const newLabels = cleanLabels(newFilters, query.labels);
    navigateToQuery(
      navigate,
      query,
      { filters: newFilters, labels: newLabels }
    );
  }
  function clearAllFilters(navigate, query) {
    navigateToQuery(
      navigate,
      query,
      { filters: null, labels: null }
    );
  }
  function filterText(query, [operation, filterKey, clauses]) {
    const formattedFilter = formattedFilters[filterKey];
    if (formattedFilter) {
      return /* @__PURE__ */ import_react30.default.createElement(import_react30.default.Fragment, null, formattedFilter, " ", FILTER_OPERATIONS_DISPLAY_NAMES[operation], " ", clauses.map((value) => /* @__PURE__ */ import_react30.default.createElement("b", { key: value }, getLabel(query.labels, filterKey, value))).reduce((prev, curr) => [prev, " or ", curr]), " ");
    } else if (filterKey.startsWith(EVENT_PROPS_PREFIX)) {
      const propKey = getPropertyKeyFromFilterKey(filterKey);
      return /* @__PURE__ */ import_react30.default.createElement(import_react30.default.Fragment, null, "Property ", /* @__PURE__ */ import_react30.default.createElement("b", null, propKey), " ", FILTER_OPERATIONS_DISPLAY_NAMES[operation], " ", clauses.map((label) => /* @__PURE__ */ import_react30.default.createElement("b", { key: label }, label)).reduce((prev, curr) => [prev, " or ", curr]), " ");
    }
    throw new Error(`Unknown filter: ${filterKey}`);
  }
  function renderDropdownFilter(filterIndex, filter, navigate, query) {
    const [_operation, filterKey, _clauses] = filter;
    const type = filterKey.startsWith(EVENT_PROPS_PREFIX) ? "props" : filterKey;
    return /* @__PURE__ */ import_react30.default.createElement(Ze.Item, { key: filterIndex }, /* @__PURE__ */ import_react30.default.createElement("div", { className: "px-3 md:px-4 sm:py-2 py-3 text-sm leading-tight flex items-center justify-between", key: filterIndex }, /* @__PURE__ */ import_react30.default.createElement(
      Link,
      {
        title: `Edit filter: ${formattedFilters[type]}`,
        to: "filter/$field",
        params: { field: FILTER_GROUP_TO_MODAL_TYPE[type] },
        search: (search) => search,
        className: "group flex w-full justify-between items-center",
        style: { width: "calc(100% - 1.5rem)" }
      },
      /* @__PURE__ */ import_react30.default.createElement("span", { className: "inline-block w-full truncate" }, filterText(query, filter)),
      /* @__PURE__ */ import_react30.default.createElement(PencilSquareIcon_default, { className: "w-4 h-4 ml-1 cursor-pointer group-hover:text-indigo-700 dark:group-hover:text-indigo-500" })
    ), /* @__PURE__ */ import_react30.default.createElement(
      "b",
      {
        title: `Remove filter: ${formattedFilters[type]}`,
        className: "ml-2 cursor-pointer hover:text-indigo-700 dark:hover:text-indigo-500",
        onClick: () => removeFilter(filterIndex, navigate, query)
      },
      /* @__PURE__ */ import_react30.default.createElement(XMarkIcon_default, { className: "w-4 h-4" })
    )));
  }
  function filterDropdownOption(option) {
    return /* @__PURE__ */ import_react30.default.createElement(Ze.Item, { key: option }, ({ active }) => /* @__PURE__ */ import_react30.default.createElement(
      Link,
      {
        to: filterRoute.to,
        params: { field: option },
        search: (search) => search,
        className: (0, import_classnames3.default)(
          active ? "bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100" : "text-gray-800 dark:text-gray-300",
          "block px-4 py-2 text-sm font-medium"
        )
      },
      formatFilterGroup(option)
    ));
  }
  function DropdownContent({ wrapped }) {
    const navigate = useNavigate();
    const site = useSiteContext();
    const { query } = useQueryContext();
    const [addingFilter, setAddingFilter] = (0, import_react30.useState)(false);
    if (wrapped === WRAPSTATE.unwrapped || addingFilter) {
      let filterModals = __spreadValues({}, FILTER_MODAL_TO_FILTER_GROUP);
      if (!site.propsAvailable) delete filterModals.props;
      return Object.keys(filterModals).map((option) => filterDropdownOption(option));
    }
    return /* @__PURE__ */ import_react30.default.createElement(import_react30.default.Fragment, null, /* @__PURE__ */ import_react30.default.createElement("div", { className: "border-b border-gray-200 dark:border-gray-500 px-4 sm:py-2 py-3 text-sm leading-tight hover:text-indigo-700 dark:hover:text-indigo-500 hover:cursor-pointer", onClick: () => setAddingFilter(true) }, "+ Add filter"), query.filters.map((filter, index2) => renderDropdownFilter(index2, filter, navigate, query)), /* @__PURE__ */ import_react30.default.createElement(Ze.Item, { key: "clear" }, /* @__PURE__ */ import_react30.default.createElement("div", { className: "border-t border-gray-200 dark:border-gray-500 px-4 sm:py-2 py-3 text-sm leading-tight hover:text-indigo-700 dark:hover:text-indigo-500 hover:cursor-pointer", onClick: () => clearAllFilters(navigate, query) }, "Clear All Filters")));
  }
  function Filters() {
    const navigate = useNavigate();
    const { query } = useQueryContext();
    const [wrapped, setWrapped] = (0, import_react30.useState)(WRAPSTATE.waiting);
    const [viewport2, setViewport] = (0, import_react30.useState)(1080);
    (0, import_react30.useEffect)(() => {
      handleResize();
      window.addEventListener("resize", handleResize, false);
      document.addEventListener("keyup", handleKeyup);
      return () => {
        window.removeEventListener("resize", handleResize, false);
        document.removeEventListener("keyup", handleKeyup);
      };
    }, []);
    (0, import_react30.useEffect)(() => {
      setWrapped(WRAPSTATE.waiting);
    }, [query, viewport2]);
    (0, import_react30.useEffect)(() => {
      if (wrapped === WRAPSTATE.waiting) {
        updateDisplayMode();
      }
    }, [wrapped]);
    function handleKeyup(e3) {
      if (e3.ctrlKey || e3.metaKey || e3.altKey) return;
      if (e3.key === "Escape") {
        clearAllFilters(navigate, query);
      }
    }
    function handleResize() {
      setViewport(window.innerWidth || 639);
    }
    function updateDisplayMode() {
      const container2 = document.getElementById("filters");
      const children = container2 && [...container2.childNodes] || [];
      if (query.filters.length > 0 && viewport2 <= 768) {
        setWrapped(WRAPSTATE.wrapped);
        return;
      }
      setWrapped(WRAPSTATE.unwrapped);
      children.forEach((child) => {
        const currentChildY = child.getBoundingClientRect().top;
        const firstChildY = children[0].getBoundingClientRect().top;
        if (currentChildY !== firstChildY) {
          setWrapped(WRAPSTATE.wrapped);
        }
      });
    }
    function renderListFilter(filterIndex, filter) {
      const text = filterText(query, filter);
      const [_operation, filterKey, _clauses] = filter;
      const type = filterKey.startsWith(EVENT_PROPS_PREFIX) ? "props" : filterKey;
      return /* @__PURE__ */ import_react30.default.createElement("span", { key: filterIndex, className: "flex bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-300 shadow text-sm rounded mr-2 items-center" }, /* @__PURE__ */ import_react30.default.createElement(
        Link,
        {
          title: `Edit filter: ${formattedFilters[type]}`,
          className: "flex w-full h-full items-center py-2 pl-3",
          to: filterRoute.to,
          params: { field: FILTER_GROUP_TO_MODAL_TYPE[type] },
          search: (search) => search
        },
        /* @__PURE__ */ import_react30.default.createElement("span", { className: "inline-block max-w-2xs md:max-w-xs truncate" }, text)
      ), /* @__PURE__ */ import_react30.default.createElement(
        "span",
        {
          title: `Remove filter: ${formattedFilters[type]}`,
          className: "flex h-full w-full px-2 cursor-pointer hover:text-indigo-700 dark:hover:text-indigo-500 items-center",
          onClick: () => removeFilter(filterIndex, navigate, query)
        },
        /* @__PURE__ */ import_react30.default.createElement(XMarkIcon_default, { className: "w-4 h-4" })
      ));
    }
    function renderDropdownButton() {
      if (wrapped === WRAPSTATE.wrapped) {
        const filterCount = query.filters.length;
        return /* @__PURE__ */ import_react30.default.createElement(import_react30.default.Fragment, null, /* @__PURE__ */ import_react30.default.createElement(AdjustmentsVerticalIcon_default, { className: "-ml-1 mr-1 h-4 w-4", "aria-hidden": "true" }), filterCount, " Filter", filterCount === 1 ? "" : "s");
      }
      return /* @__PURE__ */ import_react30.default.createElement(import_react30.default.Fragment, null, /* @__PURE__ */ import_react30.default.createElement(MagnifyingGlassIcon_default, { className: "-ml-1 mr-1 h-4 w-4 md:h-4 md:w-4", "aria-hidden": "true" }), /* @__PURE__ */ import_react30.default.createElement("span", { className: "sm:hidden" }, "Filter"), /* @__PURE__ */ import_react30.default.createElement("span", { className: "hidden sm:inline-block" }, "Filter"));
    }
    function trackFilterMenu() {
      window.plausible && window.plausible("Filter Menu: Open", { u: `${window.location.protocol}//${window.location.hostname}/:dashboard` });
    }
    function renderDropDown() {
      return /* @__PURE__ */ import_react30.default.createElement(Ze, { as: "div", className: "md:relative ml-auto" }, ({ open }) => /* @__PURE__ */ import_react30.default.createElement(import_react30.default.Fragment, null, /* @__PURE__ */ import_react30.default.createElement("div", null, /* @__PURE__ */ import_react30.default.createElement(Ze.Button, { onClick: trackFilterMenu, className: "flex items-center text-xs md:text-sm font-medium leading-tight px-3 py-2 cursor-pointer ml-auto text-gray-500 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-900 rounded" }, renderDropdownButton())), /* @__PURE__ */ import_react30.default.createElement(
        Ke,
        {
          show: open,
          as: import_react30.Fragment,
          enter: "transition ease-out duration-100",
          enterFrom: "opacity-0 scale-95",
          enterTo: "opacity-100 scale-100",
          leave: "transition ease-in duration-75",
          leaveFrom: "opacity-100 scale-100",
          leaveTo: "opacity-0 scale-95"
        },
        /* @__PURE__ */ import_react30.default.createElement(
          Ze.Items,
          {
            static: true,
            className: "absolute w-full left-0 right-0 md:w-72 md:absolute md:top-auto md:left-auto md:right-0 mt-2 origin-top-right z-10"
          },
          /* @__PURE__ */ import_react30.default.createElement(
            "div",
            {
              className: "rounded-md shadow-lg  bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5\n                  font-medium text-gray-800 dark:text-gray-200"
            },
            /* @__PURE__ */ import_react30.default.createElement(DropdownContent, { wrapped })
          )
        )
      )));
    }
    function renderFilterList() {
      if (wrapped !== WRAPSTATE.wrapped) {
        return /* @__PURE__ */ import_react30.default.createElement("div", { id: "filters", className: "flex flex-wrap" }, query.filters.map((filter, index2) => renderListFilter(index2, filter)));
      }
      return null;
    }
    return /* @__PURE__ */ import_react30.default.createElement(import_react30.default.Fragment, null, renderFilterList(), renderDropDown());
  }
  var filters_default = Filters;

  // js/dashboard/stats/current-visitors.js
  var import_react34 = __toESM(require_react());

  // js/dashboard/util/tooltip.js
  var import_react32 = __toESM(require_react());

  // node_modules/react-popper/lib/esm/utils.js
  var React27 = __toESM(require_react());
  var fromEntries = function fromEntries2(entries) {
    return entries.reduce(function(acc, _ref) {
      var key = _ref[0], value = _ref[1];
      acc[key] = value;
      return acc;
    }, {});
  };
  var useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? React27.useLayoutEffect : React27.useEffect;

  // node_modules/react-popper/lib/esm/usePopper.js
  var React28 = __toESM(require_react());
  var ReactDOM = __toESM(require_react_dom());

  // node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  // node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }

  // node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x3 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width,
      height,
      top: y2,
      right: x3 + width,
      bottom: y2 + height,
      left: x3,
      x: x3,
      y: y2
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle2(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v3 = within(min2, value, max2);
    return v3 > max2 ? max2 : v3;
  }

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (true) {
      if (!isHTMLElement(arrowElement)) {
        console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      if (true) {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      }
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x3 = _ref.x, y2 = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x3 * dpr) / dpr || 0,
      y: round(y2 * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x3 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x: x3,
      y: y2
    }) : {
      x: x3,
      y: y2
    };
    x3 = _ref3.x;
    y2 = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y2 -= offsetY - popperRect.height;
        y2 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x3 -= offsetX - popperRect.width;
        x3 *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x3,
      y: y2
    }) : {
      x: x3,
      y: y2
    };
    x3 = _ref4.x;
    y2 = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x3 + "px, " + y2 + "px)" : "translate3d(" + x3 + "px, " + y2 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x3 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    if (true) {
      var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x3 = 0;
    var y2 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x3 = visualViewport.offsetLeft;
        y2 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x3 + getWindowScrollBarX(element),
      y: y2
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x3 = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y2 = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x3 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x: x3,
      y: y2
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
      if (true) {
        console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
      }
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a3, b2) {
      return overflows[a3] - overflows[b2];
    });
  }

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i5 = 0; i5 < placements2.length; i5++) {
      var placement = placements2[i5];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break") break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x3 = _data$state$placement.x, y2 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x3;
      state.modifiersData.popperOffsets.y += y2;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = offset2 + overflow[mainSide];
      var max2 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map3 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map3.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map3.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve2) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve2(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/@popperjs/core/lib/utils/format.js
  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p3, c3) {
      return p3.replace(/%s/, c3);
    }, str);
  }

  // node_modules/@popperjs/core/lib/utils/validateModifiers.js
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
      [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index2, self2) {
        return self2.indexOf(value) === index2;
      }).forEach(function(key) {
        switch (key) {
          case "name":
            if (typeof modifier.name !== "string") {
              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
            break;
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (modifier.effect != null && typeof modifier.effect !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (modifier.requires != null && !Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s7) {
              return '"' + s7 + '"';
            }).join(", ") + '; but "' + key + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }

  // node_modules/@popperjs/core/lib/utils/uniqueBy.js
  function uniqueBy(arr, fn2) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn2(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/@popperjs/core/lib/createPopper.js
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m5) {
            return m5.enabled;
          });
          if (true) {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name = _ref.name;
              return name;
            });
            validateModifiers(modifiers);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name = _ref2.name;
                return name === "flip";
              });
              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            if (true) {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
            if (true) {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index2 = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve2) {
            instance.forceUpdate();
            resolve2(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        if (true) {
          console.error(INVALID_ELEMENT_ERROR);
        }
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
          if (typeof effect4 === "function") {
            var cleanupFn = effect4({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/react-popper/lib/esm/usePopper.js
  var import_react_fast_compare = __toESM(require_react_fast_compare());
  var EMPTY_MODIFIERS = [];
  var usePopper = function usePopper2(referenceElement, popperElement, options) {
    if (options === void 0) {
      options = {};
    }
    var prevOptions = React28.useRef(null);
    var optionsWithDefaults = {
      onFirstUpdate: options.onFirstUpdate,
      placement: options.placement || "bottom",
      strategy: options.strategy || "absolute",
      modifiers: options.modifiers || EMPTY_MODIFIERS
    };
    var _React$useState = React28.useState({
      styles: {
        popper: {
          position: optionsWithDefaults.strategy,
          left: "0",
          top: "0"
        },
        arrow: {
          position: "absolute"
        }
      },
      attributes: {}
    }), state = _React$useState[0], setState = _React$useState[1];
    var updateStateModifier = React28.useMemo(function() {
      return {
        name: "updateState",
        enabled: true,
        phase: "write",
        fn: function fn2(_ref) {
          var state2 = _ref.state;
          var elements2 = Object.keys(state2.elements);
          ReactDOM.flushSync(function() {
            setState({
              styles: fromEntries(elements2.map(function(element) {
                return [element, state2.styles[element] || {}];
              })),
              attributes: fromEntries(elements2.map(function(element) {
                return [element, state2.attributes[element]];
              }))
            });
          });
        },
        requires: ["computeStyles"]
      };
    }, []);
    var popperOptions = React28.useMemo(function() {
      var newOptions = {
        onFirstUpdate: optionsWithDefaults.onFirstUpdate,
        placement: optionsWithDefaults.placement,
        strategy: optionsWithDefaults.strategy,
        modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
          name: "applyStyles",
          enabled: false
        }])
      };
      if ((0, import_react_fast_compare.default)(prevOptions.current, newOptions)) {
        return prevOptions.current || newOptions;
      } else {
        prevOptions.current = newOptions;
        return newOptions;
      }
    }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
    var popperInstanceRef = React28.useRef();
    useIsomorphicLayoutEffect(function() {
      if (popperInstanceRef.current) {
        popperInstanceRef.current.setOptions(popperOptions);
      }
    }, [popperOptions]);
    useIsomorphicLayoutEffect(function() {
      if (referenceElement == null || popperElement == null) {
        return;
      }
      var createPopper2 = options.createPopper || createPopper;
      var popperInstance = createPopper2(referenceElement, popperElement, popperOptions);
      popperInstanceRef.current = popperInstance;
      return function() {
        popperInstance.destroy();
        popperInstanceRef.current = null;
      };
    }, [referenceElement, popperElement, options.createPopper]);
    return {
      state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
      styles: state.styles,
      attributes: state.attributes,
      update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
      forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
    };
  };

  // js/dashboard/util/tooltip.js
  var import_classnames4 = __toESM(require_classnames());
  function Tooltip({ children, info, className, onClick, boundary }) {
    const [visible, setVisible] = (0, import_react32.useState)(false);
    const [referenceElement, setReferenceElement] = (0, import_react32.useState)(null);
    const [popperElement, setPopperElement] = (0, import_react32.useState)(null);
    const [arrowElement, setArrowElement] = (0, import_react32.useState)(null);
    const { styles, attributes } = usePopper(referenceElement, popperElement, {
      placement: "top",
      modifiers: [
        { name: "arrow", options: { element: arrowElement } },
        {
          name: "offset",
          options: {
            offset: [0, 4]
          }
        },
        boundary && {
          name: "preventOverflow",
          options: {
            boundary
          }
        }
      ]
    });
    return /* @__PURE__ */ import_react32.default.createElement("div", { className: (0, import_classnames4.default)("relative", className) }, /* @__PURE__ */ import_react32.default.createElement("div", { ref: setReferenceElement, onMouseEnter: () => setVisible(true), onMouseLeave: () => setVisible(false), onClick }, children), info && visible && /* @__PURE__ */ import_react32.default.createElement("div", __spreadProps(__spreadValues({ ref: setPopperElement, style: styles.popper }, attributes.popper), { className: "z-50 p-2 rounded text-sm text-gray-100 font-bold popper-tooltip", role: "tooltip" }), info, /* @__PURE__ */ import_react32.default.createElement("div", { ref: setArrowElement, style: styles.arrow, className: "tooltip-arrow" })));
  }

  // js/dashboard/util/seconds-since-last-load.js
  var import_react33 = __toESM(require_react());
  function SecondsSinceLastLoad({ lastLoadTimestamp }) {
    const [timeNow, setTimeNow] = (0, import_react33.useState)(/* @__PURE__ */ new Date());
    (0, import_react33.useEffect)(() => {
      const interval = setInterval(() => setTimeNow(/* @__PURE__ */ new Date()), 1e3);
      return () => clearInterval(interval);
    }, []);
    return Math.round(Math.abs(lastLoadTimestamp - timeNow) / 1e3);
  }

  // js/dashboard/stats/current-visitors.js
  function CurrentVisitors({ tooltipBoundary }) {
    const { query, lastLoadTimestamp } = useQueryContext();
    const site = useSiteContext();
    const [currentVisitors, setCurrentVisitors] = (0, import_react34.useState)(null);
    const updateCount = (0, import_react34.useCallback)(() => {
      get(`/api/stats/${encodeURIComponent(site.domain)}/current-visitors`).then((res) => setCurrentVisitors(res));
    }, [site.domain]);
    (0, import_react34.useEffect)(() => {
      document.addEventListener("tick", updateCount);
      return () => {
        document.removeEventListener("tick", updateCount);
      };
    }, [updateCount]);
    (0, import_react34.useEffect)(() => {
      updateCount();
    }, [query, updateCount]);
    function tooltipInfo() {
      return /* @__PURE__ */ import_react34.default.createElement("div", null, /* @__PURE__ */ import_react34.default.createElement("p", { className: "whitespace-nowrap text-small" }, "Last updated ", /* @__PURE__ */ import_react34.default.createElement(SecondsSinceLastLoad, { lastLoadTimestamp }), "s ago"), /* @__PURE__ */ import_react34.default.createElement("p", { className: "whitespace-nowrap font-normal text-xs" }, "Click to view realtime dashboard"));
    }
    if (currentVisitors !== null && query.filters.length === 0) {
      return /* @__PURE__ */ import_react34.default.createElement(Tooltip, { info: tooltipInfo(), boundary: tooltipBoundary }, /* @__PURE__ */ import_react34.default.createElement(Link, { search: (prev) => __spreadProps(__spreadValues({}, prev), { period: "realtime" }), className: "block ml-1 md:ml-2 mr-auto text-xs md:text-sm font-bold text-gray-500 dark:text-gray-300" }, /* @__PURE__ */ import_react34.default.createElement("svg", { className: "inline w-2 mr-1 md:mr-2 text-green-500 fill-current", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ import_react34.default.createElement("circle", { cx: "8", cy: "8", r: "8" })), currentVisitors, " ", /* @__PURE__ */ import_react34.default.createElement("span", { className: "hidden sm:inline-block" }, "current visitor", currentVisitors === 1 ? "" : "s")));
    } else {
      return null;
    }
  }

  // js/dashboard/stats/graph/visitor-graph.js
  var import_react43 = __toESM(require_react());

  // js/dashboard/util/number-formatter.js
  var THOUSAND = 1e3;
  var HUNDRED_THOUSAND = 1e5;
  var MILLION = 1e6;
  var HUNDRED_MILLION = 1e8;
  var BILLION = 1e9;
  var HUNDRED_BILLION = 1e11;
  var TRILLION = 1e12;
  function numberFormatter(num) {
    if (num >= THOUSAND && num < MILLION) {
      const thousands = num / THOUSAND;
      if (thousands === Math.floor(thousands) || num >= HUNDRED_THOUSAND) {
        return Math.floor(thousands) + "k";
      } else {
        return Math.floor(thousands * 10) / 10 + "k";
      }
    } else if (num >= MILLION && num < BILLION) {
      const millions = num / MILLION;
      if (millions === Math.floor(millions) || num >= HUNDRED_MILLION) {
        return Math.floor(millions) + "M";
      } else {
        return Math.floor(millions * 10) / 10 + "M";
      }
    } else if (num >= BILLION && num < TRILLION) {
      const billions = num / BILLION;
      if (billions === Math.floor(billions) || num >= HUNDRED_BILLION) {
        return Math.floor(billions) + "B";
      } else {
        return Math.floor(billions * 10) / 10 + "B";
      }
    } else {
      return num;
    }
  }
  function pad(num, size) {
    return ("000" + num).slice(size * -1);
  }
  function durationFormatter(duration) {
    const hours = Math.floor(duration / 60 / 60);
    const minutes = Math.floor(duration / 60) % 60;
    const seconds = Math.floor(duration - minutes * 60 - hours * 60 * 60);
    if (hours > 0) {
      return `${hours}h ${minutes}m ${seconds}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${pad(seconds, 2)}s`;
    } else {
      return `${seconds}s`;
    }
  }
  function percentageFormatter(number) {
    if (typeof number === "number") {
      return number + "%";
    } else {
      return "-";
    }
  }

  // js/dashboard/stats/graph/graph-util.js
  function getGraphableMetrics(query, site) {
    const isRealtime = query.period === "realtime";
    const isGoalFilter = hasGoalFilter(query);
    const isPageFilter = getFiltersByKeyPrefix(query, "page").length > 0;
    if (isRealtime && isGoalFilter) {
      return ["visitors"];
    } else if (isRealtime) {
      return ["visitors", "pageviews"];
    } else if (isGoalFilter && revenueAvailable(query, site)) {
      return ["visitors", "events", "average_revenue", "total_revenue", "conversion_rate"];
    } else if (isGoalFilter) {
      return ["visitors", "events", "conversion_rate"];
    } else if (isPageFilter) {
      return ["visitors", "visits", "pageviews", "bounce_rate", "time_on_page"];
    } else {
      return ["visitors", "visits", "pageviews", "views_per_visit", "bounce_rate", "visit_duration"];
    }
  }
  var METRIC_LABELS = {
    "visitors": "Visitors",
    "pageviews": "Pageviews",
    "events": "Total Conversions",
    "views_per_visit": "Views per Visit",
    "visits": "Visits",
    "bounce_rate": "Bounce Rate",
    "visit_duration": "Visit Duration",
    "conversions": "Converted Visitors",
    "conversion_rate": "Conversion Rate",
    "average_revenue": "Average Revenue",
    "total_revenue": "Total Revenue"
  };
  var METRIC_FORMATTER = {
    "visitors": numberFormatter,
    "pageviews": numberFormatter,
    "events": numberFormatter,
    "visits": numberFormatter,
    "views_per_visit": (number) => number,
    "bounce_rate": (number) => `${number}%`,
    "visit_duration": durationFormatter,
    "conversions": numberFormatter,
    "conversion_rate": (number) => `${number}%`,
    "total_revenue": numberFormatter,
    "average_revenue": numberFormatter
  };
  var buildComparisonDataset = function(comparisonPlot) {
    if (!comparisonPlot) return [];
    return [{
      data: comparisonPlot,
      borderColor: "rgba(60,70,110,0.2)",
      pointBackgroundColor: "rgba(60,70,110,0.2)",
      pointHoverBackgroundColor: "rgba(60, 70, 110)",
      yAxisID: "yComparison"
    }];
  };
  var buildDashedDataset = function(plot, presentIndex) {
    if (!presentIndex) return [];
    const dashedPart = plot.slice(presentIndex - 1, presentIndex + 1);
    const dashedPlot = new Array(presentIndex - 1).concat(dashedPart);
    return [{
      data: dashedPlot,
      borderDash: [3, 3],
      borderColor: "rgba(101,116,205)",
      pointHoverBackgroundColor: "rgba(71, 87, 193)",
      yAxisID: "y"
    }];
  };
  var buildMainPlotDataset = function(plot, presentIndex) {
    const data = presentIndex ? plot.slice(0, presentIndex) : plot;
    return [{
      data,
      borderColor: "rgba(101,116,205)",
      pointBackgroundColor: "rgba(101,116,205)",
      pointHoverBackgroundColor: "rgba(71, 87, 193)",
      yAxisID: "y"
    }];
  };
  var buildDataSet = (plot, comparisonPlot, present_index, ctx, label) => {
    var gradient = ctx.createLinearGradient(0, 0, 0, 300);
    var prev_gradient = ctx.createLinearGradient(0, 0, 0, 300);
    gradient.addColorStop(0, "rgba(101,116,205, 0.2)");
    gradient.addColorStop(1, "rgba(101,116,205, 0)");
    prev_gradient.addColorStop(0, "rgba(101,116,205, 0.075)");
    prev_gradient.addColorStop(1, "rgba(101,116,205, 0)");
    const defaultOptions = { label, borderWidth: 3, pointBorderColor: "transparent", pointHoverRadius: 4, backgroundColor: gradient, fill: true };
    const dataset = [
      ...buildMainPlotDataset(plot, present_index),
      ...buildDashedDataset(plot, present_index),
      ...buildComparisonDataset(comparisonPlot)
    ];
    return dataset.map((item) => Object.assign(item, defaultOptions));
  };

  // js/dashboard/stats/graph/top-stats.js
  var import_react35 = __toESM(require_react());
  var import_classnames5 = __toESM(require_classnames());
  function Maybe({ condition, children }) {
    if (condition) {
      return children;
    } else {
      return null;
    }
  }
  function renderPercentageComparison(name, comparison, forceDarkBg = false) {
    const formattedComparison = numberFormatter(Math.abs(comparison));
    const defaultClassName = (0, import_classnames5.default)({
      "pl-2 text-xs dark:text-gray-100": !forceDarkBg,
      "pl-2 text-xs text-gray-100": forceDarkBg
    });
    const noChangeClassName = (0, import_classnames5.default)({
      "pl-2 text-xs text-gray-700 dark:text-gray-300": !forceDarkBg,
      "pl-2 text-xs text-gray-300": forceDarkBg
    });
    if (comparison > 0) {
      const color2 = name === "Bounce rate" ? "text-red-400" : "text-green-500";
      return /* @__PURE__ */ import_react35.default.createElement("span", { className: defaultClassName }, /* @__PURE__ */ import_react35.default.createElement("span", { className: color2 + " font-bold" }, "\u2191"), " ", formattedComparison, "%");
    } else if (comparison < 0) {
      const color2 = name === "Bounce rate" ? "text-green-500" : "text-red-400";
      return /* @__PURE__ */ import_react35.default.createElement("span", { className: defaultClassName }, /* @__PURE__ */ import_react35.default.createElement("span", { className: color2 + " font-bold" }, "\u2193"), " ", formattedComparison, "%");
    } else if (comparison === 0) {
      return /* @__PURE__ */ import_react35.default.createElement("span", { className: noChangeClassName }, "\u3030 0%");
    } else {
      return null;
    }
  }
  function topStatNumberShort(name, value) {
    if (["visit duration", "time on page"].includes(name.toLowerCase())) {
      return durationFormatter(value);
    } else if (["bounce rate", "conversion rate"].includes(name.toLowerCase())) {
      return value + "%";
    } else if (["average revenue", "total revenue"].includes(name.toLowerCase())) {
      return value == null ? void 0 : value.short;
    } else {
      return numberFormatter(value);
    }
  }
  function topStatNumberLong(name, value) {
    if (["visit duration", "time on page"].includes(name.toLowerCase())) {
      return durationFormatter(value);
    } else if (["bounce rate", "conversion rate"].includes(name.toLowerCase())) {
      return value + "%";
    } else if (["average revenue", "total revenue"].includes(name.toLowerCase())) {
      return value == null ? void 0 : value.long;
    } else {
      return (value || 0).toLocaleString();
    }
  }
  function TopStats({ data, onMetricUpdate, tooltipBoundary }) {
    const { query, lastLoadTimestamp } = useQueryContext();
    const site = useSiteContext();
    function tooltip(stat) {
      let statName = stat.name.toLowerCase();
      statName = stat.value === 1 ? statName.slice(0, -1) : statName;
      return /* @__PURE__ */ import_react35.default.createElement("div", null, query.comparison && /* @__PURE__ */ import_react35.default.createElement("div", { className: "whitespace-nowrap" }, topStatNumberLong(stat.name, stat.value), " vs. ", topStatNumberLong(stat.name, stat.comparison_value), " ", statName, /* @__PURE__ */ import_react35.default.createElement("span", { className: "ml-2" }, renderPercentageComparison(stat.name, stat.change, true))), !query.comparison && /* @__PURE__ */ import_react35.default.createElement("div", { className: "whitespace-nowrap" }, topStatNumberLong(stat.name, stat.value), " ", statName), stat.name === "Current visitors" && /* @__PURE__ */ import_react35.default.createElement("p", { className: "font-normal text-xs" }, "Last updated ", /* @__PURE__ */ import_react35.default.createElement(SecondsSinceLastLoad, { lastLoadTimestamp }), "s ago"));
    }
    function canMetricBeGraphed(stat) {
      const graphableMetrics = getGraphableMetrics(query, site);
      return stat.graph_metric && graphableMetrics.includes(stat.graph_metric);
    }
    function maybeUpdateMetric(stat) {
      if (canMetricBeGraphed(stat)) {
        setItem(`metric__${site.domain}`, stat.graph_metric);
        onMetricUpdate(stat.graph_metric);
      }
    }
    function blinkingDot() {
      return /* @__PURE__ */ import_react35.default.createElement("div", { key: "dot", className: "block pulsating-circle", style: { left: "125px", top: "52px" } });
    }
    function getStoredMetric() {
      return getItem(`metric__${site.domain}`);
    }
    function renderStatName(stat) {
      const isSelected = stat.graph_metric === getStoredMetric();
      const [statDisplayName, statExtraName] = stat.name.split(/(\(.+\))/g);
      const statDisplayNameClass = (0, import_classnames5.default)("text-xs font-bold tracking-wide text-gray-500 uppercase dark:text-gray-400 whitespace-nowrap flex w-content border-b", {
        "text-indigo-700 dark:text-indigo-500 border-indigo-700 dark:border-indigo-500": isSelected,
        "group-hover:text-indigo-700 dark:group-hover:text-indigo-500 border-transparent": !isSelected
      });
      return /* @__PURE__ */ import_react35.default.createElement("div", { className: statDisplayNameClass }, statDisplayName, statExtraName && /* @__PURE__ */ import_react35.default.createElement("span", { className: "hidden sm:inline-block ml-1" }, statExtraName));
    }
    function renderStat(stat, index2) {
      const className = (0, import_classnames5.default)("px-4 md:px-6 w-1/2 my-4 lg:w-auto group select-none", {
        "cursor-pointer": canMetricBeGraphed(stat),
        "lg:border-l border-gray-300": index2 > 0,
        "border-r lg:border-r-0": index2 % 2 === 0
      });
      return /* @__PURE__ */ import_react35.default.createElement(Tooltip, { key: stat.name, info: tooltip(stat, query), className, onClick: () => {
        maybeUpdateMetric(stat);
      }, boundary: tooltipBoundary }, renderStatName(stat), /* @__PURE__ */ import_react35.default.createElement("div", { className: "my-1 space-y-2" }, /* @__PURE__ */ import_react35.default.createElement("div", null, /* @__PURE__ */ import_react35.default.createElement("span", { className: "flex items-center justify-between whitespace-nowrap" }, /* @__PURE__ */ import_react35.default.createElement("p", { className: "font-bold text-xl dark:text-gray-100", id: stat.graph_metric }, topStatNumberShort(stat.name, stat.value)), /* @__PURE__ */ import_react35.default.createElement(Maybe, { condition: !query.comparison }, renderPercentageComparison(stat.name, stat.change))), /* @__PURE__ */ import_react35.default.createElement(Maybe, { condition: query.comparison }, /* @__PURE__ */ import_react35.default.createElement("p", { className: "text-xs dark:text-gray-100" }, formatDateRange(site, data.from, data.to)))), /* @__PURE__ */ import_react35.default.createElement(Maybe, { condition: query.comparison }, /* @__PURE__ */ import_react35.default.createElement("div", null, /* @__PURE__ */ import_react35.default.createElement("p", { className: "font-bold text-xl text-gray-500 dark:text-gray-400" }, topStatNumberShort(stat.name, stat.comparison_value)), /* @__PURE__ */ import_react35.default.createElement("p", { className: "text-xs text-gray-500 dark:text-gray-400" }, formatDateRange(site, data.comparing_from, data.comparing_to))))));
    }
    const stats = data && data.top_stats.map(renderStat);
    if (stats && query.period === "realtime") {
      stats.push(blinkingDot());
    }
    return stats || null;
  }

  // js/dashboard/stats/graph/interval-picker.js
  var import_react37 = __toESM(require_react());
  var import_classnames6 = __toESM(require_classnames());
  var INTERVAL_LABELS = {
    "minute": "Minutes",
    "hour": "Hours",
    "date": "Days",
    "week": "Weeks",
    "month": "Months"
  };
  function validIntervals(site, query) {
    if (query.period === "custom") {
      if (query.to.diff(query.from, "days") < 7) {
        return ["date"];
      } else if (query.to.diff(query.from, "months") < 1) {
        return ["date", "week"];
      } else if (query.to.diff(query.from, "months") < 12) {
        return ["date", "week", "month"];
      } else {
        return ["week", "month"];
      }
    } else {
      return site.validIntervalsByPeriod[query.period];
    }
  }
  function getDefaultInterval(query, validIntervals2) {
    const defaultByPeriod = {
      "day": "hour",
      "7d": "date",
      "6mo": "month",
      "12mo": "month",
      "year": "month"
    };
    if (query.period === "custom") {
      return defaultForCustomPeriod(query.from, query.to);
    } else {
      return defaultByPeriod[query.period] || validIntervals2[0];
    }
  }
  function defaultForCustomPeriod(from2, to2) {
    if (to2.diff(from2, "days") < 30) {
      return "date";
    } else if (to2.diff(from2, "months") < 6) {
      return "week";
    } else {
      return "month";
    }
  }
  function getStoredInterval(period, domain) {
    return getItem(`interval__${period}__${domain}`);
  }
  function storeInterval(period, domain, interval) {
    setItem(`interval__${period}__${domain}`, interval);
  }
  function subscribeKeybinding(element) {
    const handleKeyPress = (0, import_react37.useCallback)((event) => {
      var _a9;
      if (isKeyPressed(event, "i")) (_a9 = element.current) == null ? void 0 : _a9.click();
    }, []);
    (0, import_react37.useEffect)(() => {
      document.addEventListener("keydown", handleKeyPress);
      return () => document.removeEventListener("keydown", handleKeyPress);
    }, [handleKeyPress]);
  }
  var getCurrentInterval = function(site, query) {
    const options = validIntervals(site, query);
    const storedInterval = getStoredInterval(query.period, site.domain);
    const defaultInterval = getDefaultInterval(query, options);
    if (storedInterval && options.includes(storedInterval)) {
      return storedInterval;
    } else {
      return defaultInterval;
    }
  };
  function IntervalPicker({ onIntervalUpdate }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    if (query.period == "realtime") return null;
    const menuElement = import_react37.default.useRef(null);
    const options = validIntervals(site, query);
    const currentInterval = getCurrentInterval(site, query);
    subscribeKeybinding(menuElement);
    function updateInterval(interval) {
      storeInterval(query.period, site.domain, interval);
      onIntervalUpdate(interval);
    }
    function renderDropdownItem(option) {
      return /* @__PURE__ */ import_react37.default.createElement(Ze.Item, { onClick: () => updateInterval(option), key: option, disabled: option == currentInterval }, ({ active }) => /* @__PURE__ */ import_react37.default.createElement("span", { className: (0, import_classnames6.default)({
        "bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-200 cursor-pointer": active,
        "text-gray-700 dark:text-gray-200": !active,
        "font-bold cursor-none select-none": option == currentInterval
      }, "block px-4 py-2 text-sm") }, INTERVAL_LABELS[option]));
    }
    return /* @__PURE__ */ import_react37.default.createElement(Ze, { as: "div", className: "relative inline-block pl-2" }, ({ open }) => /* @__PURE__ */ import_react37.default.createElement(import_react37.default.Fragment, null, /* @__PURE__ */ import_react37.default.createElement(Ze.Button, { ref: menuElement, className: "text-sm inline-flex focus:outline-none text-gray-700 dark:text-gray-300 hover:text-indigo-600 dark:hover:text-indigo-600 items-center" }, INTERVAL_LABELS[currentInterval], /* @__PURE__ */ import_react37.default.createElement(ChevronDownIcon_default, { className: "ml-1 h-4 w-4", "aria-hidden": "true" })), /* @__PURE__ */ import_react37.default.createElement(
      Ke,
      {
        as: import_react37.Fragment,
        show: open,
        enter: "transition ease-out duration-100",
        enterFrom: "opacity-0 scale-95",
        enterTo: "opacity-100 scale-100",
        leave: "transition ease-in duration-75",
        leaveFrom: "opacity-100 scale-100",
        leaveTo: "opacity-0 scale-95"
      },
      /* @__PURE__ */ import_react37.default.createElement(Ze.Items, { className: "py-1 text-left origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5 focus:outline-none z-10", static: true }, options.map(renderDropdownItem))
    )));
  }

  // js/dashboard/stats/graph/stats-export.js
  var import_react38 = __toESM(require_react());
  function StatsExport() {
    const site = useSiteContext();
    const { query } = useQueryContext();
    const [exporting, setExporting] = (0, import_react38.useState)(false);
    function startExport() {
      setExporting(true);
      document.cookie = "exporting=";
      pollExportReady();
    }
    function pollExportReady() {
      if (document.cookie.includes("exporting")) {
        setTimeout(pollExportReady, 1e3);
      } else {
        setExporting(false);
      }
    }
    function renderLoading() {
      return /* @__PURE__ */ import_react38.default.createElement("svg", { className: "animate-spin h-4 w-4 text-indigo-500", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" }, /* @__PURE__ */ import_react38.default.createElement("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), /* @__PURE__ */ import_react38.default.createElement("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" }));
    }
    function renderExportLink() {
      const interval = getCurrentInterval(site, query);
      const queryParams = serializeQuery(query, [{ interval }]);
      const endpoint = `/${encodeURIComponent(site.domain)}/export${queryParams}`;
      return /* @__PURE__ */ import_react38.default.createElement("a", { href: endpoint, download: true, onClick: startExport }, /* @__PURE__ */ import_react38.default.createElement("svg", { className: "absolute text-gray-700 feather dark:text-gray-300 hover:text-indigo-600 dark:hover:text-indigo-600", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, /* @__PURE__ */ import_react38.default.createElement("path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }), /* @__PURE__ */ import_react38.default.createElement("polyline", { points: "7 10 12 15 17 10" }), /* @__PURE__ */ import_react38.default.createElement("line", { x1: "12", y1: "15", x2: "12", y2: "3" })));
    }
    return /* @__PURE__ */ import_react38.default.createElement("div", { className: "w-4 h-4 mx-2" }, exporting && renderLoading(), !exporting && renderExportLink());
  }

  // js/dashboard/stats/graph/with-imported-switch.js
  var import_react39 = __toESM(require_react());
  var import_classnames7 = __toESM(require_classnames());
  function WithImportedSwitch({ tooltipMessage, disabled }) {
    const { query } = useQueryContext();
    const importsSwitchedOn = query.with_imported;
    const iconClass = (0, import_classnames7.default)("mt-0.5", {
      "dark:text-gray-300 text-gray-700": importsSwitchedOn,
      "dark:text-gray-500 text-gray-400": !importsSwitchedOn
    });
    return /* @__PURE__ */ import_react39.default.createElement("div", { tooltip: tooltipMessage, className: "w-4 h-4 mx-2" }, /* @__PURE__ */ import_react39.default.createElement(Link, { disabled, search: (search) => __spreadProps(__spreadValues({}, search), { with_imported: !importsSwitchedOn }) }, /* @__PURE__ */ import_react39.default.createElement(BarsArrowUpIcon_default, { className: iconClass })));
  }

  // js/dashboard/stats/graph/sampling-notice.js
  var import_react40 = __toESM(require_react());
  function SamplingNotice({ topStatData }) {
    const samplePercent = topStatData == null ? void 0 : topStatData.samplePercent;
    if (samplePercent && samplePercent < 100) {
      return /* @__PURE__ */ import_react40.default.createElement("div", { tooltip: `Stats based on a ${samplePercent}% sample of all visitors`, className: "cursor-pointer w-4 h-4 mx-2" }, /* @__PURE__ */ import_react40.default.createElement("svg", { className: "absolute w-4 h-4 dark:text-gray-300 text-gray-700", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, /* @__PURE__ */ import_react40.default.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" })));
    } else {
      return null;
    }
  }

  // js/dashboard/fade-in.js
  var import_react41 = __toESM(require_react());
  function FadeIn({ className, show, children }) {
    return /* @__PURE__ */ import_react41.default.createElement(
      "div",
      {
        className: `${className || ""} ${show ? "fade-enter-active" : "fade-enter"}`
      },
      children
    );
  }

  // js/dashboard/stats/graph/line-graph.js
  var import_react42 = __toESM(require_react());

  // node_modules/chart.js/dist/chunks/helpers.segment.mjs
  function noop() {
  }
  var uid = /* @__PURE__ */ function() {
    let id = 0;
    return function() {
      return id++;
    };
  }();
  function isNullOrUndef(value) {
    return value === null || typeof value === "undefined";
  }
  function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
      return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
  }
  var isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
  function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
  }
  function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
  }
  var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
  var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
  function callback(fn2, args, thisArg) {
    if (fn2 && typeof fn2.call === "function") {
      return fn2.apply(thisArg, args);
    }
  }
  function each(loopable, fn2, thisArg, reverse) {
    let i5, len, keys;
    if (isArray(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i5 = len - 1; i5 >= 0; i5--) {
          fn2.call(thisArg, loopable[i5], i5);
        }
      } else {
        for (i5 = 0; i5 < len; i5++) {
          fn2.call(thisArg, loopable[i5], i5);
        }
      }
    } else if (isObject(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;
      for (i5 = 0; i5 < len; i5++) {
        fn2.call(thisArg, loopable[keys[i5]], keys[i5]);
      }
    }
  }
  function _elementsEqual(a0, a1) {
    let i5, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }
    for (i5 = 0, ilen = a0.length; i5 < ilen; ++i5) {
      v0 = a0[i5];
      v1 = a1[i5];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone$1(source) {
    if (isArray(source)) {
      return source.map(clone$1);
    }
    if (isObject(source)) {
      const target = /* @__PURE__ */ Object.create(null);
      const keys = Object.keys(source);
      const klen = keys.length;
      let k = 0;
      for (; k < klen; ++k) {
        target[keys[k]] = clone$1(source[keys[k]]);
      }
      return target;
    }
    return source;
  }
  function isValidKey(key) {
    return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
  }
  function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
      merge(tval, sval, options);
    } else {
      target[key] = clone$1(sval);
    }
  }
  function merge(target, source, options) {
    const sources = isArray(source) ? source : [source];
    const ilen = sources.length;
    if (!isObject(target)) {
      return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    for (let i5 = 0; i5 < ilen; ++i5) {
      source = sources[i5];
      if (!isObject(source)) {
        continue;
      }
      const keys = Object.keys(source);
      for (let k = 0, klen = keys.length; k < klen; ++k) {
        merger(keys[k], target, source, options);
      }
    }
    return target;
  }
  function mergeIf(target, source) {
    return merge(target, source, { merger: _mergerIf });
  }
  function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone$1(sval);
    }
  }
  var keyResolvers = {
    "": (v3) => v3,
    x: (o10) => o10.x,
    y: (o10) => o10.y
  };
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
      for (const k of keys) {
        if (k === "") {
          break;
        }
        obj = obj && obj[k];
      }
      return obj;
    };
  }
  function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys.push(tmp);
        tmp = "";
      }
    }
    return keys;
  }
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  var defined = (value) => typeof value !== "undefined";
  var isFunction2 = (value) => typeof value === "function";
  var setsEqual = (a3, b2) => {
    if (a3.size !== b2.size) {
      return false;
    }
    for (const item of a3) {
      if (!b2.has(item)) {
        return false;
      }
    }
    return true;
  };
  function _isClickEvent(e3) {
    return e3.type === "mouseup" || e3.type === "click" || e3.type === "contextmenu";
  }
  var PI = Math.PI;
  var TAU = 2 * PI;
  var PITAU = TAU + PI;
  var INFINITY = Number.POSITIVE_INFINITY;
  var RAD_PER_DEG = PI / 180;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  var log10 = Math.log10;
  var sign = Math.sign;
  function niceNum(range) {
    const roundedRange = Math.round(range);
    range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
    const niceRange = Math.pow(10, Math.floor(log10(range)));
    const fraction = range / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i5;
    for (i5 = 1; i5 < sqrt; i5++) {
      if (value % i5 === 0) {
        result.push(i5);
        result.push(value / i5);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a3, b2) => a3 - b2).pop();
    return result;
  }
  function isNumber(n2) {
    return !isNaN(parseFloat(n2)) && isFinite(n2);
  }
  function almostEquals(x3, y2, epsilon) {
    return Math.abs(x3 - y2) < epsilon;
  }
  function almostWhole(x3, epsilon) {
    const rounded = Math.round(x3);
    return rounded - epsilon <= x3 && rounded + epsilon >= x3;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i5, ilen, value;
    for (i5 = 0, ilen = array.length; i5 < ilen; i5++) {
      value = array[i5][property];
      if (!isNaN(value)) {
        target.min = Math.min(target.min, value);
        target.max = Math.max(target.max, value);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x3) {
    if (!isNumberFinite(x3)) {
      return;
    }
    let e3 = 1;
    let p3 = 0;
    while (Math.round(x3 * e3) / e3 !== x3) {
      e3 *= 10;
      p3++;
    }
    return p3;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  function _angleDiff(a3, b2) {
    return (a3 - b2 + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a3) {
    return (a3 % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start3, end2, sameAngleIsFullCircle) {
    const a3 = _normalizeAngle(angle);
    const s7 = _normalizeAngle(start3);
    const e3 = _normalizeAngle(end2);
    const angleToStart = _normalizeAngle(s7 - a3);
    const angleToEnd = _normalizeAngle(e3 - a3);
    const startToAngle = _normalizeAngle(a3 - s7);
    const endToAngle = _normalizeAngle(a3 - e3);
    return a3 === s7 || a3 === e3 || sameAngleIsFullCircle && s7 === e3 || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value, min2, max2) {
    return Math.max(min2, Math.min(max2, value));
  }
  function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
  }
  function _isBetween(value, start3, end2, epsilon = 1e-6) {
    return value >= Math.min(start3, end2) - epsilon && value <= Math.max(start3, end2) + epsilon;
  }
  function _lookup(table, value, cmp) {
    cmp = cmp || ((index2) => table[index2] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while (hi - lo > 1) {
      mid = lo + hi >> 1;
      if (cmp(mid)) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    return { lo, hi };
  }
  var _lookupByKey = (table, key, value, last2) => _lookup(table, value, last2 ? (index2) => table[index2][key] <= value : (index2) => table[index2][key] < value);
  var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
  function _filterBetween(values, min2, max2) {
    let start3 = 0;
    let end2 = values.length;
    while (start3 < end2 && values[start3] < min2) {
      start3++;
    }
    while (end2 > start3 && values[end2 - 1] > max2) {
      end2--;
    }
    return start3 > 0 || end2 < values.length ? values.slice(start3, end2) : values;
  }
  var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [listener]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index2 = listeners.indexOf(listener);
    if (index2 !== -1) {
      listeners.splice(index2, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set2 = /* @__PURE__ */ new Set();
    let i5, ilen;
    for (i5 = 0, ilen = items.length; i5 < ilen; ++i5) {
      set2.add(items[i5]);
    }
    if (set2.size === ilen) {
      return items;
    }
    return Array.from(set2);
  }
  var requestAnimFrame = function() {
    if (typeof window === "undefined") {
      return function(callback2) {
        return callback2();
      };
    }
    return window.requestAnimationFrame;
  }();
  function throttled(fn2, thisArg, updateFn) {
    const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
    let ticking = false;
    let args = [];
    return function(...rest) {
      args = updateArgs(rest);
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn2.apply(thisArg, args);
        });
      }
    };
  }
  function debounce2(fn2, delay) {
    let timeout;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout);
        timeout = setTimeout(fn2, delay, args);
      } else {
        fn2.apply(this, args);
      }
      return delay;
    };
  }
  var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
  var _alignStartEnd = (align, start3, end2) => align === "start" ? start3 : align === "end" ? end2 : (start3 + end2) / 2;
  var _textX = (align, left2, right2, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right2 : align === "center" ? (left2 + right2) / 2 : left2;
  };
  function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start3 = 0;
    let count = pointCount;
    if (meta._sorted) {
      const { iScale, _parsed } = meta;
      const axis = iScale.axis;
      const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start3 = _limitValue(
          Math.min(
            _lookupByKey(_parsed, iScale.axis, min2).lo,
            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min2)).lo
          ),
          0,
          pointCount - 1
        );
      }
      if (maxDefined) {
        count = _limitValue(
          Math.max(
            _lookupByKey(_parsed, iScale.axis, max2, true).hi + 1,
            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max2), true).hi + 1
          ),
          start3,
          pointCount
        ) - start3;
      } else {
        count = pointCount - start3;
      }
    }
    return { start: start3, count };
  }
  function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  var atEdge = (t7) => t7 === 0 || t7 === 1;
  var elasticIn = (t7, s7, p3) => -(Math.pow(2, 10 * (t7 -= 1)) * Math.sin((t7 - s7) * TAU / p3));
  var elasticOut = (t7, s7, p3) => Math.pow(2, -10 * t7) * Math.sin((t7 - s7) * TAU / p3) + 1;
  var effects = {
    linear: (t7) => t7,
    easeInQuad: (t7) => t7 * t7,
    easeOutQuad: (t7) => -t7 * (t7 - 2),
    easeInOutQuad: (t7) => (t7 /= 0.5) < 1 ? 0.5 * t7 * t7 : -0.5 * (--t7 * (t7 - 2) - 1),
    easeInCubic: (t7) => t7 * t7 * t7,
    easeOutCubic: (t7) => (t7 -= 1) * t7 * t7 + 1,
    easeInOutCubic: (t7) => (t7 /= 0.5) < 1 ? 0.5 * t7 * t7 * t7 : 0.5 * ((t7 -= 2) * t7 * t7 + 2),
    easeInQuart: (t7) => t7 * t7 * t7 * t7,
    easeOutQuart: (t7) => -((t7 -= 1) * t7 * t7 * t7 - 1),
    easeInOutQuart: (t7) => (t7 /= 0.5) < 1 ? 0.5 * t7 * t7 * t7 * t7 : -0.5 * ((t7 -= 2) * t7 * t7 * t7 - 2),
    easeInQuint: (t7) => t7 * t7 * t7 * t7 * t7,
    easeOutQuint: (t7) => (t7 -= 1) * t7 * t7 * t7 * t7 + 1,
    easeInOutQuint: (t7) => (t7 /= 0.5) < 1 ? 0.5 * t7 * t7 * t7 * t7 * t7 : 0.5 * ((t7 -= 2) * t7 * t7 * t7 * t7 + 2),
    easeInSine: (t7) => -Math.cos(t7 * HALF_PI) + 1,
    easeOutSine: (t7) => Math.sin(t7 * HALF_PI),
    easeInOutSine: (t7) => -0.5 * (Math.cos(PI * t7) - 1),
    easeInExpo: (t7) => t7 === 0 ? 0 : Math.pow(2, 10 * (t7 - 1)),
    easeOutExpo: (t7) => t7 === 1 ? 1 : -Math.pow(2, -10 * t7) + 1,
    easeInOutExpo: (t7) => atEdge(t7) ? t7 : t7 < 0.5 ? 0.5 * Math.pow(2, 10 * (t7 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t7 * 2 - 1)) + 2),
    easeInCirc: (t7) => t7 >= 1 ? t7 : -(Math.sqrt(1 - t7 * t7) - 1),
    easeOutCirc: (t7) => Math.sqrt(1 - (t7 -= 1) * t7),
    easeInOutCirc: (t7) => (t7 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t7 * t7) - 1) : 0.5 * (Math.sqrt(1 - (t7 -= 2) * t7) + 1),
    easeInElastic: (t7) => atEdge(t7) ? t7 : elasticIn(t7, 0.075, 0.3),
    easeOutElastic: (t7) => atEdge(t7) ? t7 : elasticOut(t7, 0.075, 0.3),
    easeInOutElastic(t7) {
      const s7 = 0.1125;
      const p3 = 0.45;
      return atEdge(t7) ? t7 : t7 < 0.5 ? 0.5 * elasticIn(t7 * 2, s7, p3) : 0.5 + 0.5 * elasticOut(t7 * 2 - 1, s7, p3);
    },
    easeInBack(t7) {
      const s7 = 1.70158;
      return t7 * t7 * ((s7 + 1) * t7 - s7);
    },
    easeOutBack(t7) {
      const s7 = 1.70158;
      return (t7 -= 1) * t7 * ((s7 + 1) * t7 + s7) + 1;
    },
    easeInOutBack(t7) {
      let s7 = 1.70158;
      if ((t7 /= 0.5) < 1) {
        return 0.5 * (t7 * t7 * (((s7 *= 1.525) + 1) * t7 - s7));
      }
      return 0.5 * ((t7 -= 2) * t7 * (((s7 *= 1.525) + 1) * t7 + s7) + 2);
    },
    easeInBounce: (t7) => 1 - effects.easeOutBounce(1 - t7),
    easeOutBounce(t7) {
      const m5 = 7.5625;
      const d5 = 2.75;
      if (t7 < 1 / d5) {
        return m5 * t7 * t7;
      }
      if (t7 < 2 / d5) {
        return m5 * (t7 -= 1.5 / d5) * t7 + 0.75;
      }
      if (t7 < 2.5 / d5) {
        return m5 * (t7 -= 2.25 / d5) * t7 + 0.9375;
      }
      return m5 * (t7 -= 2.625 / d5) * t7 + 0.984375;
    },
    easeInOutBounce: (t7) => t7 < 0.5 ? effects.easeInBounce(t7 * 2) * 0.5 : effects.easeOutBounce(t7 * 2 - 1) * 0.5 + 0.5
  };
  function round2(v3) {
    return v3 + 0.5 | 0;
  }
  var lim = (v3, l6, h3) => Math.max(Math.min(v3, h3), l6);
  function p2b(v3) {
    return lim(round2(v3 * 2.55), 0, 255);
  }
  function n2b(v3) {
    return lim(round2(v3 * 255), 0, 255);
  }
  function b2n(v3) {
    return lim(round2(v3 / 2.55) / 100, 0, 1);
  }
  function n2p(v3) {
    return lim(round2(v3 * 100), 0, 100);
  }
  var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
  var hex = [..."0123456789ABCDEF"];
  var h1 = (b2) => hex[b2 & 15];
  var h22 = (b2) => hex[(b2 & 240) >> 4] + hex[b2 & 15];
  var eq = (b2) => (b2 & 240) >> 4 === (b2 & 15);
  var isShort = (v3) => eq(v3.r) && eq(v3.g) && eq(v3.b) && eq(v3.a);
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
      }
    }
    return ret;
  }
  var alpha = (a3, f5) => a3 < 255 ? f5(a3) : "";
  function hexString(v3) {
    var f5 = isShort(v3) ? h1 : h22;
    return v3 ? "#" + f5(v3.r) + f5(v3.g) + f5(v3.b) + alpha(v3.a, f5) : void 0;
  }
  var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h3, s7, l6) {
    const a3 = s7 * Math.min(l6, 1 - l6);
    const f5 = (n2, k = (n2 + h3 / 30) % 12) => l6 - a3 * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f5(0), f5(8), f5(4)];
  }
  function hsv2rgbn(h3, s7, v3) {
    const f5 = (n2, k = (n2 + h3 / 60) % 6) => v3 - v3 * s7 * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f5(5), f5(3), f5(1)];
  }
  function hwb2rgbn(h3, w3, b2) {
    const rgb = hsl2rgbn(h3, 1, 0.5);
    let i5;
    if (w3 + b2 > 1) {
      i5 = 1 / (w3 + b2);
      w3 *= i5;
      b2 *= i5;
    }
    for (i5 = 0; i5 < 3; i5++) {
      rgb[i5] *= 1 - w3 - b2;
      rgb[i5] += w3;
    }
    return rgb;
  }
  function hueValue(r6, g3, b2, d5, max2) {
    if (r6 === max2) {
      return (g3 - b2) / d5 + (g3 < b2 ? 6 : 0);
    }
    if (g3 === max2) {
      return (b2 - r6) / d5 + 2;
    }
    return (r6 - g3) / d5 + 4;
  }
  function rgb2hsl(v3) {
    const range = 255;
    const r6 = v3.r / range;
    const g3 = v3.g / range;
    const b2 = v3.b / range;
    const max2 = Math.max(r6, g3, b2);
    const min2 = Math.min(r6, g3, b2);
    const l6 = (max2 + min2) / 2;
    let h3, s7, d5;
    if (max2 !== min2) {
      d5 = max2 - min2;
      s7 = l6 > 0.5 ? d5 / (2 - max2 - min2) : d5 / (max2 + min2);
      h3 = hueValue(r6, g3, b2, d5, max2);
      h3 = h3 * 60 + 0.5;
    }
    return [h3 | 0, s7 || 0, l6];
  }
  function calln(f5, a3, b2, c3) {
    return (Array.isArray(a3) ? f5(a3[0], a3[1], a3[2]) : f5(a3, b2, c3)).map(n2b);
  }
  function hsl2rgb(h3, s7, l6) {
    return calln(hsl2rgbn, h3, s7, l6);
  }
  function hwb2rgb(h3, w3, b2) {
    return calln(hwb2rgbn, h3, w3, b2);
  }
  function hsv2rgb(h3, s7, v3) {
    return calln(hsv2rgbn, h3, s7, v3);
  }
  function hue(h3) {
    return (h3 % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m5 = HUE_RE.exec(str);
    let a3 = 255;
    let v3;
    if (!m5) {
      return;
    }
    if (m5[5] !== v3) {
      a3 = m5[6] ? p2b(+m5[5]) : n2b(+m5[5]);
    }
    const h3 = hue(+m5[2]);
    const p1 = +m5[3] / 100;
    const p22 = +m5[4] / 100;
    if (m5[1] === "hwb") {
      v3 = hwb2rgb(h3, p1, p22);
    } else if (m5[1] === "hsv") {
      v3 = hsv2rgb(h3, p1, p22);
    } else {
      v3 = hsl2rgb(h3, p1, p22);
    }
    return {
      r: v3[0],
      g: v3[1],
      b: v3[2],
      a: a3
    };
  }
  function rotate(v3, deg) {
    var h3 = rgb2hsl(v3);
    h3[0] = hue(h3[0] + deg);
    h3 = hsl2rgb(h3);
    v3.r = h3[0];
    v3.g = h3[1];
    v3.b = h3[2];
  }
  function hslString(v3) {
    if (!v3) {
      return;
    }
    const a3 = rgb2hsl(v3);
    const h3 = a3[0];
    const s7 = n2p(a3[1]);
    const l6 = n2p(a3[2]);
    return v3.a < 255 ? `hsla(${h3}, ${s7}%, ${l6}%, ${b2n(v3.a)})` : `hsl(${h3}, ${s7}%, ${l6}%)`;
  }
  var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  };
  var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i5, j2, k, ok, nk;
    for (i5 = 0; i5 < keys.length; i5++) {
      ok = nk = keys[i5];
      for (j2 = 0; j2 < tkeys.length; j2++) {
        k = tkeys[j2];
        nk = nk.replace(k, map[k]);
      }
      k = parseInt(names$1[ok], 16);
      unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
    }
    return unpacked;
  }
  var names;
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a3 = names[str.toLowerCase()];
    return a3 && {
      r: a3[0],
      g: a3[1],
      b: a3[2],
      a: a3.length === 4 ? a3[3] : 255
    };
  }
  var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str) {
    const m5 = RGB_RE.exec(str);
    let a3 = 255;
    let r6, g3, b2;
    if (!m5) {
      return;
    }
    if (m5[7] !== r6) {
      const v3 = +m5[7];
      a3 = m5[8] ? p2b(v3) : lim(v3 * 255, 0, 255);
    }
    r6 = +m5[1];
    g3 = +m5[3];
    b2 = +m5[5];
    r6 = 255 & (m5[2] ? p2b(r6) : lim(r6, 0, 255));
    g3 = 255 & (m5[4] ? p2b(g3) : lim(g3, 0, 255));
    b2 = 255 & (m5[6] ? p2b(b2) : lim(b2, 0, 255));
    return {
      r: r6,
      g: g3,
      b: b2,
      a: a3
    };
  }
  function rgbString(v3) {
    return v3 && (v3.a < 255 ? `rgba(${v3.r}, ${v3.g}, ${v3.b}, ${b2n(v3.a)})` : `rgb(${v3.r}, ${v3.g}, ${v3.b})`);
  }
  var to = (v3) => v3 <= 31308e-7 ? v3 * 12.92 : Math.pow(v3, 1 / 2.4) * 1.055 - 0.055;
  var from = (v3) => v3 <= 0.04045 ? v3 / 12.92 : Math.pow((v3 + 0.055) / 1.055, 2.4);
  function interpolate(rgb1, rgb2, t7) {
    const r6 = from(b2n(rgb1.r));
    const g3 = from(b2n(rgb1.g));
    const b2 = from(b2n(rgb1.b));
    return {
      r: n2b(to(r6 + t7 * (from(b2n(rgb2.r)) - r6))),
      g: n2b(to(g3 + t7 * (from(b2n(rgb2.g)) - g3))),
      b: n2b(to(b2 + t7 * (from(b2n(rgb2.b)) - b2))),
      a: rgb1.a + t7 * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v3, i5, ratio) {
    if (v3) {
      let tmp = rgb2hsl(v3);
      tmp[i5] = Math.max(0, Math.min(tmp[i5] + tmp[i5] * ratio, i5 === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v3.r = tmp[0];
      v3.g = tmp[1];
      v3.b = tmp[2];
    }
  }
  function clone(v3, proto) {
    return v3 ? Object.assign(proto || {}, v3) : v3;
  }
  function fromObject(input) {
    var v3 = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v3 = { r: input[0], g: input[1], b: input[2], a: 255 };
        if (input.length > 3) {
          v3.a = n2b(input[3]);
        }
      }
    } else {
      v3 = clone(input, { r: 0, g: 0, b: 0, a: 1 });
      v3.a = n2b(v3.a);
    }
    return v3;
  }
  function functionParse(str) {
    if (str.charAt(0) === "r") {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  var Color = class _Color {
    constructor(input) {
      if (input instanceof _Color) {
        return input;
      }
      const type = typeof input;
      let v3;
      if (type === "object") {
        v3 = fromObject(input);
      } else if (type === "string") {
        v3 = hexParse(input) || nameParse(input) || functionParse(input);
      }
      this._rgb = v3;
      this._valid = !!v3;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v3 = clone(this._rgb);
      if (v3) {
        v3.a = b2n(v3.a);
      }
      return v3;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color2, weight) {
      if (color2) {
        const c1 = this.rgb;
        const c22 = color2.rgb;
        let w22;
        const p3 = weight === w22 ? 0.5 : weight;
        const w3 = 2 * p3 - 1;
        const a3 = c1.a - c22.a;
        const w1 = ((w3 * a3 === -1 ? w3 : (w3 + a3) / (1 + w3 * a3)) + 1) / 2;
        w22 = 1 - w1;
        c1.r = 255 & w1 * c1.r + w22 * c22.r + 0.5;
        c1.g = 255 & w1 * c1.g + w22 * c22.g + 0.5;
        c1.b = 255 & w1 * c1.b + w22 * c22.b + 0.5;
        c1.a = p3 * c1.a + (1 - p3) * c22.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color2, t7) {
      if (color2) {
        this._rgb = interpolate(this._rgb, color2._rgb, t7);
      }
      return this;
    }
    clone() {
      return new _Color(this.rgb);
    }
    alpha(a3) {
      this._rgb.a = n2b(a3);
      return this;
    }
    clearer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb = this._rgb;
      const val = round2(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
      rgb.r = rgb.g = rgb.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v3 = this._rgb;
      v3.r = 255 - v3.r;
      v3.g = 255 - v3.g;
      v3.b = 255 - v3.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  };
  function index_esm(input) {
    return new Color(input);
  }
  function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
      const type = value.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color(value) {
    return isPatternOrGradient(value) ? value : index_esm(value);
  }
  function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
  }
  var overrides = /* @__PURE__ */ Object.create(null);
  var descriptors = /* @__PURE__ */ Object.create(null);
  function getScope$1(node, key) {
    if (!key) {
      return node;
    }
    const keys = key.split(".");
    for (let i5 = 0, n2 = keys.length; i5 < n2; ++i5) {
      const k = keys[i5];
      node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
    }
    return node;
  }
  function set(root, scope, values) {
    if (typeof scope === "string") {
      return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ""), scope);
  }
  var Defaults = class {
    constructor(_descriptors2) {
      this.animation = void 0;
      this.backgroundColor = "rgba(0,0,0,0.1)";
      this.borderColor = "rgba(0,0,0,0.1)";
      this.color = "#666";
      this.datasets = {};
      this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
      this.elements = {};
      this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ];
      this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      };
      this.hover = {};
      this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
      this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
      this.hoverColor = (ctx, options) => getHoverColor(options.color);
      this.indexAxis = "x";
      this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      };
      this.maintainAspectRatio = true;
      this.onHover = null;
      this.onClick = null;
      this.parsing = true;
      this.plugins = {};
      this.responsive = true;
      this.scale = void 0;
      this.scales = {};
      this.showLine = true;
      this.drawActiveElementsOnTop = true;
      this.describe(_descriptors2);
    }
    set(scope, values) {
      return set(this, scope, values);
    }
    get(scope) {
      return getScope$1(this, scope);
    }
    describe(scope, values) {
      return set(descriptors, scope, values);
    }
    override(scope, values) {
      return set(overrides, scope, values);
    }
    route(scope, name, targetScope, targetName) {
      const scopeObject = getScope$1(this, scope);
      const targetScopeObject = getScope$1(this, targetScope);
      const privateName = "_" + name;
      Object.defineProperties(scopeObject, {
        [privateName]: {
          value: scopeObject[name],
          writable: true
        },
        [name]: {
          enumerable: true,
          get() {
            const local = this[privateName];
            const target = targetScopeObject[targetName];
            if (isObject(local)) {
              return Object.assign({}, target, local);
            }
            return valueOrDefault(local, target);
          },
          set(value) {
            this[privateName] = value;
          }
        }
      });
    }
  };
  var defaults = new Defaults({
    _scriptable: (name) => !name.startsWith("on"),
    _indexable: (name) => name !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  });
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
      textWidth = data[string] = ctx.measureText(string).width;
      gc.push(string);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
      data = cache.data = {};
      gc = cache.garbageCollect = [];
      cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i5, j2, jlen, thing, nestedThing;
    for (i5 = 0; i5 < ilen; i5++) {
      thing = arrayOfThings[i5];
      if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
        longest = _measureText(ctx, data, gc, longest, thing);
      } else if (isArray(thing)) {
        for (j2 = 0, jlen = thing.length; j2 < jlen; j2++) {
          nestedThing = thing[j2];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
            longest = _measureText(ctx, data, gc, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i5 = 0; i5 < gcLen; i5++) {
        delete data[gc[i5]];
      }
      gc.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options, x3, y2) {
    drawPointLegend(ctx, options, x3, y2, null);
  }
  function drawPointLegend(ctx, options, x3, y2, w3) {
    let type, xOffset, yOffset, size, cornerRadius, width;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
      type = style.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x3, y2);
        ctx.rotate(rad);
        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style) {
      default:
        if (w3) {
          ctx.ellipse(x3, y2, w3 / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x3, y2, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        ctx.moveTo(x3 + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x3 + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x3 + Math.sin(rad) * radius, y2 - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size;
        yOffset = Math.sin(rad + QUARTER_PI) * size;
        ctx.arc(x3 - xOffset, y2 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x3 + yOffset, y2 - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x3 + xOffset, y2 + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x3 - yOffset, y2 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size = Math.SQRT1_2 * radius;
          width = w3 ? w3 / 2 : size;
          ctx.rect(x3 - width, y2 - size, 2 * width, 2 * size);
          break;
        }
        rad += QUARTER_PI;
      case "rectRot":
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x3 - xOffset, y2 - yOffset);
        ctx.lineTo(x3 + yOffset, y2 - xOffset);
        ctx.lineTo(x3 + xOffset, y2 + yOffset);
        ctx.lineTo(x3 - yOffset, y2 + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      case "cross":
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x3 - xOffset, y2 - yOffset);
        ctx.lineTo(x3 + xOffset, y2 + yOffset);
        ctx.moveTo(x3 + yOffset, y2 - xOffset);
        ctx.lineTo(x3 - yOffset, y2 + xOffset);
        break;
      case "star":
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x3 - xOffset, y2 - yOffset);
        ctx.lineTo(x3 + xOffset, y2 + yOffset);
        ctx.moveTo(x3 + yOffset, y2 - xOffset);
        ctx.lineTo(x3 - yOffset, y2 + xOffset);
        rad += QUARTER_PI;
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x3 - xOffset, y2 - yOffset);
        ctx.lineTo(x3 + xOffset, y2 + yOffset);
        ctx.moveTo(x3 + yOffset, y2 - xOffset);
        ctx.lineTo(x3 - yOffset, y2 + xOffset);
        break;
      case "line":
        xOffset = w3 ? w3 / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x3 - xOffset, y2 - yOffset);
        ctx.lineTo(x3 + xOffset, y2 + yOffset);
        break;
      case "dash":
        ctx.moveTo(x3, y2);
        ctx.lineTo(x3 + Math.cos(rad) * radius, y2 + Math.sin(rad) * radius);
        break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip2, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip2) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip2) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(
      flip2 ? previous.cp1x : previous.cp2x,
      flip2 ? previous.cp1y : previous.cp2y,
      flip2 ? target.cp2x : target.cp1x,
      flip2 ? target.cp2y : target.cp1y,
      target.x,
      target.y
    );
  }
  function renderText(ctx, text, x3, y2, font, opts = {}) {
    const lines = isArray(text) ? text : [text];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i5, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i5 = 0; i5 < lines.length; ++i5) {
      line = lines[i5];
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line, x3, y2, opts.maxWidth);
      }
      ctx.fillText(line, x3, y2, opts.maxWidth);
      decorateText(ctx, x3, y2, line, opts);
      y2 += font.lineHeight;
    }
    ctx.restore();
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x3, y2, line, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line);
      const left2 = x3 - metrics.actualBoundingBoxLeft;
      const right2 = x3 + metrics.actualBoundingBoxRight;
      const top2 = y2 - metrics.actualBoundingBoxAscent;
      const bottom2 = y2 + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top2 + bottom2) / 2 : bottom2;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left2, yDecoration);
      ctx.lineTo(right2, yDecoration);
      ctx.stroke();
    }
  }
  function addRoundedRectPath(ctx, rect) {
    const { x: x3, y: y2, w: w3, h: h3, radius } = rect;
    ctx.arc(x3 + radius.topLeft, y2 + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
    ctx.lineTo(x3, y2 + h3 - radius.bottomLeft);
    ctx.arc(x3 + radius.bottomLeft, y2 + h3 - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x3 + w3 - radius.bottomRight, y2 + h3);
    ctx.arc(x3 + w3 - radius.bottomRight, y2 + h3 - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x3 + w3, y2 + radius.topRight);
    ctx.arc(x3 + w3 - radius.topRight, y2 + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x3 + radius.topLeft, y2);
  }
  var LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
  var FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
  function toLineHeight(value, size) {
    const matches = ("" + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === "normal") {
      return size * 1.2;
    }
    value = +matches[2];
    switch (matches[3]) {
      case "px":
        return value;
      case "%":
        value /= 100;
        break;
    }
    return size * value;
  }
  var numberOrZero = (v3) => +v3 || 0;
  function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject(props);
    const keys = objProps ? Object.keys(props) : props;
    const read2 = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
    for (const prop of keys) {
      ret[prop] = numberOrZero(read2(prop));
    }
    return ret;
  }
  function toTRBL(value) {
    return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
  }
  function toTRBLCorners(value) {
    return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
  }
  function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === "string") {
      size = parseInt(size, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style + '"');
      style = "";
    }
    const font = {
      family: valueOrDefault(options.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
      size,
      style,
      weight: valueOrDefault(options.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context, index2, info) {
    let cacheable = true;
    let i5, ilen, value;
    for (i5 = 0, ilen = inputs.length; i5 < ilen; ++i5) {
      value = inputs[i5];
      if (value === void 0) {
        continue;
      }
      if (context !== void 0 && typeof value === "function") {
        value = value(context);
        cacheable = false;
      }
      if (index2 !== void 0 && isArray(value)) {
        value = value[index2 % value.length];
        cacheable = false;
      }
      if (value !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min: min2, max: max2 } = minmax;
    const change = toDimension(grace, (max2 - min2) / 2);
    const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
    return {
      min: keepZero(min2, -Math.abs(change)),
      max: keepZero(max2, change)
    };
  }
  function createContext5(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
  }
  function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
    if (!defined(fallback)) {
      fallback = _resolve("_fallback", scopes);
    }
    const cache = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: rootScopes,
      _fallback: fallback,
      _getTarget: getTarget,
      override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
    };
    return new Proxy(cache, {
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      get(target, prop) {
        return _cached(
          target,
          prop,
          () => _resolveWithPrefixes(prop, prefixes, scopes, target)
        );
      },
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      set(target, prop, value) {
        const storage = target._storage || (target._storage = getTarget());
        target[prop] = storage[prop] = value;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
      _cacheable: false,
      _proxy: proxy,
      _context: context,
      _subProxy: subProxy,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      get(target, prop, receiver) {
        return _cached(
          target,
          prop,
          () => _resolveWithContext(target, prop, receiver)
        );
      },
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      set(target, prop, value) {
        proxy[prop] = value;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
    const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction2(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction2(_indexable) ? _indexable : () => _indexable
    };
  }
  var readKey = (prefix2, name) => prefix2 ? prefix2 + _capitalize(name) : name;
  var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop)) {
      return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction2(value) && descriptors2.isScriptable(prop)) {
      value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
      value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
      value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
  }
  function _resolveScriptable(prop, value, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    value = value(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
      value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (defined(_context.index) && isIndexable(prop)) {
      value = value[_context.index % value.length];
    } else if (isObject(value[0])) {
      const arr = value;
      const scopes = _proxy._scopes.filter((s7) => s7 !== arr);
      value = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value;
  }
  function resolveFallback(fallback, prop, value) {
    return isFunction2(fallback) ? fallback(prop, value) : fallback;
  }
  var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
  function addScopes(set2, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
      const scope = getScope(key, parent);
      if (scope) {
        set2.add(scope);
        const fallback = resolveFallback(scope._fallback, key, value);
        if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [...parentScopes, ...rootScopes];
    const set2 = /* @__PURE__ */ new Set();
    set2.add(value);
    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
    if (key === null) {
      return false;
    }
    if (defined(fallback) && fallback !== prop) {
      key = addScopesFromKey(set2, allScopes, fallback, key, value);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(
      Array.from(set2),
      [""],
      rootScopes,
      fallback,
      () => subGetTarget(resolver, prop, value)
    );
  }
  function addScopesFromKey(set2, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set2, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject(value)) {
      return value;
    }
    return target;
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix2 of prefixes) {
      value = _resolve(readKey(prefix2, prop), scopes);
      if (defined(value)) {
        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope of scopes) {
      if (!scope) {
        continue;
      }
      const value = scope[key];
      if (defined(value)) {
        return value;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
      keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set2 = /* @__PURE__ */ new Set();
    for (const scope of scopes) {
      for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
        set2.add(key);
      }
    }
    return Array.from(set2);
  }
  function _parseObjectDataRadialScale(meta, data, start3, count) {
    const { iScale } = meta;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i5, ilen, index2, item;
    for (i5 = 0, ilen = count; i5 < ilen; ++i5) {
      index2 = i5 + start3;
      item = data[index2];
      parsed[i5] = {
        r: iScale.parse(resolveObjectKey(item, key), index2)
      };
    }
    return parsed;
  }
  var EPSILON = Number.EPSILON || 1e-14;
  var getPoint = (points, i5) => i5 < points.length && !points[i5].skip && points[i5];
  var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
  function splineCurve(firstPoint, middlePoint, afterPoint, t7) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t7 * s01;
    const fb = t7 * s12;
    return {
      previous: {
        x: current.x - fa * (next.x - previous.x),
        y: current.y - fa * (next.y - previous.y)
      },
      next: {
        x: current.x + fb * (next.x - previous.x),
        y: current.y + fb * (next.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i5 = 0; i5 < pointsLen - 1; ++i5) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i5 + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i5], 0, EPSILON)) {
        mK[i5] = mK[i5 + 1] = 0;
        continue;
      }
      alphaK = mK[i5] / deltaK[i5];
      betaK = mK[i5 + 1] / deltaK[i5];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i5] = alphaK * tauK * deltaK[i5];
      mK[i5 + 1] = betaK * tauK * deltaK[i5];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i5 = 0; i5 < pointsLen; ++i5) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i5 + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i5];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i5];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i5, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i5 = 0; i5 < pointsLen; ++i5) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i5 + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i5] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i5] = !pointBefore ? deltaK[i5] : !pointAfter ? deltaK[i5 - 1] : sign(deltaK[i5 - 1]) !== sign(deltaK[i5]) ? 0 : (deltaK[i5 - 1] + deltaK[i5]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt, min2, max2) {
    return Math.max(Math.min(pt, max2), min2);
  }
  function capBezierPoints(points, area) {
    let i5, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i5 = 0, ilen = points.length; i5 < ilen; ++i5) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i5 < ilen - 1 && _isPointInArea(points[i5 + 1], area);
      if (!inArea) {
        continue;
      }
      point = points[i5];
      if (inAreaPrev) {
        point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
        point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
        point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i5, ilen, point, controlPoints;
    if (options.spanGaps) {
      points = points.filter((pt) => !pt.skip);
    }
    if (options.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev = loop ? points[points.length - 1] : points[0];
      for (i5 = 0, ilen = points.length; i5 < ilen; ++i5) {
        point = points[i5];
        controlPoints = splineCurve(
          prev,
          point,
          points[Math.min(i5 + 1, ilen - (loop ? 0 : 1)) % ilen],
          options.tension
        );
        point.cp1x = controlPoints.previous.x;
        point.cp1y = controlPoints.previous.y;
        point.cp2x = controlPoints.next.x;
        point.cp2y = controlPoints.next.y;
        prev = point;
      }
    }
    if (options.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  var getComputedStyle3 = (element) => window.getComputedStyle(element, null);
  function getStyle(el, property) {
    return getComputedStyle3(el).getPropertyValue(property);
  }
  var positions = ["top", "right", "bottom", "left"];
  function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i5 = 0; i5 < 4; i5++) {
      const pos = positions[i5];
      result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  var useOffsetPos = (x3, y2, target) => (x3 > 0 || y2 > 0) && (!target || !target.shadowRoot);
  function getCanvasPosition(e3, canvas) {
    const touches = e3.touches;
    const source = touches && touches.length ? touches[0] : e3;
    const { offsetX, offsetY } = source;
    let box = false;
    let x3, y2;
    if (useOffsetPos(offsetX, offsetY, e3.target)) {
      x3 = offsetX;
      y2 = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x3 = source.clientX - rect.left;
      y2 = source.clientY - rect.top;
      box = true;
    }
    return { x: x3, y: y2, box };
  }
  function getRelativePosition(evt, chart) {
    if ("native" in evt) {
      return evt;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle3(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x: x3, y: y2, box } = getCanvasPosition(evt, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x3 - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y2 - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container2 = _getParentNode(canvas);
      if (!container2) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container2.getBoundingClientRect();
        const containerStyle = getComputedStyle3(container2);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container2, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container2, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  var round1 = (v3) => Math.round(v3 * 10) / 10;
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle3(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
      const borders = getPositionedStyle(style, "border", "width");
      const paddings = getPositionedStyle(style, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = deviceHeight / pixelRatio;
    chart.width = deviceWidth / pixelRatio;
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  var supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
      const options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      window.addEventListener("test", null, options);
      window.removeEventListener("test", null, options);
    } catch (e3) {
    }
    return passiveSupported;
  }();
  function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : void 0;
  }
  function _pointInLine(p1, p22, t7, mode) {
    return {
      x: p1.x + t7 * (p22.x - p1.x),
      y: p1.y + t7 * (p22.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p22, t7, mode) {
    return {
      x: p1.x + t7 * (p22.x - p1.x),
      y: mode === "middle" ? t7 < 0.5 ? p1.y : p22.y : mode === "after" ? t7 < 1 ? p1.y : p22.y : t7 > 0 ? p22.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p22, t7, mode) {
    const cp1 = { x: p1.cp2x, y: p1.cp2y };
    const cp2 = { x: p22.cp1x, y: p22.cp1y };
    const a3 = _pointInLine(p1, cp1, t7);
    const b2 = _pointInLine(cp1, cp2, t7);
    const c3 = _pointInLine(cp2, p22, t7);
    const d5 = _pointInLine(a3, b2, t7);
    const e3 = _pointInLine(b2, c3, t7);
    return _pointInLine(d5, e3, t7);
  }
  var intlCache = /* @__PURE__ */ new Map();
  function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
      formatter = new Intl.NumberFormat(locale, options);
      intlCache.set(cacheKey, formatter);
    }
    return formatter;
  }
  function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
  }
  var getRightToLeftAdapter = function(rectX, width) {
    return {
      x(x3) {
        return rectX + rectX + width - x3;
      },
      setWidth(w3) {
        width = w3;
      },
      textAlign(align) {
        if (align === "center") {
          return align;
        }
        return align === "right" ? "left" : "right";
      },
      xPlus(x3, value) {
        return x3 - value;
      },
      leftForLtr(x3, itemWidth) {
        return x3 - itemWidth;
      }
    };
  };
  var getLeftToRightAdapter = function() {
    return {
      x(x3) {
        return x3;
      },
      setWidth(w3) {
      },
      textAlign(align) {
        return align;
      },
      xPlus(x3, value) {
        return x3 + value;
      },
      leftForLtr(x3, _itemWidth) {
        return x3;
      }
    };
  };
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
      style = ctx.canvas.style;
      original = [
        style.getPropertyValue("direction"),
        style.getPropertyPriority("direction")
      ];
      style.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original;
    }
  }
  function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a3, b2) => a3 - b2,
      normalize: (x3) => x3
    };
  }
  function normalizeSegment({ start: start3, end: end2, count, loop, style }) {
    return {
      start: start3 % count,
      end: end2 % count,
      loop: loop && (end2 - start3 + 1) % count === 0,
      style
    };
  }
  function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize } = propertyFn(property);
    const count = points.length;
    let { start: start3, end: end2, loop } = segment;
    let i5, ilen;
    if (loop) {
      start3 += count;
      end2 += count;
      for (i5 = 0, ilen = count; i5 < ilen; ++i5) {
        if (!between(normalize(points[start3 % count][property]), startBound, endBound)) {
          break;
        }
        start3--;
        end2--;
      }
      start3 %= count;
      end2 %= count;
    }
    if (end2 < start3) {
      end2 += count;
    }
    return { start: start3, end: end2, loop, style: segment.style };
  }
  function _boundSegment(segment, points, bounds) {
    if (!bounds) {
      return [segment];
    }
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare, between, normalize } = propertyFn(property);
    const { start: start3, end: end2, loop, style } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = () => inside || startIsBefore();
    const shouldStop = () => !inside || endIsBefore();
    for (let i5 = start3, prev = start3; i5 <= end2; ++i5) {
      point = points[i5 % count];
      if (point.skip) {
        continue;
      }
      value = normalize(point[property]);
      if (value === prevValue) {
        continue;
      }
      inside = between(value, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare(value, startBound) === 0 ? i5 : prev;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({ start: subStart, end: i5, loop, count, style }));
        subStart = null;
      }
      prev = i5;
      prevValue = value;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({ start: subStart, end: end2, loop, count, style }));
    }
    return result;
  }
  function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for (let i5 = 0; i5 < segments.length; i5++) {
      const sub = _boundSegment(segments[i5], line.points, bounds);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop, spanGaps) {
    let start3 = 0;
    let end2 = count - 1;
    if (loop && !spanGaps) {
      while (start3 < count && !points[start3].skip) {
        start3++;
      }
    }
    while (start3 < count && points[start3].skip) {
      start3++;
    }
    start3 %= count;
    if (loop) {
      end2 += start3;
    }
    while (end2 > start3 && points[end2 % count].skip) {
      end2--;
    }
    end2 %= count;
    return { start: start3, end: end2 };
  }
  function solidSegments(points, start3, max2, loop) {
    const count = points.length;
    const result = [];
    let last2 = start3;
    let prev = points[start3];
    let end2;
    for (end2 = start3 + 1; end2 <= max2; ++end2) {
      const cur = points[end2 % count];
      if (cur.skip || cur.stop) {
        if (!prev.skip) {
          loop = false;
          result.push({ start: start3 % count, end: (end2 - 1) % count, loop });
          start3 = last2 = cur.stop ? end2 : null;
        }
      } else {
        last2 = end2;
        if (prev.skip) {
          start3 = end2;
        }
      }
      prev = cur;
    }
    if (last2 !== null) {
      result.push({ start: start3 % count, end: last2 % count, loop });
    }
    return result;
  }
  function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop = !!line._loop;
    const { start: start3, end: end2 } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line, [{ start: start3, end: end2, loop }], points, segmentOptions);
    }
    const max2 = end2 < start3 ? end2 + count : end2;
    const completeLoop = !!line._fullLoop && start3 === 0 && end2 === count - 1;
    return splitByStyles(line, solidSegments(points, start3, max2, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
  }
  function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start3 = segments[0].start;
    let i5 = start3;
    function addStyle(s7, e3, l6, st) {
      const dir = spanGaps ? -1 : 1;
      if (s7 === e3) {
        return;
      }
      s7 += count;
      while (points[s7 % count].skip) {
        s7 -= dir;
      }
      while (points[e3 % count].skip) {
        e3 += dir;
      }
      if (s7 % count !== e3 % count) {
        result.push({ start: s7 % count, end: e3 % count, loop: l6, style: st });
        prevStyle = st;
        start3 = e3 % count;
      }
    }
    for (const segment of segments) {
      start3 = spanGaps ? start3 : segment.start;
      let prev = points[start3 % count];
      let style;
      for (i5 = start3 + 1; i5 <= segment.end; i5++) {
        const pt = points[i5 % count];
        style = readStyle(segmentOptions.setContext(createContext5(chartContext, {
          type: "segment",
          p0: prev,
          p1: pt,
          p0DataIndex: (i5 - 1) % count,
          p1DataIndex: i5 % count,
          datasetIndex
        })));
        if (styleChanged(style, prevStyle)) {
          addStyle(start3, i5 - 1, segment.loop, prevStyle);
        }
        prev = pt;
        prevStyle = style;
      }
      if (start3 < i5 - 1) {
        addStyle(start3, i5 - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options) {
    return {
      backgroundColor: options.backgroundColor,
      borderCapStyle: options.borderCapStyle,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderJoinStyle: options.borderJoinStyle,
      borderWidth: options.borderWidth,
      borderColor: options.borderColor
    };
  }
  function styleChanged(style, prevStyle) {
    return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
  }

  // node_modules/chart.js/dist/chart.mjs
  var Animator = class {
    constructor() {
      this._request = null;
      this._charts = /* @__PURE__ */ new Map();
      this._running = false;
      this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
      const callbacks = anims.listeners[type];
      const numSteps = anims.duration;
      callbacks.forEach((fn2) => fn2({
        chart,
        initial: anims.initial,
        numSteps,
        currentStep: Math.min(date - anims.start, numSteps)
      }));
    }
    _refresh() {
      if (this._request) {
        return;
      }
      this._running = true;
      this._request = requestAnimFrame.call(window, () => {
        this._update();
        this._request = null;
        if (this._running) {
          this._refresh();
        }
      });
    }
    _update(date = Date.now()) {
      let remaining = 0;
      this._charts.forEach((anims, chart) => {
        if (!anims.running || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i5 = items.length - 1;
        let draw2 = false;
        let item;
        for (; i5 >= 0; --i5) {
          item = items[i5];
          if (item._active) {
            if (item._total > anims.duration) {
              anims.duration = item._total;
            }
            item.tick(date);
            draw2 = true;
          } else {
            items[i5] = items[items.length - 1];
            items.pop();
          }
        }
        if (draw2) {
          chart.draw();
          this._notify(chart, anims, date, "progress");
        }
        if (!items.length) {
          anims.running = false;
          this._notify(chart, anims, date, "complete");
          anims.initial = false;
        }
        remaining += items.length;
      });
      this._lastDate = date;
      if (remaining === 0) {
        this._running = false;
      }
    }
    _getAnims(chart) {
      const charts = this._charts;
      let anims = charts.get(chart);
      if (!anims) {
        anims = {
          running: false,
          initial: true,
          items: [],
          listeners: {
            complete: [],
            progress: []
          }
        };
        charts.set(chart, anims);
      }
      return anims;
    }
    listen(chart, event, cb) {
      this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
      if (!items || !items.length) {
        return;
      }
      this._getAnims(chart).items.push(...items);
    }
    has(chart) {
      return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
      const anims = this._charts.get(chart);
      if (!anims) {
        return;
      }
      anims.running = true;
      anims.start = Date.now();
      anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
      this._refresh();
    }
    running(chart) {
      if (!this._running) {
        return false;
      }
      const anims = this._charts.get(chart);
      if (!anims || !anims.running || !anims.items.length) {
        return false;
      }
      return true;
    }
    stop(chart) {
      const anims = this._charts.get(chart);
      if (!anims || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i5 = items.length - 1;
      for (; i5 >= 0; --i5) {
        items[i5].cancel();
      }
      anims.items = [];
      this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
      return this._charts.delete(chart);
    }
  };
  var animator = new Animator();
  var transparent = "transparent";
  var interpolators = {
    boolean(from2, to2, factor) {
      return factor > 0.5 ? to2 : from2;
    },
    color(from2, to2, factor) {
      const c0 = color(from2 || transparent);
      const c1 = c0.valid && color(to2 || transparent);
      return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
    },
    number(from2, to2, factor) {
      return from2 + (to2 - from2) * factor;
    }
  };
  var Animation = class {
    constructor(cfg, target, prop, to2) {
      const currentValue = target[prop];
      to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
      const from2 = resolve([cfg.from, currentValue, to2]);
      this._active = true;
      this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
      this._easing = effects[cfg.easing] || effects.linear;
      this._start = Math.floor(Date.now() + (cfg.delay || 0));
      this._duration = this._total = Math.floor(cfg.duration);
      this._loop = !!cfg.loop;
      this._target = target;
      this._prop = prop;
      this._from = from2;
      this._to = to2;
      this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(cfg, to2, date) {
      if (this._active) {
        this._notify(false);
        const currentValue = this._target[this._prop];
        const elapsed = date - this._start;
        const remain = this._duration - elapsed;
        this._start = date;
        this._duration = Math.floor(Math.max(remain, cfg.duration));
        this._total += elapsed;
        this._loop = !!cfg.loop;
        this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
        this._from = resolve([cfg.from, currentValue, to2]);
      }
    }
    cancel() {
      if (this._active) {
        this.tick(Date.now());
        this._active = false;
        this._notify(false);
      }
    }
    tick(date) {
      const elapsed = date - this._start;
      const duration = this._duration;
      const prop = this._prop;
      const from2 = this._from;
      const loop = this._loop;
      const to2 = this._to;
      let factor;
      this._active = from2 !== to2 && (loop || elapsed < duration);
      if (!this._active) {
        this._target[prop] = to2;
        this._notify(true);
        return;
      }
      if (elapsed < 0) {
        this._target[prop] = from2;
        return;
      }
      factor = elapsed / duration % 2;
      factor = loop && factor > 1 ? 2 - factor : factor;
      factor = this._easing(Math.min(1, Math.max(0, factor)));
      this._target[prop] = this._fn(from2, to2, factor);
    }
    wait() {
      const promises = this._promises || (this._promises = []);
      return new Promise((res, rej) => {
        promises.push({ res, rej });
      });
    }
    _notify(resolved) {
      const method = resolved ? "res" : "rej";
      const promises = this._promises || [];
      for (let i5 = 0; i5 < promises.length; i5++) {
        promises[i5][method]();
      }
    }
  };
  var numbers = ["x", "y", "borderWidth", "radius", "tension"];
  var colors = ["color", "borderColor", "backgroundColor"];
  defaults.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  var animationOptions = Object.keys(defaults.animation);
  defaults.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults.describe("animations", {
    _fallback: "animation"
  });
  defaults.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v3) => v3 | 0
        }
      }
    }
  });
  var Animations = class {
    constructor(chart, config) {
      this._chart = chart;
      this._properties = /* @__PURE__ */ new Map();
      this.configure(config);
    }
    configure(config) {
      if (!isObject(config)) {
        return;
      }
      const animatedProps = this._properties;
      Object.getOwnPropertyNames(config).forEach((key) => {
        const cfg = config[key];
        if (!isObject(cfg)) {
          return;
        }
        const resolved = {};
        for (const option of animationOptions) {
          resolved[option] = cfg[option];
        }
        (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
          if (prop === key || !animatedProps.has(prop)) {
            animatedProps.set(prop, resolved);
          }
        });
      });
    }
    _animateOptions(target, values) {
      const newOptions = values.options;
      const options = resolveTargetOptions(target, newOptions);
      if (!options) {
        return [];
      }
      const animations = this._createAnimations(options, newOptions);
      if (newOptions.$shared) {
        awaitAll(target.options.$animations, newOptions).then(() => {
          target.options = newOptions;
        }, () => {
        });
      }
      return animations;
    }
    _createAnimations(target, values) {
      const animatedProps = this._properties;
      const animations = [];
      const running = target.$animations || (target.$animations = {});
      const props = Object.keys(values);
      const date = Date.now();
      let i5;
      for (i5 = props.length - 1; i5 >= 0; --i5) {
        const prop = props[i5];
        if (prop.charAt(0) === "$") {
          continue;
        }
        if (prop === "options") {
          animations.push(...this._animateOptions(target, values));
          continue;
        }
        const value = values[prop];
        let animation = running[prop];
        const cfg = animatedProps.get(prop);
        if (animation) {
          if (cfg && animation.active()) {
            animation.update(cfg, value, date);
            continue;
          } else {
            animation.cancel();
          }
        }
        if (!cfg || !cfg.duration) {
          target[prop] = value;
          continue;
        }
        running[prop] = animation = new Animation(cfg, target, prop, value);
        animations.push(animation);
      }
      return animations;
    }
    update(target, values) {
      if (this._properties.size === 0) {
        Object.assign(target, values);
        return;
      }
      const animations = this._createAnimations(target, values);
      if (animations.length) {
        animator.add(this._chart, animations);
        return true;
      }
    }
  };
  function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i5 = 0; i5 < keys.length; i5++) {
      const anim = animations[keys[i5]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options = target.options;
    if (!options) {
      target.options = newOptions;
      return;
    }
    if (options.$shared) {
      target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
    }
    return options;
  }
  function scaleClip(scale2, allowedOverflow) {
    const opts = scale2 && scale2.options || {};
    const reverse = opts.reverse;
    const min2 = opts.min === void 0 ? allowedOverflow : 0;
    const max2 = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max2 : min2,
      end: reverse ? min2 : max2
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x3 = scaleClip(xScale, allowedOverflow);
    const y2 = scaleClip(yScale, allowedOverflow);
    return {
      top: y2.end,
      right: x3.end,
      bottom: y2.start,
      left: x3.start
    };
  }
  function toClip(value) {
    let t7, r6, b2, l6;
    if (isObject(value)) {
      t7 = value.top;
      r6 = value.right;
      b2 = value.bottom;
      l6 = value.left;
    } else {
      t7 = r6 = b2 = l6 = value;
    }
    return {
      top: t7,
      right: r6,
      bottom: b2,
      left: l6,
      disabled: value === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i5, ilen;
    for (i5 = 0, ilen = metasets.length; i5 < ilen; ++i5) {
      keys.push(metasets[i5].index);
    }
    return keys;
  }
  function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === "single";
    let i5, ilen, datasetIndex, otherValue;
    if (value === null) {
      return;
    }
    for (i5 = 0, ilen = keys.length; i5 < ilen; ++i5) {
      datasetIndex = +keys[i5];
      if (datasetIndex === dsIndex) {
        if (options.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
        value += otherValue;
      }
    }
    return value;
  }
  function convertObjectDataToArray(data) {
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i5, ilen, key;
    for (i5 = 0, ilen = keys.length; i5 < ilen; ++i5) {
      key = keys[i5];
      adata[i5] = {
        x: key,
        y: data[key]
      };
    }
    return adata;
  }
  function isStacked(scale2, meta) {
    const stacked = scale2 && scale2.options.stacked;
    return stacked || stacked === void 0 && meta.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale2) {
    const { min: min2, max: max2, minDefined, maxDefined } = scale2.getUserBounds();
    return {
      min: minDefined ? min2 : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max2 : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value = stack[meta.index];
      if (positive && value > 0 || !positive && value < 0) {
        return meta.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i5 = 0; i5 < ilen; ++i5) {
      const item = parsed[i5];
      const { [iAxis]: index2, [vAxis]: value } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
      stack[datasetIndex] = value;
      stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales2 = chart.scales;
    return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index2) {
    return createContext5(
      parent,
      {
        active: false,
        dataset: void 0,
        datasetIndex: index2,
        index: index2,
        mode: "default",
        type: "dataset"
      }
    );
  }
  function createDataContext(parent, index2, element) {
    return createContext5(parent, {
      active: false,
      dataIndex: index2,
      parsed: void 0,
      raw: void 0,
      element,
      index: index2,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
    }
  }
  var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
  var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
  var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart, true), values: null };
  var DatasetController = class {
    constructor(chart, datasetIndex) {
      this.chart = chart;
      this._ctx = chart.ctx;
      this.index = datasetIndex;
      this._cachedDataOpts = {};
      this._cachedMeta = this.getMeta();
      this._type = this._cachedMeta.type;
      this.options = void 0;
      this._parsing = false;
      this._data = void 0;
      this._objectData = void 0;
      this._sharedOptions = void 0;
      this._drawStart = void 0;
      this._drawCount = void 0;
      this.enableOptionSharing = false;
      this.supportsDecimation = false;
      this.$context = void 0;
      this._syncList = [];
      this.initialize();
    }
    initialize() {
      const meta = this._cachedMeta;
      this.configure();
      this.linkScales();
      meta._stacked = isStacked(meta.vScale, meta);
      this.addElements();
    }
    updateIndex(datasetIndex) {
      if (this.index !== datasetIndex) {
        clearStacks(this._cachedMeta);
      }
      this.index = datasetIndex;
    }
    linkScales() {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      const chooseId = (axis, x3, y2, r6) => axis === "x" ? x3 : axis === "r" ? r6 : y2;
      const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
      const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
      const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
      const indexAxis = meta.indexAxis;
      const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
      const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
      meta.xScale = this.getScaleForId(xid);
      meta.yScale = this.getScaleForId(yid);
      meta.rScale = this.getScaleForId(rid);
      meta.iScale = this.getScaleForId(iid);
      meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    }
    _getOtherScale(scale2) {
      const meta = this._cachedMeta;
      return scale2 === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const meta = this._cachedMeta;
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
      if (meta._stacked) {
        clearStacks(meta);
      }
    }
    _dataCheck() {
      const dataset = this.getDataset();
      const data = dataset.data || (dataset.data = []);
      const _data = this._data;
      if (isObject(data)) {
        this._data = convertObjectDataToArray(data);
      } else if (_data !== data) {
        if (_data) {
          unlistenArrayEvents(_data, this);
          const meta = this._cachedMeta;
          clearStacks(meta);
          meta._parsed = [];
        }
        if (data && Object.isExtensible(data)) {
          listenArrayEvents(data, this);
        }
        this._syncList = [];
        this._data = data;
      }
    }
    addElements() {
      const meta = this._cachedMeta;
      this._dataCheck();
      if (this.datasetElementType) {
        meta.dataset = new this.datasetElementType();
      }
    }
    buildOrUpdateElements(resetNewElements) {
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      let stackChanged = false;
      this._dataCheck();
      const oldStacked = meta._stacked;
      meta._stacked = isStacked(meta.vScale, meta);
      if (meta.stack !== dataset.stack) {
        stackChanged = true;
        clearStacks(meta);
        meta.stack = dataset.stack;
      }
      this._resyncElements(resetNewElements);
      if (stackChanged || oldStacked !== meta._stacked) {
        updateStacks(this, meta._parsed);
      }
    }
    configure() {
      const config = this.chart.config;
      const scopeKeys = config.datasetScopeKeys(this._type);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
      this.options = config.createResolver(scopes, this.getContext());
      this._parsing = this.options.parsing;
      this._cachedDataOpts = {};
    }
    parse(start3, count) {
      const { _cachedMeta: meta, _data: data } = this;
      const { iScale, _stacked } = meta;
      const iAxis = iScale.axis;
      let sorted = start3 === 0 && count === data.length ? true : meta._sorted;
      let prev = start3 > 0 && meta._parsed[start3 - 1];
      let i5, cur, parsed;
      if (this._parsing === false) {
        meta._parsed = data;
        meta._sorted = true;
        parsed = data;
      } else {
        if (isArray(data[start3])) {
          parsed = this.parseArrayData(meta, data, start3, count);
        } else if (isObject(data[start3])) {
          parsed = this.parseObjectData(meta, data, start3, count);
        } else {
          parsed = this.parsePrimitiveData(meta, data, start3, count);
        }
        const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
        for (i5 = 0; i5 < count; ++i5) {
          meta._parsed[i5 + start3] = cur = parsed[i5];
          if (sorted) {
            if (isNotInOrderComparedToPrev()) {
              sorted = false;
            }
            prev = cur;
          }
        }
        meta._sorted = sorted;
      }
      if (_stacked) {
        updateStacks(this, parsed);
      }
    }
    parsePrimitiveData(meta, data, start3, count) {
      const { iScale, vScale } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = new Array(count);
      let i5, ilen, index2;
      for (i5 = 0, ilen = count; i5 < ilen; ++i5) {
        index2 = i5 + start3;
        parsed[i5] = {
          [iAxis]: singleScale || iScale.parse(labels[index2], index2),
          [vAxis]: vScale.parse(data[index2], index2)
        };
      }
      return parsed;
    }
    parseArrayData(meta, data, start3, count) {
      const { xScale, yScale } = meta;
      const parsed = new Array(count);
      let i5, ilen, index2, item;
      for (i5 = 0, ilen = count; i5 < ilen; ++i5) {
        index2 = i5 + start3;
        item = data[index2];
        parsed[i5] = {
          x: xScale.parse(item[0], index2),
          y: yScale.parse(item[1], index2)
        };
      }
      return parsed;
    }
    parseObjectData(meta, data, start3, count) {
      const { xScale, yScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const parsed = new Array(count);
      let i5, ilen, index2, item;
      for (i5 = 0, ilen = count; i5 < ilen; ++i5) {
        index2 = i5 + start3;
        item = data[index2];
        parsed[i5] = {
          x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
          y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
        };
      }
      return parsed;
    }
    getParsed(index2) {
      return this._cachedMeta._parsed[index2];
    }
    getDataElement(index2) {
      return this._cachedMeta.data[index2];
    }
    applyStack(scale2, parsed, mode) {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const value = parsed[scale2.axis];
      const stack = {
        keys: getSortedDatasetIndices(chart, true),
        values: parsed._stacks[scale2.axis]
      };
      return applyStack(stack, value, meta.index, { mode });
    }
    updateRangeFromParsed(range, scale2, parsed, stack) {
      const parsedValue = parsed[scale2.axis];
      let value = parsedValue === null ? NaN : parsedValue;
      const values = stack && parsed._stacks[scale2.axis];
      if (stack && values) {
        stack.values = values;
        value = applyStack(stack, parsedValue, this._cachedMeta.index);
      }
      range.min = Math.min(range.min, value);
      range.max = Math.max(range.max, value);
    }
    getMinMax(scale2, canStack) {
      const meta = this._cachedMeta;
      const _parsed = meta._parsed;
      const sorted = meta._sorted && scale2 === meta.iScale;
      const ilen = _parsed.length;
      const otherScale = this._getOtherScale(scale2);
      const stack = createStack(canStack, meta, this.chart);
      const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
      const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
      let i5, parsed;
      function _skip() {
        parsed = _parsed[i5];
        const otherValue = parsed[otherScale.axis];
        return !isNumberFinite(parsed[scale2.axis]) || otherMin > otherValue || otherMax < otherValue;
      }
      for (i5 = 0; i5 < ilen; ++i5) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale2, parsed, stack);
        if (sorted) {
          break;
        }
      }
      if (sorted) {
        for (i5 = ilen - 1; i5 >= 0; --i5) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range, scale2, parsed, stack);
          break;
        }
      }
      return range;
    }
    getAllParsedValues(scale2) {
      const parsed = this._cachedMeta._parsed;
      const values = [];
      let i5, ilen, value;
      for (i5 = 0, ilen = parsed.length; i5 < ilen; ++i5) {
        value = parsed[i5][scale2.axis];
        if (isNumberFinite(value)) {
          values.push(value);
        }
      }
      return values;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
        value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
      };
    }
    _update(mode) {
      const meta = this._cachedMeta;
      this.update(mode || "default");
      meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {
    }
    draw() {
      const ctx = this._ctx;
      const chart = this.chart;
      const meta = this._cachedMeta;
      const elements2 = meta.data || [];
      const area = chart.chartArea;
      const active = [];
      const start3 = this._drawStart || 0;
      const count = this._drawCount || elements2.length - start3;
      const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
      let i5;
      if (meta.dataset) {
        meta.dataset.draw(ctx, area, start3, count);
      }
      for (i5 = start3; i5 < start3 + count; ++i5) {
        const element = elements2[i5];
        if (element.hidden) {
          continue;
        }
        if (element.active && drawActiveElementsOnTop) {
          active.push(element);
        } else {
          element.draw(ctx, area);
        }
      }
      for (i5 = 0; i5 < active.length; ++i5) {
        active[i5].draw(ctx, area);
      }
    }
    getStyle(index2, active) {
      const mode = active ? "active" : "default";
      return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
    }
    getContext(index2, active, mode) {
      const dataset = this.getDataset();
      let context;
      if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
        const element = this._cachedMeta.data[index2];
        context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
        context.parsed = this.getParsed(index2);
        context.raw = dataset.data[index2];
        context.index = context.dataIndex = index2;
      } else {
        context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
        context.dataset = dataset;
        context.index = context.datasetIndex = this.index;
      }
      context.active = !!active;
      context.mode = mode;
      return context;
    }
    resolveDatasetElementOptions(mode) {
      return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index2, mode) {
      return this._resolveElementOptions(this.dataElementType.id, mode, index2);
    }
    _resolveElementOptions(elementType, mode = "default", index2) {
      const active = mode === "active";
      const cache = this._cachedDataOpts;
      const cacheKey = elementType + "-" + mode;
      const cached = cache[cacheKey];
      const sharing = this.enableOptionSharing && defined(index2);
      if (cached) {
        return cloneIfNotShared(cached, sharing);
      }
      const config = this.chart.config;
      const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
      const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      const names2 = Object.keys(defaults.elements[elementType]);
      const context = () => this.getContext(index2, active);
      const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
      if (values.$shared) {
        values.$shared = sharing;
        cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
      }
      return values;
    }
    _resolveAnimations(index2, transition, active) {
      const chart = this.chart;
      const cache = this._cachedDataOpts;
      const cacheKey = `animation-${transition}`;
      const cached = cache[cacheKey];
      if (cached) {
        return cached;
      }
      let options;
      if (chart.options.animation !== false) {
        const config = this.chart.config;
        const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        options = config.createResolver(scopes, this.getContext(index2, active, transition));
      }
      const animations = new Animations(chart, options && options.animations);
      if (options && options._cacheable) {
        cache[cacheKey] = Object.freeze(animations);
      }
      return animations;
    }
    getSharedOptions(options) {
      if (!options.$shared) {
        return;
      }
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
      return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start3, mode) {
      const firstOpts = this.resolveDataElementOptions(start3, mode);
      const previouslySharedOptions = this._sharedOptions;
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
      return { sharedOptions, includeOptions };
    }
    updateElement(element, index2, properties, mode) {
      if (isDirectUpdateMode(mode)) {
        Object.assign(element, properties);
      } else {
        this._resolveAnimations(index2, mode).update(element, properties);
      }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
      if (sharedOptions && !isDirectUpdateMode(mode)) {
        this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
      }
    }
    _setStyle(element, index2, mode, active) {
      element.active = active;
      const options = this.getStyle(index2, active);
      this._resolveAnimations(index2, mode, active).update(element, {
        options: !active && this.getSharedOptions(options) || options
      });
    }
    removeHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", false);
    }
    setHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", true);
    }
    _removeDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", false);
      }
    }
    _setDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", true);
      }
    }
    _resyncElements(resetNewElements) {
      const data = this._data;
      const elements2 = this._cachedMeta.data;
      for (const [method, arg1, arg2] of this._syncList) {
        this[method](arg1, arg2);
      }
      this._syncList = [];
      const numMeta = elements2.length;
      const numData = data.length;
      const count = Math.min(numData, numMeta);
      if (count) {
        this.parse(0, count);
      }
      if (numData > numMeta) {
        this._insertElements(numMeta, numData - numMeta, resetNewElements);
      } else if (numData < numMeta) {
        this._removeElements(numData, numMeta - numData);
      }
    }
    _insertElements(start3, count, resetNewElements = true) {
      const meta = this._cachedMeta;
      const data = meta.data;
      const end2 = start3 + count;
      let i5;
      const move = (arr) => {
        arr.length += count;
        for (i5 = arr.length - 1; i5 >= end2; i5--) {
          arr[i5] = arr[i5 - count];
        }
      };
      move(data);
      for (i5 = start3; i5 < end2; ++i5) {
        data[i5] = new this.dataElementType();
      }
      if (this._parsing) {
        move(meta._parsed);
      }
      this.parse(start3, count);
      if (resetNewElements) {
        this.updateElements(data, start3, count, "reset");
      }
    }
    updateElements(element, start3, count, mode) {
    }
    _removeElements(start3, count) {
      const meta = this._cachedMeta;
      if (this._parsing) {
        const removed = meta._parsed.splice(start3, count);
        if (meta._stacked) {
          clearStacks(meta, removed);
        }
      }
      meta.data.splice(start3, count);
    }
    _sync(args) {
      if (this._parsing) {
        this._syncList.push(args);
      } else {
        const [method, arg1, arg2] = args;
        this[method](arg1, arg2);
      }
      this.chart._dataChanges.push([this.index, ...args]);
    }
    _onDataPush() {
      const count = arguments.length;
      this._sync(["_insertElements", this.getDataset().data.length - count, count]);
    }
    _onDataPop() {
      this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
    }
    _onDataShift() {
      this._sync(["_removeElements", 0, 1]);
    }
    _onDataSplice(start3, count) {
      if (count) {
        this._sync(["_removeElements", start3, count]);
      }
      const newCount = arguments.length - 2;
      if (newCount) {
        this._sync(["_insertElements", start3, newCount]);
      }
    }
    _onDataUnshift() {
      this._sync(["_insertElements", 0, arguments.length]);
    }
  };
  DatasetController.defaults = {};
  DatasetController.prototype.datasetElementType = null;
  DatasetController.prototype.dataElementType = null;
  function getAllScaleValues(scale2, type) {
    if (!scale2._cache.$bar) {
      const visibleMetas = scale2.getMatchingVisibleMetas(type);
      let values = [];
      for (let i5 = 0, ilen = visibleMetas.length; i5 < ilen; i5++) {
        values = values.concat(visibleMetas[i5].controller.getAllParsedValues(scale2));
      }
      scale2._cache.$bar = _arrayUnique(values.sort((a3, b2) => a3 - b2));
    }
    return scale2._cache.$bar;
  }
  function computeMinSampleSize(meta) {
    const scale2 = meta.iScale;
    const values = getAllScaleValues(scale2, meta.type);
    let min2 = scale2._length;
    let i5, ilen, curr, prev;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev)) {
        min2 = Math.min(min2, Math.abs(curr - prev) || min2);
      }
      prev = curr;
    };
    for (i5 = 0, ilen = values.length; i5 < ilen; ++i5) {
      curr = scale2.getPixelForValue(values[i5]);
      updateMinAndPrev();
    }
    prev = void 0;
    for (i5 = 0, ilen = scale2.ticks.length; i5 < ilen; ++i5) {
      curr = scale2.getPixelForTick(i5);
      updateMinAndPrev();
    }
    return min2;
  }
  function computeFitCategoryTraits(index2, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
      size = ruler.min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      size = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size / stackCount,
      ratio,
      start: ruler.pixels[index2] - size / 2
    };
  }
  function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index2];
    let prev = index2 > 0 ? pixels[index2 - 1] : null;
    let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      next = curr + curr - prev;
    }
    const start3 = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size / stackCount,
      ratio: options.barPercentage,
      start: start3
    };
  }
  function parseFloatBar(entry, item, vScale, i5) {
    const startValue = vScale.parse(entry[0], i5);
    const endValue = vScale.parse(entry[1], i5);
    const min2 = Math.min(startValue, endValue);
    const max2 = Math.max(startValue, endValue);
    let barStart = min2;
    let barEnd = max2;
    if (Math.abs(min2) > Math.abs(max2)) {
      barStart = max2;
      barEnd = min2;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min: min2,
      max: max2
    };
  }
  function parseValue(entry, item, vScale, i5) {
    if (isArray(entry)) {
      parseFloatBar(entry, item, vScale, i5);
    } else {
      item[vScale.axis] = vScale.parse(entry, i5);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta, data, start3, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i5, ilen, item, entry;
    for (i5 = start3, ilen = start3 + count; i5 < ilen; ++i5) {
      entry = data[i5];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i5], i5);
      parsed.push(parseValue(entry, item, vScale, i5));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size, vScale, actualBase) {
    if (size !== 0) {
      return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start3, end2, top2, bottom2;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start3 = "left";
      end2 = "right";
    } else {
      reverse = properties.base < properties.y;
      start3 = "bottom";
      end2 = "top";
    }
    if (reverse) {
      top2 = "end";
      bottom2 = "start";
    } else {
      top2 = "start";
      bottom2 = "end";
    }
    return { start: start3, end: end2, reverse, top: top2, bottom: bottom2 };
  }
  function setBorderSkipped(properties, options, stack, index2) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = { top: true, right: true, bottom: true, left: true };
      return;
    }
    const { start: start3, end: end2, reverse, top: top2, bottom: bottom2 } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index2) {
        edge = top2;
      } else if ((stack._bottom || 0) === index2) {
        edge = bottom2;
      } else {
        res[parseEdge(bottom2, start3, end2, reverse)] = true;
        edge = top2;
      }
    }
    res[parseEdge(edge, start3, end2, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a3, b2, reverse) {
    if (reverse) {
      edge = swap(edge, a3, b2);
      edge = startEnd(edge, b2, a3);
    } else {
      edge = startEnd(edge, a3, b2);
    }
    return edge;
  }
  function swap(orig, v1, v22) {
    return orig === v1 ? v22 : orig === v22 ? v1 : orig;
  }
  function startEnd(v3, start3, end2) {
    return v3 === "start" ? start3 : v3 === "end" ? end2 : v3;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  var BarController = class extends DatasetController {
    parsePrimitiveData(meta, data, start3, count) {
      return parseArrayOrPrimitive(meta, data, start3, count);
    }
    parseArrayData(meta, data, start3, count) {
      return parseArrayOrPrimitive(meta, data, start3, count);
    }
    parseObjectData(meta, data, start3, count) {
      const { iScale, vScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
      const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
      const parsed = [];
      let i5, ilen, item, obj;
      for (i5 = start3, ilen = start3 + count; i5 < ilen; ++i5) {
        obj = data[i5];
        item = {};
        item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i5);
        parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i5));
      }
      return parsed;
    }
    updateRangeFromParsed(range, scale2, parsed, stack) {
      super.updateRangeFromParsed(range, scale2, parsed, stack);
      const custom = parsed._custom;
      if (custom && scale2 === this._cachedMeta.vScale) {
        range.min = Math.min(range.min, custom.min);
        range.max = Math.max(range.max, custom.max);
      }
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const { iScale, vScale } = meta;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
      return {
        label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
        value
      };
    }
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
      const meta = this._cachedMeta;
      meta.stack = this.getDataset().stack;
    }
    update(mode) {
      const meta = this._cachedMeta;
      this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start3, count, mode) {
      const reset = mode === "reset";
      const { index: index2, _cachedMeta: { vScale } } = this;
      const base = vScale.getBasePixel();
      const horizontal = vScale.isHorizontal();
      const ruler = this._getRuler();
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      for (let i5 = start3; i5 < start3 + count; i5++) {
        const parsed = this.getParsed(i5);
        const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i5);
        const ipixels = this._calculateBarIndexPixels(i5, ruler);
        const stack = (parsed._stacks || {})[vScale.axis];
        const properties = {
          horizontal,
          base: vpixels.base,
          enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index2 === stack._top || index2 === stack._bottom),
          x: horizontal ? vpixels.head : ipixels.center,
          y: horizontal ? ipixels.center : vpixels.head,
          height: horizontal ? ipixels.size : Math.abs(vpixels.size),
          width: horizontal ? Math.abs(vpixels.size) : ipixels.size
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i5, bars[i5].active ? "active" : mode);
        }
        const options = properties.options || bars[i5].options;
        setBorderSkipped(properties, options, stack, index2);
        setInflateAmount(properties, options, ruler.ratio);
        this.updateElement(bars[i5], i5, properties, mode);
      }
    }
    _getStacks(last2, dataIndex) {
      const { iScale } = this._cachedMeta;
      const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
      const stacked = iScale.options.stacked;
      const stacks = [];
      const skipNull = (meta) => {
        const parsed = meta.controller.getParsed(dataIndex);
        const val = parsed && parsed[meta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          return true;
        }
      };
      for (const meta of metasets) {
        if (dataIndex !== void 0 && skipNull(meta)) {
          continue;
        }
        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
          stacks.push(meta.stack);
        }
        if (meta.index === last2) {
          break;
        }
      }
      if (!stacks.length) {
        stacks.push(void 0);
      }
      return stacks;
    }
    _getStackCount(index2) {
      return this._getStacks(void 0, index2).length;
    }
    _getStackIndex(datasetIndex, name, dataIndex) {
      const stacks = this._getStacks(datasetIndex, dataIndex);
      const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
      return index2 === -1 ? stacks.length - 1 : index2;
    }
    _getRuler() {
      const opts = this.options;
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const pixels = [];
      let i5, ilen;
      for (i5 = 0, ilen = meta.data.length; i5 < ilen; ++i5) {
        pixels.push(iScale.getPixelForValue(this.getParsed(i5)[iScale.axis], i5));
      }
      const barThickness = opts.barThickness;
      const min2 = barThickness || computeMinSampleSize(meta);
      return {
        min: min2,
        pixels,
        start: iScale._startPixel,
        end: iScale._endPixel,
        stackCount: this._getStackCount(),
        scale: iScale,
        grouped: opts.grouped,
        ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
      };
    }
    _calculateBarValuePixels(index2) {
      const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
      const actualBase = baseValue || 0;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const floating = isFloatBar(custom);
      let value = parsed[vScale.axis];
      let start3 = 0;
      let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
      let head, size;
      if (length !== value) {
        start3 = length - value;
        length = value;
      }
      if (floating) {
        value = custom.barStart;
        length = custom.barEnd - custom.barStart;
        if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
          start3 = 0;
        }
        start3 += value;
      }
      const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start3;
      let base = vScale.getPixelForValue(startValue);
      if (this.chart.getDataVisibility(index2)) {
        head = vScale.getPixelForValue(start3 + length);
      } else {
        head = base;
      }
      size = head - base;
      if (Math.abs(size) < minBarLength) {
        size = barSign(size, vScale, actualBase) * minBarLength;
        if (value === actualBase) {
          base -= size / 2;
        }
        const startPixel = vScale.getPixelForDecimal(0);
        const endPixel = vScale.getPixelForDecimal(1);
        const min2 = Math.min(startPixel, endPixel);
        const max2 = Math.max(startPixel, endPixel);
        base = Math.max(Math.min(base, max2), min2);
        head = base + size;
      }
      if (base === vScale.getPixelForValue(actualBase)) {
        const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
        base += halfGrid;
        size -= halfGrid;
      }
      return {
        size,
        base,
        head,
        center: head + size / 2
      };
    }
    _calculateBarIndexPixels(index2, ruler) {
      const scale2 = ruler.scale;
      const options = this.options;
      const skipNull = options.skipNull;
      const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
      let center, size;
      if (ruler.grouped) {
        const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
        const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
        const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
        center = range.start + range.chunk * stackIndex + range.chunk / 2;
        size = Math.min(maxBarThickness, range.chunk * range.ratio);
      } else {
        center = scale2.getPixelForValue(this.getParsed(index2)[scale2.axis], index2);
        size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
      }
      return {
        base: center - size / 2,
        head: center + size / 2,
        center,
        size
      };
    }
    draw() {
      const meta = this._cachedMeta;
      const vScale = meta.vScale;
      const rects = meta.data;
      const ilen = rects.length;
      let i5 = 0;
      for (; i5 < ilen; ++i5) {
        if (this.getParsed(i5)[vScale.axis] !== null) {
          rects[i5].draw(this._ctx);
        }
      }
    }
  };
  BarController.id = "bar";
  BarController.defaults = {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "base", "width", "height"]
      }
    }
  };
  BarController.overrides = {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  };
  var BubbleController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
    }
    parsePrimitiveData(meta, data, start3, count) {
      const parsed = super.parsePrimitiveData(meta, data, start3, count);
      for (let i5 = 0; i5 < parsed.length; i5++) {
        parsed[i5]._custom = this.resolveDataElementOptions(i5 + start3).radius;
      }
      return parsed;
    }
    parseArrayData(meta, data, start3, count) {
      const parsed = super.parseArrayData(meta, data, start3, count);
      for (let i5 = 0; i5 < parsed.length; i5++) {
        const item = data[start3 + i5];
        parsed[i5]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i5 + start3).radius);
      }
      return parsed;
    }
    parseObjectData(meta, data, start3, count) {
      const parsed = super.parseObjectData(meta, data, start3, count);
      for (let i5 = 0; i5 < parsed.length; i5++) {
        const item = data[start3 + i5];
        parsed[i5]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i5 + start3).radius);
      }
      return parsed;
    }
    getMaxOverflow() {
      const data = this._cachedMeta.data;
      let max2 = 0;
      for (let i5 = data.length - 1; i5 >= 0; --i5) {
        max2 = Math.max(max2, data[i5].size(this.resolveDataElementOptions(i5)) / 2);
      }
      return max2 > 0 && max2;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x3 = xScale.getLabelForValue(parsed.x);
      const y2 = yScale.getLabelForValue(parsed.y);
      const r6 = parsed._custom;
      return {
        label: meta.label,
        value: "(" + x3 + ", " + y2 + (r6 ? ", " + r6 : "") + ")"
      };
    }
    update(mode) {
      const points = this._cachedMeta.data;
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start3, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      for (let i5 = start3; i5 < start3 + count; i5++) {
        const point = points[i5];
        const parsed = !reset && this.getParsed(i5);
        const properties = {};
        const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
        const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
        properties.skip = isNaN(iPixel) || isNaN(vPixel);
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i5, point.active ? "active" : mode);
          if (reset) {
            properties.options.radius = 0;
          }
        }
        this.updateElement(point, i5, properties, mode);
      }
    }
    resolveDataElementOptions(index2, mode) {
      const parsed = this.getParsed(index2);
      let values = super.resolveDataElementOptions(index2, mode);
      if (values.$shared) {
        values = Object.assign({}, values, { $shared: false });
      }
      const radius = values.radius;
      if (mode !== "active") {
        values.radius = 0;
      }
      values.radius += valueOrDefault(parsed && parsed._custom, radius);
      return values;
    }
  };
  BubbleController.id = "bubble";
  BubbleController.defaults = {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "borderWidth", "radius"]
      }
    }
  };
  BubbleController.overrides = {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    },
    plugins: {
      tooltip: {
        callbacks: {
          title() {
            return "";
          }
        }
      }
    }
  };
  function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
      const startAngle = rotation;
      const endAngle = startAngle + circumference;
      const startX = Math.cos(startAngle);
      const startY = Math.sin(startAngle);
      const endX = Math.cos(endAngle);
      const endY = Math.sin(endAngle);
      const calcMax = (angle, a3, b2) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a3, a3 * cutout, b2, b2 * cutout);
      const calcMin = (angle, a3, b2) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a3, a3 * cutout, b2, b2 * cutout);
      const maxX = calcMax(0, startX, endX);
      const maxY = calcMax(HALF_PI, startY, endY);
      const minX = calcMin(PI, startX, endX);
      const minY = calcMin(PI + HALF_PI, startY, endY);
      ratioX = (maxX - minX) / 2;
      ratioY = (maxY - minY) / 2;
      offsetX = -(maxX + minX) / 2;
      offsetY = -(maxY + minY) / 2;
    }
    return { ratioX, ratioY, offsetX, offsetY };
  }
  var DoughnutController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.enableOptionSharing = true;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.offsetX = void 0;
      this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(start3, count) {
      const data = this.getDataset().data;
      const meta = this._cachedMeta;
      if (this._parsing === false) {
        meta._parsed = data;
      } else {
        let getter = (i6) => +data[i6];
        if (isObject(data[start3])) {
          const { key = "value" } = this._parsing;
          getter = (i6) => +resolveObjectKey(data[i6], key);
        }
        let i5, ilen;
        for (i5 = start3, ilen = start3 + count; i5 < ilen; ++i5) {
          meta._parsed[i5] = getter(i5);
        }
      }
    }
    _getRotation() {
      return toRadians(this.options.rotation - 90);
    }
    _getCircumference() {
      return toRadians(this.options.circumference);
    }
    _getRotationExtents() {
      let min2 = TAU;
      let max2 = -TAU;
      for (let i5 = 0; i5 < this.chart.data.datasets.length; ++i5) {
        if (this.chart.isDatasetVisible(i5)) {
          const controller = this.chart.getDatasetMeta(i5).controller;
          const rotation = controller._getRotation();
          const circumference = controller._getCircumference();
          min2 = Math.min(min2, rotation);
          max2 = Math.max(max2, rotation + circumference);
        }
      }
      return {
        rotation: min2,
        circumference: max2 - min2
      };
    }
    update(mode) {
      const chart = this.chart;
      const { chartArea } = chart;
      const meta = this._cachedMeta;
      const arcs = meta.data;
      const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
      const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
      const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
      const chartWeight = this._getRingWeight(this.index);
      const { circumference, rotation } = this._getRotationExtents();
      const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
      const maxWidth = (chartArea.width - spacing) / ratioX;
      const maxHeight = (chartArea.height - spacing) / ratioY;
      const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
      const outerRadius = toDimension(this.options.radius, maxRadius);
      const innerRadius = Math.max(outerRadius * cutout, 0);
      const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
      this.offsetX = offsetX * outerRadius;
      this.offsetY = offsetY * outerRadius;
      meta.total = this.calculateTotal();
      this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
      this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i5, reset) {
      const opts = this.options;
      const meta = this._cachedMeta;
      const circumference = this._getCircumference();
      if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i5) || meta._parsed[i5] === null || meta.data[i5].hidden) {
        return 0;
      }
      return this.calculateCircumference(meta._parsed[i5] * circumference / TAU);
    }
    updateElements(arcs, start3, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const centerX = (chartArea.left + chartArea.right) / 2;
      const centerY = (chartArea.top + chartArea.bottom) / 2;
      const animateScale = reset && animationOpts.animateScale;
      const innerRadius = animateScale ? 0 : this.innerRadius;
      const outerRadius = animateScale ? 0 : this.outerRadius;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      let startAngle = this._getRotation();
      let i5;
      for (i5 = 0; i5 < start3; ++i5) {
        startAngle += this._circumference(i5, reset);
      }
      for (i5 = start3; i5 < start3 + count; ++i5) {
        const circumference = this._circumference(i5, reset);
        const arc = arcs[i5];
        const properties = {
          x: centerX + this.offsetX,
          y: centerY + this.offsetY,
          startAngle,
          endAngle: startAngle + circumference,
          circumference,
          outerRadius,
          innerRadius
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i5, arc.active ? "active" : mode);
        }
        startAngle += circumference;
        this.updateElement(arc, i5, properties, mode);
      }
    }
    calculateTotal() {
      const meta = this._cachedMeta;
      const metaData = meta.data;
      let total = 0;
      let i5;
      for (i5 = 0; i5 < metaData.length; i5++) {
        const value = meta._parsed[i5];
        if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i5) && !metaData[i5].hidden) {
          total += Math.abs(value);
        }
      }
      return total;
    }
    calculateCircumference(value) {
      const total = this._cachedMeta.total;
      if (total > 0 && !isNaN(value)) {
        return TAU * (Math.abs(value) / total);
      }
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2], chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    getMaxBorderWidth(arcs) {
      let max2 = 0;
      const chart = this.chart;
      let i5, ilen, meta, controller, options;
      if (!arcs) {
        for (i5 = 0, ilen = chart.data.datasets.length; i5 < ilen; ++i5) {
          if (chart.isDatasetVisible(i5)) {
            meta = chart.getDatasetMeta(i5);
            arcs = meta.data;
            controller = meta.controller;
            break;
          }
        }
      }
      if (!arcs) {
        return 0;
      }
      for (i5 = 0, ilen = arcs.length; i5 < ilen; ++i5) {
        options = controller.resolveDataElementOptions(i5);
        if (options.borderAlign !== "inner") {
          max2 = Math.max(max2, options.borderWidth || 0, options.hoverBorderWidth || 0);
        }
      }
      return max2;
    }
    getMaxOffset(arcs) {
      let max2 = 0;
      for (let i5 = 0, ilen = arcs.length; i5 < ilen; ++i5) {
        const options = this.resolveDataElementOptions(i5);
        max2 = Math.max(max2, options.offset || 0, options.hoverOffset || 0);
      }
      return max2;
    }
    _getRingWeightOffset(datasetIndex) {
      let ringWeightOffset = 0;
      for (let i5 = 0; i5 < datasetIndex; ++i5) {
        if (this.chart.isDatasetVisible(i5)) {
          ringWeightOffset += this._getRingWeight(i5);
        }
      }
      return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
      return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  };
  DoughnutController.id = "doughnut";
  DoughnutController.defaults = {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  };
  DoughnutController.descriptors = {
    _scriptable: (name) => name !== "spacing",
    _indexable: (name) => name !== "spacing"
  };
  DoughnutController.overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle } } = chart.legend.options;
              return data.labels.map((label, i5) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i5);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i5),
                  index: i5
                };
              });
            }
            return [];
          }
        },
        onClick(e3, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      },
      tooltip: {
        callbacks: {
          title() {
            return "";
          },
          label(tooltipItem) {
            let dataLabel = tooltipItem.label;
            const value = ": " + tooltipItem.formattedValue;
            if (isArray(dataLabel)) {
              dataLabel = dataLabel.slice();
              dataLabel[0] += value;
            } else {
              dataLabel += value;
            }
            return dataLabel;
          }
        }
      }
    }
  };
  var LineController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      this.supportsDecimation = true;
      super.initialize();
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { dataset: line, data: points = [], _dataset } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start3, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start3;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start3 = 0;
        count = points.length;
      }
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
      this.updateElements(points, start3, count, mode);
    }
    updateElements(points, start3, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start3, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start3 > 0 && this.getParsed(start3 - 1);
      for (let i5 = start3; i5 < start3 + count; ++i5) {
        const point = points[i5];
        const parsed = this.getParsed(i5);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i5);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i5);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i5 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i5];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i5, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i5, properties, mode);
        }
        prevParsed = parsed;
      }
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      const data = meta.data || [];
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
      const meta = this._cachedMeta;
      meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
      super.draw();
    }
  };
  LineController.id = "line";
  LineController.defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  };
  LineController.overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  var PolarAreaController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.innerRadius = void 0;
      this.outerRadius = void 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    parseObjectData(meta, data, start3, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start3, count);
    }
    update(mode) {
      const arcs = this._cachedMeta.data;
      this._updateRadius();
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    getMinMax() {
      const meta = this._cachedMeta;
      const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
      meta.data.forEach((element, index2) => {
        const parsed = this.getParsed(index2).r;
        if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
          if (parsed < range.min) {
            range.min = parsed;
          }
          if (parsed > range.max) {
            range.max = parsed;
          }
        }
      });
      return range;
    }
    _updateRadius() {
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      const outerRadius = Math.max(minSize / 2, 0);
      const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
      this.outerRadius = outerRadius - radiusLength * this.index;
      this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start3, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const scale2 = this._cachedMeta.rScale;
      const centerX = scale2.xCenter;
      const centerY = scale2.yCenter;
      const datasetStartAngle = scale2.getIndexAngle(0) - 0.5 * PI;
      let angle = datasetStartAngle;
      let i5;
      const defaultAngle = 360 / this.countVisibleElements();
      for (i5 = 0; i5 < start3; ++i5) {
        angle += this._computeAngle(i5, mode, defaultAngle);
      }
      for (i5 = start3; i5 < start3 + count; i5++) {
        const arc = arcs[i5];
        let startAngle = angle;
        let endAngle = angle + this._computeAngle(i5, mode, defaultAngle);
        let outerRadius = chart.getDataVisibility(i5) ? scale2.getDistanceFromCenterForValue(this.getParsed(i5).r) : 0;
        angle = endAngle;
        if (reset) {
          if (animationOpts.animateScale) {
            outerRadius = 0;
          }
          if (animationOpts.animateRotate) {
            startAngle = endAngle = datasetStartAngle;
          }
        }
        const properties = {
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius,
          startAngle,
          endAngle,
          options: this.resolveDataElementOptions(i5, arc.active ? "active" : mode)
        };
        this.updateElement(arc, i5, properties, mode);
      }
    }
    countVisibleElements() {
      const meta = this._cachedMeta;
      let count = 0;
      meta.data.forEach((element, index2) => {
        if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
          count++;
        }
      });
      return count;
    }
    _computeAngle(index2, mode, defaultAngle) {
      return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
    }
  };
  PolarAreaController.id = "polarArea";
  PolarAreaController.defaults = {
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
      }
    },
    indexAxis: "r",
    startAngle: 0
  };
  PolarAreaController.overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle } } = chart.legend.options;
              return data.labels.map((label, i5) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i5);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i5),
                  index: i5
                };
              });
            }
            return [];
          }
        },
        onClick(e3, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      },
      tooltip: {
        callbacks: {
          title() {
            return "";
          },
          label(context) {
            return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
          }
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  };
  var PieController = class extends DoughnutController {
  };
  PieController.id = "pie";
  PieController.defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  };
  var RadarController = class extends DatasetController {
    getLabelAndValue(index2) {
      const vScale = this._cachedMeta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: vScale.getLabels()[index2],
        value: "" + vScale.getLabelForValue(parsed[vScale.axis])
      };
    }
    parseObjectData(meta, data, start3, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start3, count);
    }
    update(mode) {
      const meta = this._cachedMeta;
      const line = meta.dataset;
      const points = meta.data || [];
      const labels = meta.iScale.getLabels();
      line.points = points;
      if (mode !== "resize") {
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        const properties = {
          _loop: true,
          _fullLoop: labels.length === points.length,
          options
        };
        this.updateElement(line, void 0, properties, mode);
      }
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start3, count, mode) {
      const scale2 = this._cachedMeta.rScale;
      const reset = mode === "reset";
      for (let i5 = start3; i5 < start3 + count; i5++) {
        const point = points[i5];
        const options = this.resolveDataElementOptions(i5, point.active ? "active" : mode);
        const pointPosition = scale2.getPointPositionForValue(i5, this.getParsed(i5).r);
        const x3 = reset ? scale2.xCenter : pointPosition.x;
        const y2 = reset ? scale2.yCenter : pointPosition.y;
        const properties = {
          x: x3,
          y: y2,
          angle: pointPosition.angle,
          skip: isNaN(x3) || isNaN(y2),
          options
        };
        this.updateElement(point, i5, properties, mode);
      }
    }
  };
  RadarController.id = "radar";
  RadarController.defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
      line: {
        fill: "start"
      }
    }
  };
  RadarController.overrides = {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  };
  var Element2 = class {
    constructor() {
      this.x = void 0;
      this.y = void 0;
      this.active = false;
      this.options = void 0;
      this.$animations = void 0;
    }
    tooltipPosition(useFinalPosition) {
      const { x: x3, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
      return { x: x3, y: y2 };
    }
    hasValue() {
      return isNumber(this.x) && isNumber(this.y);
    }
    getProps(props, final) {
      const anims = this.$animations;
      if (!final || !anims) {
        return this;
      }
      const ret = {};
      props.forEach((prop) => {
        ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
      });
      return ret;
    }
  };
  Element2.defaults = {};
  Element2.defaultRoutes = void 0;
  var formatters = {
    values(value) {
      return isArray(value) ? value : "" + value;
    },
    numeric(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const locale = this.chart.options.locale;
      let notation;
      let delta = tickValue;
      if (ticks.length > 1) {
        const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
        if (maxTick < 1e-4 || maxTick > 1e15) {
          notation = "scientific";
        }
        delta = calculateDelta(tickValue, ticks);
      }
      const logDelta = log10(Math.abs(delta));
      const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
      const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
      Object.assign(options, this.options.ticks.format);
      return formatNumber(tickValue, locale, options);
    },
    logarithmic(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
      if (remain === 1 || remain === 2 || remain === 5) {
        return formatters.numeric.call(this, tickValue, index2, ticks);
      }
      return "";
    }
  };
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  var Ticks = { formatters };
  defaults.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawBorder: true,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false,
      borderDash: [],
      borderDashOffset: 0,
      borderWidth: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults.route("scale.ticks", "color", "", "color");
  defaults.route("scale.grid", "color", "", "borderColor");
  defaults.route("scale.grid", "borderColor", "", "borderColor");
  defaults.route("scale.title", "color", "", "color");
  defaults.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
  });
  defaults.describe("scales", {
    _fallback: "scale"
  });
  defaults.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
  function autoSkip(scale2, ticks) {
    const tickOpts = scale2.options.ticks;
    const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale2);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last2 = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i5, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last2 - first) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
      for (i5 = 0, ilen = numMajorIndices - 1; i5 < ilen; i5++) {
        skip(ticks, newTicks, spacing, majorIndices[i5], majorIndices[i5 + 1]);
      }
      skip(ticks, newTicks, spacing, last2, isNullOrUndef(avgMajorSpacing) ? ticks.length : last2 + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale2) {
    const offset2 = scale2.options.offset;
    const tickLength = scale2._tickSize();
    const maxScale = scale2._length / tickLength + (offset2 ? 0 : 1);
    const maxChart = scale2._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i5 = 0, ilen = factors.length - 1; i5 < ilen; i5++) {
      const factor = factors[i5];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i5, ilen;
    for (i5 = 0, ilen = ticks.length; i5 < ilen; i5++) {
      if (ticks[i5].major) {
        result.push(i5);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i5;
    spacing = Math.ceil(spacing);
    for (i5 = 0; i5 < ticks.length; i5++) {
      if (i5 === next) {
        newTicks.push(ticks[i5]);
        count++;
        next = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start3 = valueOrDefault(majorStart, 0);
    const end2 = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i5, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length = majorEnd - majorStart;
      spacing = length / Math.floor(length / spacing);
    }
    next = start3;
    while (next < 0) {
      count++;
      next = Math.round(start3 + count * spacing);
    }
    for (i5 = Math.max(start3, 0); i5 < end2; i5++) {
      if (i5 === next) {
        newTicks.push(ticks[i5]);
        count++;
        next = Math.round(start3 + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i5, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i5 = 1; i5 < len; ++i5) {
      if (arr[i5] - arr[i5 - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
  var offsetFromEdge = (scale2, edge, offset2) => edge === "top" || edge === "left" ? scale2[edge] + offset2 : scale2[edge] - offset2;
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i5 = 0;
    for (; i5 < len; i5 += increment) {
      result.push(arr[Math.floor(i5)]);
    }
    return result;
  }
  function getPixelForGridLine(scale2, index2, offsetGridLines) {
    const length = scale2.ticks.length;
    const validIndex2 = Math.min(index2, length - 1);
    const start3 = scale2._startPixel;
    const end2 = scale2._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale2.getPixelForTick(validIndex2);
    let offset2;
    if (offsetGridLines) {
      if (length === 1) {
        offset2 = Math.max(lineValue - start3, end2 - lineValue);
      } else if (index2 === 0) {
        offset2 = (scale2.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset2 = (lineValue - scale2.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index2 ? offset2 : -offset2;
      if (lineValue < start3 - epsilon || lineValue > end2 + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length) {
    each(caches, (cache) => {
      const gc = cache.gc;
      const gcLen = gc.length / 2;
      let i5;
      if (gcLen > length) {
        for (i5 = 0; i5 < gcLen; ++i5) {
          delete cache.data[gc[i5]];
        }
        gc.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
  }
  function getTitleHeight(options, fallback) {
    if (!options.display) {
      return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale2) {
    return createContext5(parent, {
      scale: scale2,
      type: "scale"
    });
  }
  function createTickContext(parent, index2, tick) {
    return createContext5(parent, {
      tick,
      index: index2,
      type: "tick"
    });
  }
  function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position !== "right" || !reverse && position === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale2, offset2, position, align) {
    const { top: top2, left: left2, bottom: bottom2, right: right2, chart } = scale2;
    const { chartArea, scales: scales2 } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom2 - top2;
    const width = right2 - left2;
    if (scale2.isHorizontal()) {
      titleX = _alignStartEnd(align, left2, right2);
      if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset2;
      } else if (position === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset2;
      } else {
        titleY = offsetFromEdge(scale2, position, offset2);
      }
      maxWidth = right2 - left2;
    } else {
      if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset2;
      } else if (position === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset2;
      } else {
        titleX = offsetFromEdge(scale2, position, offset2);
      }
      titleY = _alignStartEnd(align, bottom2, top2);
      rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return { titleX, titleY, maxWidth, rotation };
  }
  var Scale = class _Scale extends Element2 {
    constructor(cfg) {
      super();
      this.id = cfg.id;
      this.type = cfg.type;
      this.options = void 0;
      this.ctx = cfg.ctx;
      this.chart = cfg.chart;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this.maxWidth = void 0;
      this.maxHeight = void 0;
      this.paddingTop = void 0;
      this.paddingBottom = void 0;
      this.paddingLeft = void 0;
      this.paddingRight = void 0;
      this.axis = void 0;
      this.labelRotation = void 0;
      this.min = void 0;
      this.max = void 0;
      this._range = void 0;
      this.ticks = [];
      this._gridLineItems = null;
      this._labelItems = null;
      this._labelSizes = null;
      this._length = 0;
      this._maxLength = 0;
      this._longestTextCache = {};
      this._startPixel = void 0;
      this._endPixel = void 0;
      this._reversePixels = false;
      this._userMax = void 0;
      this._userMin = void 0;
      this._suggestedMax = void 0;
      this._suggestedMin = void 0;
      this._ticksLength = 0;
      this._borderValue = 0;
      this._cache = {};
      this._dataLimitsCached = false;
      this.$context = void 0;
    }
    init(options) {
      this.options = options.setContext(this.getContext());
      this.axis = options.axis;
      this._userMin = this.parse(options.min);
      this._userMax = this.parse(options.max);
      this._suggestedMin = this.parse(options.suggestedMin);
      this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw, index2) {
      return raw;
    }
    getUserBounds() {
      let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
      _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
      _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
      _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
      _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
      return {
        min: finiteOrDefault(_userMin, _suggestedMin),
        max: finiteOrDefault(_userMax, _suggestedMax),
        minDefined: isNumberFinite(_userMin),
        maxDefined: isNumberFinite(_userMax)
      };
    }
    getMinMax(canStack) {
      let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
      let range;
      if (minDefined && maxDefined) {
        return { min: min2, max: max2 };
      }
      const metas = this.getMatchingVisibleMetas();
      for (let i5 = 0, ilen = metas.length; i5 < ilen; ++i5) {
        range = metas[i5].controller.getMinMax(this, canStack);
        if (!minDefined) {
          min2 = Math.min(min2, range.min);
        }
        if (!maxDefined) {
          max2 = Math.max(max2, range.max);
        }
      }
      min2 = maxDefined && min2 > max2 ? max2 : min2;
      max2 = minDefined && min2 > max2 ? min2 : max2;
      return {
        min: finiteOrDefault(min2, finiteOrDefault(max2, min2)),
        max: finiteOrDefault(max2, finiteOrDefault(min2, max2))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
    beforeLayout() {
      this._cache = {};
      this._dataLimitsCached = false;
    }
    beforeUpdate() {
      callback(this.options.beforeUpdate, [this]);
    }
    update(maxWidth, maxHeight, margins) {
      const { beginAtZero, grace, ticks: tickOpts } = this.options;
      const sampleSize = tickOpts.sampleSize;
      this.beforeUpdate();
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      this.ticks = null;
      this._labelSizes = null;
      this._gridLineItems = null;
      this._labelItems = null;
      this.beforeSetDimensions();
      this.setDimensions();
      this.afterSetDimensions();
      this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
      if (!this._dataLimitsCached) {
        this.beforeDataLimits();
        this.determineDataLimits();
        this.afterDataLimits();
        this._range = _addGrace(this, grace, beginAtZero);
        this._dataLimitsCached = true;
      }
      this.beforeBuildTicks();
      this.ticks = this.buildTicks() || [];
      this.afterBuildTicks();
      const samplingEnabled = sampleSize < this.ticks.length;
      this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
      this.configure();
      this.beforeCalculateLabelRotation();
      this.calculateLabelRotation();
      this.afterCalculateLabelRotation();
      if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
        this.ticks = autoSkip(this, this.ticks);
        this._labelSizes = null;
        this.afterAutoSkip();
      }
      if (samplingEnabled) {
        this._convertTicksToLabels(this.ticks);
      }
      this.beforeFit();
      this.fit();
      this.afterFit();
      this.afterUpdate();
    }
    configure() {
      let reversePixels = this.options.reverse;
      let startPixel, endPixel;
      if (this.isHorizontal()) {
        startPixel = this.left;
        endPixel = this.right;
      } else {
        startPixel = this.top;
        endPixel = this.bottom;
        reversePixels = !reversePixels;
      }
      this._startPixel = startPixel;
      this._endPixel = endPixel;
      this._reversePixels = reversePixels;
      this._length = endPixel - startPixel;
      this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      callback(this.options.afterUpdate, [this]);
    }
    beforeSetDimensions() {
      callback(this.options.beforeSetDimensions, [this]);
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = 0;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = 0;
        this.bottom = this.height;
      }
      this.paddingLeft = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
    }
    afterSetDimensions() {
      callback(this.options.afterSetDimensions, [this]);
    }
    _callHooks(name) {
      this.chart.notifyPlugins(name, this.getContext());
      callback(this.options[name], [this]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      callback(this.options.beforeTickToLabelConversion, [this]);
    }
    generateTickLabels(ticks) {
      const tickOpts = this.options.ticks;
      let i5, ilen, tick;
      for (i5 = 0, ilen = ticks.length; i5 < ilen; i5++) {
        tick = ticks[i5];
        tick.label = callback(tickOpts.callback, [tick.value, i5, ticks], this);
      }
    }
    afterTickToLabelConversion() {
      callback(this.options.afterTickToLabelConversion, [this]);
    }
    beforeCalculateLabelRotation() {
      callback(this.options.beforeCalculateLabelRotation, [this]);
    }
    calculateLabelRotation() {
      const options = this.options;
      const tickOpts = options.ticks;
      const numTicks = this.ticks.length;
      const minRotation = tickOpts.minRotation || 0;
      const maxRotation = tickOpts.maxRotation;
      let labelRotation = minRotation;
      let tickWidth, maxHeight, maxLabelDiagonal;
      if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
        this.labelRotation = minRotation;
        return;
      }
      const labelSizes = this._getLabelSizes();
      const maxLabelWidth = labelSizes.widest.width;
      const maxLabelHeight = labelSizes.highest.height;
      const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
      tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
        maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = toDegrees(Math.min(
          Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),
          Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))
        ));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }
      this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
      callback(this.options.afterCalculateLabelRotation, [this]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      callback(this.options.beforeFit, [this]);
    }
    fit() {
      const minSize = {
        width: 0,
        height: 0
      };
      const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
      const display = this._isVisible();
      const isHorizontal = this.isHorizontal();
      if (display) {
        const titleHeight = getTitleHeight(titleOpts, chart.options.font);
        if (isHorizontal) {
          minSize.width = this.maxWidth;
          minSize.height = getTickMarkLength(gridOpts) + titleHeight;
        } else {
          minSize.height = this.maxHeight;
          minSize.width = getTickMarkLength(gridOpts) + titleHeight;
        }
        if (tickOpts.display && this.ticks.length) {
          const { first, last: last2, widest, highest } = this._getLabelSizes();
          const tickPadding = tickOpts.padding * 2;
          const angleRadians = toRadians(this.labelRotation);
          const cos = Math.cos(angleRadians);
          const sin = Math.sin(angleRadians);
          if (isHorizontal) {
            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
          } else {
            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
          }
          this._calculatePadding(first, last2, sin, cos);
        }
      }
      this._handleMargins();
      if (isHorizontal) {
        this.width = this._length = chart.width - this._margins.left - this._margins.right;
        this.height = minSize.height;
      } else {
        this.width = minSize.width;
        this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
      }
    }
    _calculatePadding(first, last2, sin, cos) {
      const { ticks: { align, padding }, position } = this.options;
      const isRotated = this.labelRotation !== 0;
      const labelsBelowTicks = position !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const offsetLeft = this.getPixelForTick(0) - this.left;
        const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
        let paddingLeft = 0;
        let paddingRight = 0;
        if (isRotated) {
          if (labelsBelowTicks) {
            paddingLeft = cos * first.width;
            paddingRight = sin * last2.height;
          } else {
            paddingLeft = sin * first.height;
            paddingRight = cos * last2.width;
          }
        } else if (align === "start") {
          paddingRight = last2.width;
        } else if (align === "end") {
          paddingLeft = first.width;
        } else if (align !== "inner") {
          paddingLeft = first.width / 2;
          paddingRight = last2.width / 2;
        }
        this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
        this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
      } else {
        let paddingTop = last2.height / 2;
        let paddingBottom = first.height / 2;
        if (align === "start") {
          paddingTop = 0;
          paddingBottom = first.height;
        } else if (align === "end") {
          paddingTop = last2.height;
          paddingBottom = 0;
        }
        this.paddingTop = paddingTop + padding;
        this.paddingBottom = paddingBottom + padding;
      }
    }
    _handleMargins() {
      if (this._margins) {
        this._margins.left = Math.max(this.paddingLeft, this._margins.left);
        this._margins.top = Math.max(this.paddingTop, this._margins.top);
        this._margins.right = Math.max(this.paddingRight, this._margins.right);
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
      }
    }
    afterFit() {
      callback(this.options.afterFit, [this]);
    }
    isHorizontal() {
      const { axis, position } = this.options;
      return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
      this.beforeTickToLabelConversion();
      this.generateTickLabels(ticks);
      let i5, ilen;
      for (i5 = 0, ilen = ticks.length; i5 < ilen; i5++) {
        if (isNullOrUndef(ticks[i5].label)) {
          ticks.splice(i5, 1);
          ilen--;
          i5--;
        }
      }
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let labelSizes = this._labelSizes;
      if (!labelSizes) {
        const sampleSize = this.options.ticks.sampleSize;
        let ticks = this.ticks;
        if (sampleSize < ticks.length) {
          ticks = sample(ticks, sampleSize);
        }
        this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
      }
      return labelSizes;
    }
    _computeLabelSizes(ticks, length) {
      const { ctx, _longestTextCache: caches } = this;
      const widths = [];
      const heights = [];
      let widestLabelSize = 0;
      let highestLabelSize = 0;
      let i5, j2, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
      for (i5 = 0; i5 < length; ++i5) {
        label = ticks[i5].label;
        tickFont = this._resolveTickFontOptions(i5);
        ctx.font = fontString = tickFont.string;
        cache = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray(label)) {
          width = _measureText(ctx, cache.data, cache.gc, width, label);
          height = lineHeight;
        } else if (isArray(label)) {
          for (j2 = 0, jlen = label.length; j2 < jlen; ++j2) {
            nestedLabel = label[j2];
            if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
              width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length);
      const widest = widths.indexOf(widestLabelSize);
      const highest = heights.indexOf(highestLabelSize);
      const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
      return {
        first: valueAt(0),
        last: valueAt(length - 1),
        widest: valueAt(widest),
        highest: valueAt(highest),
        widths,
        heights
      };
    }
    getLabelForValue(value) {
      return value;
    }
    getPixelForValue(value, index2) {
      return NaN;
    }
    getValueForPixel(pixel) {
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getPixelForDecimal(decimal) {
      if (this._reversePixels) {
        decimal = 1 - decimal;
      }
      const pixel = this._startPixel + decimal * this._length;
      return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
      const decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min: min2, max: max2 } = this;
      return min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0;
    }
    getContext(index2) {
      const ticks = this.ticks || [];
      if (index2 >= 0 && index2 < ticks.length) {
        const tick = ticks[index2];
        return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
      }
      return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
      const optionTicks = this.options.ticks;
      const rot = toRadians(this.labelRotation);
      const cos = Math.abs(Math.cos(rot));
      const sin = Math.abs(Math.sin(rot));
      const labelSizes = this._getLabelSizes();
      const padding = optionTicks.autoSkipPadding || 0;
      const w3 = labelSizes ? labelSizes.widest.width + padding : 0;
      const h3 = labelSizes ? labelSizes.highest.height + padding : 0;
      return this.isHorizontal() ? h3 * cos > w3 * sin ? w3 / cos : h3 / sin : h3 * sin < w3 * cos ? h3 / cos : w3 / sin;
    }
    _isVisible() {
      const display = this.options.display;
      if (display !== "auto") {
        return !!display;
      }
      return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
      const axis = this.axis;
      const chart = this.chart;
      const options = this.options;
      const { grid, position } = options;
      const offset2 = grid.offset;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const ticksLength = ticks.length + (offset2 ? 1 : 0);
      const tl = getTickMarkLength(grid);
      const items = [];
      const borderOpts = grid.setContext(this.getContext());
      const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
      const axisHalfWidth = axisWidth / 2;
      const alignBorderValue = function(pixel) {
        return _alignPixel(chart, pixel, axisWidth);
      };
      let borderValue, i5, lineValue, alignedLineValue;
      let tx1, ty1, tx2, ty2, x1, y1, x22, y2;
      if (position === "top") {
        borderValue = alignBorderValue(this.bottom);
        ty1 = this.bottom - tl;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y2 = chartArea.bottom;
      } else if (position === "bottom") {
        borderValue = alignBorderValue(this.top);
        y1 = chartArea.top;
        y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = this.top + tl;
      } else if (position === "left") {
        borderValue = alignBorderValue(this.right);
        tx1 = this.right - tl;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x22 = chartArea.right;
      } else if (position === "right") {
        borderValue = alignBorderValue(this.left);
        x1 = chartArea.left;
        x22 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = this.left + tl;
      } else if (axis === "x") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        y1 = chartArea.top;
        y2 = chartArea.bottom;
        ty1 = borderValue + axisHalfWidth;
        ty2 = ty1 + tl;
      } else if (axis === "y") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        tx1 = borderValue - axisHalfWidth;
        tx2 = tx1 - tl;
        x1 = chartArea.left;
        x22 = chartArea.right;
      }
      const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
      const step = Math.max(1, Math.ceil(ticksLength / limit));
      for (i5 = 0; i5 < ticksLength; i5 += step) {
        const optsAtIndex = grid.setContext(this.getContext(i5));
        const lineWidth = optsAtIndex.lineWidth;
        const lineColor = optsAtIndex.color;
        const borderDash = optsAtIndex.borderDash || [];
        const borderDashOffset = optsAtIndex.borderDashOffset;
        const tickWidth = optsAtIndex.tickWidth;
        const tickColor = optsAtIndex.tickColor;
        const tickBorderDash = optsAtIndex.tickBorderDash || [];
        const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
        lineValue = getPixelForGridLine(this, i5, offset2);
        if (lineValue === void 0) {
          continue;
        }
        alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
        if (isHorizontal) {
          tx1 = tx2 = x1 = x22 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y2 = alignedLineValue;
        }
        items.push({
          tx1,
          ty1,
          tx2,
          ty2,
          x1,
          y1,
          x2: x22,
          y2,
          width: lineWidth,
          color: lineColor,
          borderDash,
          borderDashOffset,
          tickWidth,
          tickColor,
          tickBorderDash,
          tickBorderDashOffset
        });
      }
      this._ticksLength = ticksLength;
      this._borderValue = borderValue;
      return items;
    }
    _computeLabelItems(chartArea) {
      const axis = this.axis;
      const options = this.options;
      const { position, ticks: optionTicks } = options;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const { align, crossAlign, padding, mirror } = optionTicks;
      const tl = getTickMarkLength(options.grid);
      const tickAndPadding = tl + padding;
      const hTickAndPadding = mirror ? -padding : tickAndPadding;
      const rotation = -toRadians(this.labelRotation);
      const items = [];
      let i5, ilen, tick, label, x3, y2, textAlign, pixel, font, lineHeight, lineCount, textOffset;
      let textBaseline = "middle";
      if (position === "top") {
        y2 = this.bottom - hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "bottom") {
        y2 = this.top + hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "left") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x3 = ret.x;
      } else if (position === "right") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x3 = ret.x;
      } else if (axis === "x") {
        if (position === "center") {
          y2 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          y2 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
        }
        textAlign = this._getXAxisLabelAlignment();
      } else if (axis === "y") {
        if (position === "center") {
          x3 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
        } else if (isObject(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          x3 = this.chart.scales[positionAxisID].getPixelForValue(value);
        }
        textAlign = this._getYAxisLabelAlignment(tl).textAlign;
      }
      if (axis === "y") {
        if (align === "start") {
          textBaseline = "top";
        } else if (align === "end") {
          textBaseline = "bottom";
        }
      }
      const labelSizes = this._getLabelSizes();
      for (i5 = 0, ilen = ticks.length; i5 < ilen; ++i5) {
        tick = ticks[i5];
        label = tick.label;
        const optsAtIndex = optionTicks.setContext(this.getContext(i5));
        pixel = this.getPixelForTick(i5) + optionTicks.labelOffset;
        font = this._resolveTickFontOptions(i5);
        lineHeight = font.lineHeight;
        lineCount = isArray(label) ? label.length : 1;
        const halfCount = lineCount / 2;
        const color2 = optsAtIndex.color;
        const strokeColor = optsAtIndex.textStrokeColor;
        const strokeWidth = optsAtIndex.textStrokeWidth;
        let tickTextAlign = textAlign;
        if (isHorizontal) {
          x3 = pixel;
          if (textAlign === "inner") {
            if (i5 === ilen - 1) {
              tickTextAlign = !this.options.reverse ? "right" : "left";
            } else if (i5 === 0) {
              tickTextAlign = !this.options.reverse ? "left" : "right";
            } else {
              tickTextAlign = "center";
            }
          }
          if (position === "top") {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = -lineCount * lineHeight + lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
            } else {
              textOffset = -labelSizes.highest.height + lineHeight / 2;
            }
          } else {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
            } else {
              textOffset = labelSizes.highest.height - lineCount * lineHeight;
            }
          }
          if (mirror) {
            textOffset *= -1;
          }
        } else {
          y2 = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }
        let backdrop;
        if (optsAtIndex.showLabelBackdrop) {
          const labelPadding = toPadding(optsAtIndex.backdropPadding);
          const height = labelSizes.heights[i5];
          const width = labelSizes.widths[i5];
          let top2 = y2 + textOffset - labelPadding.top;
          let left2 = x3 - labelPadding.left;
          switch (textBaseline) {
            case "middle":
              top2 -= height / 2;
              break;
            case "bottom":
              top2 -= height;
              break;
          }
          switch (textAlign) {
            case "center":
              left2 -= width / 2;
              break;
            case "right":
              left2 -= width;
              break;
          }
          backdrop = {
            left: left2,
            top: top2,
            width: width + labelPadding.width,
            height: height + labelPadding.height,
            color: optsAtIndex.backdropColor
          };
        }
        items.push({
          rotation,
          label,
          font,
          color: color2,
          strokeColor,
          strokeWidth,
          textOffset,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [x3, y2],
          backdrop
        });
      }
      return items;
    }
    _getXAxisLabelAlignment() {
      const { position, ticks } = this.options;
      const rotation = -toRadians(this.labelRotation);
      if (rotation) {
        return position === "top" ? "left" : "right";
      }
      let align = "center";
      if (ticks.align === "start") {
        align = "left";
      } else if (ticks.align === "end") {
        align = "right";
      } else if (ticks.align === "inner") {
        align = "inner";
      }
      return align;
    }
    _getYAxisLabelAlignment(tl) {
      const { position, ticks: { crossAlign, mirror, padding } } = this.options;
      const labelSizes = this._getLabelSizes();
      const tickAndPadding = tl + padding;
      const widest = labelSizes.widest.width;
      let textAlign;
      let x3;
      if (position === "left") {
        if (mirror) {
          x3 = this.right + padding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x3 += widest / 2;
          } else {
            textAlign = "right";
            x3 += widest;
          }
        } else {
          x3 = this.right - tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x3 -= widest / 2;
          } else {
            textAlign = "left";
            x3 = this.left;
          }
        }
      } else if (position === "right") {
        if (mirror) {
          x3 = this.left + padding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x3 -= widest / 2;
          } else {
            textAlign = "left";
            x3 -= widest;
          }
        } else {
          x3 = this.left + tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x3 += widest / 2;
          } else {
            textAlign = "right";
            x3 = this.right;
          }
        }
      } else {
        textAlign = "right";
      }
      return { textAlign, x: x3 };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) {
        return;
      }
      const chart = this.chart;
      const position = this.options.position;
      if (position === "left" || position === "right") {
        return { top: 0, left: this.left, bottom: chart.height, right: this.right };
      }
      if (position === "top" || position === "bottom") {
        return { top: this.top, left: 0, bottom: this.bottom, right: chart.width };
      }
    }
    drawBackground() {
      const { ctx, options: { backgroundColor }, left: left2, top: top2, width, height } = this;
      if (backgroundColor) {
        ctx.save();
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(left2, top2, width, height);
        ctx.restore();
      }
    }
    getLineWidthForValue(value) {
      const grid = this.options.grid;
      if (!this._isVisible() || !grid.display) {
        return 0;
      }
      const ticks = this.ticks;
      const index2 = ticks.findIndex((t7) => t7.value === value);
      if (index2 >= 0) {
        const opts = grid.setContext(this.getContext(index2));
        return opts.lineWidth;
      }
      return 0;
    }
    drawGrid(chartArea) {
      const grid = this.options.grid;
      const ctx = this.ctx;
      const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
      let i5, ilen;
      const drawLine = (p1, p22, style) => {
        if (!style.width || !style.color) {
          return;
        }
        ctx.save();
        ctx.lineWidth = style.width;
        ctx.strokeStyle = style.color;
        ctx.setLineDash(style.borderDash || []);
        ctx.lineDashOffset = style.borderDashOffset;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p22.x, p22.y);
        ctx.stroke();
        ctx.restore();
      };
      if (grid.display) {
        for (i5 = 0, ilen = items.length; i5 < ilen; ++i5) {
          const item = items[i5];
          if (grid.drawOnChartArea) {
            drawLine(
              { x: item.x1, y: item.y1 },
              { x: item.x2, y: item.y2 },
              item
            );
          }
          if (grid.drawTicks) {
            drawLine(
              { x: item.tx1, y: item.ty1 },
              { x: item.tx2, y: item.ty2 },
              {
                color: item.tickColor,
                width: item.tickWidth,
                borderDash: item.tickBorderDash,
                borderDashOffset: item.tickBorderDashOffset
              }
            );
          }
        }
      }
    }
    drawBorder() {
      const { chart, ctx, options: { grid } } = this;
      const borderOpts = grid.setContext(this.getContext());
      const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
      if (!axisWidth) {
        return;
      }
      const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
      const borderValue = this._borderValue;
      let x1, x22, y1, y2;
      if (this.isHorizontal()) {
        x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
        x22 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
        y1 = y2 = borderValue;
      } else {
        y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
        y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
        x1 = x22 = borderValue;
      }
      ctx.save();
      ctx.lineWidth = borderOpts.borderWidth;
      ctx.strokeStyle = borderOpts.borderColor;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x22, y2);
      ctx.stroke();
      ctx.restore();
    }
    drawLabels(chartArea) {
      const optionTicks = this.options.ticks;
      if (!optionTicks.display) {
        return;
      }
      const ctx = this.ctx;
      const area = this._computeLabelArea();
      if (area) {
        clipArea(ctx, area);
      }
      const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
      let i5, ilen;
      for (i5 = 0, ilen = items.length; i5 < ilen; ++i5) {
        const item = items[i5];
        const tickFont = item.font;
        const label = item.label;
        if (item.backdrop) {
          ctx.fillStyle = item.backdrop.color;
          ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
        }
        let y2 = item.textOffset;
        renderText(ctx, label, 0, y2, tickFont, item);
      }
      if (area) {
        unclipArea(ctx);
      }
    }
    drawTitle() {
      const { ctx, options: { position, title, reverse } } = this;
      if (!title.display) {
        return;
      }
      const font = toFont(title.font);
      const padding = toPadding(title.padding);
      const align = title.align;
      let offset2 = font.lineHeight / 2;
      if (position === "bottom" || position === "center" || isObject(position)) {
        offset2 += padding.bottom;
        if (isArray(title.text)) {
          offset2 += font.lineHeight * (title.text.length - 1);
        }
      } else {
        offset2 += padding.top;
      }
      const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset2, position, align);
      renderText(ctx, title.text, 0, 0, font, {
        color: title.color,
        maxWidth,
        rotation,
        textAlign: titleAlign(align, position, reverse),
        textBaseline: "middle",
        translation: [titleX, titleY]
      });
    }
    draw(chartArea) {
      if (!this._isVisible()) {
        return;
      }
      this.drawBackground();
      this.drawGrid(chartArea);
      this.drawBorder();
      this.drawTitle();
      this.drawLabels(chartArea);
    }
    _layers() {
      const opts = this.options;
      const tz = opts.ticks && opts.ticks.z || 0;
      const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
      if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
        return [{
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }];
      }
      return [{
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      }, {
        z: gz + 1,
        draw: () => {
          this.drawBorder();
        }
      }, {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }];
    }
    getMatchingVisibleMetas(type) {
      const metas = this.chart.getSortedVisibleDatasetMetas();
      const axisID = this.axis + "AxisID";
      const result = [];
      let i5, ilen;
      for (i5 = 0, ilen = metas.length; i5 < ilen; ++i5) {
        const meta = metas[i5];
        if (meta[axisID] === this.id && (!type || meta.type === type)) {
          result.push(meta);
        }
      }
      return result;
    }
    _resolveTickFontOptions(index2) {
      const opts = this.options.ticks.setContext(this.getContext(index2));
      return toFont(opts.font);
    }
    _maxDigits() {
      const fontSize = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
  };
  var TypedRegistry = class {
    constructor(type, scope, override) {
      this.type = type;
      this.scope = scope;
      this.override = override;
      this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(type) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
      const proto = Object.getPrototypeOf(item);
      let parentScope;
      if (isIChartComponent(proto)) {
        parentScope = this.register(proto);
      }
      const items = this.items;
      const id = item.id;
      const scope = this.scope + "." + id;
      if (!id) {
        throw new Error("class does not have id: " + item);
      }
      if (id in items) {
        return scope;
      }
      items[id] = item;
      registerDefaults(item, scope, parentScope);
      if (this.override) {
        defaults.override(item.id, item.overrides);
      }
      return scope;
    }
    get(id) {
      return this.items[id];
    }
    unregister(item) {
      const items = this.items;
      const id = item.id;
      const scope = this.scope;
      if (id in items) {
        delete items[id];
      }
      if (scope && id in defaults[scope]) {
        delete defaults[scope][id];
        if (this.override) {
          delete overrides[id];
        }
      }
    }
  };
  function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
      parentScope ? defaults.get(parentScope) : {},
      defaults.get(scope),
      item.defaults
    ]);
    defaults.set(scope, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults.describe(scope, item.descriptors);
    }
  }
  function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [scope].concat(propertyParts).join(".");
      const parts = routes[property].split(".");
      const targetName = parts.pop();
      const targetScope = parts.join(".");
      defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
  }
  var Registry = class {
    constructor() {
      this.controllers = new TypedRegistry(DatasetController, "datasets", true);
      this.elements = new TypedRegistry(Element2, "elements");
      this.plugins = new TypedRegistry(Object, "plugins");
      this.scales = new TypedRegistry(Scale, "scales");
      this._typedRegistries = [this.controllers, this.scales, this.elements];
    }
    add(...args) {
      this._each("register", args);
    }
    remove(...args) {
      this._each("unregister", args);
    }
    addControllers(...args) {
      this._each("register", args, this.controllers);
    }
    addElements(...args) {
      this._each("register", args, this.elements);
    }
    addPlugins(...args) {
      this._each("register", args, this.plugins);
    }
    addScales(...args) {
      this._each("register", args, this.scales);
    }
    getController(id) {
      return this._get(id, this.controllers, "controller");
    }
    getElement(id) {
      return this._get(id, this.elements, "element");
    }
    getPlugin(id) {
      return this._get(id, this.plugins, "plugin");
    }
    getScale(id) {
      return this._get(id, this.scales, "scale");
    }
    removeControllers(...args) {
      this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
      this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
      this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
      this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
      [...args].forEach((arg) => {
        const reg = typedRegistry || this._getRegistryForType(arg);
        if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
          this._exec(method, reg, arg);
        } else {
          each(arg, (item) => {
            const itemReg = typedRegistry || this._getRegistryForType(item);
            this._exec(method, itemReg, item);
          });
        }
      });
    }
    _exec(method, registry2, component) {
      const camelMethod = _capitalize(method);
      callback(component["before" + camelMethod], [], component);
      registry2[method](component);
      callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
      for (let i5 = 0; i5 < this._typedRegistries.length; i5++) {
        const reg = this._typedRegistries[i5];
        if (reg.isForType(type)) {
          return reg;
        }
      }
      return this.plugins;
    }
    _get(id, typedRegistry, type) {
      const item = typedRegistry.get(id);
      if (item === void 0) {
        throw new Error('"' + id + '" is not a registered ' + type + ".");
      }
      return item;
    }
  };
  var registry = new Registry();
  var ScatterController = class extends DatasetController {
    update(mode) {
      const meta = this._cachedMeta;
      const { data: points = [] } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start: start3, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start3;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start3 = 0;
        count = points.length;
      }
      if (this.options.showLine) {
        const { dataset: line, _dataset } = meta;
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
      }
      this.updateElements(points, start3, count, mode);
    }
    addElements() {
      const { showLine } = this.options;
      if (!this.datasetElementType && showLine) {
        this.datasetElementType = registry.getElement("line");
      }
      super.addElements();
    }
    updateElements(points, start3, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const firstOpts = this.resolveDataElementOptions(start3, mode);
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start3 > 0 && this.getParsed(start3 - 1);
      for (let i5 = start3; i5 < start3 + count; ++i5) {
        const point = points[i5];
        const parsed = this.getParsed(i5);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i5);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i5);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i5 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i5];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i5, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i5, properties, mode);
        }
        prevParsed = parsed;
      }
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const data = meta.data || [];
      if (!this.options.showLine) {
        let max2 = 0;
        for (let i5 = data.length - 1; i5 >= 0; --i5) {
          max2 = Math.max(max2, data[i5].size(this.resolveDataElementOptions(i5)) / 2);
        }
        return max2 > 0 && max2;
      }
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
  };
  ScatterController.id = "scatter";
  ScatterController.defaults = {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
  };
  ScatterController.overrides = {
    interaction: {
      mode: "point"
    },
    plugins: {
      tooltip: {
        callbacks: {
          title() {
            return "";
          },
          label(item) {
            return "(" + item.label + ", " + item.formattedValue + ")";
          }
        }
      }
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  };
  var controllers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController,
    BubbleController,
    DoughnutController,
    LineController,
    PolarAreaController,
    PieController,
    RadarController,
    ScatterController
  });
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  var DateAdapter = class {
    constructor(options) {
      this.options = options || {};
    }
    init(chartOptions) {
    }
    formats() {
      return abstract();
    }
    parse(value, format2) {
      return abstract();
    }
    format(timestamp, format2) {
      return abstract();
    }
    add(timestamp, amount, unit) {
      return abstract();
    }
    diff(a3, b2, unit) {
      return abstract();
    }
    startOf(timestamp, unit, weekday) {
      return abstract();
    }
    endOf(timestamp, unit) {
      return abstract();
    }
  };
  DateAdapter.override = function(members) {
    Object.assign(DateAdapter.prototype, members);
  };
  var adapters = {
    _date: DateAdapter
  };
  function binarySearch(metaset, axis, value, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        return lookupMethod(data, axis, value);
      } else if (controller._sharedOptions) {
        const el = data[0];
        const range = typeof el.getRange === "function" && el.getRange(axis);
        if (range) {
          const start3 = lookupMethod(data, axis, value - range);
          const end2 = lookupMethod(data, axis, value + range);
          return { lo: start3.lo, hi: end2.hi };
        }
      }
    }
    return { lo: 0, hi: data.length - 1 };
  }
  function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for (let i5 = 0, ilen = metasets.length; i5 < ilen; ++i5) {
      const { index: index2, data } = metasets[i5];
      const { lo, hi } = binarySearch(metasets[i5], axis, value, intersect);
      for (let j2 = lo; j2 <= hi; ++j2) {
        const element = data[j2];
        if (!element.skip) {
          handler(element, index2, j2);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
      const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index2) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position.x, position.y, useFinalPosition)) {
        items.push({ element, datasetIndex, index: index2 });
      }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index2) {
      const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
      const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({ element, datasetIndex, index: index2 });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index2) {
      const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position, center);
      if (distance < minDistance) {
        items = [{ element, datasetIndex, index: index2 }];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({ element, datasetIndex, index: index2 });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
      if (element[rangeMethod](position[axis], useFinalPosition)) {
        items.push({ element, datasetIndex, index: index2 });
        intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  var Interaction = {
    evaluateInteractionItems,
    modes: {
      index(chart, e3, options, useFinalPosition) {
        const position = getRelativePosition(e3, chart);
        const axis = options.axis || "x";
        const includeInvisible = options.includeInvisible || false;
        const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        const elements2 = [];
        if (!items.length) {
          return [];
        }
        chart.getSortedVisibleDatasetMetas().forEach((meta) => {
          const index2 = items[0].index;
          const element = meta.data[index2];
          if (element && !element.skip) {
            elements2.push({ element, datasetIndex: meta.index, index: index2 });
          }
        });
        return elements2;
      },
      dataset(chart, e3, options, useFinalPosition) {
        const position = getRelativePosition(e3, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        if (items.length > 0) {
          const datasetIndex = items[0].datasetIndex;
          const data = chart.getDatasetMeta(datasetIndex).data;
          items = [];
          for (let i5 = 0; i5 < data.length; ++i5) {
            items.push({ element: data[i5], datasetIndex, index: i5 });
          }
        }
        return items;
      },
      point(chart, e3, options, useFinalPosition) {
        const position = getRelativePosition(e3, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
      },
      nearest(chart, e3, options, useFinalPosition) {
        const position = getRelativePosition(e3, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
      },
      x(chart, e3, options, useFinalPosition) {
        const position = getRelativePosition(e3, chart);
        return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
      },
      y(chart, e3, options, useFinalPosition) {
        const position = getRelativePosition(e3, chart);
        return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
      }
    }
  };
  var STATIC_POSITIONS = ["left", "top", "right", "bottom"];
  function filterByPosition(array, position) {
    return array.filter((v3) => v3.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v3) => STATIC_POSITIONS.indexOf(v3.pos) === -1 && v3.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a3, b2) => {
      const v0 = reverse ? b2 : a3;
      const v1 = reverse ? a3 : b2;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i5, ilen, box, pos, stack, stackWeight;
    for (i5 = 0, ilen = (boxes || []).length; i5 < ilen; ++i5) {
      box = boxes[i5];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i5,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap of layouts2) {
      const { stack, pos, stackWeight } = wrap;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i5, ilen, layout;
    for (i5 = 0, ilen = layouts2.length; i5 < ilen; ++i5) {
      layout = layouts2[i5];
      const { fullSize } = layout.box;
      const stack = stacks[layout.stack];
      const factor = stack && layout.stackWeight / stack.weight;
      if (layout.horizontal) {
        layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout.height = hBoxMaxHeight;
      } else {
        layout.width = vBoxMaxWidth;
        layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
    const left2 = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right2 = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom2 = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left2.concat(top2),
      rightAndBottom: right2.concat(centerVertical).concat(bottom2).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left2.concat(right2).concat(centerVertical),
      horizontal: top2.concat(bottom2).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a3, b2) {
    return Math.max(maxPadding[a3], chartArea[a3]) + Math.max(maxPadding[b2], chartArea[b2]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject(pos)) {
      if (layout.size) {
        chartArea[pos] -= layout.size;
      }
      const stack = stacks[layout.stack] || { size: 0, count: 1 };
      stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
      layout.size = stack.size / stack.count;
      chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
      const margin = { left: 0, top: 0, right: 0, bottom: 0 };
      positions2.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i5, ilen, layout, box, refit, changed;
    for (i5 = 0, ilen = boxes.length, refit = 0; i5 < ilen; ++i5) {
      layout = boxes[i5];
      box = layout.box;
      box.update(
        layout.width || chartArea.w,
        layout.height || chartArea.h,
        getMargins(layout.horizontal, chartArea)
      );
      const { same, other } = updateDims(chartArea, params, layout, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left2, top2, width, height) {
    box.top = top2;
    box.left = left2;
    box.right = left2 + width;
    box.bottom = top2 + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x: x3, y: y2 } = chartArea;
    for (const layout of boxes) {
      const box = layout.box;
      const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
      const weight = layout.stackWeight / stack.weight || 1;
      if (layout.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y2 = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y2, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y2, width, height);
        }
        stack.start = y2;
        stack.placed += width;
        y2 = box.bottom;
      } else {
        const height = chartArea.h * weight;
        const width = stack.size || box.width;
        if (defined(stack.start)) {
          x3 = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x3, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x3, chartArea.top + stack.placed, width, height);
        }
        stack.start = x3;
        stack.placed += height;
        x3 = box.right;
      }
    }
    chartArea.x = x3;
    chartArea.y = y2;
  }
  defaults.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
  var layouts = {
    addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }
      item.fullSize = item.fullSize || false;
      item.position = item.position || "top";
      item.weight = item.weight || 0;
      item._layers = item._layers || function() {
        return [{
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }];
      };
      chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
      const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index2 !== -1) {
        chart.boxes.splice(index2, 1);
      }
    },
    configure(chart, item, options) {
      item.fullSize = options.fullSize;
      item.position = options.position;
      item.weight = options.weight;
    },
    update(chart, width, height, minPadding) {
      if (!chart) {
        return;
      }
      const padding = toPadding(chart.options.layout.padding);
      const availableWidth = Math.max(width - padding.width, 0);
      const availableHeight = Math.max(height - padding.height, 0);
      const boxes = buildLayoutBoxes(chart.boxes);
      const verticalBoxes = boxes.vertical;
      const horizontalBoxes = boxes.horizontal;
      each(chart.boxes, (box) => {
        if (typeof box.beforeLayout === "function") {
          box.beforeLayout();
        }
      });
      const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
      const params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding,
        availableWidth,
        availableHeight,
        vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
        hBoxMaxHeight: availableHeight / 2
      });
      const maxPadding = Object.assign({}, padding);
      updateMaxPadding(maxPadding, toPadding(minPadding));
      const chartArea = Object.assign({
        maxPadding,
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
      fitBoxes(boxes.fullSize, chartArea, params, stacks);
      fitBoxes(verticalBoxes, chartArea, params, stacks);
      if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
        fitBoxes(verticalBoxes, chartArea, params, stacks);
      }
      handleMaxPadding(chartArea);
      placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h,
        height: chartArea.h,
        width: chartArea.w
      };
      each(boxes.chartArea, (layout) => {
        const box = layout.box;
        Object.assign(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
      });
    }
  };
  var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {
    }
    releaseContext(context) {
      return false;
    }
    addEventListener(chart, type, listener) {
    }
    removeEventListener(chart, type, listener) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
      width = Math.max(0, width || element.width);
      height = height || element.height;
      return {
        width,
        height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
      };
    }
    isAttached(canvas) {
      return true;
    }
    updateConfig(config) {
    }
  };
  var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
      return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config) {
      config.options.animation = false;
    }
  };
  var EXPANDO_KEY = "$chartjs";
  var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };
  var isNullOrEmpty = (value) => value === null || value === "";
  function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
  function addListener(node, type, listener) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
  function removeListener(chart, type, listener) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
  function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x: x3, y: y2 } = getRelativePosition(event, chart);
    return {
      type,
      chart,
      native: event,
      x: x3 !== void 0 ? x3 : null,
      y: y2 !== void 0 ? y2 : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
      if (node === canvas || node.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.addedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, { childList: true, subtree: true });
    return observer;
  }
  function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.removedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, { childList: true, subtree: true });
    return observer;
  }
  var drpListeningCharts = /* @__PURE__ */ new Map();
  var oldDevicePixelRatio = 0;
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container2 = canvas && _getParentNode(canvas);
    if (!container2) {
      return;
    }
    const resize = throttled((width, height) => {
      const w3 = container2.clientWidth;
      listener(width, height);
      if (w3 < container2.clientWidth) {
        listener();
      }
    }, window);
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize(width, height);
    });
    observer.observe(container2);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
  }
  function releaseObserver(chart, type, observer) {
    if (observer) {
      observer.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event) => {
      if (chart.ctx !== null) {
        listener(fromNativeEvent(event, chart));
      }
    }, chart, (args) => {
      const event = args[0];
      return [event, event.offsetX, event.offsetY];
    });
    addListener(canvas, type, proxy);
    return proxy;
  }
  var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
      const context = canvas && canvas.getContext && canvas.getContext("2d");
      if (context && context.canvas === canvas) {
        initCanvas(canvas, aspectRatio);
        return context;
      }
      return null;
    }
    releaseContext(context) {
      const canvas = context.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return false;
      }
      const initial = canvas[EXPANDO_KEY].initial;
      ["height", "width"].forEach((prop) => {
        const value = initial[prop];
        if (isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      const style = initial.style || {};
      Object.keys(style).forEach((key) => {
        canvas.style[key] = style[key];
      });
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
      return true;
    }
    addEventListener(chart, type, listener) {
      this.removeEventListener(chart, type);
      const proxies = chart.$proxies || (chart.$proxies = {});
      const handlers = {
        attach: createAttachObserver,
        detach: createDetachObserver,
        resize: createResizeObserver
      };
      const handler = handlers[type] || createProxyAndListen;
      proxies[type] = handler(chart, type, listener);
    }
    removeEventListener(chart, type) {
      const proxies = chart.$proxies || (chart.$proxies = {});
      const proxy = proxies[type];
      if (!proxy) {
        return;
      }
      const handlers = {
        attach: releaseObserver,
        detach: releaseObserver,
        resize: releaseObserver
      };
      const handler = handlers[type] || removeListener;
      handler(chart, type, proxy);
      proxies[type] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
      return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
      const container2 = _getParentNode(canvas);
      return !!(container2 && container2.isConnected);
    }
  };
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  var PluginService = class {
    constructor() {
      this._init = [];
    }
    notify(chart, hook, args, filter) {
      if (hook === "beforeInit") {
        this._init = this._createDescriptors(chart, true);
        this._notify(this._init, chart, "install");
      }
      const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
      const result = this._notify(descriptors2, chart, hook, args);
      if (hook === "afterDestroy") {
        this._notify(descriptors2, chart, "stop");
        this._notify(this._init, chart, "uninstall");
      }
      return result;
    }
    _notify(descriptors2, chart, hook, args) {
      args = args || {};
      for (const descriptor of descriptors2) {
        const plugin = descriptor.plugin;
        const method = plugin[hook];
        const params = [chart, args, descriptor.options];
        if (callback(method, params, plugin) === false && args.cancelable) {
          return false;
        }
      }
      return true;
    }
    invalidate() {
      if (!isNullOrUndef(this._cache)) {
        this._oldCache = this._cache;
        this._cache = void 0;
      }
    }
    _descriptors(chart) {
      if (this._cache) {
        return this._cache;
      }
      const descriptors2 = this._cache = this._createDescriptors(chart);
      this._notifyStateChanges(chart);
      return descriptors2;
    }
    _createDescriptors(chart, all) {
      const config = chart && chart.config;
      const options = valueOrDefault(config.options && config.options.plugins, {});
      const plugins2 = allPlugins(config);
      return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
    }
    _notifyStateChanges(chart) {
      const previousDescriptors = this._oldCache || [];
      const descriptors2 = this._cache;
      const diff = (a3, b2) => a3.filter((x3) => !b2.some((y2) => x3.plugin.id === y2.plugin.id));
      this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
      this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
  };
  function allPlugins(config) {
    const localIds = {};
    const plugins2 = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i5 = 0; i5 < keys.length; i5++) {
      plugins2.push(registry.getPlugin(keys[i5]));
    }
    const local = config.plugins || [];
    for (let i5 = 0; i5 < local.length; i5++) {
      const plugin = local[i5];
      if (plugins2.indexOf(plugin) === -1) {
        plugins2.push(plugin);
        localIds[plugin.id] = true;
      }
    }
    return { plugins: plugins2, localIds };
  }
  function getOpts(options, all) {
    if (!all && options === false) {
      return null;
    }
    if (options === true) {
      return {};
    }
    return options;
  }
  function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins2) {
      const id = plugin.id;
      const opts = getOpts(options[id], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin,
        options: pluginOpts(chart.config, { plugin, local: localIds[id] }, opts, context)
      });
    }
    return result;
  }
  function pluginOpts(config, { plugin, local }, opts, context) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
      scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context, [""], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options) {
    const datasetDefaults = defaults.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") {
      axis = indexAxis;
    } else if (id === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
      return "x";
    }
    if (position === "left" || position === "right") {
      return "y";
    }
  }
  function determineAxis(id, scaleOptions) {
    if (id === "x" || id === "y") {
      return id;
    }
    return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
  }
  function mergeScaleConfig(config, options) {
    const chartDefaults = overrides[config.type] || { scales: {} };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const firstIDs = /* @__PURE__ */ Object.create(null);
    const scales2 = /* @__PURE__ */ Object.create(null);
    Object.keys(configScales).forEach((id) => {
      const scaleConf = configScales[id];
      if (!isObject(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
      }
      const axis = determineAxis(id, scaleConf);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      firstIDs[axis] = firstIDs[axis] || id;
      scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
    });
    config.data.datasets.forEach((dataset) => {
      const type = dataset.type || config.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
      const datasetDefaults = overrides[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
        scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
        mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
      });
    });
    Object.keys(scales2).forEach((key) => {
      const scale2 = scales2[key];
      mergeIf(scale2, [defaults.scales[scale2.type], defaults.scale]);
    });
    return scales2;
  }
  function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
  }
  function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
  }
  function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
  }
  var keyCache = /* @__PURE__ */ new Map();
  var keysCached = /* @__PURE__ */ new Set();
  function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
      keys = generate();
      keyCache.set(cacheKey, keys);
      keysCached.add(keys);
    }
    return keys;
  }
  var addIfFound = (set2, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
      set2.add(opts);
    }
  };
  var Config = class {
    constructor(config) {
      this._config = initConfig(config);
      this._scopeCache = /* @__PURE__ */ new Map();
      this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(type) {
      this._config.type = type;
    }
    get data() {
      return this._config.data;
    }
    set data(data) {
      this._config.data = initData(data);
    }
    get options() {
      return this._config.options;
    }
    set options(options) {
      this._config.options = options;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const config = this._config;
      this.clearCache();
      initOptions(config);
    }
    clearCache() {
      this._scopeCache.clear();
      this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
      return cachedKeys(
        datasetType,
        () => [[
          `datasets.${datasetType}`,
          ""
        ]]
      );
    }
    datasetAnimationScopeKeys(datasetType, transition) {
      return cachedKeys(
        `${datasetType}.transition.${transition}`,
        () => [
          [
            `datasets.${datasetType}.transitions.${transition}`,
            `transitions.${transition}`
          ],
          [
            `datasets.${datasetType}`,
            ""
          ]
        ]
      );
    }
    datasetElementScopeKeys(datasetType, elementType) {
      return cachedKeys(
        `${datasetType}-${elementType}`,
        () => [[
          `datasets.${datasetType}.elements.${elementType}`,
          `datasets.${datasetType}`,
          `elements.${elementType}`,
          ""
        ]]
      );
    }
    pluginScopeKeys(plugin) {
      const id = plugin.id;
      const type = this.type;
      return cachedKeys(
        `${type}-plugin-${id}`,
        () => [[
          `plugins.${id}`,
          ...plugin.additionalOptionScopes || []
        ]]
      );
    }
    _cachedScopes(mainScope, resetCache) {
      const _scopeCache = this._scopeCache;
      let cache = _scopeCache.get(mainScope);
      if (!cache || resetCache) {
        cache = /* @__PURE__ */ new Map();
        _scopeCache.set(mainScope, cache);
      }
      return cache;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
      const { options, type } = this;
      const cache = this._cachedScopes(mainScope, resetCache);
      const cached = cache.get(keyLists);
      if (cached) {
        return cached;
      }
      const scopes = /* @__PURE__ */ new Set();
      keyLists.forEach((keys) => {
        if (mainScope) {
          scopes.add(mainScope);
          keys.forEach((key) => addIfFound(scopes, mainScope, key));
        }
        keys.forEach((key) => addIfFound(scopes, options, key));
        keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
        keys.forEach((key) => addIfFound(scopes, defaults, key));
        keys.forEach((key) => addIfFound(scopes, descriptors, key));
      });
      const array = Array.from(scopes);
      if (array.length === 0) {
        array.push(/* @__PURE__ */ Object.create(null));
      }
      if (keysCached.has(keyLists)) {
        cache.set(keyLists, array);
      }
      return array;
    }
    chartOptionScopes() {
      const { options, type } = this;
      return [
        options,
        overrides[type] || {},
        defaults.datasets[type] || {},
        { type },
        defaults,
        descriptors
      ];
    }
    resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
      const result = { $shared: true };
      const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
      let options = resolver;
      if (needContext(resolver, names2)) {
        result.$shared = false;
        context = isFunction2(context) ? context() : context;
        const subResolver = this.createResolver(scopes, context, subPrefixes);
        options = _attachContext(resolver, context, subResolver);
      }
      for (const prop of names2) {
        result[prop] = options[prop];
      }
      return result;
    }
    createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
      const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
      return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
    }
  };
  function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
      cache = /* @__PURE__ */ new Map();
      resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p3) => !p3.toLowerCase().includes("hover"))
      };
      cache.set(cacheKey, cached);
    }
    return cached;
  }
  var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction2(value[key]), false);
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction2(value) || hasFunction(value)) || indexable && isArray(value)) {
        return true;
      }
    }
    return false;
  }
  var version = "3.9.1";
  var KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
  function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
  }
  function compare2Level(l1, l22) {
    return function(a3, b2) {
      return a3[l1] === b2[l1] ? a3[l22] - b2[l22] : a3[l1] - b2[l1];
    };
  }
  function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions2 = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions2 && animationOptions2.onComplete, [context], chart);
  }
  function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions2 = chart.options.animation;
    callback(animationOptions2 && animationOptions2.onProgress, [context], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  var instances = {};
  var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c3) => c3.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start3, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
      const intKey = +key;
      if (intKey >= start3) {
        const value = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start3) {
          obj[intKey + move] = value;
        }
      }
    }
  }
  function determineLastEvent(e3, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e3.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e3;
  }
  var Chart = class {
    constructor(item, userConfig) {
      const config = this.config = new Config(userConfig);
      const initialCanvas = getCanvas(item);
      const existingChart = getChart(initialCanvas);
      if (existingChart) {
        throw new Error(
          "Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused."
        );
      }
      const options = config.createResolver(config.chartOptionScopes(), this.getContext());
      this.platform = new (config.platform || _detectPlatform(initialCanvas))();
      this.platform.updateConfig(config);
      const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
      const canvas = context && context.canvas;
      const height = canvas && canvas.height;
      const width = canvas && canvas.width;
      this.id = uid();
      this.ctx = context;
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this._options = options;
      this._aspectRatio = this.aspectRatio;
      this._layers = [];
      this._metasets = [];
      this._stacks = void 0;
      this.boxes = [];
      this.currentDevicePixelRatio = void 0;
      this.chartArea = void 0;
      this._active = [];
      this._lastEvent = void 0;
      this._listeners = {};
      this._responsiveListeners = void 0;
      this._sortedMetasets = [];
      this.scales = {};
      this._plugins = new PluginService();
      this.$proxies = {};
      this._hiddenIndices = {};
      this.attached = false;
      this._animationsDisabled = void 0;
      this.$context = void 0;
      this._doResize = debounce2((mode) => this.update(mode), options.resizeDelay || 0);
      this._dataChanges = [];
      instances[this.id] = this;
      if (!context || !canvas) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      animator.listen(this, "complete", onAnimationsComplete);
      animator.listen(this, "progress", onAnimationProgress);
      this._initialize();
      if (this.attached) {
        this.update();
      }
    }
    get aspectRatio() {
      const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
      if (!isNullOrUndef(aspectRatio)) {
        return aspectRatio;
      }
      if (maintainAspectRatio && _aspectRatio) {
        return _aspectRatio;
      }
      return height ? width / height : null;
    }
    get data() {
      return this.config.data;
    }
    set data(data) {
      this.config.data = data;
    }
    get options() {
      return this._options;
    }
    set options(options) {
      this.config.options = options;
    }
    _initialize() {
      this.notifyPlugins("beforeInit");
      if (this.options.responsive) {
        this.resize();
      } else {
        retinaScale(this, this.options.devicePixelRatio);
      }
      this.bindEvents();
      this.notifyPlugins("afterInit");
      return this;
    }
    clear() {
      clearCanvas(this.canvas, this.ctx);
      return this;
    }
    stop() {
      animator.stop(this);
      return this;
    }
    resize(width, height) {
      if (!animator.running(this)) {
        this._resize(width, height);
      } else {
        this._resizeBeforeDraw = { width, height };
      }
    }
    _resize(width, height) {
      const options = this.options;
      const canvas = this.canvas;
      const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
      const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
      const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
      const mode = this.width ? "resize" : "attach";
      this.width = newSize.width;
      this.height = newSize.height;
      this._aspectRatio = this.aspectRatio;
      if (!retinaScale(this, newRatio, true)) {
        return;
      }
      this.notifyPlugins("resize", { size: newSize });
      callback(options.onResize, [this, newSize], this);
      if (this.attached) {
        if (this._doResize(mode)) {
          this.render();
        }
      }
    }
    ensureScalesHaveIDs() {
      const options = this.options;
      const scalesOptions = options.scales || {};
      each(scalesOptions, (axisOptions, axisID) => {
        axisOptions.id = axisID;
      });
    }
    buildOrUpdateScales() {
      const options = this.options;
      const scaleOpts = options.scales;
      const scales2 = this.scales;
      const updated = Object.keys(scales2).reduce((obj, id) => {
        obj[id] = false;
        return obj;
      }, {});
      let items = [];
      if (scaleOpts) {
        items = items.concat(
          Object.keys(scaleOpts).map((id) => {
            const scaleOptions = scaleOpts[id];
            const axis = determineAxis(id, scaleOptions);
            const isRadial = axis === "r";
            const isHorizontal = axis === "x";
            return {
              options: scaleOptions,
              dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
              dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
            };
          })
        );
      }
      each(items, (item) => {
        const scaleOptions = item.options;
        const id = scaleOptions.id;
        const axis = determineAxis(id, scaleOptions);
        const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
        if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id] = true;
        let scale2 = null;
        if (id in scales2 && scales2[id].type === scaleType) {
          scale2 = scales2[id];
        } else {
          const scaleClass = registry.getScale(scaleType);
          scale2 = new scaleClass({
            id,
            type: scaleType,
            ctx: this.ctx,
            chart: this
          });
          scales2[scale2.id] = scale2;
        }
        scale2.init(scaleOptions, options);
      });
      each(updated, (hasUpdated, id) => {
        if (!hasUpdated) {
          delete scales2[id];
        }
      });
      each(scales2, (scale2) => {
        layouts.configure(this, scale2, scale2.options);
        layouts.addBox(this, scale2);
      });
    }
    _updateMetasets() {
      const metasets = this._metasets;
      const numData = this.data.datasets.length;
      const numMeta = metasets.length;
      metasets.sort((a3, b2) => a3.index - b2.index);
      if (numMeta > numData) {
        for (let i5 = numData; i5 < numMeta; ++i5) {
          this._destroyDatasetMeta(i5);
        }
        metasets.splice(numData, numMeta - numData);
      }
      this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: metasets, data: { datasets } } = this;
      if (metasets.length > datasets.length) {
        delete this._stacks;
      }
      metasets.forEach((meta, index2) => {
        if (datasets.filter((x3) => x3 === meta._dataset).length === 0) {
          this._destroyDatasetMeta(index2);
        }
      });
    }
    buildOrUpdateControllers() {
      const newControllers = [];
      const datasets = this.data.datasets;
      let i5, ilen;
      this._removeUnreferencedMetasets();
      for (i5 = 0, ilen = datasets.length; i5 < ilen; i5++) {
        const dataset = datasets[i5];
        let meta = this.getDatasetMeta(i5);
        const type = dataset.type || this.config.type;
        if (meta.type && meta.type !== type) {
          this._destroyDatasetMeta(i5);
          meta = this.getDatasetMeta(i5);
        }
        meta.type = type;
        meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
        meta.order = dataset.order || 0;
        meta.index = i5;
        meta.label = "" + dataset.label;
        meta.visible = this.isDatasetVisible(i5);
        if (meta.controller) {
          meta.controller.updateIndex(i5);
          meta.controller.linkScales();
        } else {
          const ControllerClass = registry.getController(type);
          const { datasetElementType, dataElementType } = defaults.datasets[type];
          Object.assign(ControllerClass.prototype, {
            dataElementType: registry.getElement(dataElementType),
            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
          });
          meta.controller = new ControllerClass(this, i5);
          newControllers.push(meta.controller);
        }
      }
      this._updateMetasets();
      return newControllers;
    }
    _resetElements() {
      each(this.data.datasets, (dataset, datasetIndex) => {
        this.getDatasetMeta(datasetIndex).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements();
      this.notifyPlugins("reset");
    }
    update(mode) {
      const config = this.config;
      config.update();
      const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
      const animsDisabled = this._animationsDisabled = !options.animation;
      this._updateScales();
      this._checkEventBindings();
      this._updateHiddenIndices();
      this._plugins.invalidate();
      if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
        return;
      }
      const newControllers = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let minPadding = 0;
      for (let i5 = 0, ilen = this.data.datasets.length; i5 < ilen; i5++) {
        const { controller } = this.getDatasetMeta(i5);
        const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
        controller.buildOrUpdateElements(reset);
        minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
      }
      minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
      this._updateLayout(minPadding);
      if (!animsDisabled) {
        each(newControllers, (controller) => {
          controller.reset();
        });
      }
      this._updateDatasets(mode);
      this.notifyPlugins("afterUpdate", { mode });
      this._layers.sort(compare2Level("z", "_idx"));
      const { _active, _lastEvent } = this;
      if (_lastEvent) {
        this._eventHandler(_lastEvent, true);
      } else if (_active.length) {
        this._updateHoverStyles(_active, _active, true);
      }
      this.render();
    }
    _updateScales() {
      each(this.scales, (scale2) => {
        layouts.removeBox(this, scale2);
      });
      this.ensureScalesHaveIDs();
      this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const options = this.options;
      const existingEvents = new Set(Object.keys(this._listeners));
      const newEvents = new Set(options.events);
      if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
        this.unbindEvents();
        this.bindEvents();
      }
    }
    _updateHiddenIndices() {
      const { _hiddenIndices } = this;
      const changes = this._getUniformDataChanges() || [];
      for (const { method, start: start3, count } of changes) {
        const move = method === "_removeElements" ? -count : count;
        moveNumericKeys(_hiddenIndices, start3, move);
      }
    }
    _getUniformDataChanges() {
      const _dataChanges = this._dataChanges;
      if (!_dataChanges || !_dataChanges.length) {
        return;
      }
      this._dataChanges = [];
      const datasetCount = this.data.datasets.length;
      const makeSet = (idx) => new Set(
        _dataChanges.filter((c3) => c3[0] === idx).map((c3, i5) => i5 + "," + c3.splice(1).join(","))
      );
      const changeSet = makeSet(0);
      for (let i5 = 1; i5 < datasetCount; i5++) {
        if (!setsEqual(changeSet, makeSet(i5))) {
          return;
        }
      }
      return Array.from(changeSet).map((c3) => c3.split(",")).map((a3) => ({ method: a3[1], start: +a3[2], count: +a3[3] }));
    }
    _updateLayout(minPadding) {
      if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
        return;
      }
      layouts.update(this, this.width, this.height, minPadding);
      const area = this.chartArea;
      const noArea = area.width <= 0 || area.height <= 0;
      this._layers = [];
      each(this.boxes, (box) => {
        if (noArea && box.position === "chartArea") {
          return;
        }
        if (box.configure) {
          box.configure();
        }
        this._layers.push(...box._layers());
      }, this);
      this._layers.forEach((item, index2) => {
        item._idx = index2;
      });
      this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
      if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
        return;
      }
      for (let i5 = 0, ilen = this.data.datasets.length; i5 < ilen; ++i5) {
        this.getDatasetMeta(i5).controller.configure();
      }
      for (let i5 = 0, ilen = this.data.datasets.length; i5 < ilen; ++i5) {
        this._updateDataset(i5, isFunction2(mode) ? mode({ datasetIndex: i5 }) : mode);
      }
      this.notifyPlugins("afterDatasetsUpdate", { mode });
    }
    _updateDataset(index2, mode) {
      const meta = this.getDatasetMeta(index2);
      const args = { meta, index: index2, mode, cancelable: true };
      if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
        return;
      }
      meta.controller._update(mode);
      args.cancelable = false;
      this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
      if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
        return;
      }
      if (animator.has(this)) {
        if (this.attached && !animator.running(this)) {
          animator.start(this);
        }
      } else {
        this.draw();
        onAnimationsComplete({ chart: this });
      }
    }
    draw() {
      let i5;
      if (this._resizeBeforeDraw) {
        const { width, height } = this._resizeBeforeDraw;
        this._resize(width, height);
        this._resizeBeforeDraw = null;
      }
      this.clear();
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
        return;
      }
      const layers = this._layers;
      for (i5 = 0; i5 < layers.length && layers[i5].z <= 0; ++i5) {
        layers[i5].draw(this.chartArea);
      }
      this._drawDatasets();
      for (; i5 < layers.length; ++i5) {
        layers[i5].draw(this.chartArea);
      }
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
      const metasets = this._sortedMetasets;
      const result = [];
      let i5, ilen;
      for (i5 = 0, ilen = metasets.length; i5 < ilen; ++i5) {
        const meta = metasets[i5];
        if (!filterVisible || meta.visible) {
          result.push(meta);
        }
      }
      return result;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
        return;
      }
      const metasets = this.getSortedVisibleDatasetMetas();
      for (let i5 = metasets.length - 1; i5 >= 0; --i5) {
        this._drawDataset(metasets[i5]);
      }
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
      const ctx = this.ctx;
      const clip = meta._clip;
      const useClip = !clip.disabled;
      const area = this.chartArea;
      const args = {
        meta,
        index: meta.index,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
        return;
      }
      if (useClip) {
        clipArea(ctx, {
          left: clip.left === false ? 0 : area.left - clip.left,
          right: clip.right === false ? this.width : area.right + clip.right,
          top: clip.top === false ? 0 : area.top - clip.top,
          bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
        });
      }
      meta.controller.draw();
      if (useClip) {
        unclipArea(ctx);
      }
      args.cancelable = false;
      this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
      return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e3, mode, options, useFinalPosition) {
      const method = Interaction.modes[mode];
      if (typeof method === "function") {
        return method(this, e3, options, useFinalPosition);
      }
      return [];
    }
    getDatasetMeta(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      const metasets = this._metasets;
      let meta = metasets.filter((x3) => x3 && x3._dataset === dataset).pop();
      if (!meta) {
        meta = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: dataset && dataset.order || 0,
          index: datasetIndex,
          _dataset: dataset,
          _parsed: [],
          _sorted: false
        };
        metasets.push(meta);
      }
      return meta;
    }
    getContext() {
      return this.$context || (this.$context = createContext5(null, { chart: this, type: "chart" }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      if (!dataset) {
        return false;
      }
      const meta = this.getDatasetMeta(datasetIndex);
      return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
      const meta = this.getDatasetMeta(datasetIndex);
      meta.hidden = !visible;
    }
    toggleDataVisibility(index2) {
      this._hiddenIndices[index2] = !this._hiddenIndices[index2];
    }
    getDataVisibility(index2) {
      return !this._hiddenIndices[index2];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
      const mode = visible ? "show" : "hide";
      const meta = this.getDatasetMeta(datasetIndex);
      const anims = meta.controller._resolveAnimations(void 0, mode);
      if (defined(dataIndex)) {
        meta.data[dataIndex].hidden = !visible;
        this.update();
      } else {
        this.setDatasetVisibility(datasetIndex, visible);
        anims.update(meta, { visible });
        this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
      }
    }
    hide(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
      const meta = this._metasets[datasetIndex];
      if (meta && meta.controller) {
        meta.controller._destroy();
      }
      delete this._metasets[datasetIndex];
    }
    _stop() {
      let i5, ilen;
      this.stop();
      animator.remove(this);
      for (i5 = 0, ilen = this.data.datasets.length; i5 < ilen; ++i5) {
        this._destroyDatasetMeta(i5);
      }
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas, ctx } = this;
      this._stop();
      this.config.clearCache();
      if (canvas) {
        this.unbindEvents();
        clearCanvas(canvas, ctx);
        this.platform.releaseContext(ctx);
        this.canvas = null;
        this.ctx = null;
      }
      this.notifyPlugins("destroy");
      delete instances[this.id];
      this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
      return this.canvas.toDataURL(...args);
    }
    bindEvents() {
      this.bindUserEvents();
      if (this.options.responsive) {
        this.bindResponsiveEvents();
      } else {
        this.attached = true;
      }
    }
    bindUserEvents() {
      const listeners = this._listeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const listener = (e3, x3, y2) => {
        e3.offsetX = x3;
        e3.offsetY = y2;
        this._eventHandler(e3);
      };
      each(this.options.events, (type) => _add(type, listener));
    }
    bindResponsiveEvents() {
      if (!this._responsiveListeners) {
        this._responsiveListeners = {};
      }
      const listeners = this._responsiveListeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const _remove = (type, listener2) => {
        if (listeners[type]) {
          platform.removeEventListener(this, type, listener2);
          delete listeners[type];
        }
      };
      const listener = (width, height) => {
        if (this.canvas) {
          this.resize(width, height);
        }
      };
      let detached;
      const attached = () => {
        _remove("attach", attached);
        this.attached = true;
        this.resize();
        _add("resize", listener);
        _add("detach", detached);
      };
      detached = () => {
        this.attached = false;
        _remove("resize", listener);
        this._stop();
        this._resize(0, 0);
        _add("attach", attached);
      };
      if (platform.isAttached(this.canvas)) {
        attached();
      } else {
        detached();
      }
    }
    unbindEvents() {
      each(this._listeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._listeners = {};
      each(this._responsiveListeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
      const prefix2 = enabled ? "set" : "remove";
      let meta, item, i5, ilen;
      if (mode === "dataset") {
        meta = this.getDatasetMeta(items[0].datasetIndex);
        meta.controller["_" + prefix2 + "DatasetHoverStyle"]();
      }
      for (i5 = 0, ilen = items.length; i5 < ilen; ++i5) {
        item = items[i5];
        const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
        if (controller) {
          controller[prefix2 + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements) {
      const lastActive = this._active || [];
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("No dataset found at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(active, lastActive);
      if (changed) {
        this._active = active;
        this._lastEvent = null;
        this._updateHoverStyles(active, lastActive);
      }
    }
    notifyPlugins(hook, args, filter) {
      return this._plugins.notify(this, hook, args, filter);
    }
    _updateHoverStyles(active, lastActive, replay) {
      const hoverOptions = this.options.hover;
      const diff = (a3, b2) => a3.filter((x3) => !b2.some((y2) => x3.datasetIndex === y2.datasetIndex && x3.index === y2.index));
      const deactivated = diff(lastActive, active);
      const activated = replay ? active : diff(active, lastActive);
      if (deactivated.length) {
        this.updateHoverStyle(deactivated, hoverOptions.mode, false);
      }
      if (activated.length && hoverOptions.mode) {
        this.updateHoverStyle(activated, hoverOptions.mode, true);
      }
    }
    _eventHandler(e3, replay) {
      const args = {
        event: e3,
        replay,
        cancelable: true,
        inChartArea: this.isPointInArea(e3)
      };
      const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e3.native.type);
      if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
        return;
      }
      const changed = this._handleEvent(e3, replay, args.inChartArea);
      args.cancelable = false;
      this.notifyPlugins("afterEvent", args, eventFilter);
      if (changed || args.changed) {
        this.render();
      }
      return this;
    }
    _handleEvent(e3, replay, inChartArea) {
      const { _active: lastActive = [], options } = this;
      const useFinalPosition = replay;
      const active = this._getActiveElements(e3, lastActive, inChartArea, useFinalPosition);
      const isClick = _isClickEvent(e3);
      const lastEvent = determineLastEvent(e3, this._lastEvent, inChartArea, isClick);
      if (inChartArea) {
        this._lastEvent = null;
        callback(options.onHover, [e3, active, this], this);
        if (isClick) {
          callback(options.onClick, [e3, active, this], this);
        }
      }
      const changed = !_elementsEqual(active, lastActive);
      if (changed || replay) {
        this._active = active;
        this._updateHoverStyles(active, lastActive, replay);
      }
      this._lastEvent = lastEvent;
      return changed;
    }
    _getActiveElements(e3, lastActive, inChartArea, useFinalPosition) {
      if (e3.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const hoverOptions = this.options.hover;
      return this.getElementsAtEventForMode(e3, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
  };
  var invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
  var enumerable = true;
  Object.defineProperties(Chart, {
    defaults: {
      enumerable,
      value: defaults
    },
    instances: {
      enumerable,
      value: instances
    },
    overrides: {
      enumerable,
      value: overrides
    },
    registry: {
      enumerable,
      value: registry
    },
    version: {
      enumerable,
      value: version
    },
    getChart: {
      enumerable,
      value: getChart
    },
    register: {
      enumerable,
      value: (...items) => {
        registry.add(...items);
        invalidatePlugins();
      }
    },
    unregister: {
      enumerable,
      value: (...items) => {
        registry.remove(...items);
        invalidatePlugins();
      }
    }
  });
  function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x: x3, y: y2, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x3, y2, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
      angleMargin = pixelMargin / innerRadius;
      ctx.arc(x3, y2, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x3, y2, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
  }
  function toRadiusCorners(value) {
    return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
  }
  function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o10 = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val) => {
      const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
      return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
      outerStart: computeOuterLimit(o10.outerStart),
      outerEnd: computeOuterLimit(o10.outerEnd),
      innerStart: _limitValue(o10.innerStart, 0, innerLimit),
      innerEnd: _limitValue(o10.innerEnd, 0, innerLimit)
    };
  }
  function rThetaToXY(r6, theta, x3, y2) {
    return {
      x: x3 + r6 * Math.cos(theta),
      y: y2 + r6 * Math.sin(theta)
    };
  }
  function pathArc(ctx, element, offset2, spacing, end2, circular) {
    const { x: x3, y: y2, startAngle: start3, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset2 - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset2 + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha2 = end2 - start3;
    if (spacing) {
      const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
      const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
      const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
      const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
      spacingOffset = (alpha2 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha2 * outerRadius - offset2 / PI) / outerRadius;
    const angleOffset = (alpha2 - beta) / 2;
    const startAngle = start3 + angleOffset + spacingOffset;
    const endAngle = end2 - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
      ctx.arc(x3, y2, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x3, y2);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x3, y2);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x3, y2);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      ctx.arc(x3, y2, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x3, y2);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x3, y2);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x3, y2);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
    } else {
      ctx.moveTo(x3, y2);
      const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x3;
      const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y2;
      ctx.lineTo(outerStartX, outerStartY);
      const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x3;
      const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y2;
      ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
  }
  function drawArc(ctx, element, offset2, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset2, spacing, startAngle + TAU, circular);
      for (let i5 = 0; i5 < fullCircles; ++i5) {
        ctx.fill();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + circumference % TAU;
        if (circumference % TAU === 0) {
          endAngle += TAU;
        }
      }
    }
    pathArc(ctx, element, offset2, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
  }
  function drawFullCircleBorders(ctx, element, inner) {
    const { x: x3, y: y2, startAngle, pixelMargin, fullCircles } = element;
    const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
    const innerRadius = element.innerRadius + pixelMargin;
    let i5;
    if (inner) {
      clipArc(ctx, element, startAngle + TAU);
    }
    ctx.beginPath();
    ctx.arc(x3, y2, innerRadius, startAngle + TAU, startAngle, true);
    for (i5 = 0; i5 < fullCircles; ++i5) {
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.arc(x3, y2, outerRadius, startAngle, startAngle + TAU);
    for (i5 = 0; i5 < fullCircles; ++i5) {
      ctx.stroke();
    }
  }
  function drawBorder(ctx, element, offset2, spacing, endAngle, circular) {
    const { options } = element;
    const { borderWidth, borderJoinStyle } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) {
      return;
    }
    if (inner) {
      ctx.lineWidth = borderWidth * 2;
      ctx.lineJoin = borderJoinStyle || "round";
    } else {
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = borderJoinStyle || "bevel";
    }
    if (element.fullCircles) {
      drawFullCircleBorders(ctx, element, inner);
    }
    if (inner) {
      clipArc(ctx, element, endAngle);
    }
    pathArc(ctx, element, offset2, spacing, endAngle, circular);
    ctx.stroke();
  }
  var ArcElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.circumference = void 0;
      this.startAngle = void 0;
      this.endAngle = void 0;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.pixelMargin = 0;
      this.fullCircles = 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(chartX, chartY, useFinalPosition) {
      const point = this.getProps(["x", "y"], useFinalPosition);
      const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
      const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const rAdjust = this.options.spacing / 2;
      const _circumference = valueOrDefault(circumference, endAngle - startAngle);
      const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
      const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
      return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
      const { x: x3, y: y2, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const { offset: offset2, spacing } = this.options;
      const halfAngle = (startAngle + endAngle) / 2;
      const halfRadius = (innerRadius + outerRadius + spacing + offset2) / 2;
      return {
        x: x3 + Math.cos(halfAngle) * halfRadius,
        y: y2 + Math.sin(halfAngle) * halfRadius
      };
    }
    tooltipPosition(useFinalPosition) {
      return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
      const { options, circumference } = this;
      const offset2 = (options.offset || 0) / 2;
      const spacing = (options.spacing || 0) / 2;
      const circular = options.circular;
      this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
      this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
      if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
        return;
      }
      ctx.save();
      let radiusOffset = 0;
      if (offset2) {
        radiusOffset = offset2 / 2;
        const halfAngle = (this.startAngle + this.endAngle) / 2;
        ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
        if (this.circumference >= PI) {
          radiusOffset = offset2;
        }
      }
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);
      drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
      ctx.restore();
    }
  };
  ArcElement.id = "arc";
  ArcElement.defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true
  };
  ArcElement.defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  function setStyle(ctx, options, style = options) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options) {
    if (options.stepped) {
      return _steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start3 = Math.max(paramsStart, segmentStart);
    const end2 = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start: start3,
      loop: segment.loop,
      ilen: end2 < start3 && !outside ? count + end2 - start3 : end2 - start3
    };
  }
  function pathSegment(ctx, line, segment, params) {
    const { points, options } = line;
    const { count, start: start3, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move = true, reverse } = params || {};
    let i5, point, prev;
    for (i5 = 0; i5 <= ilen; ++i5) {
      point = points[(start3 + (reverse ? ilen - i5 : i5)) % count];
      if (point.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point.x, point.y);
        move = false;
      } else {
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      prev = point;
    }
    if (loop) {
      point = points[(start3 + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
  }
  function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start: start3, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i5, point, prevX, minY, maxY, lastY;
    const pointIndex = (index2) => (start3 + (reverse ? ilen - index2 : index2)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point = points[pointIndex(0)];
      ctx.moveTo(point.x, point.y);
    }
    for (i5 = 0; i5 <= ilen; ++i5) {
      point = points[pointIndex(i5)];
      if (point.skip) {
        continue;
      }
      const x3 = point.x;
      const y2 = point.y;
      const truncX = x3 | 0;
      if (truncX === prevX) {
        if (y2 < minY) {
          minY = y2;
        } else if (y2 > maxY) {
          maxY = y2;
        }
        avgX = (countX * avgX + x3) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x3, y2);
        prevX = truncX;
        countX = 0;
        minY = maxY = y2;
      }
      lastY = y2;
    }
    drawX();
  }
  function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options) {
    if (options.stepped) {
      return _steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start3, count) {
    let path = line._path;
    if (!path) {
      path = line._path = new Path2D();
      if (line.path(path, start3, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start3, count) {
    const { segments, options } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments) {
      setStyle(ctx, options, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line, segment, { start: start3, end: start3 + count - 1 })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  var usePath2D = typeof Path2D === "function";
  function draw(ctx, line, start3, count) {
    if (usePath2D && !line.options.segment) {
      strokePathWithCache(ctx, line, start3, count);
    } else {
      strokePathDirect(ctx, line, start3, count);
    }
  }
  var LineElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.animated = true;
      this.options = void 0;
      this._chart = void 0;
      this._loop = void 0;
      this._fullLoop = void 0;
      this._path = void 0;
      this._points = void 0;
      this._segments = void 0;
      this._decimated = false;
      this._pointsUpdated = false;
      this._datasetIndex = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    updateControlPoints(chartArea, indexAxis) {
      const options = this.options;
      if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
        const loop = options.spanGaps ? this._loop : this._fullLoop;
        _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
        this._pointsUpdated = true;
      }
    }
    set points(points) {
      this._points = points;
      delete this._segments;
      delete this._path;
      this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
    first() {
      const segments = this.segments;
      const points = this.points;
      return segments.length && points[segments[0].start];
    }
    last() {
      const segments = this.segments;
      const points = this.points;
      const count = segments.length;
      return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
      const options = this.options;
      const value = point[property];
      const points = this.points;
      const segments = _boundSegments(this, { property, start: value, end: value });
      if (!segments.length) {
        return;
      }
      const result = [];
      const _interpolate = _getInterpolationMethod(options);
      let i5, ilen;
      for (i5 = 0, ilen = segments.length; i5 < ilen; ++i5) {
        const { start: start3, end: end2 } = segments[i5];
        const p1 = points[start3];
        const p22 = points[end2];
        if (p1 === p22) {
          result.push(p1);
          continue;
        }
        const t7 = Math.abs((value - p1[property]) / (p22[property] - p1[property]));
        const interpolated = _interpolate(p1, p22, t7, options.stepped);
        interpolated[property] = point[property];
        result.push(interpolated);
      }
      return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
      const segmentMethod = _getSegmentMethod(this);
      return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start3, count) {
      const segments = this.segments;
      const segmentMethod = _getSegmentMethod(this);
      let loop = this._loop;
      start3 = start3 || 0;
      count = count || this.points.length - start3;
      for (const segment of segments) {
        loop &= segmentMethod(ctx, this, segment, { start: start3, end: start3 + count - 1 });
      }
      return !!loop;
    }
    draw(ctx, chartArea, start3, count) {
      const options = this.options || {};
      const points = this.points || [];
      if (points.length && options.borderWidth) {
        ctx.save();
        draw(ctx, this, start3, count);
        ctx.restore();
      }
      if (this.animated) {
        this._pointsUpdated = false;
        this._path = void 0;
      }
    }
  };
  LineElement.id = "line";
  LineElement.defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  };
  LineElement.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  LineElement.descriptors = {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash" && name !== "fill"
  };
  function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value } = el.getProps([axis], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
  }
  var PointElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.parsed = void 0;
      this.skip = void 0;
      this.stop = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      const options = this.options;
      const { x: x3, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
      return Math.pow(mouseX - x3, 2) + Math.pow(mouseY - y2, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x: x3, y: y2 } = this.getProps(["x", "y"], useFinalPosition);
      return { x: x3, y: y2 };
    }
    size(options) {
      options = options || this.options || {};
      let radius = options.radius || 0;
      radius = Math.max(radius, radius && options.hoverRadius || 0);
      const borderWidth = radius && options.borderWidth || 0;
      return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
      const options = this.options;
      if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
        return;
      }
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.fillStyle = options.backgroundColor;
      drawPoint(ctx, options, this.x, this.y);
    }
    getRange() {
      const options = this.options || {};
      return options.radius + options.hitRadius;
    }
  };
  PointElement.id = "point";
  PointElement.defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  PointElement.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  function getBarBounds(bar, useFinalPosition) {
    const { x: x3, y: y2, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
    let left2, right2, top2, bottom2, half;
    if (bar.horizontal) {
      half = height / 2;
      left2 = Math.min(x3, base);
      right2 = Math.max(x3, base);
      top2 = y2 - half;
      bottom2 = y2 + half;
    } else {
      half = width / 2;
      left2 = x3 - half;
      right2 = x3 + half;
      top2 = Math.min(y2, base);
      bottom2 = Math.max(y2, base);
    }
    return { left: left2, top: top2, right: right2, bottom: bottom2 };
  }
  function skipOrLimit(skip2, value, min2, max2) {
    return skip2 ? 0 : _limitValue(value, min2, max2);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o10 = toTRBL(value);
    return {
      t: skipOrLimit(skip2.top, o10.top, 0, maxH),
      r: skipOrLimit(skip2.right, o10.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o10.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o10.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
    const value = bar.options.borderRadius;
    const o10 = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject(value);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o10.topLeft, 0, maxR),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o10.topRight, 0, maxR),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o10.bottomLeft, 0, maxR),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o10.bottomRight, 0, maxR)
    };
  }
  function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x3, y2, useFinalPosition) {
    const skipX = x3 === null;
    const skipY = y2 === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x3, bounds.left, bounds.right)) && (skipY || _isBetween(y2, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x3 = rect.x !== refRect.x ? -amount : 0;
    const y2 = rect.y !== refRect.y ? -amount : 0;
    const w3 = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x3;
    const h3 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y2;
    return {
      x: rect.x + x3,
      y: rect.y + y2,
      w: rect.w + w3,
      h: rect.h + h3,
      radius: rect.radius
    };
  }
  var BarElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.horizontal = void 0;
      this.base = void 0;
      this.width = void 0;
      this.height = void 0;
      this.inflateAmount = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    draw(ctx) {
      const { inflateAmount, options: { borderColor, backgroundColor } } = this;
      const { inner, outer } = boundingRects(this);
      const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
      ctx.save();
      if (outer.w !== inner.w || outer.h !== inner.h) {
        ctx.beginPath();
        addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
        ctx.clip();
        addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
        ctx.fillStyle = borderColor;
        ctx.fill("evenodd");
      }
      ctx.beginPath();
      addRectPath(ctx, inflateRect(inner, inflateAmount));
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x: x3, y: y2, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
      return {
        x: horizontal ? (x3 + base) / 2 : x3,
        y: horizontal ? y2 : (y2 + base) / 2
      };
    }
    getRange(axis) {
      return axis === "x" ? this.width / 2 : this.height / 2;
    }
  };
  BarElement.id = "bar";
  BarElement.defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  };
  BarElement.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  var elements = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement,
    LineElement,
    PointElement,
    BarElement
  });
  function lttbDecimation(data, start3, count, availableWidth, options) {
    const samples = options.samples || availableWidth;
    if (samples >= count) {
      return data.slice(start3, start3 + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start3 + count - 1;
    let a3 = start3;
    let i5, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a3];
    for (i5 = 0; i5 < samples - 2; i5++) {
      let avgX = 0;
      let avgY = 0;
      let j2;
      const avgRangeStart = Math.floor((i5 + 1) * bucketWidth) + 1 + start3;
      const avgRangeEnd = Math.min(Math.floor((i5 + 2) * bucketWidth) + 1, count) + start3;
      const avgRangeLength = avgRangeEnd - avgRangeStart;
      for (j2 = avgRangeStart; j2 < avgRangeEnd; j2++) {
        avgX += data[j2].x;
        avgY += data[j2].y;
      }
      avgX /= avgRangeLength;
      avgY /= avgRangeLength;
      const rangeOffs = Math.floor(i5 * bucketWidth) + 1 + start3;
      const rangeTo = Math.min(Math.floor((i5 + 1) * bucketWidth) + 1, count) + start3;
      const { x: pointAx, y: pointAy } = data[a3];
      maxArea = area = -1;
      for (j2 = rangeOffs; j2 < rangeTo; j2++) {
        area = 0.5 * Math.abs(
          (pointAx - avgX) * (data[j2].y - pointAy) - (pointAx - data[j2].x) * (avgY - pointAy)
        );
        if (area > maxArea) {
          maxArea = area;
          maxAreaPoint = data[j2];
          nextA = j2;
        }
      }
      decimated[sampledIndex++] = maxAreaPoint;
      a3 = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
  }
  function minMaxDecimation(data, start3, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i5, point, x3, y2, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start3 + count - 1;
    const xMin = data[start3].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for (i5 = start3; i5 < start3 + count; ++i5) {
      point = data[i5];
      x3 = (point.x - xMin) / dx * availableWidth;
      y2 = point.y;
      const truncX = x3 | 0;
      if (truncX === prevX) {
        if (y2 < minY) {
          minY = y2;
          minIndex = i5;
        } else if (y2 > maxY) {
          maxY = y2;
          maxIndex = i5;
        }
        avgX = (countX * avgX + point.x) / ++countX;
      } else {
        const lastIndex = i5 - 1;
        if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
          const intermediateIndex1 = Math.min(minIndex, maxIndex);
          const intermediateIndex2 = Math.max(minIndex, maxIndex);
          if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
            decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {
              x: avgX
            }));
          }
          if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
            decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {
              x: avgX
            }));
          }
        }
        if (i5 > 0 && lastIndex !== startIndex) {
          decimated.push(data[lastIndex]);
        }
        decimated.push(point);
        prevX = truncX;
        countX = 0;
        minY = maxY = y2;
        minIndex = maxIndex = startIndex = i5;
      }
    }
    return decimated;
  }
  function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
      const data = dataset._data;
      delete dataset._decimated;
      delete dataset._data;
      Object.defineProperty(dataset, "data", { value: data });
    }
  }
  function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset) => {
      cleanDecimatedDataset(dataset);
    });
  }
  function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start3 = 0;
    let count;
    const { iScale } = meta;
    const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start3 = _limitValue(_lookupByKey(points, iScale.axis, min2).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(_lookupByKey(points, iScale.axis, max2).hi + 1, start3, pointCount) - start3;
    } else {
      count = pointCount - start3;
    }
    return { start: start3, count };
  }
  var plugin_decimation = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (chart, args, options) => {
      if (!options.enabled) {
        cleanDecimatedData(chart);
        return;
      }
      const availableWidth = chart.width;
      chart.data.datasets.forEach((dataset, datasetIndex) => {
        const { _data, indexAxis } = dataset;
        const meta = chart.getDatasetMeta(datasetIndex);
        const data = _data || dataset.data;
        if (resolve([indexAxis, chart.options.indexAxis]) === "y") {
          return;
        }
        if (!meta.controller.supportsDecimation) {
          return;
        }
        const xAxis = chart.scales[meta.xAxisID];
        if (xAxis.type !== "linear" && xAxis.type !== "time") {
          return;
        }
        if (chart.options.parsing) {
          return;
        }
        let { start: start3, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
        const threshold = options.threshold || 4 * availableWidth;
        if (count <= threshold) {
          cleanDecimatedDataset(dataset);
          return;
        }
        if (isNullOrUndef(_data)) {
          dataset._data = data;
          delete dataset.data;
          Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            get: function() {
              return this._decimated;
            },
            set: function(d5) {
              this._data = d5;
            }
          });
        }
        let decimated;
        switch (options.algorithm) {
          case "lttb":
            decimated = lttbDecimation(data, start3, count, availableWidth, options);
            break;
          case "min-max":
            decimated = minMaxDecimation(data, start3, count, availableWidth);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
        }
        dataset._decimated = decimated;
      });
    },
    destroy(chart) {
      cleanDecimatedData(chart);
    }
  };
  function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments) {
      let { start: start3, end: end2 } = segment;
      end2 = _findSegmentEnd(start3, end2, points);
      const bounds = _getBounds(property, points[start3], points[end2], segment.loop);
      if (!target.segments) {
        parts.push({
          source: segment,
          target: bounds,
          start: points[start3],
          end: points[end2]
        });
        continue;
      }
      const targetSegments = _boundSegments(target, bounds);
      for (const tgt of targetSegments) {
        const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
        const fillSources = _boundSegment(segment, points, subBounds);
        for (const fillSource of fillSources) {
          parts.push({
            source: fillSource,
            target: tgt,
            start: {
              [property]: _getEdge(bounds, subBounds, "start", Math.max)
            },
            end: {
              [property]: _getEdge(bounds, subBounds, "end", Math.min)
            }
          });
        }
      }
    }
    return parts;
  }
  function _getBounds(property, first, last2, loop) {
    if (loop) {
      return;
    }
    let start3 = first[property];
    let end2 = last2[property];
    if (property === "angle") {
      start3 = _normalizeAngle(start3);
      end2 = _normalizeAngle(end2);
    }
    return { property, start: start3, end: end2 };
  }
  function _pointsFromSegments(boundary, line) {
    const { x: x3 = null, y: y2 = null } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start: start3, end: end2 }) => {
      end2 = _findSegmentEnd(start3, end2, linePoints);
      const first = linePoints[start3];
      const last2 = linePoints[end2];
      if (y2 !== null) {
        points.push({ x: first.x, y: y2 });
        points.push({ x: last2.x, y: y2 });
      } else if (x3 !== null) {
        points.push({ x: x3, y: first.y });
        points.push({ x: x3, y: last2.y });
      }
    });
    return points;
  }
  function _findSegmentEnd(start3, end2, points) {
    for (; end2 > start3; end2--) {
      const point = points[end2];
      if (!isNaN(point.x) && !isNaN(point.y)) {
        break;
      }
    }
    return end2;
  }
  function _getEdge(a3, b2, prop, fn2) {
    if (a3 && b2) {
      return fn2(a3[prop], b2[prop]);
    }
    return a3 ? a3[prop] : b2 ? b2[prop] : 0;
  }
  function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (isArray(boundary)) {
      _loop = true;
      points = boundary;
    } else {
      points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
      points,
      options: { tension: 0 },
      _loop,
      _fullLoop: _loop
    }) : null;
  }
  function _shouldApplyFill(source) {
    return source && source.fill !== false;
  }
  function _resolveTarget(sources, index2, propagate) {
    const source = sources[index2];
    let fill2 = source.fill;
    const visited = [index2];
    let target;
    if (!propagate) {
      return fill2;
    }
    while (fill2 !== false && visited.indexOf(fill2) === -1) {
      if (!isNumberFinite(fill2)) {
        return fill2;
      }
      target = sources[fill2];
      if (!target) {
        return false;
      }
      if (target.visible) {
        return fill2;
      }
      visited.push(fill2);
      fill2 = target.fill;
    }
    return false;
  }
  function _decodeFill(line, index2, count) {
    const fill2 = parseFillOption(line);
    if (isObject(fill2)) {
      return isNaN(fill2.value) ? false : fill2;
    }
    let target = parseFloat(fill2);
    if (isNumberFinite(target) && Math.floor(target) === target) {
      return decodeTargetIndex(fill2[0], index2, target, count);
    }
    return ["origin", "start", "end", "stack", "shape"].indexOf(fill2) >= 0 && fill2;
  }
  function decodeTargetIndex(firstCh, index2, target, count) {
    if (firstCh === "-" || firstCh === "+") {
      target = index2 + target;
    }
    if (target === index2 || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  function _getTargetPixel(fill2, scale2) {
    let pixel = null;
    if (fill2 === "start") {
      pixel = scale2.bottom;
    } else if (fill2 === "end") {
      pixel = scale2.top;
    } else if (isObject(fill2)) {
      pixel = scale2.getPixelForValue(fill2.value);
    } else if (scale2.getBasePixel) {
      pixel = scale2.getBasePixel();
    }
    return pixel;
  }
  function _getTargetValue(fill2, scale2, startValue) {
    let value;
    if (fill2 === "start") {
      value = startValue;
    } else if (fill2 === "end") {
      value = scale2.options.reverse ? scale2.min : scale2.max;
    } else if (isObject(fill2)) {
      value = fill2.value;
    } else {
      value = scale2.getBaseValue();
    }
    return value;
  }
  function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill2 === void 0) {
      fill2 = !!options.backgroundColor;
    }
    if (fill2 === false || fill2 === null) {
      return false;
    }
    if (fill2 === true) {
      return "origin";
    }
    return fill2;
  }
  function _buildStackLine(source) {
    const { scale: scale2, index: index2, line } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale2, index2);
    linesBelow.push(_createBoundaryLine({ x: null, y: scale2.bottom }, line));
    for (let i5 = 0; i5 < segments.length; i5++) {
      const segment = segments[i5];
      for (let j2 = segment.start; j2 <= segment.end; j2++) {
        addPointsBelow(points, sourcePoints[j2], linesBelow);
      }
    }
    return new LineElement({ points, options: {} });
  }
  function getLinesBelow(scale2, index2) {
    const below = [];
    const metas = scale2.getMatchingVisibleMetas("line");
    for (let i5 = 0; i5 < metas.length; i5++) {
      const meta = metas[i5];
      if (meta.index === index2) {
        break;
      }
      if (!meta.hidden) {
        below.unshift(meta.dataset);
      }
    }
    return below;
  }
  function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for (let j2 = 0; j2 < linesBelow.length; j2++) {
      const line = linesBelow[j2];
      const { first, last: last2, point } = findPoint(line, sourcePoint, "x");
      if (!point || first && last2) {
        continue;
      }
      if (first) {
        postponed.unshift(point);
      } else {
        points.push(point);
        if (!last2) {
          break;
        }
      }
    }
    points.push(...postponed);
  }
  function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
      return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last2 = false;
    for (let i5 = 0; i5 < segments.length; i5++) {
      const segment = segments[i5];
      const firstValue = linePoints[segment.start][property];
      const lastValue = linePoints[segment.end][property];
      if (_isBetween(pointValue, firstValue, lastValue)) {
        first = pointValue === firstValue;
        last2 = pointValue === lastValue;
        break;
      }
    }
    return { first, last: last2, point };
  }
  var simpleArc = class {
    constructor(opts) {
      this.x = opts.x;
      this.y = opts.y;
      this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
      const { x: x3, y: y2, radius } = this;
      bounds = bounds || { start: 0, end: TAU };
      ctx.arc(x3, y2, radius, bounds.end, bounds.start, true);
      return !opts.bounds;
    }
    interpolate(point) {
      const { x: x3, y: y2, radius } = this;
      const angle = point.angle;
      return {
        x: x3 + Math.cos(angle) * radius,
        y: y2 + Math.sin(angle) * radius,
        angle
      };
    }
  };
  function _getTarget(source) {
    const { chart, fill: fill2, line } = source;
    if (isNumberFinite(fill2)) {
      return getLineByIndex(chart, fill2);
    }
    if (fill2 === "stack") {
      return _buildStackLine(source);
    }
    if (fill2 === "shape") {
      return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
      return boundary;
    }
    return _createBoundaryLine(boundary, line);
  }
  function getLineByIndex(chart, index2) {
    const meta = chart.getDatasetMeta(index2);
    const visible = meta && chart.isDatasetVisible(index2);
    return visible ? meta.dataset : null;
  }
  function computeBoundary(source) {
    const scale2 = source.scale || {};
    if (scale2.getPointPositionForValue) {
      return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
  }
  function computeLinearBoundary(source) {
    const { scale: scale2 = {}, fill: fill2 } = source;
    const pixel = _getTargetPixel(fill2, scale2);
    if (isNumberFinite(pixel)) {
      const horizontal = scale2.isHorizontal();
      return {
        x: horizontal ? pixel : null,
        y: horizontal ? null : pixel
      };
    }
    return null;
  }
  function computeCircularBoundary(source) {
    const { scale: scale2, fill: fill2 } = source;
    const options = scale2.options;
    const length = scale2.getLabels().length;
    const start3 = options.reverse ? scale2.max : scale2.min;
    const value = _getTargetValue(fill2, scale2, start3);
    const target = [];
    if (options.grid.circular) {
      const center = scale2.getPointPositionForValue(0, start3);
      return new simpleArc({
        x: center.x,
        y: center.y,
        radius: scale2.getDistanceFromCenterForValue(value)
      });
    }
    for (let i5 = 0; i5 < length; ++i5) {
      target.push(scale2.getPointPositionForValue(i5, value));
    }
    return target;
  }
  function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { line, scale: scale2, axis } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color2 = lineOpts.backgroundColor;
    const { above = color2, below = color2 } = fillOption || {};
    if (target && line.points.length) {
      clipArea(ctx, area);
      doFill(ctx, { line, target, above, below, area, scale: scale2, axis });
      unclipArea(ctx);
    }
  }
  function doFill(ctx, cfg) {
    const { line, target, above, below, area, scale: scale2 } = cfg;
    const property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    if (property === "x" && below !== above) {
      clipVertical(ctx, target, area.top);
      fill(ctx, { line, target, color: above, scale: scale2, property });
      ctx.restore();
      ctx.save();
      clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, { line, target, color: below, scale: scale2, property });
    ctx.restore();
  }
  function clipVertical(ctx, target, clipY) {
    const { segments, points } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments) {
      const { start: start3, end: end2 } = segment;
      const firstPoint = points[start3];
      const lastPoint = points[_findSegmentEnd(start3, end2, points)];
      if (first) {
        ctx.moveTo(firstPoint.x, firstPoint.y);
        first = false;
      } else {
        ctx.lineTo(firstPoint.x, clipY);
        ctx.lineTo(firstPoint.x, firstPoint.y);
      }
      lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
      if (lineLoop) {
        ctx.closePath();
      } else {
        ctx.lineTo(lastPoint.x, clipY);
      }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
  }
  function fill(ctx, cfg) {
    const { line, target, property, color: color2, scale: scale2 } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src, target: tgt, start: start3, end: end2 } of segments) {
      const { style: { backgroundColor = color2 } = {} } = src;
      const notShape = target !== true;
      ctx.save();
      ctx.fillStyle = backgroundColor;
      clipBounds(ctx, scale2, notShape && _getBounds(property, start3, end2));
      ctx.beginPath();
      const lineLoop = !!line.pathSegment(ctx, src);
      let loop;
      if (notShape) {
        if (lineLoop) {
          ctx.closePath();
        } else {
          interpolatedLineTo(ctx, target, end2, property);
        }
        const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
        loop = lineLoop && targetLoop;
        if (!loop) {
          interpolatedLineTo(ctx, target, start3, property);
        }
      }
      ctx.closePath();
      ctx.fill(loop ? "evenodd" : "nonzero");
      ctx.restore();
    }
  }
  function clipBounds(ctx, scale2, bounds) {
    const { top: top2, bottom: bottom2 } = scale2.chart.chartArea;
    const { property, start: start3, end: end2 } = bounds || {};
    if (property === "x") {
      ctx.beginPath();
      ctx.rect(start3, top2, end2 - start3, bottom2 - top2);
      ctx.clip();
    }
  }
  function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
      ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
  }
  var index = {
    id: "filler",
    afterDatasetsUpdate(chart, _args, options) {
      const count = (chart.data.datasets || []).length;
      const sources = [];
      let meta, i5, line, source;
      for (i5 = 0; i5 < count; ++i5) {
        meta = chart.getDatasetMeta(i5);
        line = meta.dataset;
        source = null;
        if (line && line.options && line instanceof LineElement) {
          source = {
            visible: chart.isDatasetVisible(i5),
            index: i5,
            fill: _decodeFill(line, i5, count),
            chart,
            axis: meta.controller.options.indexAxis,
            scale: meta.vScale,
            line
          };
        }
        meta.$filler = source;
        sources.push(source);
      }
      for (i5 = 0; i5 < count; ++i5) {
        source = sources[i5];
        if (!source || source.fill === false) {
          continue;
        }
        source.fill = _resolveTarget(sources, i5, options.propagate);
      }
    },
    beforeDraw(chart, _args, options) {
      const draw2 = options.drawTime === "beforeDraw";
      const metasets = chart.getSortedVisibleDatasetMetas();
      const area = chart.chartArea;
      for (let i5 = metasets.length - 1; i5 >= 0; --i5) {
        const source = metasets[i5].$filler;
        if (!source) {
          continue;
        }
        source.line.updateControlPoints(area, source.axis);
        if (draw2 && source.fill) {
          _drawfill(chart.ctx, source, area);
        }
      }
    },
    beforeDatasetsDraw(chart, _args, options) {
      if (options.drawTime !== "beforeDatasetsDraw") {
        return;
      }
      const metasets = chart.getSortedVisibleDatasetMetas();
      for (let i5 = metasets.length - 1; i5 >= 0; --i5) {
        const source = metasets[i5].$filler;
        if (_shouldApplyFill(source)) {
          _drawfill(chart.ctx, source, chart.chartArea);
        }
      }
    },
    beforeDatasetDraw(chart, args, options) {
      const source = args.meta.$filler;
      if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
        return;
      }
      _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
      boxHeight = Math.min(boxHeight, fontSize);
      boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
      boxWidth,
      boxHeight,
      itemHeight: Math.max(fontSize, boxHeight)
    };
  };
  var itemsEqual = (a3, b2) => a3 !== null && b2 !== null && a3.datasetIndex === b2.datasetIndex && a3.index === b2.index;
  var Legend = class extends Element2 {
    constructor(config) {
      super();
      this._added = false;
      this.legendHitBoxes = [];
      this._hoveredItem = null;
      this.doughnutMode = false;
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this.legendItems = void 0;
      this.columnSizes = void 0;
      this.lineWidths = void 0;
      this.maxHeight = void 0;
      this.maxWidth = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.height = void 0;
      this.width = void 0;
      this._margins = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins;
      this.setDimensions();
      this.buildLabels();
      this.fit();
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = this._margins.left;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = this._margins.top;
        this.bottom = this.height;
      }
    }
    buildLabels() {
      const labelOpts = this.options.labels || {};
      let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
      }
      if (labelOpts.sort) {
        legendItems = legendItems.sort((a3, b2) => labelOpts.sort(a3, b2, this.chart.data));
      }
      if (this.options.reverse) {
        legendItems.reverse();
      }
      this.legendItems = legendItems;
    }
    fit() {
      const { options, ctx } = this;
      if (!options.display) {
        this.width = this.height = 0;
        return;
      }
      const labelOpts = options.labels;
      const labelFont = toFont(labelOpts.font);
      const fontSize = labelFont.size;
      const titleHeight = this._computeTitleHeight();
      const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
      let width, height;
      ctx.font = labelFont.string;
      if (this.isHorizontal()) {
        width = this.maxWidth;
        height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      } else {
        height = this.maxHeight;
        width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      }
      this.width = Math.min(width, options.maxWidth || this.maxWidth);
      this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxWidth, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const lineWidths = this.lineWidths = [0];
      const lineHeight = itemHeight + padding;
      let totalHeight = titleHeight;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let row = -1;
      let top2 = -lineHeight;
      this.legendItems.forEach((legendItem, i5) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i5 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
          totalHeight += lineHeight;
          lineWidths[lineWidths.length - (i5 > 0 ? 0 : 1)] = 0;
          top2 += lineHeight;
          row++;
        }
        hitboxes[i5] = { left: 0, top: top2, row, width: itemWidth, height: itemHeight };
        lineWidths[lineWidths.length - 1] += itemWidth + padding;
      });
      return totalHeight;
    }
    _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxHeight, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const columnSizes = this.columnSizes = [];
      const heightLimit = maxHeight - titleHeight;
      let totalWidth = padding;
      let currentColWidth = 0;
      let currentColHeight = 0;
      let left2 = 0;
      let col = 0;
      this.legendItems.forEach((legendItem, i5) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i5 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
          totalWidth += currentColWidth + padding;
          columnSizes.push({ width: currentColWidth, height: currentColHeight });
          left2 += currentColWidth + padding;
          col++;
          currentColWidth = currentColHeight = 0;
        }
        hitboxes[i5] = { left: left2, top: currentColHeight, col, width: itemWidth, height: itemHeight };
        currentColWidth = Math.max(currentColWidth, itemWidth);
        currentColHeight += itemHeight + padding;
      });
      totalWidth += currentColWidth;
      columnSizes.push({ width: currentColWidth, height: currentColHeight });
      return totalWidth;
    }
    adjustHitBoxes() {
      if (!this.options.display) {
        return;
      }
      const titleHeight = this._computeTitleHeight();
      const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
      const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
      if (this.isHorizontal()) {
        let row = 0;
        let left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        for (const hitbox of hitboxes) {
          if (row !== hitbox.row) {
            row = hitbox.row;
            left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          }
          hitbox.top += this.top + titleHeight + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left2), hitbox.width);
          left2 += hitbox.width + padding;
        }
      } else {
        let col = 0;
        let top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        for (const hitbox of hitboxes) {
          if (hitbox.col !== col) {
            col = hitbox.col;
            top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          }
          hitbox.top = top2;
          hitbox.left += this.left + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
          top2 += hitbox.height + padding;
        }
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const ctx = this.ctx;
        clipArea(ctx, this);
        this._draw();
        unclipArea(ctx);
      }
    }
    _draw() {
      const { options: opts, columnSizes, lineWidths, ctx } = this;
      const { align, labels: labelOpts } = opts;
      const defaultColor = defaults.color;
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const labelFont = toFont(labelOpts.font);
      const { color: fontColor, padding } = labelOpts;
      const fontSize = labelFont.size;
      const halfFontSize = fontSize / 2;
      let cursor;
      this.drawTitle();
      ctx.textAlign = rtlHelper.textAlign("left");
      ctx.textBaseline = "middle";
      ctx.lineWidth = 0.5;
      ctx.font = labelFont.string;
      const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
      const drawLegendBox = function(x3, y2, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
          return;
        }
        ctx.save();
        const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
        ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
        if (labelOpts.usePointStyle) {
          const drawOptions = {
            radius: boxHeight * Math.SQRT2 / 2,
            pointStyle: legendItem.pointStyle,
            rotation: legendItem.rotation,
            borderWidth: lineWidth
          };
          const centerX = rtlHelper.xPlus(x3, boxWidth / 2);
          const centerY = y2 + halfFontSize;
          drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
        } else {
          const yBoxTop = y2 + Math.max((fontSize - boxHeight) / 2, 0);
          const xBoxLeft = rtlHelper.leftForLtr(x3, boxWidth);
          const borderRadius = toTRBLCorners(legendItem.borderRadius);
          ctx.beginPath();
          if (Object.values(borderRadius).some((v3) => v3 !== 0)) {
            addRoundedRectPath(ctx, {
              x: xBoxLeft,
              y: yBoxTop,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
          } else {
            ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
          }
          ctx.fill();
          if (lineWidth !== 0) {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      const fillText = function(x3, y2, legendItem) {
        renderText(ctx, legendItem.text, x3, y2 + itemHeight / 2, labelFont, {
          strikethrough: legendItem.hidden,
          textAlign: rtlHelper.textAlign(legendItem.textAlign)
        });
      };
      const isHorizontal = this.isHorizontal();
      const titleHeight = this._computeTitleHeight();
      if (isHorizontal) {
        cursor = {
          x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
          y: this.top + padding + titleHeight,
          line: 0
        };
      } else {
        cursor = {
          x: this.left + padding,
          y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
          line: 0
        };
      }
      overrideTextDirection(this.ctx, opts.textDirection);
      const lineHeight = itemHeight + padding;
      this.legendItems.forEach((legendItem, i5) => {
        ctx.strokeStyle = legendItem.fontColor || fontColor;
        ctx.fillStyle = legendItem.fontColor || fontColor;
        const textWidth = ctx.measureText(legendItem.text).width;
        const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
        const width = boxWidth + halfFontSize + textWidth;
        let x3 = cursor.x;
        let y2 = cursor.y;
        rtlHelper.setWidth(this.width);
        if (isHorizontal) {
          if (i5 > 0 && x3 + width + padding > this.right) {
            y2 = cursor.y += lineHeight;
            cursor.line++;
            x3 = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
          }
        } else if (i5 > 0 && y2 + lineHeight > this.bottom) {
          x3 = cursor.x = x3 + columnSizes[cursor.line].width + padding;
          cursor.line++;
          y2 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
        }
        const realX = rtlHelper.x(x3);
        drawLegendBox(realX, y2, legendItem);
        x3 = _textX(textAlign, x3 + boxWidth + halfFontSize, isHorizontal ? x3 + width : this.right, opts.rtl);
        fillText(rtlHelper.x(x3), y2, legendItem);
        if (isHorizontal) {
          cursor.x += width + padding;
        } else {
          cursor.y += lineHeight;
        }
      });
      restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
      const opts = this.options;
      const titleOpts = opts.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      if (!titleOpts.display) {
        return;
      }
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const ctx = this.ctx;
      const position = titleOpts.position;
      const halfFontSize = titleFont.size / 2;
      const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
      let y2;
      let left2 = this.left;
      let maxWidth = this.width;
      if (this.isHorizontal()) {
        maxWidth = Math.max(...this.lineWidths);
        y2 = this.top + topPaddingPlusHalfFontSize;
        left2 = _alignStartEnd(opts.align, left2, this.right - maxWidth);
      } else {
        const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
        y2 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
      }
      const x3 = _alignStartEnd(position, left2, left2 + maxWidth);
      ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
      ctx.textBaseline = "middle";
      ctx.strokeStyle = titleOpts.color;
      ctx.fillStyle = titleOpts.color;
      ctx.font = titleFont.string;
      renderText(ctx, titleOpts.text, x3, y2, titleFont);
    }
    _computeTitleHeight() {
      const titleOpts = this.options.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x3, y2) {
      let i5, hitBox, lh;
      if (_isBetween(x3, this.left, this.right) && _isBetween(y2, this.top, this.bottom)) {
        lh = this.legendHitBoxes;
        for (i5 = 0; i5 < lh.length; ++i5) {
          hitBox = lh[i5];
          if (_isBetween(x3, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y2, hitBox.top, hitBox.top + hitBox.height)) {
            return this.legendItems[i5];
          }
        }
      }
      return null;
    }
    handleEvent(e3) {
      const opts = this.options;
      if (!isListened(e3.type, opts)) {
        return;
      }
      const hoveredItem = this._getLegendItemAt(e3.x, e3.y);
      if (e3.type === "mousemove" || e3.type === "mouseout") {
        const previous = this._hoveredItem;
        const sameItem = itemsEqual(previous, hoveredItem);
        if (previous && !sameItem) {
          callback(opts.onLeave, [e3, previous, this], this);
        }
        this._hoveredItem = hoveredItem;
        if (hoveredItem && !sameItem) {
          callback(opts.onHover, [e3, hoveredItem, this], this);
        }
      } else if (hoveredItem) {
        callback(opts.onClick, [e3, hoveredItem, this], this);
      }
    }
  };
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options) {
      const legend = chart.legend = new Legend({ ctx: chart.ctx, options, chart });
      layouts.configure(chart, legend, options);
      layouts.addBox(chart, legend);
    },
    stop(chart) {
      layouts.removeBox(chart, chart.legend);
      delete chart.legend;
    },
    beforeUpdate(chart, _args, options) {
      const legend = chart.legend;
      layouts.configure(chart, legend, options);
      legend.options = options;
    },
    afterUpdate(chart) {
      const legend = chart.legend;
      legend.buildLabels();
      legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
      if (!args.replay) {
        chart.legend.handleEvent(args.event);
      }
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(e3, legendItem, legend) {
        const index2 = legendItem.datasetIndex;
        const ci = legend.chart;
        if (ci.isDatasetVisible(index2)) {
          ci.hide(index2);
          legendItem.hidden = true;
        } else {
          ci.show(index2);
          legendItem.hidden = false;
        }
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (ctx) => ctx.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(chart) {
          const datasets = chart.data.datasets;
          const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart.legend.options;
          return chart._getSortedDatasetMetas().map((meta) => {
            const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
            const borderWidth = toPadding(style.borderWidth);
            return {
              text: datasets[meta.index].label,
              fillStyle: style.backgroundColor,
              fontColor: color2,
              hidden: !meta.visible,
              lineCap: style.borderCapStyle,
              lineDash: style.borderDash,
              lineDashOffset: style.borderDashOffset,
              lineJoin: style.borderJoinStyle,
              lineWidth: (borderWidth.width + borderWidth.height) / 4,
              strokeStyle: style.borderColor,
              pointStyle: pointStyle || style.pointStyle,
              rotation: style.rotation,
              textAlign: textAlign || style.textAlign,
              borderRadius: 0,
              datasetIndex: meta.index
            };
          }, this);
        }
      },
      title: {
        color: (ctx) => ctx.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (name) => !name.startsWith("on"),
      labels: {
        _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
      }
    }
  };
  var Title = class extends Element2 {
    constructor(config) {
      super();
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this._padding = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
      const opts = this.options;
      this.left = 0;
      this.top = 0;
      if (!opts.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = maxWidth;
      this.height = this.bottom = maxHeight;
      const lineCount = isArray(opts.text) ? opts.text.length : 1;
      this._padding = toPadding(opts.padding);
      const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
      if (this.isHorizontal()) {
        this.height = textSize;
      } else {
        this.width = textSize;
      }
    }
    isHorizontal() {
      const pos = this.options.position;
      return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset2) {
      const { top: top2, left: left2, bottom: bottom2, right: right2, options } = this;
      const align = options.align;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      if (this.isHorizontal()) {
        titleX = _alignStartEnd(align, left2, right2);
        titleY = top2 + offset2;
        maxWidth = right2 - left2;
      } else {
        if (options.position === "left") {
          titleX = left2 + offset2;
          titleY = _alignStartEnd(align, bottom2, top2);
          rotation = PI * -0.5;
        } else {
          titleX = right2 - offset2;
          titleY = _alignStartEnd(align, top2, bottom2);
          rotation = PI * 0.5;
        }
        maxWidth = bottom2 - top2;
      }
      return { titleX, titleY, maxWidth, rotation };
    }
    draw() {
      const ctx = this.ctx;
      const opts = this.options;
      if (!opts.display) {
        return;
      }
      const fontOpts = toFont(opts.font);
      const lineHeight = fontOpts.lineHeight;
      const offset2 = lineHeight / 2 + this._padding.top;
      const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset2);
      renderText(ctx, opts.text, 0, 0, fontOpts, {
        color: opts.color,
        maxWidth,
        rotation,
        textAlign: _toLeftRightCenter(opts.align),
        textBaseline: "middle",
        translation: [titleX, titleY]
      });
    }
  };
  function createTitle(chart, titleOpts) {
    const title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options) {
      createTitle(chart, options);
    },
    stop(chart) {
      const titleBlock = chart.titleBlock;
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options) {
      const title = chart.titleBlock;
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var map2 = /* @__PURE__ */ new WeakMap();
  var plugin_subtitle = {
    id: "subtitle",
    start(chart, _args, options) {
      const title = new Title({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, title, options);
      layouts.addBox(chart, title);
      map2.set(chart, title);
    },
    stop(chart) {
      layouts.removeBox(chart, map2.get(chart));
      map2.delete(chart);
    },
    beforeUpdate(chart, _args, options) {
      const title = map2.get(chart);
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var positioners = {
    average(items) {
      if (!items.length) {
        return false;
      }
      let i5, len;
      let x3 = 0;
      let y2 = 0;
      let count = 0;
      for (i5 = 0, len = items.length; i5 < len; ++i5) {
        const el = items[i5].element;
        if (el && el.hasValue()) {
          const pos = el.tooltipPosition();
          x3 += pos.x;
          y2 += pos.y;
          ++count;
        }
      }
      return {
        x: x3 / count,
        y: y2 / count
      };
    },
    nearest(items, eventPosition) {
      if (!items.length) {
        return false;
      }
      let x3 = eventPosition.x;
      let y2 = eventPosition.y;
      let minDistance = Number.POSITIVE_INFINITY;
      let i5, len, nearestElement;
      for (i5 = 0, len = items.length; i5 < len; ++i5) {
        const el = items[i5].element;
        if (el && el.hasValue()) {
          const center = el.getCenterPoint();
          const d5 = distanceBetweenPoints(eventPosition, center);
          if (d5 < minDistance) {
            minDistance = d5;
            nearestElement = el;
          }
        }
      }
      if (nearestElement) {
        const tp = nearestElement.tooltipPosition();
        x3 = tp.x;
        y2 = tp.y;
      }
      return {
        x: x3,
        y: y2
      };
    }
  };
  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (isArray(toPush)) {
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }
    return base;
  }
  function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
      return str.split("\n");
    }
    return str;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index: index2 } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index2);
    return {
      chart,
      label,
      parsed: controller.getParsed(index2),
      raw: chart.data.datasets[datasetIndex].data[index2],
      formattedValue: value,
      dataset: controller.getDataset(),
      dataIndex: index2,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
      height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem) => {
      each(bodyItem.before, maxLineWidth);
      each(bodyItem.lines, maxLineWidth);
      each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return { width, height };
  }
  function determineYAlign(chart, size) {
    const { y: y2, height } = size;
    if (y2 < height / 2) {
      return "top";
    } else if (y2 > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x: x3, width } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x3 + width + caret > chart.width) {
      return true;
    }
    if (xAlign === "right" && x3 - width - caret < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options, size, yAlign) {
    const { x: x3, width } = size;
    const { width: chartWidth, chartArea: { left: left2, right: right2 } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x3 <= (left2 + right2) / 2 ? "left" : "right";
    } else if (x3 <= width / 2) {
      xAlign = "left";
    } else if (x3 >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
      xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
      yAlign
    };
  }
  function alignX(size, xAlign) {
    let { x: x3, width } = size;
    if (xAlign === "right") {
      x3 -= width;
    } else if (xAlign === "center") {
      x3 -= width / 2;
    }
    return x3;
  }
  function alignY(size, yAlign, paddingAndSize) {
    let { y: y2, height } = size;
    if (yAlign === "top") {
      y2 += paddingAndSize;
    } else if (yAlign === "bottom") {
      y2 -= height + paddingAndSize;
    } else {
      y2 -= height / 2;
    }
    return y2;
  }
  function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x3 = alignX(size, xAlign);
    const y2 = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x3 += paddingAndSize;
      } else if (xAlign === "right") {
        x3 -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x3 -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x3 += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x3, 0, chart.width - size.width),
      y: _limitValue(y2, 0, chart.height - size.height)
    };
  }
  function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext5(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
  }
  var Tooltip2 = class extends Element2 {
    constructor(config) {
      super();
      this.opacity = 0;
      this._active = [];
      this._eventPosition = void 0;
      this._size = void 0;
      this._cachedAnimations = void 0;
      this._tooltipItems = [];
      this.$animations = void 0;
      this.$context = void 0;
      this.chart = config.chart || config._chart;
      this._chart = this.chart;
      this.options = config.options;
      this.dataPoints = void 0;
      this.title = void 0;
      this.beforeBody = void 0;
      this.body = void 0;
      this.afterBody = void 0;
      this.footer = void 0;
      this.xAlign = void 0;
      this.yAlign = void 0;
      this.x = void 0;
      this.y = void 0;
      this.height = void 0;
      this.width = void 0;
      this.caretX = void 0;
      this.caretY = void 0;
      this.labelColors = void 0;
      this.labelPointStyles = void 0;
      this.labelTextColors = void 0;
    }
    initialize(options) {
      this.options = options;
      this._cachedAnimations = void 0;
      this.$context = void 0;
    }
    _resolveAnimations() {
      const cached = this._cachedAnimations;
      if (cached) {
        return cached;
      }
      const chart = this.chart;
      const options = this.options.setContext(this.getContext());
      const opts = options.enabled && chart.options.animation && options.animations;
      const animations = new Animations(this.chart, opts);
      if (opts._cacheable) {
        this._cachedAnimations = Object.freeze(animations);
      }
      return animations;
    }
    getContext() {
      return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
      const { callbacks } = options;
      const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
      const title = callbacks.title.apply(this, [context]);
      const afterTitle = callbacks.afterTitle.apply(this, [context]);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    }
    getBeforeBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
    }
    getBody(tooltipItems, options) {
      const { callbacks } = options;
      const bodyItems = [];
      each(tooltipItems, (context) => {
        const bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        const scoped = overrideCallbacks(callbacks, context);
        pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
        pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
        pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
    }
    getFooter(tooltipItems, options) {
      const { callbacks } = options;
      const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
      const footer = callbacks.footer.apply(this, [tooltipItems]);
      const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    }
    _createItems(options) {
      const active = this._active;
      const data = this.chart.data;
      const labelColors = [];
      const labelPointStyles = [];
      const labelTextColors = [];
      let tooltipItems = [];
      let i5, len;
      for (i5 = 0, len = active.length; i5 < len; ++i5) {
        tooltipItems.push(createTooltipItem(this.chart, active[i5]));
      }
      if (options.filter) {
        tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
      }
      if (options.itemSort) {
        tooltipItems = tooltipItems.sort((a3, b2) => options.itemSort(a3, b2, data));
      }
      each(tooltipItems, (context) => {
        const scoped = overrideCallbacks(options.callbacks, context);
        labelColors.push(scoped.labelColor.call(this, context));
        labelPointStyles.push(scoped.labelPointStyle.call(this, context));
        labelTextColors.push(scoped.labelTextColor.call(this, context));
      });
      this.labelColors = labelColors;
      this.labelPointStyles = labelPointStyles;
      this.labelTextColors = labelTextColors;
      this.dataPoints = tooltipItems;
      return tooltipItems;
    }
    update(changed, replay) {
      const options = this.options.setContext(this.getContext());
      const active = this._active;
      let properties;
      let tooltipItems = [];
      if (!active.length) {
        if (this.opacity !== 0) {
          properties = {
            opacity: 0
          };
        }
      } else {
        const position = positioners[options.position].call(this, active, this._eventPosition);
        tooltipItems = this._createItems(options);
        this.title = this.getTitle(tooltipItems, options);
        this.beforeBody = this.getBeforeBody(tooltipItems, options);
        this.body = this.getBody(tooltipItems, options);
        this.afterBody = this.getAfterBody(tooltipItems, options);
        this.footer = this.getFooter(tooltipItems, options);
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, size);
        const alignment = determineAlignment(this.chart, options, positionAndSize);
        const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        properties = {
          opacity: 1,
          x: backgroundPoint.x,
          y: backgroundPoint.y,
          width: size.width,
          height: size.height,
          caretX: position.x,
          caretY: position.y
        };
      }
      this._tooltipItems = tooltipItems;
      this.$context = void 0;
      if (properties) {
        this._resolveAnimations().update(this, properties);
      }
      if (changed && options.external) {
        options.external.call(this, { chart: this.chart, tooltip: this, replay });
      }
    }
    drawCaret(tooltipPoint, ctx, size, options) {
      const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
      const { xAlign, yAlign } = this;
      const { caretSize, cornerRadius } = options;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      const { x: ptX, y: ptY } = tooltipPoint;
      const { width, height } = size;
      let x1, x22, x3, y1, y2, y3;
      if (yAlign === "center") {
        y2 = ptY + height / 2;
        if (xAlign === "left") {
          x1 = ptX;
          x22 = x1 - caretSize;
          y1 = y2 + caretSize;
          y3 = y2 - caretSize;
        } else {
          x1 = ptX + width;
          x22 = x1 + caretSize;
          y1 = y2 - caretSize;
          y3 = y2 + caretSize;
        }
        x3 = x1;
      } else {
        if (xAlign === "left") {
          x22 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x22 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
        } else {
          x22 = this.caretX;
        }
        if (yAlign === "top") {
          y1 = ptY;
          y2 = y1 - caretSize;
          x1 = x22 - caretSize;
          x3 = x22 + caretSize;
        } else {
          y1 = ptY + height;
          y2 = y1 + caretSize;
          x1 = x22 + caretSize;
          x3 = x22 - caretSize;
        }
        y3 = y1;
      }
      return { x1, x2: x22, x3, y1, y2, y3 };
    }
    drawTitle(pt, ctx, options) {
      const title = this.title;
      const length = title.length;
      let titleFont, titleSpacing, i5;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.titleAlign, options);
        ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
        ctx.textBaseline = "middle";
        titleFont = toFont(options.titleFont);
        titleSpacing = options.titleSpacing;
        ctx.fillStyle = options.titleColor;
        ctx.font = titleFont.string;
        for (i5 = 0; i5 < length; ++i5) {
          ctx.fillText(title[i5], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
          pt.y += titleFont.lineHeight + titleSpacing;
          if (i5 + 1 === length) {
            pt.y += options.titleMarginBottom - titleSpacing;
          }
        }
      }
    }
    _drawColorBox(ctx, pt, i5, rtlHelper, options) {
      const labelColors = this.labelColors[i5];
      const labelPointStyle = this.labelPointStyles[i5];
      const { boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      const colorX = getAlignedX(this, "left", options);
      const rtlColorX = rtlHelper.x(colorX);
      const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
      const colorY = pt.y + yOffSet;
      if (options.usePointStyle) {
        const drawOptions = {
          radius: Math.min(boxWidth, boxHeight) / 2,
          pointStyle: labelPointStyle.pointStyle,
          rotation: labelPointStyle.rotation,
          borderWidth: 1
        };
        const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
        const centerY = colorY + boxHeight / 2;
        ctx.strokeStyle = options.multiKeyBackground;
        ctx.fillStyle = options.multiKeyBackground;
        drawPoint(ctx, drawOptions, centerX, centerY);
        ctx.strokeStyle = labelColors.borderColor;
        ctx.fillStyle = labelColors.backgroundColor;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        ctx.lineWidth = isObject(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;
        ctx.strokeStyle = labelColors.borderColor;
        ctx.setLineDash(labelColors.borderDash || []);
        ctx.lineDashOffset = labelColors.borderDashOffset || 0;
        const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
        const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
        const borderRadius = toTRBLCorners(labelColors.borderRadius);
        if (Object.values(borderRadius).some((v3) => v3 !== 0)) {
          ctx.beginPath();
          ctx.fillStyle = options.multiKeyBackground;
          addRoundedRectPath(ctx, {
            x: outerX,
            y: colorY,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = labelColors.backgroundColor;
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: innerX,
            y: colorY + 1,
            w: boxWidth - 2,
            h: boxHeight - 2,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillStyle = options.multiKeyBackground;
          ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
          ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
          ctx.fillStyle = labelColors.backgroundColor;
          ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
        }
      }
      ctx.fillStyle = this.labelTextColors[i5];
    }
    drawBody(pt, ctx, options) {
      const { body } = this;
      const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      let bodyLineHeight = bodyFont.lineHeight;
      let xLinePadding = 0;
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      const fillLineOfText = function(line) {
        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
        pt.y += bodyLineHeight + bodySpacing;
      };
      const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      let bodyItem, textColor, lines, i5, j2, ilen, jlen;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = "middle";
      ctx.font = bodyFont.string;
      pt.x = getAlignedX(this, bodyAlignForCalculation, options);
      ctx.fillStyle = options.bodyColor;
      each(this.beforeBody, fillLineOfText);
      xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
      for (i5 = 0, ilen = body.length; i5 < ilen; ++i5) {
        bodyItem = body[i5];
        textColor = this.labelTextColors[i5];
        ctx.fillStyle = textColor;
        each(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;
        if (displayColors && lines.length) {
          this._drawColorBox(ctx, pt, i5, rtlHelper, options);
          bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
        }
        for (j2 = 0, jlen = lines.length; j2 < jlen; ++j2) {
          fillLineOfText(lines[j2]);
          bodyLineHeight = bodyFont.lineHeight;
        }
        each(bodyItem.after, fillLineOfText);
      }
      xLinePadding = 0;
      bodyLineHeight = bodyFont.lineHeight;
      each(this.afterBody, fillLineOfText);
      pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
      const footer = this.footer;
      const length = footer.length;
      let footerFont, i5;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.footerAlign, options);
        pt.y += options.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
        ctx.textBaseline = "middle";
        footerFont = toFont(options.footerFont);
        ctx.fillStyle = options.footerColor;
        ctx.font = footerFont.string;
        for (i5 = 0; i5 < length; ++i5) {
          ctx.fillText(footer[i5], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
          pt.y += footerFont.lineHeight + options.footerSpacing;
        }
      }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
      const { xAlign, yAlign } = this;
      const { x: x3, y: y2 } = pt;
      const { width, height } = tooltipSize;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.beginPath();
      ctx.moveTo(x3 + topLeft, y2);
      if (yAlign === "top") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x3 + width - topRight, y2);
      ctx.quadraticCurveTo(x3 + width, y2, x3 + width, y2 + topRight);
      if (yAlign === "center" && xAlign === "right") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x3 + width, y2 + height - bottomRight);
      ctx.quadraticCurveTo(x3 + width, y2 + height, x3 + width - bottomRight, y2 + height);
      if (yAlign === "bottom") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x3 + bottomLeft, y2 + height);
      ctx.quadraticCurveTo(x3, y2 + height, x3, y2 + height - bottomLeft);
      if (yAlign === "center" && xAlign === "left") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x3, y2 + topLeft);
      ctx.quadraticCurveTo(x3, y2, x3 + topLeft, y2);
      ctx.closePath();
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    _updateAnimationTarget(options) {
      const chart = this.chart;
      const anims = this.$animations;
      const animX = anims && anims.x;
      const animY = anims && anims.y;
      if (animX || animY) {
        const position = positioners[options.position].call(this, this._active, this._eventPosition);
        if (!position) {
          return;
        }
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, this._size);
        const alignment = determineAlignment(chart, options, positionAndSize);
        const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
        if (animX._to !== point.x || animY._to !== point.y) {
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          this.width = size.width;
          this.height = size.height;
          this.caretX = position.x;
          this.caretY = position.y;
          this._resolveAnimations().update(this, point);
        }
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(ctx) {
      const options = this.options.setContext(this.getContext());
      let opacity = this.opacity;
      if (!opacity) {
        return;
      }
      this._updateAnimationTarget(options);
      const tooltipSize = {
        width: this.width,
        height: this.height
      };
      const pt = {
        x: this.x,
        y: this.y
      };
      opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
      const padding = toPadding(options.padding);
      const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      if (options.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;
        this.drawBackground(pt, ctx, tooltipSize, options);
        overrideTextDirection(ctx, options.textDirection);
        pt.y += padding.top;
        this.drawTitle(pt, ctx, options);
        this.drawBody(pt, ctx, options);
        this.drawFooter(pt, ctx, options);
        restoreTextDirection(ctx, options.textDirection);
        ctx.restore();
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
      const lastActive = this._active;
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.chart.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("Cannot find a dataset at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(lastActive, active);
      const positionChanged = this._positionChanged(active, eventPosition);
      if (changed || positionChanged) {
        this._active = active;
        this._eventPosition = eventPosition;
        this._ignoreReplayEvents = true;
        this.update(true);
      }
    }
    handleEvent(e3, replay, inChartArea = true) {
      if (replay && this._ignoreReplayEvents) {
        return false;
      }
      this._ignoreReplayEvents = false;
      const options = this.options;
      const lastActive = this._active || [];
      const active = this._getActiveElements(e3, lastActive, replay, inChartArea);
      const positionChanged = this._positionChanged(active, e3);
      const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
      if (changed) {
        this._active = active;
        if (options.enabled || options.external) {
          this._eventPosition = {
            x: e3.x,
            y: e3.y
          };
          this.update(true, replay);
        }
      }
      return changed;
    }
    _getActiveElements(e3, lastActive, replay, inChartArea) {
      const options = this.options;
      if (e3.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const active = this.chart.getElementsAtEventForMode(e3, options.mode, options, replay);
      if (options.reverse) {
        active.reverse();
      }
      return active;
    }
    _positionChanged(active, e3) {
      const { caretX, caretY, options } = this;
      const position = positioners[options.position].call(this, active, e3);
      return position !== false && (caretX !== position.x || caretY !== position.y);
    }
  };
  Tooltip2.positioners = positioners;
  var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip2,
    positioners,
    afterInit(chart, _args, options) {
      if (options) {
        chart.tooltip = new Tooltip2({ chart, options });
      }
    },
    beforeUpdate(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    reset(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    afterDraw(chart) {
      const tooltip = chart.tooltip;
      if (tooltip && tooltip._willRender()) {
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
          return;
        }
        tooltip.draw(chart.ctx);
        chart.notifyPlugins("afterTooltipDraw", args);
      }
    },
    afterEvent(chart, args) {
      if (chart.tooltip) {
        const useFinalPosition = args.replay;
        if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
          args.changed = true;
        }
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (ctx, opts) => opts.bodyFont.size,
      boxWidth: (ctx, opts) => opts.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: ["x", "y", "width", "height", "caretX", "caretY"]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: {
        beforeTitle: noop,
        title(tooltipItems) {
          if (tooltipItems.length > 0) {
            const item = tooltipItems[0];
            const labels = item.chart.data.labels;
            const labelCount = labels ? labels.length : 0;
            if (this && this.options && this.options.mode === "dataset") {
              return item.dataset.label || "";
            } else if (item.label) {
              return item.label;
            } else if (labelCount > 0 && item.dataIndex < labelCount) {
              return labels[item.dataIndex];
            }
          }
          return "";
        },
        afterTitle: noop,
        beforeBody: noop,
        beforeLabel: noop,
        label(tooltipItem) {
          if (this && this.options && this.options.mode === "dataset") {
            return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
          }
          let label = tooltipItem.dataset.label || "";
          if (label) {
            label += ": ";
          }
          const value = tooltipItem.formattedValue;
          if (!isNullOrUndef(value)) {
            label += value;
          }
          return label;
        },
        labelColor(tooltipItem) {
          const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
          const options = meta.controller.getStyle(tooltipItem.dataIndex);
          return {
            borderColor: options.borderColor,
            backgroundColor: options.backgroundColor,
            borderWidth: options.borderWidth,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderRadius: 0
          };
        },
        labelTextColor() {
          return this.options.bodyColor;
        },
        labelPointStyle(tooltipItem) {
          const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
          const options = meta.controller.getStyle(tooltipItem.dataIndex);
          return {
            pointStyle: options.pointStyle,
            rotation: options.rotation
          };
        },
        afterLabel: noop,
        afterBody: noop,
        beforeFooter: noop,
        footer: noop,
        afterFooter: noop
      }
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: ["interaction"]
  };
  var plugins = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
  });
  var addIfString = (labels, raw, index2, addedLabels) => {
    if (typeof raw === "string") {
      index2 = labels.push(raw) - 1;
      addedLabels.unshift({ index: index2, label: raw });
    } else if (isNaN(raw)) {
      index2 = null;
    }
    return index2;
  };
  function findOrAddLabel(labels, raw, index2, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
      return addIfString(labels, raw, index2, addedLabels);
    }
    const last2 = labels.lastIndexOf(raw);
    return first !== last2 ? index2 : first;
  }
  var validIndex = (index2, max2) => index2 === null ? null : _limitValue(Math.round(index2), 0, max2);
  var CategoryScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this._startValue = void 0;
      this._valueRange = 0;
      this._addedLabels = [];
    }
    init(scaleOptions) {
      const added = this._addedLabels;
      if (added.length) {
        const labels = this.getLabels();
        for (const { index: index2, label } of added) {
          if (labels[index2] === label) {
            labels.splice(index2, 1);
          }
        }
        this._addedLabels = [];
      }
      super.init(scaleOptions);
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      const labels = this.getLabels();
      index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
      return validIndex(index2, labels.length - 1);
    }
    determineDataLimits() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min: min2, max: max2 } = this.getMinMax(true);
      if (this.options.bounds === "ticks") {
        if (!minDefined) {
          min2 = 0;
        }
        if (!maxDefined) {
          max2 = this.getLabels().length - 1;
        }
      }
      this.min = min2;
      this.max = max2;
    }
    buildTicks() {
      const min2 = this.min;
      const max2 = this.max;
      const offset2 = this.options.offset;
      const ticks = [];
      let labels = this.getLabels();
      labels = min2 === 0 && max2 === labels.length - 1 ? labels : labels.slice(min2, max2 + 1);
      this._valueRange = Math.max(labels.length - (offset2 ? 0 : 1), 1);
      this._startValue = this.min - (offset2 ? 0.5 : 0);
      for (let value = min2; value <= max2; value++) {
        ticks.push({ value });
      }
      return ticks;
    }
    getLabelForValue(value) {
      const labels = this.getLabels();
      if (value >= 0 && value < labels.length) {
        return labels[value];
      }
      return value;
    }
    configure() {
      super.configure();
      if (!this.isHorizontal()) {
        this._reversePixels = !this._reversePixels;
      }
    }
    getPixelForValue(value) {
      if (typeof value !== "number") {
        value = this.parse(value);
      }
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getValueForPixel(pixel) {
      return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  };
  CategoryScale.id = "category";
  CategoryScale.defaults = {
    ticks: {
      callback: CategoryScale.prototype.getLabelForValue
    }
  };
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min: min2, max: max2, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min2);
    const maxDefined = !isNullOrUndef(max2);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [{ value: rmin }, { value: rmax }];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max2 - min2) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max2 - min2) / spacing, maxTicks));
      spacing = (max2 - min2) / numSpaces;
      niceMin = min2;
      niceMax = max2;
    } else if (countDefined) {
      niceMin = minDefined ? min2 : niceMin;
      niceMax = maxDefined ? max2 : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(
      _decimalPlaces(spacing),
      _decimalPlaces(niceMin)
    );
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j2 = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min2) {
        ticks.push({ value: min2 });
        if (niceMin < min2) {
          j2++;
        }
        if (almostEquals(Math.round((niceMin + j2 * spacing) * factor) / factor, min2, relativeLabelSize(min2, minSpacing, generationOptions))) {
          j2++;
        }
      } else if (niceMin < min2) {
        j2++;
      }
    }
    for (; j2 < numSpaces; ++j2) {
      ticks.push({ value: Math.round((niceMin + j2 * spacing) * factor) / factor });
    }
    if (maxDefined && includeBounds && niceMax !== max2) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max2, relativeLabelSize(max2, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max2;
      } else {
        ticks.push({ value: max2 });
      }
    } else if (!maxDefined || niceMax === max2) {
      ticks.push({ value: niceMax });
    }
    return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
  }
  var LinearScaleBase = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._endValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
        return null;
      }
      return +raw;
    }
    handleTickRangeOptions() {
      const { beginAtZero } = this.options;
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min: min2, max: max2 } = this;
      const setMin = (v3) => min2 = minDefined ? min2 : v3;
      const setMax = (v3) => max2 = maxDefined ? max2 : v3;
      if (beginAtZero) {
        const minSign = sign(min2);
        const maxSign = sign(max2);
        if (minSign < 0 && maxSign < 0) {
          setMax(0);
        } else if (minSign > 0 && maxSign > 0) {
          setMin(0);
        }
      }
      if (min2 === max2) {
        let offset2 = 1;
        if (max2 >= Number.MAX_SAFE_INTEGER || min2 <= Number.MIN_SAFE_INTEGER) {
          offset2 = Math.abs(max2 * 0.05);
        }
        setMax(max2 + offset2);
        if (!beginAtZero) {
          setMin(min2 - offset2);
        }
      }
      this.min = min2;
      this.max = max2;
    }
    getTickLimit() {
      const tickOpts = this.options.ticks;
      let { maxTicksLimit, stepSize } = tickOpts;
      let maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
        if (maxTicks > 1e3) {
          console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
          maxTicks = 1e3;
        }
      } else {
        maxTicks = this.computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const opts = this.options;
      const tickOpts = opts.ticks;
      let maxTicks = this.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      const numericGeneratorOptions = {
        maxTicks,
        bounds: opts.bounds,
        min: opts.min,
        max: opts.max,
        precision: tickOpts.precision,
        step: tickOpts.stepSize,
        count: tickOpts.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: tickOpts.minRotation || 0,
        includeBounds: tickOpts.includeBounds !== false
      };
      const dataRange = this._range || this;
      const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    configure() {
      const ticks = this.ticks;
      let start3 = this.min;
      let end2 = this.max;
      super.configure();
      if (this.options.offset && ticks.length) {
        const offset2 = (end2 - start3) / Math.max(ticks.length - 1, 1) / 2;
        start3 -= offset2;
        end2 += offset2;
      }
      this._startValue = start3;
      this._endValue = end2;
      this._valueRange = end2 - start3;
    }
    getLabelForValue(value) {
      return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
  };
  var LinearScale = class extends LinearScaleBase {
    determineDataLimits() {
      const { min: min2, max: max2 } = this.getMinMax(true);
      this.min = isNumberFinite(min2) ? min2 : 0;
      this.max = isNumberFinite(max2) ? max2 : 1;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const horizontal = this.isHorizontal();
      const length = horizontal ? this.width : this.height;
      const minRotation = toRadians(this.options.ticks.minRotation);
      const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
      const tickFont = this._resolveTickFontOptions(0);
      return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
  };
  LinearScale.id = "linear";
  LinearScale.defaults = {
    ticks: {
      callback: Ticks.formatters.numeric
    }
  };
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
    return remain === 1;
  }
  function generateTicks(generationOptions, dataRange) {
    const endExp = Math.floor(log10(dataRange.max));
    const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
    const ticks = [];
    let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
    let exp = Math.floor(log10(tickVal));
    let significand = Math.floor(tickVal / Math.pow(10, exp));
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    do {
      ticks.push({ value: tickVal, major: isMajor(tickVal) });
      ++significand;
      if (significand === 10) {
        significand = 1;
        ++exp;
        precision = exp >= 0 ? 1 : precision;
      }
      tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
    } while (exp < endExp || exp === endExp && significand < endSignificand);
    const lastTick = finiteOrDefault(generationOptions.max, tickVal);
    ticks.push({ value: lastTick, major: isMajor(tickVal) });
    return ticks;
  }
  var LogarithmicScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      const value = LinearScaleBase.prototype.parse.apply(this, [raw, index2]);
      if (value === 0) {
        this._zero = true;
        return void 0;
      }
      return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
      const { min: min2, max: max2 } = this.getMinMax(true);
      this.min = isNumberFinite(min2) ? Math.max(0, min2) : null;
      this.max = isNumberFinite(max2) ? Math.max(0, max2) : null;
      if (this.options.beginAtZero) {
        this._zero = true;
      }
      this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let min2 = this.min;
      let max2 = this.max;
      const setMin = (v3) => min2 = minDefined ? min2 : v3;
      const setMax = (v3) => max2 = maxDefined ? max2 : v3;
      const exp = (v3, m5) => Math.pow(10, Math.floor(log10(v3)) + m5);
      if (min2 === max2) {
        if (min2 <= 0) {
          setMin(1);
          setMax(10);
        } else {
          setMin(exp(min2, -1));
          setMax(exp(max2, 1));
        }
      }
      if (min2 <= 0) {
        setMin(exp(max2, -1));
      }
      if (max2 <= 0) {
        setMax(exp(min2, 1));
      }
      if (this._zero && this.min !== this._suggestedMin && min2 === exp(this.min, 0)) {
        setMin(exp(min2, -1));
      }
      this.min = min2;
      this.max = max2;
    }
    buildTicks() {
      const opts = this.options;
      const generationOptions = {
        min: this._userMin,
        max: this._userMax
      };
      const ticks = generateTicks(generationOptions, this);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    getLabelForValue(value) {
      return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const start3 = this.min;
      super.configure();
      this._startValue = log10(start3);
      this._valueRange = log10(this.max) - log10(start3);
    }
    getPixelForValue(value) {
      if (value === void 0 || value === 0) {
        value = this.min;
      }
      if (value === null || isNaN(value)) {
        return NaN;
      }
      return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      const decimal = this.getDecimalForPixel(pixel);
      return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
  };
  LogarithmicScale.id = "logarithmic";
  LogarithmicScale.defaults = {
    ticks: {
      callback: Ticks.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  };
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray(label) ? label : [label];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size, min2, max2) {
    if (angle === min2 || angle === max2) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min2 || angle > max2) {
      return {
        start: pos - size,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size
    };
  }
  function fitWithPointLabels(scale2) {
    const orig = {
      l: scale2.left + scale2._padding.left,
      r: scale2.right - scale2._padding.right,
      t: scale2.top + scale2._padding.top,
      b: scale2.bottom - scale2._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale2._pointLabels.length;
    const pointLabelOpts = scale2.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i5 = 0; i5 < valueCount; i5++) {
      const opts = pointLabelOpts.setContext(scale2.getPointLabelContext(i5));
      padding[i5] = opts.padding;
      const pointPosition = scale2.getPointPosition(i5, scale2.drawingArea + padding[i5], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale2.ctx, plFont, scale2._pointLabels[i5]);
      labelSizes[i5] = textSize;
      const angleRadians = _normalizeAngle(scale2.getIndexAngle(i5) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale2.setCenterPoint(
      orig.l - limits.l,
      limits.r - orig.r,
      orig.t - limits.t,
      limits.b - orig.b
    );
    scale2._pointLabelItems = buildPointLabelItems(scale2, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x3 = 0;
    let y2 = 0;
    if (hLimits.start < orig.l) {
      x3 = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x3);
    } else if (hLimits.end > orig.r) {
      x3 = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x3);
    }
    if (vLimits.start < orig.t) {
      y2 = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y2);
    } else if (vLimits.end > orig.b) {
      y2 = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y2);
    }
  }
  function buildPointLabelItems(scale2, labelSizes, padding) {
    const items = [];
    const valueCount = scale2._pointLabels.length;
    const opts = scale2.options;
    const extra = getTickBackdropHeight(opts) / 2;
    const outerDistance = scale2.drawingArea;
    const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
    for (let i5 = 0; i5 < valueCount; i5++) {
      const pointLabelPosition = scale2.getPointPosition(i5, outerDistance + extra + padding[i5], additionalAngle);
      const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
      const size = labelSizes[i5];
      const y2 = yForAngle(pointLabelPosition.y, size.h, angle);
      const textAlign = getTextAlignForAngle(angle);
      const left2 = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
      items.push({
        x: pointLabelPosition.x,
        y: y2,
        textAlign,
        left: left2,
        top: y2,
        right: left2 + size.w,
        bottom: y2 + size.h
      });
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x3, w3, align) {
    if (align === "right") {
      x3 -= w3;
    } else if (align === "center") {
      x3 -= w3 / 2;
    }
    return x3;
  }
  function yForAngle(y2, h3, angle) {
    if (angle === 90 || angle === 270) {
      y2 -= h3 / 2;
    } else if (angle > 270 || angle < 90) {
      y2 -= h3;
    }
    return y2;
  }
  function drawPointLabels(scale2, labelCount) {
    const { ctx, options: { pointLabels } } = scale2;
    for (let i5 = labelCount - 1; i5 >= 0; i5--) {
      const optsAtIndex = pointLabels.setContext(scale2.getPointLabelContext(i5));
      const plFont = toFont(optsAtIndex.font);
      const { x: x3, y: y2, textAlign, left: left2, top: top2, right: right2, bottom: bottom2 } = scale2._pointLabelItems[i5];
      const { backdropColor } = optsAtIndex;
      if (!isNullOrUndef(backdropColor)) {
        const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillStyle = backdropColor;
        const backdropLeft = left2 - padding.left;
        const backdropTop = top2 - padding.top;
        const backdropWidth = right2 - left2 + padding.width;
        const backdropHeight = bottom2 - top2 + padding.height;
        if (Object.values(borderRadius).some((v3) => v3 !== 0)) {
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: backdropLeft,
            y: backdropTop,
            w: backdropWidth,
            h: backdropHeight,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
        }
      }
      renderText(
        ctx,
        scale2._pointLabels[i5],
        x3,
        y2 + plFont.lineHeight / 2,
        plFont,
        {
          color: optsAtIndex.color,
          textAlign,
          textBaseline: "middle"
        }
      );
    }
  }
  function pathRadiusLine(scale2, radius, circular, labelCount) {
    const { ctx } = scale2;
    if (circular) {
      ctx.arc(scale2.xCenter, scale2.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale2.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i5 = 1; i5 < labelCount; i5++) {
        pointPosition = scale2.getPointPosition(i5, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale2, gridLineOpts, radius, labelCount) {
    const ctx = scale2.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(gridLineOpts.borderDash);
    ctx.lineDashOffset = gridLineOpts.borderDashOffset;
    ctx.beginPath();
    pathRadiusLine(scale2, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index2, label) {
    return createContext5(parent, {
      label,
      index: index2,
      type: "pointLabel"
    });
  }
  var RadialLinearScale = class extends LinearScaleBase {
    constructor(cfg) {
      super(cfg);
      this.xCenter = void 0;
      this.yCenter = void 0;
      this.drawingArea = void 0;
      this._pointLabels = [];
      this._pointLabelItems = [];
    }
    setDimensions() {
      const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
      const w3 = this.width = this.maxWidth - padding.width;
      const h3 = this.height = this.maxHeight - padding.height;
      this.xCenter = Math.floor(this.left + w3 / 2 + padding.left);
      this.yCenter = Math.floor(this.top + h3 / 2 + padding.top);
      this.drawingArea = Math.floor(Math.min(w3, h3) / 2);
    }
    determineDataLimits() {
      const { min: min2, max: max2 } = this.getMinMax(false);
      this.min = isNumberFinite(min2) && !isNaN(min2) ? min2 : 0;
      this.max = isNumberFinite(max2) && !isNaN(max2) ? max2 : 0;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
      LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
      this._pointLabels = this.getLabels().map((value, index2) => {
        const label = callback(this.options.pointLabels.callback, [value, index2], this);
        return label || label === 0 ? label : "";
      }).filter((v3, i5) => this.chart.getDataVisibility(i5));
    }
    fit() {
      const opts = this.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        this.setCenterPoint(0, 0, 0, 0);
      }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
      this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
      this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index2) {
      const angleMultiplier = TAU / (this._pointLabels.length || 1);
      const startAngle = this.options.startAngle || 0;
      return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
      if (isNullOrUndef(value)) {
        return NaN;
      }
      const scalingFactor = this.drawingArea / (this.max - this.min);
      if (this.options.reverse) {
        return (this.max - value) * scalingFactor;
      }
      return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
      if (isNullOrUndef(distance)) {
        return NaN;
      }
      const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index2) {
      const pointLabels = this._pointLabels || [];
      if (index2 >= 0 && index2 < pointLabels.length) {
        const pointLabel = pointLabels[index2];
        return createPointLabelContext(this.getContext(), index2, pointLabel);
      }
    }
    getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
      const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
      return {
        x: Math.cos(angle) * distanceFromCenter + this.xCenter,
        y: Math.sin(angle) * distanceFromCenter + this.yCenter,
        angle
      };
    }
    getPointPositionForValue(index2, value) {
      return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index2) {
      return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
    }
    getPointLabelPosition(index2) {
      const { left: left2, top: top2, right: right2, bottom: bottom2 } = this._pointLabelItems[index2];
      return {
        left: left2,
        top: top2,
        right: right2,
        bottom: bottom2
      };
    }
    drawBackground() {
      const { backgroundColor, grid: { circular } } = this.options;
      if (backgroundColor) {
        const ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
        ctx.closePath();
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
    }
    drawGrid() {
      const ctx = this.ctx;
      const opts = this.options;
      const { angleLines, grid } = opts;
      const labelCount = this._pointLabels.length;
      let i5, offset2, position;
      if (opts.pointLabels.display) {
        drawPointLabels(this, labelCount);
      }
      if (grid.display) {
        this.ticks.forEach((tick, index2) => {
          if (index2 !== 0) {
            offset2 = this.getDistanceFromCenterForValue(tick.value);
            const optsAtIndex = grid.setContext(this.getContext(index2 - 1));
            drawRadiusLine(this, optsAtIndex, offset2, labelCount);
          }
        });
      }
      if (angleLines.display) {
        ctx.save();
        for (i5 = labelCount - 1; i5 >= 0; i5--) {
          const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i5));
          const { color: color2, lineWidth } = optsAtIndex;
          if (!lineWidth || !color2) {
            continue;
          }
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color2;
          ctx.setLineDash(optsAtIndex.borderDash);
          ctx.lineDashOffset = optsAtIndex.borderDashOffset;
          offset2 = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
          position = this.getPointPosition(i5, offset2);
          ctx.beginPath();
          ctx.moveTo(this.xCenter, this.yCenter);
          ctx.lineTo(position.x, position.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const ctx = this.ctx;
      const opts = this.options;
      const tickOpts = opts.ticks;
      if (!tickOpts.display) {
        return;
      }
      const startAngle = this.getIndexAngle(0);
      let offset2, width;
      ctx.save();
      ctx.translate(this.xCenter, this.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      this.ticks.forEach((tick, index2) => {
        if (index2 === 0 && !opts.reverse) {
          return;
        }
        const optsAtIndex = tickOpts.setContext(this.getContext(index2));
        const tickFont = toFont(optsAtIndex.font);
        offset2 = this.getDistanceFromCenterForValue(this.ticks[index2].value);
        if (optsAtIndex.showLabelBackdrop) {
          ctx.font = tickFont.string;
          width = ctx.measureText(tick.label).width;
          ctx.fillStyle = optsAtIndex.backdropColor;
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillRect(
            -width / 2 - padding.left,
            -offset2 - tickFont.size / 2 - padding.top,
            width + padding.width,
            tickFont.size + padding.height
          );
        }
        renderText(ctx, tick.label, 0, -offset2, tickFont, {
          color: optsAtIndex.color
        });
      });
      ctx.restore();
    }
    drawTitle() {
    }
  };
  RadialLinearScale.id = "radialLinear";
  RadialLinearScale.defaults = {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ticks.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(label) {
        return label;
      },
      padding: 5,
      centerPointLabels: false
    }
  };
  RadialLinearScale.defaultRoutes = {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  };
  RadialLinearScale.descriptors = {
    angleLines: {
      _fallback: "grid"
    }
  };
  var INTERVALS = {
    millisecond: { common: true, size: 1, steps: 1e3 },
    second: { common: true, size: 1e3, steps: 60 },
    minute: { common: true, size: 6e4, steps: 60 },
    hour: { common: true, size: 36e5, steps: 24 },
    day: { common: true, size: 864e5, steps: 30 },
    week: { common: false, size: 6048e5, steps: 4 },
    month: { common: true, size: 2628e6, steps: 12 },
    quarter: { common: false, size: 7884e6, steps: 4 },
    year: { common: true, size: 3154e7 }
  };
  var UNITS = Object.keys(INTERVALS);
  function sorter(a3, b2) {
    return a3 - b2;
  }
  function parse(scale2, input) {
    if (isNullOrUndef(input)) {
      return null;
    }
    const adapter = scale2._adapter;
    const { parser, round: round3, isoWeekday } = scale2._parseOpts;
    let value = input;
    if (typeof parser === "function") {
      value = parser(value);
    }
    if (!isNumberFinite(value)) {
      value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
      return null;
    }
    if (round3) {
      value = round3 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round3);
    }
    return +value;
  }
  function determineUnitForAutoTicks(minUnit, min2, max2, capacity) {
    const ilen = UNITS.length;
    for (let i5 = UNITS.indexOf(minUnit); i5 < ilen - 1; ++i5) {
      const interval = INTERVALS[UNITS[i5]];
      const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
      if (interval.common && Math.ceil((max2 - min2) / (factor * interval.size)) <= capacity) {
        return UNITS[i5];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale2, numTicks, minUnit, min2, max2) {
    for (let i5 = UNITS.length - 1; i5 >= UNITS.indexOf(minUnit); i5--) {
      const unit = UNITS[i5];
      if (INTERVALS[unit].common && scale2._adapter.diff(max2, min2, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i5 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i5 < ilen; ++i5) {
      if (INTERVALS[UNITS[i5]].common) {
        return UNITS[i5];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo, hi } = _lookup(timestamps, time);
      const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale2, ticks, map3, majorUnit) {
    const adapter = scale2._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last2 = ticks[ticks.length - 1].value;
    let major, index2;
    for (major = first; major <= last2; major = +adapter.add(major, 1, majorUnit)) {
      index2 = map3[major];
      if (index2 >= 0) {
        ticks[index2].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale2, values, majorUnit) {
    const ticks = [];
    const map3 = {};
    const ilen = values.length;
    let i5, value;
    for (i5 = 0; i5 < ilen; ++i5) {
      value = values[i5];
      map3[value] = i5;
      ticks.push({
        value,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale2, ticks, map3, majorUnit);
  }
  var TimeScale = class extends Scale {
    constructor(props) {
      super(props);
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
      this._unit = "day";
      this._majorUnit = void 0;
      this._offsets = {};
      this._normalized = false;
      this._parseOpts = void 0;
    }
    init(scaleOpts, opts) {
      const time = scaleOpts.time || (scaleOpts.time = {});
      const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
      adapter.init(opts);
      mergeIf(time.displayFormats, adapter.formats());
      this._parseOpts = {
        parser: time.parser,
        round: time.round,
        isoWeekday: time.isoWeekday
      };
      super.init(scaleOpts);
      this._normalized = opts.normalized;
    }
    parse(raw, index2) {
      if (raw === void 0) {
        return null;
      }
      return parse(this, raw);
    }
    beforeLayout() {
      super.beforeLayout();
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const options = this.options;
      const adapter = this._adapter;
      const unit = options.time.unit || "day";
      let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
      function _applyBounds(bounds) {
        if (!minDefined && !isNaN(bounds.min)) {
          min2 = Math.min(min2, bounds.min);
        }
        if (!maxDefined && !isNaN(bounds.max)) {
          max2 = Math.max(max2, bounds.max);
        }
      }
      if (!minDefined || !maxDefined) {
        _applyBounds(this._getLabelBounds());
        if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
          _applyBounds(this.getMinMax(false));
        }
      }
      min2 = isNumberFinite(min2) && !isNaN(min2) ? min2 : +adapter.startOf(Date.now(), unit);
      max2 = isNumberFinite(max2) && !isNaN(max2) ? max2 : +adapter.endOf(Date.now(), unit) + 1;
      this.min = Math.min(min2, max2 - 1);
      this.max = Math.max(min2 + 1, max2);
    }
    _getLabelBounds() {
      const arr = this.getLabelTimestamps();
      let min2 = Number.POSITIVE_INFINITY;
      let max2 = Number.NEGATIVE_INFINITY;
      if (arr.length) {
        min2 = arr[0];
        max2 = arr[arr.length - 1];
      }
      return { min: min2, max: max2 };
    }
    buildTicks() {
      const options = this.options;
      const timeOpts = options.time;
      const tickOpts = options.ticks;
      const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
      if (options.bounds === "ticks" && timestamps.length) {
        this.min = this._userMin || timestamps[0];
        this.max = this._userMax || timestamps[timestamps.length - 1];
      }
      const min2 = this.min;
      const max2 = this.max;
      const ticks = _filterBetween(timestamps, min2, max2);
      this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min2)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
      this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
      this.initOffsets(timestamps);
      if (options.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
      if (this.options.offsetAfterAutoskip) {
        this.initOffsets(this.ticks.map((tick) => +tick.value));
      }
    }
    initOffsets(timestamps) {
      let start3 = 0;
      let end2 = 0;
      let first, last2;
      if (this.options.offset && timestamps.length) {
        first = this.getDecimalForValue(timestamps[0]);
        if (timestamps.length === 1) {
          start3 = 1 - first;
        } else {
          start3 = (this.getDecimalForValue(timestamps[1]) - first) / 2;
        }
        last2 = this.getDecimalForValue(timestamps[timestamps.length - 1]);
        if (timestamps.length === 1) {
          end2 = last2;
        } else {
          end2 = (last2 - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
      }
      const limit = timestamps.length < 3 ? 0.5 : 0.25;
      start3 = _limitValue(start3, 0, limit);
      end2 = _limitValue(end2, 0, limit);
      this._offsets = { start: start3, end: end2, factor: 1 / (start3 + 1 + end2) };
    }
    _generate() {
      const adapter = this._adapter;
      const min2 = this.min;
      const max2 = this.max;
      const options = this.options;
      const timeOpts = options.time;
      const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min2, max2, this._getLabelCapacity(min2));
      const stepSize = valueOrDefault(timeOpts.stepSize, 1);
      const weekday = minor === "week" ? timeOpts.isoWeekday : false;
      const hasWeekday = isNumber(weekday) || weekday === true;
      const ticks = {};
      let first = min2;
      let time, count;
      if (hasWeekday) {
        first = +adapter.startOf(first, "isoWeek", weekday);
      }
      first = +adapter.startOf(first, hasWeekday ? "day" : minor);
      if (adapter.diff(max2, min2, minor) > 1e5 * stepSize) {
        throw new Error(min2 + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor);
      }
      const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
      for (time = first, count = 0; time < max2; time = +adapter.add(time, stepSize, minor), count++) {
        addTick(ticks, time, timestamps);
      }
      if (time === max2 || options.bounds === "ticks" || count === 1) {
        addTick(ticks, time, timestamps);
      }
      return Object.keys(ticks).sort((a3, b2) => a3 - b2).map((x3) => +x3);
    }
    getLabelForValue(value) {
      const adapter = this._adapter;
      const timeOpts = this.options.time;
      if (timeOpts.tooltipFormat) {
        return adapter.format(value, timeOpts.tooltipFormat);
      }
      return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    _tickFormatFunction(time, index2, ticks, format2) {
      const options = this.options;
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const majorUnit = this._majorUnit;
      const minorFormat = unit && formats[unit];
      const majorFormat = majorUnit && formats[majorUnit];
      const tick = ticks[index2];
      const major = majorUnit && majorFormat && tick && tick.major;
      const label = this._adapter.format(time, format2 || (major ? majorFormat : minorFormat));
      const formatter = options.ticks.callback;
      return formatter ? callback(formatter, [label, index2, ticks], this) : label;
    }
    generateTickLabels(ticks) {
      let i5, ilen, tick;
      for (i5 = 0, ilen = ticks.length; i5 < ilen; ++i5) {
        tick = ticks[i5];
        tick.label = this._tickFormatFunction(tick.value, i5, ticks);
      }
    }
    getDecimalForValue(value) {
      return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
      const offsets = this._offsets;
      const pos = this.getDecimalForValue(value);
      return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
      const ticksOpts = this.options.ticks;
      const tickLabelWidth = this.ctx.measureText(label).width;
      const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      const cosRotation = Math.cos(angle);
      const sinRotation = Math.sin(angle);
      const tickFontSize = this._resolveTickFontOptions(0).size;
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    }
    _getLabelCapacity(exampleTime) {
      const timeOpts = this.options.time;
      const displayFormats = timeOpts.displayFormats;
      const format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format2);
      const size = this._getLabelSize(exampleLabel);
      const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
      return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
      let timestamps = this._cache.data || [];
      let i5, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const metas = this.getMatchingVisibleMetas();
      if (this._normalized && metas.length) {
        return this._cache.data = metas[0].controller.getAllParsedValues(this);
      }
      for (i5 = 0, ilen = metas.length; i5 < ilen; ++i5) {
        timestamps = timestamps.concat(metas[i5].controller.getAllParsedValues(this));
      }
      return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
      const timestamps = this._cache.labels || [];
      let i5, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const labels = this.getLabels();
      for (i5 = 0, ilen = labels.length; i5 < ilen; ++i5) {
        timestamps.push(parse(this, labels[i5]));
      }
      return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
      return _arrayUnique(values.sort(sorter));
    }
  };
  TimeScale.id = "time";
  TimeScale.defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      major: {
        enabled: false
      }
    }
  };
  function interpolate2(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo].pos && val <= table[hi].pos) {
        ({ lo, hi } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo]);
      ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
      if (val >= table[lo].time && val <= table[hi].time) {
        ({ lo, hi } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo]);
      ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var TimeSeriesScale = class extends TimeScale {
    constructor(props) {
      super(props);
      this._table = [];
      this._minPos = void 0;
      this._tableRange = void 0;
    }
    initOffsets() {
      const timestamps = this._getTimestampsForTable();
      const table = this._table = this.buildLookupTable(timestamps);
      this._minPos = interpolate2(table, this.min);
      this._tableRange = interpolate2(table, this.max) - this._minPos;
      super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
      const { min: min2, max: max2 } = this;
      const items = [];
      const table = [];
      let i5, ilen, prev, curr, next;
      for (i5 = 0, ilen = timestamps.length; i5 < ilen; ++i5) {
        curr = timestamps[i5];
        if (curr >= min2 && curr <= max2) {
          items.push(curr);
        }
      }
      if (items.length < 2) {
        return [
          { time: min2, pos: 0 },
          { time: max2, pos: 1 }
        ];
      }
      for (i5 = 0, ilen = items.length; i5 < ilen; ++i5) {
        next = items[i5 + 1];
        prev = items[i5 - 1];
        curr = items[i5];
        if (Math.round((next + prev) / 2) !== curr) {
          table.push({ time: curr, pos: i5 / (ilen - 1) });
        }
      }
      return table;
    }
    _getTimestampsForTable() {
      let timestamps = this._cache.all || [];
      if (timestamps.length) {
        return timestamps;
      }
      const data = this.getDataTimestamps();
      const label = this.getLabelTimestamps();
      if (data.length && label.length) {
        timestamps = this.normalize(data.concat(label));
      } else {
        timestamps = data.length ? data : label;
      }
      timestamps = this._cache.all = timestamps;
      return timestamps;
    }
    getDecimalForValue(value) {
      return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
    }
  };
  TimeSeriesScale.id = "timeseries";
  TimeSeriesScale.defaults = TimeScale.defaults;
  var scales = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale,
    LinearScale,
    LogarithmicScale,
    RadialLinearScale,
    TimeScale,
    TimeSeriesScale
  });
  var registerables = [
    controllers,
    elements,
    plugins,
    scales
  ];

  // node_modules/chart.js/auto/auto.mjs
  Chart.register(...registerables);
  var auto_default = Chart;

  // js/dashboard/stats/graph/date-formatter.js
  var browserDateFormat = Intl.DateTimeFormat(navigator.language, { hour: "numeric" });
  var is12HourClock = function() {
    return browserDateFormat.resolvedOptions().hour12;
  };
  var monthIntervalFormatter = {
    long(isoDate, options) {
      const formatted = this.short(isoDate, options);
      return options.isBucketPartial ? `Partial of ${formatted}` : formatted;
    },
    short(isoDate, _options) {
      return formatMonthYYYY(parseUTCDate(isoDate));
    }
  };
  var weekIntervalFormatter = {
    long(isoDate, options) {
      const formatted = this.short(isoDate, options);
      return options.isBucketPartial ? `Partial week of ${formatted}` : `Week of ${formatted}`;
    },
    short(isoDate, options) {
      return formatDayShort(parseUTCDate(isoDate), options.shouldShowYear);
    }
  };
  var dateIntervalFormatter = {
    long(isoDate, _options) {
      return parseUTCDate(isoDate).format("ddd, D MMM");
    },
    short(isoDate, options) {
      return formatDayShort(parseUTCDate(isoDate), options.shouldShowYear);
    }
  };
  var hourIntervalFormatter = {
    long(isoDate, options) {
      return this.short(isoDate, options);
    },
    short(isoDate, _options) {
      if (is12HourClock()) {
        return parseUTCDate(isoDate).format("ha");
      } else {
        return parseUTCDate(isoDate).format("HH:mm");
      }
    }
  };
  var minuteIntervalFormatter = {
    long(isoDate, options) {
      if (options.period == "realtime") {
        const minutesAgo = Math.abs(isoDate);
        return minutesAgo === 1 ? "1 minute ago" : minutesAgo + " minutes ago";
      } else {
        return this.short(isoDate, options);
      }
    },
    short(isoDate, options) {
      if (options.period === "realtime") return isoDate + "m";
      if (is12HourClock()) {
        return parseUTCDate(isoDate).format("h:mma");
      } else {
        return parseUTCDate(isoDate).format("HH:mm");
      }
    }
  };
  var factory = {
    month: monthIntervalFormatter,
    week: weekIntervalFormatter,
    date: dateIntervalFormatter,
    hour: hourIntervalFormatter,
    minute: minuteIntervalFormatter
  };
  function dateFormatter({ interval, longForm, period, isPeriodFull, shouldShowYear = false }) {
    const displayMode = longForm ? "long" : "short";
    const options = { period, interval, isBucketPartial: !isPeriodFull, shouldShowYear };
    return function(isoDate, _index, _ticks) {
      return factory[interval][displayMode](isoDate, options);
    };
  }

  // js/dashboard/stats/graph/graph-tooltip.js
  var renderBucketLabel = function(query, graphData, label, comparison = false) {
    var _a9;
    let isPeriodFull = (_a9 = graphData.full_intervals) == null ? void 0 : _a9[label];
    if (comparison) isPeriodFull = true;
    const formattedLabel = dateFormatter({
      interval: graphData.interval,
      longForm: true,
      period: query.period,
      isPeriodFull
    })(label);
    if (query.period === "realtime") {
      return dateFormatter({
        interval: graphData.interval,
        longForm: true,
        period: query.period
      })(label);
    }
    if (graphData.interval === "hour" || graphData.interval == "minute") {
      const date = dateFormatter({ interval: "date", longForm: true, period: query.period })(label);
      return `${date}, ${formattedLabel}`;
    }
    return formattedLabel;
  };
  var calculatePercentageDifference = function(oldValue, newValue) {
    if (oldValue == 0 && newValue > 0) {
      return 100;
    } else if (oldValue == 0 && newValue == 0) {
      return 0;
    } else {
      return Math.round((newValue - oldValue) / oldValue * 100);
    }
  };
  var buildTooltipData = function(query, graphData, metric, tooltipModel) {
    const data = tooltipModel.dataPoints.find((dataPoint) => dataPoint.dataset.yAxisID == "y");
    const comparisonData = tooltipModel.dataPoints.find((dataPoint) => dataPoint.dataset.yAxisID == "yComparison");
    const label = data && renderBucketLabel(query, graphData, graphData.labels[data.dataIndex]);
    const comparisonLabel = comparisonData && renderBucketLabel(query, graphData, graphData.comparison_labels[comparisonData.dataIndex], true);
    const value = (data == null ? void 0 : data.raw) || 0;
    const comparisonValue = (comparisonData == null ? void 0 : comparisonData.raw) || 0;
    const comparisonDifference = label && comparisonLabel && calculatePercentageDifference(comparisonValue, value);
    const metricFormatter = METRIC_FORMATTER[metric];
    const formattedValue = metricFormatter(value);
    const formattedComparisonValue = comparisonData && metricFormatter(comparisonValue);
    return { label, formattedValue, comparisonLabel, formattedComparisonValue, comparisonDifference };
  };
  function GraphTooltip(graphData, metric, query) {
    return (context) => {
      const tooltipModel = context.tooltip;
      const offset2 = document.getElementById("main-graph-canvas").getBoundingClientRect();
      let tooltipEl = document.getElementById("chartjs-tooltip");
      if (!tooltipEl) {
        tooltipEl = document.createElement("div");
        tooltipEl.id = "chartjs-tooltip";
        tooltipEl.style.display = "none";
        tooltipEl.style.opacity = 0;
        document.body.appendChild(tooltipEl);
      }
      if (tooltipEl && offset2 && window.innerWidth < 768) {
        tooltipEl.style.top = offset2.y + offset2.height + window.scrollY + 15 + "px";
        tooltipEl.style.left = offset2.x + "px";
        tooltipEl.style.right = null;
        tooltipEl.style.opacity = 1;
      }
      if (tooltipModel.opacity === 0) {
        tooltipEl.style.display = "none";
        return;
      }
      if (tooltipModel.body) {
        const tooltipData = buildTooltipData(query, graphData, metric, tooltipModel);
        tooltipEl.innerHTML = `
        <aside class="text-gray-100 flex flex-col">
          <div class="flex justify-between items-center">
            <span class="font-semibold mr-4 text-lg">${METRIC_LABELS[metric]}</span>
            ${tooltipData.comparisonDifference ? `<div class="inline-flex items-center space-x-1">
              ${tooltipData.comparisonDifference > 0 ? `<span class="font-semibold text-sm text-green-500">&uarr;</span><span>${tooltipData.comparisonDifference}%</span>` : ""}
              ${tooltipData.comparisonDifference < 0 ? `<span class="font-semibold text-sm text-red-400">&darr;</span><span>${tooltipData.comparisonDifference * -1}%</span>` : ""}
              ${tooltipData.comparisonDifference == 0 ? `<span class="font-semibold text-sm">\u3030 0%</span>` : ""}
            </div>` : ""}
          </div>

          ${tooltipData.label ? `<div class="flex flex-col">
            <div class="flex flex-row justify-between items-center">
              <span class="flex items-center mr-4">
                <div class="w-3 h-3 mr-1 rounded-full" style="background-color: rgba(101,116,205)"></div>
                <span>${tooltipData.label}</span>
              </span>
              <span class="text-base font-bold">${tooltipData.formattedValue}</span>
            </div>` : ""}

            ${tooltipData.comparisonLabel ? `<div class="flex flex-row justify-between items-center">
              <span class="flex items-center mr-4">
                <div class="w-3 h-3 mr-1 rounded-full bg-gray-500"></div>
                <span>${tooltipData.comparisonLabel}</span>
              </span>
              <span class="text-base font-bold">${tooltipData.formattedComparisonValue}</span>
            </div>` : ""}
          </div>

          ${graphData.interval === "month" ? `<span class="font-semibold italic">Click to view month</span>` : ""}
          ${graphData.interval === "date" ? `<span class="font-semibold italic">Click to view day</span>` : ""}
        </aside>
      `;
      }
      tooltipEl.style.display = null;
    };
  }

  // js/dashboard/stats/graph/line-graph.js
  var import_classnames8 = __toESM(require_classnames());
  var calculateMaximumY = function(dataset) {
    const yAxisValues = dataset.flatMap((item) => item.data).map((item) => item || 0);
    if (yAxisValues) {
      return Math.max(...yAxisValues);
    } else {
      return 1;
    }
  };
  var LineGraph = class extends import_react42.default.Component {
    constructor(props) {
      super(props);
      this.regenerateChart = this.regenerateChart.bind(this);
      this.updateWindowDimensions = this.updateWindowDimensions.bind(this);
    }
    getGraphMetric() {
      let metric = this.props.graphData.metric;
      if (metric == "visitors" && hasGoalFilter(this.props.query)) {
        return "conversions";
      } else {
        return metric;
      }
    }
    regenerateChart() {
      const { graphData, query } = this.props;
      const metric = this.getGraphMetric();
      const graphEl = document.getElementById("main-graph-canvas");
      this.ctx = graphEl.getContext("2d");
      const dataSet = buildDataSet(graphData.plot, graphData.comparison_plot, graphData.present_index, this.ctx, METRIC_LABELS[metric]);
      return new auto_default(this.ctx, {
        type: "line",
        data: {
          labels: graphData.labels,
          datasets: dataSet
        },
        options: {
          animation: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              enabled: false,
              mode: "index",
              intersect: false,
              position: "average",
              external: GraphTooltip(graphData, metric, query)
            }
          },
          responsive: true,
          maintainAspectRatio: false,
          onResize: this.updateWindowDimensions,
          elements: { line: { tension: 0 }, point: { radius: 0 } },
          onClick: this.maybeHopToHoveredPeriod.bind(this),
          scale: {
            ticks: { precision: 0, maxTicksLimit: 8 }
          },
          scales: {
            y: {
              min: 0,
              suggestedMax: calculateMaximumY(dataSet),
              ticks: {
                callback: METRIC_FORMATTER[metric],
                color: this.props.darkTheme ? "rgb(243, 244, 246)" : void 0
              },
              grid: {
                zeroLineColor: "transparent",
                drawBorder: false
              }
            },
            yComparison: {
              min: 0,
              suggestedMax: calculateMaximumY(dataSet),
              display: false,
              grid: { display: false }
            },
            x: {
              grid: { display: false },
              ticks: {
                callback: function(val, _index, _ticks) {
                  if (this.getLabelForValue(val) == "__blank__") return "";
                  const hasMultipleYears = graphData.labels.filter((date) => typeof date === "string").map((date) => date.split("-")[0]).filter((value, index2, list) => list.indexOf(value) === index2).length > 1;
                  if (graphData.interval === "hour" && query.period !== "day") {
                    const date = dateFormatter({
                      interval: "date",
                      longForm: false,
                      period: query.period,
                      shouldShowYear: hasMultipleYears
                    })(this.getLabelForValue(val));
                    const hour = dateFormatter({
                      interval: graphData.interval,
                      longForm: false,
                      period: query.period,
                      shouldShowYear: hasMultipleYears
                    })(this.getLabelForValue(val));
                    return `${date}, ${hour}`;
                  }
                  if (graphData.interval === "minute" && query.period !== "realtime") {
                    return dateFormatter({
                      interval: "hour",
                      longForm: false,
                      period: query.period
                    })(this.getLabelForValue(val));
                  }
                  return dateFormatter({
                    interval: graphData.interval,
                    longForm: false,
                    period: query.period,
                    shouldShowYear: hasMultipleYears
                  })(this.getLabelForValue(val));
                },
                color: this.props.darkTheme ? "rgb(243, 244, 246)" : void 0
              }
            }
          },
          interaction: {
            mode: "index",
            intersect: false
          }
        }
      });
    }
    repositionTooltip(e3) {
      const tooltipEl = document.getElementById("chartjs-tooltip");
      if (tooltipEl && window.innerWidth >= 768) {
        if (e3.clientX > 0.66 * window.innerWidth) {
          tooltipEl.style.right = window.innerWidth - e3.clientX + window.pageXOffset + "px";
          tooltipEl.style.left = null;
        } else {
          tooltipEl.style.right = null;
          tooltipEl.style.left = e3.clientX + window.pageXOffset + "px";
        }
        tooltipEl.style.top = e3.clientY + window.pageYOffset + "px";
        tooltipEl.style.opacity = 1;
      }
    }
    componentDidMount() {
      if (this.props.graphData) {
        this.chart = this.regenerateChart();
      }
      window.addEventListener("mousemove", this.repositionTooltip);
    }
    componentDidUpdate(prevProps) {
      const { graphData, darkTheme } = this.props;
      const tooltip = document.getElementById("chartjs-tooltip");
      if (graphData !== prevProps.graphData || darkTheme !== prevProps.darkTheme) {
        if (graphData) {
          if (this.chart) {
            this.chart.destroy();
          }
          this.chart = this.regenerateChart();
          this.chart.update();
        }
        if (tooltip) {
          tooltip.style.display = "none";
        }
      }
      if (!graphData) {
        if (this.chart) {
          this.chart.destroy();
        }
        if (tooltip) {
          tooltip.style.display = "none";
        }
      }
    }
    componentWillUnmount() {
      const tooltip = document.getElementById("chartjs-tooltip");
      if (tooltip) {
        tooltip.style.opacity = 0;
        tooltip.style.display = "none";
      }
      window.removeEventListener("mousemove", this.repositionTooltip);
    }
    /**
     * The current ticks' limits are set to treat iPad (regular/Mini/Pro) as a regular screen.
     * @param {*} chart - The chart instance.
     * @param {*} dimensions - An object containing the new dimensions *of the chart.*
     */
    updateWindowDimensions(chart, dimensions) {
      chart.options.scales.x.ticks.maxTicksLimit = dimensions.width < 720 ? 5 : 8;
    }
    maybeHopToHoveredPeriod(e3) {
      const element = this.chart.getElementsAtEventForMode(e3, "index", { intersect: false })[0];
      const date = this.props.graphData.labels[element.index] || this.props.graphData.comparison_labels[element.index];
      if (this.props.graphData.interval === "month") {
        navigateToQuery(this.props.navigate, this.props.query, { period: "month", date });
      } else if (this.props.graphData.interval === "date") {
        navigateToQuery(this.props.navigate, this.props.query, { period: "day", date });
      }
    }
    render() {
      const { graphData } = this.props;
      const canvasClass = (0, import_classnames8.default)("mt-4 select-none", { "cursor-pointer": !["minute", "hour"].includes(graphData == null ? void 0 : graphData.interval) });
      return /* @__PURE__ */ import_react42.default.createElement(FadeIn, { show: graphData }, /* @__PURE__ */ import_react42.default.createElement("div", { className: "relative h-96 print:h-auto print:pb-8 w-full z-0" }, /* @__PURE__ */ import_react42.default.createElement("canvas", { id: "main-graph-canvas", className: canvasClass })));
    }
  };
  function LineGraphWrapped(props) {
    const { query } = useQueryContext();
    const navigate = useNavigate();
    return /* @__PURE__ */ import_react42.default.createElement(LineGraph, __spreadProps(__spreadValues({}, props), { navigate, query }));
  }

  // js/dashboard/stats/graph/visitor-graph.js
  function fetchTopStats(site, query) {
    const q3 = __spreadValues({}, query);
    if (!isComparisonEnabled(q3.comparison)) {
      q3.comparison = "previous_period";
    }
    return get(apiPath(site, "/top-stats"), q3);
  }
  function fetchMainGraph(site, query, metric, interval) {
    const params = { metric, interval };
    return get(apiPath(site, "/main-graph"), query, params);
  }
  function VisitorGraph({ updateImportedDataInView }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const isRealtime = query.period === "realtime";
    const isDarkTheme = document.querySelector("html").classList.contains("dark") || false;
    const topStatsBoundary = (0, import_react43.useRef)(null);
    const [topStatData, setTopStatData] = (0, import_react43.useState)(null);
    const [topStatsLoading, setTopStatsLoading] = (0, import_react43.useState)(true);
    const [graphData, setGraphData] = (0, import_react43.useState)(null);
    const [graphLoading, setGraphLoading] = (0, import_react43.useState)(true);
    const [graphRefreshing, setGraphRefreshing] = (0, import_react43.useState)(false);
    const onIntervalUpdate = (0, import_react43.useCallback)((newInterval) => {
      setGraphData(null);
      setGraphRefreshing(true);
      fetchGraphData(getStoredMetric(), newInterval);
    }, [query]);
    const onMetricUpdate = (0, import_react43.useCallback)((newMetric) => {
      setGraphData(null);
      setGraphRefreshing(true);
      fetchGraphData(newMetric, getCurrentInterval(site, query));
    }, [query]);
    (0, import_react43.useEffect)(() => {
      setTopStatData(null);
      setTopStatsLoading(true);
      setGraphData(null);
      setGraphLoading(true);
      fetchTopStatsAndGraphData();
      if (isRealtime) {
        document.addEventListener("tick", fetchTopStatsAndGraphData);
      }
      return () => {
        document.removeEventListener("tick", fetchTopStatsAndGraphData);
      };
    }, [query]);
    (0, import_react43.useEffect)(() => {
      if (topStatData) {
        storeTopStatsContainerHeight();
      }
    }, [topStatData]);
    function fetchTopStatsAndGraphData() {
      fetchTopStats(site, query).then((res) => {
        if (updateImportedDataInView) {
          updateImportedDataInView(res.includes_imported);
        }
        setTopStatData(res);
        setTopStatsLoading(false);
      });
      let metric = getStoredMetric();
      const availableMetrics = getGraphableMetrics(query, site);
      if (!availableMetrics.includes(metric)) {
        metric = availableMetrics[0];
        setItem(`metric__${site.domain}`, metric);
      }
      const interval = getCurrentInterval(site, query);
      fetchGraphData(metric, interval);
    }
    function fetchGraphData(metric, interval) {
      fetchMainGraph(site, query, metric, interval).then((res) => {
        setGraphData(res);
        setGraphLoading(false);
        setGraphRefreshing(false);
      });
    }
    function getStoredMetric() {
      return getItem(`metric__${site.domain}`);
    }
    function storeTopStatsContainerHeight() {
      setItem(`topStatsHeight__${site.domain}`, document.getElementById("top-stats-container").clientHeight);
    }
    function getTopStatsHeight() {
      if (topStatData) {
        return "auto";
      } else {
        return `${getItem(`topStatsHeight__${site.domain}`) || 89}px`;
      }
    }
    return /* @__PURE__ */ import_react43.default.createElement("div", { className: "relative w-full mt-2 bg-white rounded shadow-xl dark:bg-gray-825" }, (topStatsLoading || graphLoading) && renderLoader(), /* @__PURE__ */ import_react43.default.createElement(FadeIn, { show: !(topStatsLoading || graphLoading) }, /* @__PURE__ */ import_react43.default.createElement("div", { id: "top-stats-container", className: "flex flex-wrap", ref: topStatsBoundary, style: { height: getTopStatsHeight() } }, /* @__PURE__ */ import_react43.default.createElement(
      TopStats,
      {
        data: topStatData,
        onMetricUpdate,
        tooltipBoundary: topStatsBoundary.current
      }
    )), /* @__PURE__ */ import_react43.default.createElement("div", { className: "relative px-2" }, graphRefreshing && renderLoader(), /* @__PURE__ */ import_react43.default.createElement("div", { className: "absolute right-4 -top-8 py-1 flex items-center" }, !isRealtime && /* @__PURE__ */ import_react43.default.createElement(StatsExport, null), /* @__PURE__ */ import_react43.default.createElement(SamplingNotice, { samplePercent: topStatData }), !!(topStatData == null ? void 0 : topStatData.with_imported_switch) && (topStatData == null ? void 0 : topStatData.with_imported_switch.visible) && /* @__PURE__ */ import_react43.default.createElement(
      WithImportedSwitch,
      {
        tooltipMessage: topStatData.with_imported_switch.tooltip_msg,
        disabled: !topStatData.with_imported_switch.togglable
      }
    ), /* @__PURE__ */ import_react43.default.createElement(IntervalPicker, { onIntervalUpdate })), /* @__PURE__ */ import_react43.default.createElement(LineGraphWrapped, { graphData, darkTheme: isDarkTheme }))));
  }
  function renderLoader() {
    return /* @__PURE__ */ import_react43.default.createElement("div", { className: "absolute h-full w-full flex items-center justify-center" }, /* @__PURE__ */ import_react43.default.createElement("div", { className: "loading" }, /* @__PURE__ */ import_react43.default.createElement("div", null)));
  }

  // js/dashboard/stats/sources/index.js
  var import_react56 = __toESM(require_react());

  // js/dashboard/stats/sources/search-terms.js
  var import_react48 = __toESM(require_react());

  // js/dashboard/stats/bar.js
  var import_react44 = __toESM(require_react());
  function barWidth(count, all, plot) {
    let maxVal = all[0][plot];
    for (const val of all) {
      if (val > maxVal) maxVal = val[plot];
    }
    return count / maxVal * 100;
  }
  function Bar({ count, all, bg, maxWidthDeduction, children, plot = "visitors" }) {
    const width = barWidth(count, all, plot);
    const style = maxWidthDeduction ? { maxWidth: `calc(100% - ${maxWidthDeduction})` } : {};
    return /* @__PURE__ */ import_react44.default.createElement(
      "div",
      {
        className: "w-full h-full relative",
        style
      },
      /* @__PURE__ */ import_react44.default.createElement(
        "div",
        {
          className: `absolute top-0 left-0 h-full ${bg || ""}`,
          style: { width: `${width}%` }
        }
      ),
      children
    );
  }

  // js/dashboard/stats/more-link.js
  var import_react45 = __toESM(require_react());
  function detailsIcon() {
    return /* @__PURE__ */ import_react45.default.createElement(
      "svg",
      {
        className: "feather mr-1",
        style: { marginTop: "-2px" },
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: "2",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      },
      /* @__PURE__ */ import_react45.default.createElement("path", { d: "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" })
    );
  }
  function MoreLink({ linkProps, list, className, onClick }) {
    if (list.length > 0) {
      return /* @__PURE__ */ import_react45.default.createElement("div", { className: `w-full text-center ${className ? className : ""}` }, /* @__PURE__ */ import_react45.default.createElement(
        Link,
        __spreadProps(__spreadValues({}, linkProps), {
          className: "leading-snug font-bold text-sm text-gray-500 dark:text-gray-400 hover:text-red-500 dark:hover:text-red-400 transition tracking-wide",
          onClick
        }),
        detailsIcon(),
        "DETAILS"
      ));
    }
    return null;
  }

  // js/dashboard/stats/modals/rocket-icon.js
  var import_react46 = __toESM(require_react());
  function RocketIcon() {
    return /* @__PURE__ */ import_react46.default.createElement("svg", { className: "inline fill-current", xmlns: "http://www.w3.org/2000/svg", width: "100", height: "100", version: "1.1", x: "0px", y: "0px", viewBox: "0 0 100 125", style: { enableBackground: "new 0 0 100 100" }, xmlSpace: "preserve" }, /* @__PURE__ */ import_react46.default.createElement("g", null, /* @__PURE__ */ import_react46.default.createElement("path", { d: "M35.6830368,38.7263184c2.7299805,0,4.9511719-2.2211914,4.9511719-4.9511719s-2.2211914-4.9511719-4.9511719-4.9511719   c-2.7304688,0-4.9516602,2.2211914-4.9516602,4.9511719S32.9525681,38.7263184,35.6830368,38.7263184z M35.6830368,30.8239746   c1.6274414,0,2.9511719,1.3237305,2.9511719,2.9511719s-1.3237305,2.9511719-2.9511719,2.9511719   s-2.9516602-1.3237305-2.9516602-2.9511719S34.0555954,30.8239746,35.6830368,30.8239746z" }), /* @__PURE__ */ import_react46.default.createElement("path", { d: "M43.4540329,27.4133301c2.1630859,0,3.9228516-1.7597656,3.9228516-3.9228516s-1.7597656-3.9228516-3.9228516-3.9228516   c-2.1625977,0-3.9223633,1.7597656-3.9223633,3.9228516S41.2914352,27.4133301,43.4540329,27.4133301z M43.4540329,21.567627   c1.0600586,0,1.9228516,0.862793,1.9228516,1.9228516s-0.862793,1.9228516-1.9228516,1.9228516   s-1.9223633-0.862793-1.9223633-1.9228516S42.3939743,21.567627,43.4540329,21.567627z" }), /* @__PURE__ */ import_react46.default.createElement("path", { d: "M80.2762985,41.4973145c3.6635742,0,6.6445313-2.980957,6.6445313-6.6445313s-2.980957-6.6445313-6.6445313-6.6445313   c-3.6640625,0-6.6450195,2.980957-6.6450195,6.6445313S76.612236,41.4973145,80.2762985,41.4973145z M80.2762985,30.208252   c2.5610352,0,4.6445313,2.0834961,4.6445313,4.6445313s-2.0834961,4.6445313-4.6445313,4.6445313   s-4.6450195-2.0834961-4.6450195-4.6445313S77.7152634,30.208252,80.2762985,30.208252z" }), /* @__PURE__ */ import_react46.default.createElement("path", { d: "M86.4340134,28.1555176c1.9663086,0,3.565918-1.5996094,3.565918-3.565918s-1.5996094-3.565918-3.565918-3.565918   c-1.9658203,0-3.5654297,1.5996094-3.5654297,3.565918S84.4681931,28.1555176,86.4340134,28.1555176z M86.4340134,23.0236816   c0.8632813,0,1.565918,0.7026367,1.565918,1.565918s-0.7026367,1.565918-1.565918,1.565918   s-1.5654297-0.7026367-1.5654297-1.565918S85.5707321,23.0236816,86.4340134,23.0236816z" }), /* @__PURE__ */ import_react46.default.createElement("path", { d: "M79.9183884,48.1384277l-0.5896606,0.1737061c0.1333618-0.4435425,0.2112427-0.9072266,0.2112427-1.3841553   c0-0.4707031-0.0678711-0.9375-0.2045898-1.3950195c-0.78125-2.5327148-3.4887695-3.9741211-6.0366211-3.2119141   l-1.7001953,0.5170898c-0.3798828,0.1108398-0.7299805,0.1855469-1.0664063,0.2265625   c-0.003479,0.0004272-0.006897,0.000061-0.010376,0.0004883c-0.0266113,0.0028076-0.0534058-0.0014648-0.0794678,0.00354   c-0.6416626,0.0675659-1.277771,0.0505981-1.8896484-0.0645752l-4.8505859-0.8999023   c-3.8491211-0.7124023-7.8662109-0.4970703-11.6201172,0.6259766l-11.3138428,3.4025879   c-0.0564575-0.0429077-0.1116943-0.0877075-0.1778564-0.1184082l-13.7036133-6.3583984   c-0.230957-0.1069336-0.4951172-0.121582-0.7353516-0.0419922l-8.2226563,2.7250977   c-0.309082,0.1025391-0.5488281,0.3486328-0.6425781,0.6601563c-0.0942383,0.3110352-0.03125,0.6489258,0.1694336,0.9052734   l5.8516235,7.4795532l-2.1152954,0.6361694c-0.2539063,0.0761719-0.4672852,0.2504883-0.5927734,0.4838867   c-0.1254883,0.2338867-0.1533203,0.5078125-0.0766602,0.7617188l0.3309326,1.0892944   c-0.2720337,0.0733643-0.5426636,0.1504517-0.8016357,0.250061c-4.4667969,1.7197266-6.3505859,7.1894531-6.4287109,7.4213867   c-0.1542969,0.4580078,0.0415039,0.9609375,0.4648438,1.1943359c0.1640625,0.0908203,3.1762695,1.7246094,6.574707,1.7246094   c1.0532227,0,2.144043-0.1572266,3.1977539-0.5654297c0.0115356-0.0044556,0.022644-0.010437,0.0341797-0.0149536   l0.0750732,0.2472534l-1.4403076,0.4239502c-0.2548828,0.0751953-0.4692383,0.2485352-0.5961914,0.4819336   s-0.1557617,0.5073242-0.0800781,0.762207l0.2781982,0.9320679c-1.5239868-0.0391846-2.9415283,0.1781616-4.2181396,0.6724243   c-5.4560547,2.1005859-7.7651367,8.8061523-7.8608398,9.090332c-0.1176758,0.3505859-0.0327148,0.7373047,0.2211914,1.0058594   c0.2539063,0.269043,0.6376953,0.3745117,0.9916992,0.2773438c1.5864258-0.4365234,3.1904297-0.6772461,4.7919922-0.7211914   l-1.0683594,1.046875c-0.269043,0.2631836-0.3671875,0.6552734-0.2543945,1.0141602s0.4174805,0.6240234,0.7880859,0.6865234   c0.0708008,0.0117188,0.9082031,0.1474609,2.121582,0.1474609c1.3310547,0,3.1152344-0.1635742,4.8369141-0.8339844   c0.9935913-0.385376,1.942627-0.9547729,2.8378296-1.6859131l0.4258423,1.4300537   c0.1289063,0.434082,0.5268555,0.715332,0.9580078,0.715332c0.09375,0,0.1889648-0.0136719,0.2832031-0.0415039l3.6088257-1.064209   c0.5294189,0.4693604,1.2138062,0.7355957,1.9185181,0.7355957c0.2729492,0,0.5488281-0.0395508,0.8183594-0.1206055   l2.612793-0.7680664c0.6903687-0.1968994,1.2542114-0.6436157,1.6234131-1.2183228   c0.3770752,0.1716309,0.7831421,0.2798462,1.2032471,0.2798462c0.2666016,0,0.5361328-0.0366211,0.8007813-0.1132813   l2.6342773-0.7744141c0.6880493-0.2131348,1.241272-0.6553345,1.6037598-1.2210083   c0.3721924,0.1687622,0.7717285,0.2756958,1.1843262,0.2756958c0.2724609,0,0.5478516-0.0395508,0.8178711-0.1206055   l2.612793-0.7675781c0.980957-0.2804565,1.713623-1.0597534,1.9748535-2.0108032l33.9655762-10.0023804   c3.3706055-1.003418,5.6347656-4.0170898,5.6347656-7.4985352c0-0.7524414-0.1083984-1.4975586-0.3222656-2.2167969   C88.4432907,49.2814941,84.0643845,46.9157715,79.9183884,48.1384277z M26.4042282,41.6369629l10.9301758,5.0717773   l-12.3256836,3.6044922l-5.1030273-6.5224609L26.4042282,41.6369629z M63.3373337,44.0710449l2.6757202,0.4962769   l-6.4960327,2.1526489c-0.3745117,0.121582-0.7783203-0.0761719-0.9013672-0.4448242l-0.8479614-2.5335693   C59.6291428,43.6253662,61.5039597,43.730957,63.3373337,44.0710449z M52.6566696,44.645752   c1.0076294-0.3015137,2.0372925-0.5230713,3.0765381-0.6818237l0.9859619,2.9459839   c0.3779297,1.1303711,1.4384766,1.847168,2.5737305,1.8466797c0.2832031,0,0.5708008-0.0444336,0.8535156-0.1381836   l10.8579102-3.5981445c0.0090942-0.0029907,0.0158081-0.0096436,0.0247192-0.0128784   c0.3674316-0.0574341,0.7401123-0.1351929,1.1417847-0.2532349l1.7055664-0.5185547   c1.4975586-0.4467773,3.0883789,0.3989258,3.5454102,1.878418c0.078125,0.2631836,0.1181641,0.5371094,0.1181641,0.8139648   c0,0.8886719-0.4160156,1.7143555-1.1201172,2.2368164l-28.8650513,8.5059814l-0.8562622,0.2522583   c-0.2514038-0.196106-0.5341187-0.3519897-0.8377686-0.4598999c-0.0093384-0.0098267-0.0202637-0.0175781-0.0297241-0.0272827   c-0.038208-0.0392456-0.079895-0.0735474-0.1200562-0.1102905c-0.0634155-0.0580444-0.1269531-0.1153564-0.1948242-0.1671143   c-0.0471191-0.0359497-0.0963745-0.067749-0.1453857-0.1005859c-0.0665283-0.0444946-0.1335449-0.0876465-0.2033081-0.1263428   c-0.0535278-0.0297241-0.1080322-0.0564575-0.163269-0.0827026c-0.0698853-0.0332031-0.1405029-0.0636597-0.2127686-0.0911255   c-0.0580444-0.0220947-0.1160889-0.0426025-0.1754761-0.0609131c-0.0736694-0.0227051-0.1481323-0.0411987-0.2234497-0.0580444   c-0.0602417-0.0134888-0.1199341-0.0269775-0.1810303-0.0365601c-0.0789795-0.0123901-0.1585693-0.0187988-0.2385254-0.0245972   c-0.0588379-0.0043335-0.1170044-0.0105591-0.1762085-0.0112305c-0.0892334-0.0009766-0.1785889,0.0061035-0.2682495,0.0134888   c-0.0505371,0.0042114-0.1008911,0.0043335-0.1514893,0.0112305c-0.1401367,0.019043-0.2800293,0.0469971-0.4185791,0.0874023   l-2.6254883,0.7714844c-0.1715088,0.0514526-0.335022,0.1169434-0.4894409,0.1948242   c-0.1483154,0.0748291-0.2871094,0.1623535-0.4178467,0.258667c-0.0053711,0.0039673-0.0119019,0.0066528-0.0172729,0.0106812   c-0.1115723,0.083374-0.2116089,0.1785278-0.3088379,0.2757568c-0.020752,0.020752-0.0458374,0.0375366-0.0658569,0.0588379   c-0.0830688,0.0883789-0.1534424,0.1865234-0.2243042,0.2841187c-0.0264282,0.036377-0.0588379,0.0684204-0.0834961,0.105957   c-0.0002441,0.0003662-0.0006104,0.0007324-0.0008545,0.0010986c-0.008728-0.0039673-0.0183105-0.0056763-0.0270996-0.0095215   c-0.0830688-0.0366821-0.1703491-0.0613403-0.2565308-0.0900269c-0.0712891-0.0236816-0.1404419-0.0530396-0.213501-0.0710449   c-0.0961914-0.0238037-0.1952515-0.0338135-0.2938232-0.0474854c-0.0670166-0.0093384-0.1325073-0.0254517-0.2003174-0.0299683   c-0.1109619-0.0073853-0.2233276,0.0008545-0.3355103,0.0066528c-0.0574341,0.0029907-0.1143188-0.0018921-0.171875,0.0046387   c-0.1697998,0.0193481-0.3398438,0.0536499-0.5081787,0.1049194l-2.6225586,0.7709961   c-0.1702271,0.0504761-0.3327026,0.1159668-0.4865723,0.194458c-0.0361938,0.0184937-0.0670166,0.0443115-0.1022339,0.064209   c-0.114624,0.0647583-0.2285767,0.1306152-0.3320923,0.2097778c-0.0396729,0.0302734-0.0722656,0.0681152-0.1102295,0.1004028   c-0.0912476,0.0775757-0.1833496,0.1543579-0.263916,0.2424927c-0.0459595,0.0502319-0.0822754,0.1082764-0.1245728,0.1616211   c-0.0603638,0.0762329-0.1253662,0.1488647-0.1779175,0.230957c-0.4283447-0.1953125-0.90625-0.2789307-1.394104-0.2468872   c-0.0344849,0.0022583-0.0682373-0.0021362-0.1028442,0.0013428c-0.1741333,0.0176392-0.3493042,0.0509033-0.5236816,0.100708   l-2.6259766,0.7719727c-0.1636353,0.0493164-0.3181763,0.1143799-0.4664307,0.1885986   c-0.0487671,0.0244141-0.0928955,0.0542603-0.1398315,0.0811157c-0.0963745,0.0551758-0.1904907,0.1124878-0.2788086,0.1773682   c-0.0499268,0.0366821-0.0962524,0.0762939-0.1435547,0.1159058c-0.0778809,0.0652466-0.1521606,0.1329956-0.2223511,0.2055054   c-0.0435181,0.0449219-0.0854492,0.09021-0.1258545,0.1376343c-0.0662231,0.0778198-0.1264648,0.1592407-0.18396,0.2432251   c-0.03302,0.0482788-0.0672607,0.0950928-0.09729,0.1452026c-0.0593262,0.098999-0.1095581,0.2024536-0.1566162,0.3079224   c-0.0180054,0.0402222-0.0400391,0.078186-0.0561523,0.1193237c-0.0580444,0.1479492-0.1044922,0.300354-0.137207,0.4569702   c-0.007019,0.0336914-0.0078735,0.0687256-0.0136719,0.1027222c-0.0180664,0.1057129-0.0368042,0.2113647-0.0427246,0.3195801   l-0.2138062-0.7027588c0.012085-0.1270142,0.0072021-0.2562256-0.0317993-0.3841553l-1.1140137-3.6674194l-0.322998-1.0791626   c-0.0026855-0.0089111-0.0092773-0.015564-0.012207-0.024353l-0.9248047-3.0444946   c-0.0401001-0.1308594-0.1096802-0.2437134-0.1931763-0.3440552l-0.2487183-0.8175659L52.6566696,44.645752z    M22.3425827,59.2571411l0.0478516,0.1574097c-0.1259155,0.0722656-0.2521362,0.1400757-0.3763428,0.1901855   c-0.253418,0.0957031-0.5390625,0.1601563-0.8525391,0.1923828c0.2495117-0.1816406,0.5009766-0.3227539,0.7504883-0.4189453   C22.0441818,59.3267212,22.1913376,59.2897949,22.3425827,59.2571411z M23.1390915,62.5144043   c-2.6728516,1.0361328-5.8369141-0.0449219-7.2880859-0.668457c0.6430664-1.4326172,2.2358398-4.3408203,4.9189453-5.3740234   c0.213562-0.0823975,0.4368286-0.1488037,0.6634521-0.2074585l0.3309937,1.0894775   c-0.1945801,0.0488892-0.3952637,0.0895996-0.5745239,0.1589966c-1.090332,0.421875-2.1020508,1.2758789-3.0068359,2.5380859   c-0.1958008,0.2734375-0.2412109,0.6269531-0.1206055,0.940918s0.3911133,0.5463867,0.7197266,0.6186523   c0.6391602,0.1396484,1.2744141,0.2109375,1.8881836,0.2109375c0.7543945,0,1.4448242-0.1166992,2.0698242-0.3535156   c0.0811157-0.0325317,0.1576538-0.0828857,0.2376709-0.1199341l0.3328857,1.0957642   C23.2537155,62.4679565,23.1967697,62.4923706,23.1390915,62.5144043z M23.5314255,72.725647l0.0012207,0.0040894   c-0.5898438,0.7407227-1.1948242,1.3237305-1.8076172,1.7416992c-0.5957031-0.9111328-1.5537109-1.5366211-2.6308594-1.7211914   c0.199707-0.1118164,0.4003906-0.2060547,0.6015625-0.2827148c1.0146484-0.387207,2.3012695-0.4477539,3.6938477-0.2143555   L23.5314255,72.725647z M21.756279,77.7346191c-1.2910156,0.5024414-2.6557617,0.6630859-3.7475586,0.6904297l1.1201172-1.0976563   c0.2788086-0.2729492,0.3730469-0.6831055,0.2421875-1.050293s-0.4633789-0.625-0.8515625-0.6601563   c-0.6420898-0.0581055-1.2861328-0.0869141-1.9301758-0.0869141c-1.2963867,0-2.5947266,0.1171875-3.8862305,0.3515625   c0.9746094-1.9414063,2.9125977-4.96875,5.9301758-6.1308594c1.1391602-0.440918,2.434082-0.6181641,3.8476563-0.5322266   l0.2842407,0.9488525c-1.3863525-0.1206055-2.680603,0.0112915-3.7837524,0.4320068   c-1.2207031,0.4672852-2.3857422,1.3544922-3.4614258,2.6357422c-0.2607422,0.3105469-0.3085938,0.7480469-0.1201172,1.1069336   c0.1879883,0.3588867,0.5737305,0.5717773,0.9785156,0.5317383l1.8959961-0.1762695   c0.0302734-0.003418,0.0610352-0.0043945,0.0913086-0.0043945c0.784668,0.0019531,1.4975586,0.4169922,1.831543,1.1416016   c0.0463867,0.0922852,0.0771484,0.1743164,0.097168,0.2583008c0.0678711,0.2875977,0.2592773,0.5307617,0.5229492,0.6635742   c0.1416016,0.0712891,0.2958984,0.1069336,0.4501953,0.1069336c0.1342773,0,0.2685547-0.0268555,0.3945313-0.0810547   c0.8795776-0.3776855,1.7250366-1.0009155,2.534668-1.8171997l0.3041992,1.0198364   C23.6381149,76.7746582,22.7172165,77.3615723,21.756279,77.7346191z M25.7430954,72.3293457   c-0.0053711-0.0239258-0.0117188-0.0478516-0.0185547-0.0712891l-1.6694336-5.5859375l0.6426392-0.1890869   c0.1815186,0.1630859,0.4124756,0.2652588,0.6615601,0.2652588c0.0947266,0,0.190918-0.0136719,0.2866211-0.0424805   l0.7924194-0.2364502l2.1046753,7.0847168l1.0675659,3.6032104l-2.2332153,0.6588745L25.7430954,72.3293457z    M35.3881149,76.8781738l-2.6269531,0.7719727c-0.3734741,0.1134644-0.7839355-0.0386963-0.998291-0.3710938   c-0.0044556-0.0070801-0.0038452-0.0159912-0.0085449-0.0229492c-0.0307617-0.0463867-0.0595703-0.1108398-0.0820313-0.1914063   l-1.4168701-4.7697754l-2.2486572-7.5876465l-0.2172852-0.7382813c-0.0527344-0.4150391,0.2158203-0.8164063,0.6328125-0.9418945   l2.6118164-0.7680664c0.4311523-0.1245117,0.8818359,0.0771484,1.0400391,0.4121094l3.5966187,12.0499268l0.3242798,1.0936279   c0.0015259,0.0049438,0.0045166,0.0084229,0.0061035,0.0133667l0.0114746,0.0383911   c0.0001221,0.0003052,0.0003662,0.001709,0.0004883,0.0020752c0.0063477,0.031189,0.0131836,0.0750122,0.0131836,0.145874   c0,0.0057373,0.0036621,0.0105591,0.0037842,0.0162964C36.0345993,76.4204712,35.773613,76.7678833,35.3881149,76.8781738z    M41.6283493,75.0583496l-2.6157227,0.7685547c-0.3842773,0.1107788-0.7797852-0.0397949-1.0014038-0.3787842   c-0.0003052-0.0004883-0.0002441-0.0010986-0.0005493-0.0015869c-0.0240479-0.0377808-0.0378418-0.0718384-0.053833-0.1066895   c-0.0119019-0.026001-0.0247803-0.0489502-0.0344238-0.0758057c-0.0065308-0.0221558-0.0131226-0.0442505-0.0206299-0.06604   c-0.001709-0.005127-0.0059204-0.0084839-0.0077515-0.0136108l-3.7139282-12.5259399l-0.1210938-0.4052734   c-0.0109863-0.0336914-0.0181274-0.0585327-0.0230103-0.0740356c-0.0022583-0.0072632-0.005188-0.0172729-0.0057983-0.0172729   c-0.0004883,0-0.0004883,0.0014648-0.0004883,0.0048828c-0.0610352-0.4277344,0.2119141-0.8452148,0.6318359-0.9697266   l2.6289063-0.7724609c0.40625-0.125,0.8422852,0.0654297,1.034668,0.4501953   c0.0029297,0.0058594,0.0058594,0.0112305,0.0087891,0.0170898c0.0043945,0.0102539,0.0087891,0.0205078,0.0131836,0.0302734   c0.015625,0.034668,0.0341797,0.0708008,0.0463867,0.1069336l3.8374023,12.9326172   c0.0012207,0.0040894,0.0032349,0.0079956,0.0044556,0.012085l0.0062866,0.0211182   c0.0129395,0.0390625,0.0126953,0.0739746,0.0166626,0.107666c0.0024414,0.0253906,0.0077515,0.0415649,0.0077515,0.0773926   c0,0.0050049,0.0032349,0.0092163,0.0032959,0.0142212C42.2725143,74.5970459,42.0161667,74.9381714,41.6283493,75.0583496z    M48.509697,72.3605957c0.0048828,0.3955078-0.2558594,0.7475586-0.6416016,0.8579102l-2.6264648,0.7714844   c-0.3828125,0.1132813-0.7822266-0.0351563-0.9838867-0.3564453c-0.0009155-0.0015259-0.0010376-0.0028076-0.0019531-0.0043335   c-0.003479-0.0057983-0.0027466-0.0128784-0.0063477-0.0186157c-0.0113525-0.0181274-0.015686-0.0336304-0.0253296-0.0511475   c-0.026001-0.0504761-0.0529175-0.1010132-0.0684204-0.1506348c-0.0031128-0.0101929-0.0059204-0.0204468-0.0092773-0.0306396   c-0.0010376-0.0032349-0.0037231-0.0053711-0.0047607-0.008606l-3.7252197-12.5631714l-0.1323242-0.456543   c-0.0039063-0.0375977-0.0102539-0.074707-0.0185547-0.1113281c-0.0249023-0.3901367,0.2368164-0.7514648,0.6362305-0.8710938   l2.6176758-0.7695313c0.3603516-0.1015625,0.7441406,0.0283203,0.9614258,0.3271484   c0.0151367,0.0214844,0.0566406,0.078125,0.0737305,0.0981445c0.0341797,0.0678711,0.0683594,0.1425781,0.0791016,0.1674805   l3.8598633,13.0180664c0.0068359,0.0180664,0.0161133,0.0527344,0.0161133,0.1391602   C48.509697,72.3522949,48.509697,72.3562012,48.509697,72.3605957z M83.7972946,61.208252L50.2455368,71.088623   L46.943779,59.935791l33.5390625-9.8789063c3.0947266-0.909668,6.3588867,0.8496094,7.2783203,3.9257813   c0.1582031,0.5327148,0.2387695,1.0859375,0.2387695,1.6450195C87.9999313,58.2175293,86.3099899,60.4602051,83.7972946,61.208252z   " }), /* @__PURE__ */ import_react46.default.createElement("path", { d: "M82.1522751,50.5427246c-0.4902344,0-0.9799805,0.0712891-1.456543,0.2124023   c-0.5292969,0.1572266-0.831543,0.7133789-0.6748047,1.2431641c0.1572266,0.5292969,0.7143555,0.8310547,1.2431641,0.6748047   c1.6289063-0.4804688,3.3920898,0.496582,3.8676758,2.0874023c0.1293945,0.4335938,0.5273438,0.7138672,0.9575195,0.7138672   c0.0952148,0,0.1914063-0.0136719,0.2871094-0.0424805c0.5288086-0.1582031,0.8295898-0.715332,0.6713867-1.2446289   C86.4061813,52.0412598,84.3929977,50.5427246,82.1522751,50.5427246z" }), /* @__PURE__ */ import_react46.default.createElement("path", { d: "M78.2572556,51.4729004l-2.8793945,0.847168c-0.5297852,0.15625-0.8330078,0.7119141-0.6772461,1.2416992   c0.128418,0.4355469,0.5268555,0.7182617,0.9589844,0.7182617c0.09375,0,0.1884766-0.0136719,0.2827148-0.0410156   l2.8793945-0.847168c0.5297852-0.15625,0.8330078-0.7119141,0.6772461-1.2416992   C79.3427048,51.6203613,78.784111,51.3190918,78.2572556,51.4729004z" }), /* @__PURE__ */ import_react46.default.createElement("path", { d: "M72.7758102,53.0856934l-23.9584961,7.0512695c-0.5297852,0.15625-0.8330078,0.7119141-0.6772461,1.2416992   c0.128418,0.4355469,0.5268555,0.7182617,0.9589844,0.7182617c0.09375,0,0.1884766-0.0136719,0.2827148-0.0410156   l23.9584961-7.0512695c0.5297852-0.15625,0.8330078-0.7119141,0.6772461-1.2416992   C73.8607712,53.232666,73.303154,52.932373,72.7758102,53.0856934z" })));
  }

  // js/dashboard/components/lazy-loader.js
  var import_react47 = __toESM(require_react());

  // node_modules/react-intersection-observer/index.mjs
  var React42 = __toESM(require_react(), 1);
  var React210 = __toESM(require_react(), 1);
  var observerMap = /* @__PURE__ */ new Map();
  var RootIds = /* @__PURE__ */ new WeakMap();
  var rootId = 0;
  var unsupportedValue = void 0;
  function getRootId(root) {
    if (!root)
      return "0";
    if (RootIds.has(root))
      return RootIds.get(root);
    rootId += 1;
    RootIds.set(root, rootId.toString());
    return RootIds.get(root);
  }
  function optionsToId(options) {
    return Object.keys(options).sort().filter(
      (key) => options[key] !== void 0
    ).map((key) => {
      return `${key}_${key === "root" ? getRootId(options.root) : options[key]}`;
    }).toString();
  }
  function createObserver(options) {
    let id = optionsToId(options);
    let instance = observerMap.get(id);
    if (!instance) {
      const elements2 = /* @__PURE__ */ new Map();
      let thresholds;
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          var _a9;
          const inView = entry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold);
          if (options.trackVisibility && typeof entry.isVisible === "undefined") {
            entry.isVisible = inView;
          }
          (_a9 = elements2.get(entry.target)) == null ? void 0 : _a9.forEach((callback2) => {
            callback2(inView, entry);
          });
        });
      }, options);
      thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
      instance = {
        id,
        observer,
        elements: elements2
      };
      observerMap.set(id, instance);
    }
    return instance;
  }
  function observe(element, callback2, options = {}, fallbackInView = unsupportedValue) {
    if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
      const bounds = element.getBoundingClientRect();
      callback2(fallbackInView, {
        isIntersecting: fallbackInView,
        target: element,
        intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
        time: 0,
        boundingClientRect: bounds,
        intersectionRect: bounds,
        rootBounds: bounds
      });
      return () => {
      };
    }
    const { id, observer, elements: elements2 } = createObserver(options);
    let callbacks = elements2.get(element) || [];
    if (!elements2.has(element)) {
      elements2.set(element, callbacks);
    }
    callbacks.push(callback2);
    observer.observe(element);
    return function unobserve() {
      callbacks.splice(callbacks.indexOf(callback2), 1);
      if (callbacks.length === 0) {
        elements2.delete(element);
        observer.unobserve(element);
      }
      if (elements2.size === 0) {
        observer.disconnect();
        observerMap.delete(id);
      }
    };
  }
  function useInView({
    threshold,
    delay,
    trackVisibility,
    rootMargin,
    root,
    triggerOnce,
    skip: skip2,
    initialInView,
    fallbackInView,
    onChange
  } = {}) {
    var _a9;
    const [ref, setRef] = React210.useState(null);
    const callback2 = React210.useRef();
    const [state, setState] = React210.useState({
      inView: !!initialInView,
      entry: void 0
    });
    callback2.current = onChange;
    React210.useEffect(
      () => {
        if (skip2 || !ref)
          return;
        let unobserve;
        unobserve = observe(
          ref,
          (inView, entry) => {
            setState({
              inView,
              entry
            });
            if (callback2.current)
              callback2.current(inView, entry);
            if (entry.isIntersecting && triggerOnce && unobserve) {
              unobserve();
              unobserve = void 0;
            }
          },
          {
            root,
            rootMargin,
            threshold,
            // @ts-ignore
            trackVisibility,
            // @ts-ignore
            delay
          },
          fallbackInView
        );
        return () => {
          if (unobserve) {
            unobserve();
          }
        };
      },
      // We break the rule here, because we aren't including the actual `threshold` variable
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        // If the threshold is an array, convert it to a string, so it won't change between renders.
        // eslint-disable-next-line react-hooks/exhaustive-deps
        Array.isArray(threshold) ? threshold.toString() : threshold,
        ref,
        root,
        rootMargin,
        triggerOnce,
        skip2,
        trackVisibility,
        fallbackInView,
        delay
      ]
    );
    const entryTarget = (_a9 = state.entry) == null ? void 0 : _a9.target;
    const previousEntryTarget = React210.useRef();
    if (!ref && entryTarget && !triggerOnce && !skip2 && previousEntryTarget.current !== entryTarget) {
      previousEntryTarget.current = entryTarget;
      setState({
        inView: !!initialInView,
        entry: void 0
      });
    }
    const result = [setRef, state.inView, state.entry];
    result.ref = result[0];
    result.inView = result[1];
    result.entry = result[2];
    return result;
  }

  // js/dashboard/components/lazy-loader.js
  function LazyLoader(props) {
    const [hasBecomeVisibleYet, setHasBecomeVisibleYet] = (0, import_react47.useState)(false);
    const { ref, inView } = useInView({
      threshold: 0
    });
    (0, import_react47.useEffect)(() => {
      if (inView && !hasBecomeVisibleYet) {
        setHasBecomeVisibleYet(true);
        props.onVisible && props.onVisible();
      }
    }, [inView]);
    return /* @__PURE__ */ import_react47.default.createElement("div", { ref }, props.children);
  }

  // js/dashboard/stats/sources/search-terms.js
  function ConfigureSearchTermsCTA({ site }) {
    return /* @__PURE__ */ import_react48.default.createElement(import_react48.default.Fragment, null, /* @__PURE__ */ import_react48.default.createElement("div", null, "Configure the integration to view search terms"), /* @__PURE__ */ import_react48.default.createElement("a", { href: `/${encodeURIComponent(site.domain)}/settings/integrations`, className: "button mt-4" }, "Connect with Google"));
  }
  var SearchTerms = class extends import_react48.default.Component {
    constructor(props) {
      super(props);
      this.state = { loading: true, errorPayload: null };
      this.onVisible = this.onVisible.bind(this);
      this.fetchSearchTerms = this.fetchSearchTerms.bind(this);
    }
    onVisible() {
      this.fetchSearchTerms();
      if (this.props.query.period === "realtime") {
        document.addEventListener("tick", this.fetchSearchTerms);
      }
    }
    componentDidUpdate(prevProps) {
      if (this.props.query !== prevProps.query) {
        this.setState({ loading: true, terms: null });
        this.fetchSearchTerms();
      }
    }
    componentWillUnmount() {
      document.removeEventListener("tick", this.fetchSearchTerms);
    }
    fetchSearchTerms() {
      get(`/api/stats/${encodeURIComponent(this.props.site.domain)}/referrers/Google`, this.props.query).then((res) => this.setState({
        loading: false,
        searchTerms: res.results,
        errorPayload: null
      })).catch((error) => {
        this.setState({ loading: false, searchTerms: [], errorPayload: error.payload });
      });
    }
    renderSearchTerm(term) {
      return /* @__PURE__ */ import_react48.default.createElement("div", { className: "flex items-center justify-between my-1 text-sm", key: term.name }, /* @__PURE__ */ import_react48.default.createElement(
        Bar,
        {
          count: term.visitors,
          all: this.state.searchTerms,
          bg: "bg-blue-50 dark:bg-gray-500 dark:bg-opacity-15",
          maxWidthDeduction: "4rem"
        },
        /* @__PURE__ */ import_react48.default.createElement("span", { className: "flex px-2 py-1.5 dark:text-gray-300 z-9 relative break-all" }, /* @__PURE__ */ import_react48.default.createElement("span", { className: "md:truncate block" }, term.name))
      ), /* @__PURE__ */ import_react48.default.createElement("span", { className: "font-medium dark:text-gray-200" }, numberFormatter(term.visitors)));
    }
    renderList() {
      if (this.state.errorPayload) {
        const { reason, is_admin, error } = this.state.errorPayload;
        return /* @__PURE__ */ import_react48.default.createElement("div", { className: "text-center text-gray-700 dark:text-gray-300 text-sm mt-20" }, /* @__PURE__ */ import_react48.default.createElement(RocketIcon, null), /* @__PURE__ */ import_react48.default.createElement("div", null, error), reason === "not_configured" && is_admin && /* @__PURE__ */ import_react48.default.createElement(ConfigureSearchTermsCTA, { site: this.props.site }));
      } else if (this.state.searchTerms.length > 0) {
        const valLabel = this.props.query.period === "realtime" ? "Current visitors" : "Visitors";
        return /* @__PURE__ */ import_react48.default.createElement(import_react48.default.Fragment, null, /* @__PURE__ */ import_react48.default.createElement("div", { className: "flex items-center mt-3 mb-2 justify-between text-gray-500 dark:text-gray-400 text-xs font-bold tracking-wide" }, /* @__PURE__ */ import_react48.default.createElement("span", null, "Search term"), /* @__PURE__ */ import_react48.default.createElement("span", null, valLabel)), this.state.searchTerms.map(this.renderSearchTerm.bind(this)));
      } else {
        return /* @__PURE__ */ import_react48.default.createElement("div", { className: "text-center text-gray-700 dark:text-gray-300 " }, /* @__PURE__ */ import_react48.default.createElement("div", { className: "mt-44 mx-auto font-medium text-gray-500 dark:text-gray-400" }, "No data yet"));
      }
    }
    renderContent() {
      if (this.state.searchTerms) {
        return /* @__PURE__ */ import_react48.default.createElement(import_react48.default.Fragment, null, /* @__PURE__ */ import_react48.default.createElement("h3", { className: "font-bold dark:text-gray-100" }, "Search Terms"), this.renderList(), /* @__PURE__ */ import_react48.default.createElement(MoreLink, { list: this.state.searchTerms, linkProps: { to: referrersGoogleRoute.to, search: (search) => search }, className: "w-full pb-4 absolute bottom-0 left-0" }));
      }
    }
    render() {
      return /* @__PURE__ */ import_react48.default.createElement("div", null, this.state.loading && /* @__PURE__ */ import_react48.default.createElement("div", { className: "loading mt-44 mx-auto" }, /* @__PURE__ */ import_react48.default.createElement("div", null)), /* @__PURE__ */ import_react48.default.createElement(FadeIn, { show: !this.state.loading, className: "flex-grow" }, /* @__PURE__ */ import_react48.default.createElement(LazyLoader, { onVisible: this.onVisible }, this.renderContent())));
    }
  };

  // js/dashboard/stats/sources/source-list.js
  var import_react53 = __toESM(require_react());

  // js/dashboard/stats/reports/list.js
  var import_react50 = __toESM(require_react());

  // node_modules/react-flip-move/dist/react-flip-move.es.js
  var import_react49 = __toESM(require_react());
  var import_react_dom2 = __toESM(require_react_dom());
  function warnOnce(msg) {
    var hasWarned = false;
    return function() {
      if (!hasWarned) {
        console.warn(msg);
        hasWarned = true;
      }
    };
  }
  var statelessFunctionalComponentSupplied = warnOnce("\n>> Error, via react-flip-move <<\n\nYou provided a stateless functional component as a child to <FlipMove>. Unfortunately, SFCs aren't supported, because Flip Move needs access to the backing instances via refs, and SFCs don't have a public instance that holds that info.\n\nPlease wrap your components in a native element (eg. <div>), or a non-functional component.\n");
  var primitiveNodeSupplied = warnOnce("\n>> Error, via react-flip-move <<\n\nYou provided a primitive (text or number) node as a child to <FlipMove>. Flip Move needs containers with unique keys to move children around.\n\nPlease wrap your value in a native element (eg. <span>), or a component.\n");
  var invalidTypeForTimingProp = function invalidTypeForTimingProp2(args) {
    return console.error("\n>> Error, via react-flip-move <<\n\nThe prop you provided for '" + args.prop + "' is invalid. It needs to be a positive integer, or a string that can be resolved to a number. The value you provided is '" + args.value + "'.\n\nAs a result,  the default value for this parameter will be used, which is '" + args.defaultValue + "'.\n");
  };
  var invalidEnterLeavePreset = function invalidEnterLeavePreset2(args) {
    return console.error("\n>> Error, via react-flip-move <<\n\nThe enter/leave preset you provided is invalid. We don't currently have a '" + args.value + " preset.'\n\nAcceptable values are " + args.acceptableValues + ". The default value of '" + args.defaultValue + "' will be used.\n");
  };
  var parentNodePositionStatic = warnOnce(`
>> Warning, via react-flip-move <<

When using "wrapperless" mode (by supplying 'typeName' of 'null'), strange things happen when the direct parent has the default "static" position.

FlipMove has added 'position: relative' to this node, to ensure Flip Move animates correctly.

To avoid seeing this warning, simply apply a non-static position to that parent node.
`);
  var childIsDisabled = warnOnce("\n>> Warning, via react-flip-move <<\n\nOne or more of Flip Move's child elements have the html attribute 'disabled' set to true.\n\nPlease note that this will cause animations to break in Internet Explorer 11 and below. Either remove the disabled attribute or set 'animation' to false.\n");
  var enterPresets = {
    elevator: {
      from: { transform: "scale(0)", opacity: "0" },
      to: { transform: "", opacity: "" }
    },
    fade: {
      from: { opacity: "0" },
      to: { opacity: "" }
    },
    accordionVertical: {
      from: { transform: "scaleY(0)", transformOrigin: "center top" },
      to: { transform: "", transformOrigin: "center top" }
    },
    accordionHorizontal: {
      from: { transform: "scaleX(0)", transformOrigin: "left center" },
      to: { transform: "", transformOrigin: "left center" }
    },
    none: null
  };
  var leavePresets = {
    elevator: {
      from: { transform: "scale(1)", opacity: "1" },
      to: { transform: "scale(0)", opacity: "0" }
    },
    fade: {
      from: { opacity: "1" },
      to: { opacity: "0" }
    },
    accordionVertical: {
      from: { transform: "scaleY(1)", transformOrigin: "center top" },
      to: { transform: "scaleY(0)", transformOrigin: "center top" }
    },
    accordionHorizontal: {
      from: { transform: "scaleX(1)", transformOrigin: "left center" },
      to: { transform: "scaleX(0)", transformOrigin: "left center" }
    },
    none: null
  };
  var appearPresets = enterPresets;
  var defaultPreset = "elevator";
  var disablePreset = "none";
  var find = function find2(predicate, arr) {
    for (var i5 = 0; i5 < arr.length; i5++) {
      if (predicate(arr[i5], i5, arr)) {
        return arr[i5];
      }
    }
    return void 0;
  };
  var every = function every2(predicate, arr) {
    for (var i5 = 0; i5 < arr.length; i5++) {
      if (!predicate(arr[i5], i5, arr)) {
        return false;
      }
    }
    return true;
  };
  var _isArray = function isArray2(arr) {
    _isArray = Array.isArray || function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
    return _isArray(arr);
  };
  var isElementAnSFC = function isElementAnSFC2(element) {
    var isNativeDOMElement = typeof element.type === "string";
    if (isNativeDOMElement) {
      return false;
    }
    return typeof element.type === "function" && !element.type.prototype.isReactComponent;
  };
  function omit(obj) {
    var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var result = {};
    Object.keys(obj).forEach(function(key) {
      if (attrs.indexOf(key) === -1) {
        result[key] = obj[key];
      }
    });
    return result;
  }
  function arraysEqual(a3, b2) {
    var sameObject = a3 === b2;
    if (sameObject) {
      return true;
    }
    var notBothArrays = !_isArray(a3) || !_isArray(b2);
    var differentLengths = a3.length !== b2.length;
    if (notBothArrays || differentLengths) {
      return false;
    }
    return every(function(element, index2) {
      return element === b2[index2];
    }, a3);
  }
  function memoizeString(fn2) {
    var cache = {};
    return function(str) {
      if (!cache[str]) {
        cache[str] = fn2(str);
      }
      return cache[str];
    };
  }
  var hyphenate = memoizeString(function(str) {
    return str.replace(/([A-Z])/g, "-$1").toLowerCase();
  });
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var _extends = Object.assign || function(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = arguments[i5];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var inherits = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  var possibleConstructorReturn = function(self2, call) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self2;
  };
  function propConverter(ComposedComponent) {
    var _class, _temp;
    return _temp = _class = function(_Component) {
      inherits(FlipMovePropConverter, _Component);
      function FlipMovePropConverter() {
        classCallCheck(this, FlipMovePropConverter);
        return possibleConstructorReturn(this, _Component.apply(this, arguments));
      }
      FlipMovePropConverter.prototype.checkChildren = function checkChildren(children) {
        if (false) {
          return;
        }
        import_react49.Children.forEach(children, function(child) {
          if (child == null || typeof child === "boolean") {
            return;
          }
          if ((typeof child === "undefined" ? "undefined" : _typeof(child)) !== "object") {
            primitiveNodeSupplied();
            return;
          }
          if (isElementAnSFC(child) && child.key != null) {
            statelessFunctionalComponentSupplied();
          }
        });
      };
      FlipMovePropConverter.prototype.convertProps = function convertProps(props) {
        var workingProps = {
          // explicitly bypass the props that don't need conversion
          children: props.children,
          easing: props.easing,
          onStart: props.onStart,
          onFinish: props.onFinish,
          onStartAll: props.onStartAll,
          onFinishAll: props.onFinishAll,
          typeName: props.typeName,
          disableAllAnimations: props.disableAllAnimations,
          getPosition: props.getPosition,
          maintainContainerHeight: props.maintainContainerHeight,
          verticalAlignment: props.verticalAlignment,
          // Do string-to-int conversion for all timing-related props
          duration: this.convertTimingProp("duration"),
          delay: this.convertTimingProp("delay"),
          staggerDurationBy: this.convertTimingProp("staggerDurationBy"),
          staggerDelayBy: this.convertTimingProp("staggerDelayBy"),
          // Our enter/leave animations can be specified as boolean (default or
          // disabled), string (preset name), or object (actual animation values).
          // Let's standardize this so that they're always objects
          appearAnimation: this.convertAnimationProp(props.appearAnimation, appearPresets),
          enterAnimation: this.convertAnimationProp(props.enterAnimation, enterPresets),
          leaveAnimation: this.convertAnimationProp(props.leaveAnimation, leavePresets),
          delegated: {}
        };
        this.checkChildren(workingProps.children);
        var primaryPropKeys = Object.keys(workingProps);
        var delegatedProps = omit(this.props, primaryPropKeys);
        delegatedProps.style = _extends({
          position: "relative"
        }, delegatedProps.style);
        workingProps.delegated = delegatedProps;
        return workingProps;
      };
      FlipMovePropConverter.prototype.convertTimingProp = function convertTimingProp(prop) {
        var rawValue = this.props[prop];
        var value = typeof rawValue === "number" ? rawValue : parseInt(rawValue, 10);
        if (isNaN(value)) {
          var defaultValue = FlipMovePropConverter.defaultProps[prop];
          if (true) {
            invalidTypeForTimingProp({
              prop,
              value: rawValue,
              defaultValue
            });
          }
          return defaultValue;
        }
        return value;
      };
      FlipMovePropConverter.prototype.convertAnimationProp = function convertAnimationProp(animation, presets) {
        switch (typeof animation === "undefined" ? "undefined" : _typeof(animation)) {
          case "boolean": {
            return presets[animation ? defaultPreset : disablePreset];
          }
          case "string": {
            var presetKeys = Object.keys(presets);
            if (presetKeys.indexOf(animation) === -1) {
              if (true) {
                invalidEnterLeavePreset({
                  value: animation,
                  acceptableValues: presetKeys.join(", "),
                  defaultValue: defaultPreset
                });
              }
              return presets[defaultPreset];
            }
            return presets[animation];
          }
          default: {
            return animation;
          }
        }
      };
      FlipMovePropConverter.prototype.render = function render() {
        return import_react49.default.createElement(ComposedComponent, this.convertProps(this.props));
      };
      return FlipMovePropConverter;
    }(import_react49.Component), _class.defaultProps = {
      easing: "ease-in-out",
      duration: 350,
      delay: 0,
      staggerDurationBy: 0,
      staggerDelayBy: 0,
      typeName: "div",
      enterAnimation: defaultPreset,
      leaveAnimation: defaultPreset,
      disableAllAnimations: false,
      getPosition: function getPosition(node) {
        return node.getBoundingClientRect();
      },
      maintainContainerHeight: false,
      verticalAlignment: "top"
    }, _temp;
  }
  function applyStylesToDOMNode(_ref) {
    var domNode = _ref.domNode, styles = _ref.styles;
    Object.keys(styles).forEach(function(key) {
      domNode.style.setProperty(hyphenate(key), styles[key]);
    });
  }
  function whichTransitionEvent() {
    var transitions = {
      transition: "transitionend",
      "-o-transition": "oTransitionEnd",
      "-moz-transition": "transitionend",
      "-webkit-transition": "webkitTransitionEnd"
    };
    if (typeof document === "undefined") return "";
    var el = document.createElement("fakeelement");
    var match = find(function(t7) {
      return el.style.getPropertyValue(t7) !== void 0;
    }, Object.keys(transitions));
    return match ? transitions[match] : "";
  }
  var getRelativeBoundingBox = function getRelativeBoundingBox2(_ref2) {
    var childDomNode = _ref2.childDomNode, parentDomNode = _ref2.parentDomNode, getPosition = _ref2.getPosition;
    var parentBox = getPosition(parentDomNode);
    var _getPosition = getPosition(childDomNode), top2 = _getPosition.top, left2 = _getPosition.left, right2 = _getPosition.right, bottom2 = _getPosition.bottom, width = _getPosition.width, height = _getPosition.height;
    return {
      top: top2 - parentBox.top,
      left: left2 - parentBox.left,
      right: parentBox.right - right2,
      bottom: parentBox.bottom - bottom2,
      width,
      height
    };
  };
  var getPositionDelta = function getPositionDelta2(_ref3) {
    var childDomNode = _ref3.childDomNode, childBoundingBox = _ref3.childBoundingBox, parentBoundingBox = _ref3.parentBoundingBox, getPosition = _ref3.getPosition;
    var defaultBox = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      height: 0,
      width: 0
    };
    var oldRelativeBox = childBoundingBox || defaultBox;
    var parentBox = parentBoundingBox || defaultBox;
    var newAbsoluteBox = getPosition(childDomNode);
    var newRelativeBox = {
      top: newAbsoluteBox.top - parentBox.top,
      left: newAbsoluteBox.left - parentBox.left
    };
    return [oldRelativeBox.left - newRelativeBox.left, oldRelativeBox.top - newRelativeBox.top];
  };
  var removeNodeFromDOMFlow = function removeNodeFromDOMFlow2(childData, verticalAlignment) {
    var domNode = childData.domNode, boundingBox = childData.boundingBox;
    if (!domNode || !boundingBox) {
      return;
    }
    var computed = window.getComputedStyle(domNode);
    var marginAttrs = ["margin-top", "margin-left", "margin-right"];
    var margins = marginAttrs.reduce(function(acc, margin) {
      var _babelHelpers$extends;
      var propertyVal = computed.getPropertyValue(margin);
      return _extends({}, acc, (_babelHelpers$extends = {}, _babelHelpers$extends[margin] = Number(propertyVal.replace("px", "")), _babelHelpers$extends));
    }, {});
    var topOffset = verticalAlignment === "bottom" ? boundingBox.top - boundingBox.height : boundingBox.top;
    var styles = {
      position: "absolute",
      top: topOffset - margins["margin-top"] + "px",
      left: boundingBox.left - margins["margin-left"] + "px",
      right: boundingBox.right - margins["margin-right"] + "px"
    };
    applyStylesToDOMNode({ domNode, styles });
  };
  var updateHeightPlaceholder = function updateHeightPlaceholder2(_ref4) {
    var domNode = _ref4.domNode, parentData = _ref4.parentData, getPosition = _ref4.getPosition;
    var parentDomNode = parentData.domNode;
    var parentBoundingBox = parentData.boundingBox;
    if (!parentDomNode || !parentBoundingBox) {
      return;
    }
    applyStylesToDOMNode({ domNode, styles: { height: "0" } });
    var originalParentHeight = parentBoundingBox.height;
    var collapsedParentHeight = getPosition(parentDomNode).height;
    var reductionInHeight = originalParentHeight - collapsedParentHeight;
    var styles = {
      height: reductionInHeight > 0 ? reductionInHeight + "px" : "0"
    };
    applyStylesToDOMNode({ domNode, styles });
  };
  var getNativeNode = function getNativeNode2(element) {
    if (typeof HTMLElement === "undefined") {
      return null;
    }
    if (element instanceof HTMLElement) {
      return element;
    }
    var foundNode = (0, import_react_dom2.findDOMNode)(element);
    if (foundNode && foundNode.nodeType === Node.TEXT_NODE) {
      return null;
    }
    return foundNode;
  };
  var createTransitionString = function createTransitionString2(index2, props) {
    var delay = props.delay, duration = props.duration;
    var staggerDurationBy = props.staggerDurationBy, staggerDelayBy = props.staggerDelayBy, easing = props.easing;
    delay += index2 * staggerDelayBy;
    duration += index2 * staggerDurationBy;
    var cssProperties = ["transform", "opacity"];
    return cssProperties.map(function(prop) {
      return prop + " " + duration + "ms " + easing + " " + delay + "ms";
    }).join(", ");
  };
  var transitionEnd = whichTransitionEvent();
  var noBrowserSupport = !transitionEnd;
  function getKey(childData) {
    return childData.key || "";
  }
  function getElementChildren(children) {
    return import_react49.Children.toArray(children);
  }
  var FlipMove$1 = function(_Component) {
    inherits(FlipMove, _Component);
    function FlipMove() {
      var _temp, _this, _ret;
      classCallCheck(this, FlipMove);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
        children: getElementChildren(
          // `this.props` ought to always be defined at this point, but a report
          // was made about it not being defined in IE10.
          // TODO: Test in IE10, to see if there's an underlying cause that can
          // be addressed.
          _this.props ? _this.props.children : []
        ).map(function(element) {
          return _extends({}, element, {
            element,
            appearing: true
          });
        })
      }, _this.childrenData = {}, _this.parentData = {
        domNode: null,
        boundingBox: null
      }, _this.heightPlaceholderData = {
        domNode: null
      }, _this.remainingAnimations = 0, _this.childrenToAnimate = [], _this.findDOMContainer = function() {
        var domNode = import_react_dom2.default.findDOMNode(_this);
        var parentNode = domNode && domNode.parentNode;
        if (!parentNode || !(parentNode instanceof HTMLElement)) {
          return;
        }
        if (window.getComputedStyle(parentNode).position === "static") {
          parentNode.style.position = "relative";
          parentNodePositionStatic();
        }
        _this.parentData.domNode = parentNode;
      }, _this.runAnimation = function() {
        var dynamicChildren = _this.state.children.filter(_this.doesChildNeedToBeAnimated);
        var childrenInitialStyles = dynamicChildren.map(function(child) {
          return _this.computeInitialStyles(child);
        });
        dynamicChildren.forEach(function(child, index2) {
          _this.remainingAnimations += 1;
          _this.childrenToAnimate.push(getKey(child));
          _this.animateChild(child, index2, childrenInitialStyles[index2]);
        });
        if (typeof _this.props.onStartAll === "function") {
          _this.callChildrenHook(_this.props.onStartAll);
        }
      }, _this.doesChildNeedToBeAnimated = function(child) {
        if (!getKey(child)) {
          return false;
        }
        var childData = _this.getChildData(getKey(child));
        var childDomNode = childData.domNode;
        var childBoundingBox = childData.boundingBox;
        var parentBoundingBox = _this.parentData.boundingBox;
        if (!childDomNode) {
          return false;
        }
        var _this$props = _this.props, appearAnimation = _this$props.appearAnimation, enterAnimation = _this$props.enterAnimation, leaveAnimation = _this$props.leaveAnimation, getPosition = _this$props.getPosition;
        var isAppearingWithAnimation = child.appearing && appearAnimation;
        var isEnteringWithAnimation = child.entering && enterAnimation;
        var isLeavingWithAnimation = child.leaving && leaveAnimation;
        if (isAppearingWithAnimation || isEnteringWithAnimation || isLeavingWithAnimation) {
          return true;
        }
        var _getPositionDelta = getPositionDelta({
          childDomNode,
          childBoundingBox,
          parentBoundingBox,
          getPosition
        }), dX = _getPositionDelta[0], dY = _getPositionDelta[1];
        return dX !== 0 || dY !== 0;
      }, _temp), possibleConstructorReturn(_this, _ret);
    }
    FlipMove.prototype.componentDidMount = function componentDidMount() {
      if (this.props.typeName === null) {
        this.findDOMContainer();
      }
      var shouldTriggerFLIP = this.props.appearAnimation && !this.isAnimationDisabled(this.props);
      if (shouldTriggerFLIP) {
        this.prepForAnimation();
        this.runAnimation();
      }
    };
    FlipMove.prototype.componentDidUpdate = function componentDidUpdate(previousProps) {
      if (this.props.typeName === null) {
        this.findDOMContainer();
      }
      var oldChildrenKeys = getElementChildren(this.props.children).map(function(d5) {
        return d5.key;
      });
      var nextChildrenKeys = getElementChildren(previousProps.children).map(function(d5) {
        return d5.key;
      });
      var shouldTriggerFLIP = !arraysEqual(oldChildrenKeys, nextChildrenKeys) && !this.isAnimationDisabled(this.props);
      if (shouldTriggerFLIP) {
        this.prepForAnimation();
        this.runAnimation();
      }
    };
    FlipMove.prototype.calculateNextSetOfChildren = function calculateNextSetOfChildren(nextChildren) {
      var _this2 = this;
      var updatedChildren = nextChildren.map(function(nextChild) {
        var child = _this2.findChildByKey(nextChild.key);
        var isEntering = !child || child.leaving;
        return _extends({}, nextChild, { element: nextChild, entering: isEntering });
      });
      var numOfChildrenLeaving = 0;
      this.state.children.forEach(function(child, index2) {
        var isLeaving = !find(function(_ref) {
          var key = _ref.key;
          return key === getKey(child);
        }, nextChildren);
        if (!isLeaving || !_this2.props.leaveAnimation) return;
        var nextChild = _extends({}, child, { leaving: true });
        var nextChildIndex = index2 + numOfChildrenLeaving;
        updatedChildren.splice(nextChildIndex, 0, nextChild);
        numOfChildrenLeaving += 1;
      });
      return updatedChildren;
    };
    FlipMove.prototype.prepForAnimation = function prepForAnimation() {
      var _this3 = this;
      var _props = this.props, leaveAnimation = _props.leaveAnimation, maintainContainerHeight = _props.maintainContainerHeight, getPosition = _props.getPosition;
      if (leaveAnimation) {
        var leavingChildren = this.state.children.filter(function(child) {
          return child.leaving;
        });
        leavingChildren.forEach(function(leavingChild) {
          var childData = _this3.getChildData(getKey(leavingChild));
          if (!_this3.isAnimationDisabled(_this3.props) && childData.domNode && childData.domNode.disabled) {
            childIsDisabled();
          }
          if (childData.boundingBox) {
            removeNodeFromDOMFlow(childData, _this3.props.verticalAlignment);
          }
        });
        if (maintainContainerHeight && this.heightPlaceholderData.domNode) {
          updateHeightPlaceholder({
            domNode: this.heightPlaceholderData.domNode,
            parentData: this.parentData,
            getPosition
          });
        }
      }
      this.state.children.forEach(function(child) {
        var _getChildData = _this3.getChildData(getKey(child)), domNode = _getChildData.domNode;
        if (!domNode) {
          return;
        }
        if (!child.entering && !child.leaving) {
          applyStylesToDOMNode({
            domNode,
            styles: {
              transition: ""
            }
          });
        }
      });
    };
    FlipMove.prototype.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
      this.updateBoundingBoxCaches();
      var nextChildren = getElementChildren(nextProps.children);
      this.setState({
        children: this.isAnimationDisabled(nextProps) ? nextChildren.map(function(element) {
          return _extends({}, element, { element });
        }) : this.calculateNextSetOfChildren(nextChildren)
      });
    };
    FlipMove.prototype.animateChild = function animateChild(child, index2, childInitialStyles) {
      var _this4 = this;
      var _getChildData2 = this.getChildData(getKey(child)), domNode = _getChildData2.domNode;
      if (!domNode) {
        return;
      }
      applyStylesToDOMNode({
        domNode,
        styles: childInitialStyles
      });
      if (this.props.onStart) this.props.onStart(child, domNode);
      requestAnimationFrame(function() {
        requestAnimationFrame(function() {
          var styles = {
            transition: createTransitionString(index2, _this4.props),
            transform: "",
            opacity: ""
          };
          if (child.appearing && _this4.props.appearAnimation) {
            styles = _extends({}, styles, _this4.props.appearAnimation.to);
          } else if (child.entering && _this4.props.enterAnimation) {
            styles = _extends({}, styles, _this4.props.enterAnimation.to);
          } else if (child.leaving && _this4.props.leaveAnimation) {
            styles = _extends({}, styles, _this4.props.leaveAnimation.to);
          }
          applyStylesToDOMNode({ domNode, styles });
        });
      });
      this.bindTransitionEndHandler(child);
    };
    FlipMove.prototype.bindTransitionEndHandler = function bindTransitionEndHandler(child) {
      var _this5 = this;
      var _getChildData3 = this.getChildData(getKey(child)), domNode = _getChildData3.domNode;
      if (!domNode) {
        return;
      }
      var transitionEndHandler = function transitionEndHandler2(ev) {
        if (ev.target !== domNode) return;
        domNode.style.transition = "";
        _this5.triggerFinishHooks(child, domNode);
        domNode.removeEventListener(transitionEnd, transitionEndHandler2);
        if (child.leaving) {
          _this5.removeChildData(getKey(child));
        }
      };
      domNode.addEventListener(transitionEnd, transitionEndHandler);
    };
    FlipMove.prototype.triggerFinishHooks = function triggerFinishHooks(child, domNode) {
      var _this6 = this;
      if (this.props.onFinish) this.props.onFinish(child, domNode);
      this.remainingAnimations -= 1;
      if (this.remainingAnimations === 0) {
        var nextChildren = this.state.children.filter(function(_ref2) {
          var leaving = _ref2.leaving;
          return !leaving;
        }).map(function(item) {
          return _extends({}, item, {
            // fix for Flow
            element: item.element,
            appearing: false,
            entering: false
          });
        });
        this.setState({ children: nextChildren }, function() {
          if (typeof _this6.props.onFinishAll === "function") {
            _this6.callChildrenHook(_this6.props.onFinishAll);
          }
          _this6.childrenToAnimate = [];
        });
        if (this.heightPlaceholderData.domNode) {
          this.heightPlaceholderData.domNode.style.height = "0";
        }
      }
    };
    FlipMove.prototype.callChildrenHook = function callChildrenHook(hook) {
      var _this7 = this;
      var elements2 = [];
      var domNodes = [];
      this.childrenToAnimate.forEach(function(childKey) {
        var child = _this7.findChildByKey(childKey);
        if (!child) {
          return;
        }
        elements2.push(child);
        if (_this7.hasChildData(childKey)) {
          domNodes.push(_this7.getChildData(childKey).domNode);
        }
      });
      hook(elements2, domNodes);
    };
    FlipMove.prototype.updateBoundingBoxCaches = function updateBoundingBoxCaches() {
      var _this8 = this;
      var parentDomNode = this.parentData.domNode;
      if (!parentDomNode) {
        return;
      }
      this.parentData.boundingBox = this.props.getPosition(parentDomNode);
      var childrenBoundingBoxes = [];
      this.state.children.forEach(function(child) {
        var childKey = getKey(child);
        if (!childKey) {
          childrenBoundingBoxes.push(null);
          return;
        }
        if (!_this8.hasChildData(childKey)) {
          childrenBoundingBoxes.push(null);
          return;
        }
        var childData = _this8.getChildData(childKey);
        if (!childData.domNode || !child) {
          childrenBoundingBoxes.push(null);
          return;
        }
        childrenBoundingBoxes.push(getRelativeBoundingBox({
          childDomNode: childData.domNode,
          parentDomNode,
          getPosition: _this8.props.getPosition
        }));
      });
      this.state.children.forEach(function(child, index2) {
        var childKey = getKey(child);
        var childBoundingBox = childrenBoundingBoxes[index2];
        if (!childKey) {
          return;
        }
        _this8.setChildData(childKey, {
          boundingBox: childBoundingBox
        });
      });
    };
    FlipMove.prototype.computeInitialStyles = function computeInitialStyles(child) {
      if (child.appearing) {
        return this.props.appearAnimation ? this.props.appearAnimation.from : {};
      } else if (child.entering) {
        if (!this.props.enterAnimation) {
          return {};
        }
        return _extends({
          position: "",
          top: "",
          left: "",
          right: "",
          bottom: ""
        }, this.props.enterAnimation.from);
      } else if (child.leaving) {
        return this.props.leaveAnimation ? this.props.leaveAnimation.from : {};
      }
      var childData = this.getChildData(getKey(child));
      var childDomNode = childData.domNode;
      var childBoundingBox = childData.boundingBox;
      var parentBoundingBox = this.parentData.boundingBox;
      if (!childDomNode) {
        return {};
      }
      var _getPositionDelta2 = getPositionDelta({
        childDomNode,
        childBoundingBox,
        parentBoundingBox,
        getPosition: this.props.getPosition
      }), dX = _getPositionDelta2[0], dY = _getPositionDelta2[1];
      return {
        transform: "translate(" + dX + "px, " + dY + "px)"
      };
    };
    FlipMove.prototype.isAnimationDisabled = function isAnimationDisabled(props) {
      return noBrowserSupport || props.disableAllAnimations || props.duration === 0 && props.delay === 0 && props.staggerDurationBy === 0 && props.staggerDelayBy === 0;
    };
    FlipMove.prototype.findChildByKey = function findChildByKey(key) {
      return find(function(child) {
        return getKey(child) === key;
      }, this.state.children);
    };
    FlipMove.prototype.hasChildData = function hasChildData(key) {
      return Object.prototype.hasOwnProperty.call(this.childrenData, key);
    };
    FlipMove.prototype.getChildData = function getChildData(key) {
      return this.hasChildData(key) ? this.childrenData[key] : {};
    };
    FlipMove.prototype.setChildData = function setChildData(key, data) {
      this.childrenData[key] = _extends({}, this.getChildData(key), data);
    };
    FlipMove.prototype.removeChildData = function removeChildData(key) {
      delete this.childrenData[key];
      this.setState(function(prevState) {
        return _extends({}, prevState, {
          children: prevState.children.filter(function(child) {
            return child.element.key !== key;
          })
        });
      });
    };
    FlipMove.prototype.createHeightPlaceholder = function createHeightPlaceholder() {
      var _this9 = this;
      var typeName = this.props.typeName;
      var isContainerAList = typeName === "ul" || typeName === "ol";
      var placeholderType = isContainerAList ? "li" : "div";
      return (0, import_react49.createElement)(placeholderType, {
        key: "height-placeholder",
        ref: function ref(domNode) {
          _this9.heightPlaceholderData.domNode = domNode;
        },
        style: { visibility: "hidden", height: 0 }
      });
    };
    FlipMove.prototype.childrenWithRefs = function childrenWithRefs() {
      var _this10 = this;
      return this.state.children.map(function(child) {
        return (0, import_react49.cloneElement)(child.element, {
          ref: function ref(element) {
            if (!element) {
              return;
            }
            var domNode = getNativeNode(element);
            _this10.setChildData(getKey(child), { domNode });
          }
        });
      });
    };
    FlipMove.prototype.render = function render() {
      var _this11 = this;
      var _props2 = this.props, typeName = _props2.typeName, delegated = _props2.delegated, leaveAnimation = _props2.leaveAnimation, maintainContainerHeight = _props2.maintainContainerHeight;
      var children = this.childrenWithRefs();
      if (leaveAnimation && maintainContainerHeight) {
        children.push(this.createHeightPlaceholder());
      }
      if (!typeName) return children;
      var props = _extends({}, delegated, {
        children,
        ref: function ref(node) {
          _this11.parentData.domNode = node;
        }
      });
      return (0, import_react49.createElement)(typeName, props);
    };
    return FlipMove;
  }(import_react49.Component);
  var enhancedFlipMove = /* @__PURE__ */ propConverter(FlipMove$1);
  var react_flip_move_es_default = enhancedFlipMove;

  // js/dashboard/stats/reports/list.js
  var import_classnames9 = __toESM(require_classnames());
  var MAX_ITEMS = 9;
  var MIN_HEIGHT = 380;
  var ROW_HEIGHT = 32;
  var ROW_GAP_HEIGHT = 4;
  var DATA_CONTAINER_HEIGHT = (ROW_HEIGHT + ROW_GAP_HEIGHT) * (MAX_ITEMS - 1) + ROW_HEIGHT;
  var COL_MIN_WIDTH = 70;
  function FilterLink({ to: to2, filterInfo, onClick, children, extraClass }) {
    const { query } = useQueryContext();
    const className = (0, import_classnames9.default)(`${extraClass}`, { "hover:underline": !!filterInfo });
    if (filterInfo) {
      const { prefix: prefix2, filter, labels } = filterInfo;
      const newFilters = replaceFilterByPrefix(query, prefix2, filter);
      const newLabels = cleanLabels(newFilters, query.labels, filter[1], labels);
      return /* @__PURE__ */ import_react50.default.createElement(Link, { to: to2, onClick, className, search: (search) => {
        return __spreadProps(__spreadValues({}, search), { filters: newFilters, labels: newLabels });
      } }, children);
    } else {
      return /* @__PURE__ */ import_react50.default.createElement("span", { className }, children);
    }
  }
  function ExternalLink({ item, externalLinkDest }) {
    const dest = externalLinkDest && externalLinkDest(item);
    if (dest) {
      return /* @__PURE__ */ import_react50.default.createElement(
        "a",
        {
          target: "_blank",
          rel: "noreferrer",
          href: dest,
          className: "w-4 h-4 hidden group-hover:block"
        },
        /* @__PURE__ */ import_react50.default.createElement("svg", { className: "inline w-full h-full ml-1 -mt-1 text-gray-600 dark:text-gray-400", fill: "currentColor", viewBox: "0 0 20 20" }, /* @__PURE__ */ import_react50.default.createElement("path", { d: "M11 3a1 1 0 100 2h2.586l-6.293 6.293a1 1 0 101.414 1.414L15 6.414V9a1 1 0 102 0V4a1 1 0 00-1-1h-5z" }), /* @__PURE__ */ import_react50.default.createElement("path", { d: "M5 5a2 2 0 00-2 2v8a2 2 0 002 2h8a2 2 0 002-2v-3a1 1 0 10-2 0v3H5V7h3a1 1 0 000-2H5z" }))
      );
    }
    return null;
  }
  function ListReport({ keyLabel, metrics, colMinWidth = COL_MIN_WIDTH, afterFetchData, detailsLinkProps, maybeHideDetails, onClick, color: color2, getFilterFor, renderIcon, externalLinkDest, fetchData }) {
    const { query } = useQueryContext();
    const [state, setState] = (0, import_react50.useState)({ loading: true, list: null });
    const [visible, setVisible] = (0, import_react50.useState)(false);
    const isRealtime = isRealTimeDashboard(query);
    const goalFilterApplied = hasGoalFilter(query);
    const getData = (0, import_react50.useCallback)(() => {
      if (!isRealtime) {
        setState({ loading: true, list: null });
      }
      fetchData().then((response) => {
        if (afterFetchData) {
          afterFetchData(response);
        }
        setState({ loading: false, list: response.results });
      });
    }, [keyLabel, query]);
    const onVisible = () => {
      setVisible(true);
    };
    (0, import_react50.useEffect)(() => {
      if (isRealtime) {
        setState({ loading: true, list: null });
      }
    }, [goalFilterApplied]);
    (0, import_react50.useEffect)(() => {
      if (visible) {
        if (isRealtime) {
          document.addEventListener("tick", getData);
        }
        getData();
      }
      return () => {
        document.removeEventListener("tick", getData);
      };
    }, [keyLabel, query, visible]);
    function getAvailableMetrics() {
      return metrics.filter((metric) => {
        return state.list.some((listItem) => listItem[metric.key] != null);
      });
    }
    function hiddenOnMobileClass(metric) {
      if (metric.meta.hiddenOnMobile) {
        return "hidden md:block";
      } else {
        return "";
      }
    }
    function renderReport() {
      if (state.list && state.list.length > 0) {
        return /* @__PURE__ */ import_react50.default.createElement("div", { className: "h-full flex flex-col" }, /* @__PURE__ */ import_react50.default.createElement("div", { style: { height: ROW_HEIGHT } }, renderReportHeader()), /* @__PURE__ */ import_react50.default.createElement("div", { style: { minHeight: DATA_CONTAINER_HEIGHT } }, renderReportBody()), maybeRenderDetailsLink());
      }
      return renderNoDataYet();
    }
    function renderReportHeader() {
      const metricLabels = getAvailableMetrics().map((metric) => {
        return /* @__PURE__ */ import_react50.default.createElement(
          "div",
          {
            key: metric.key,
            className: `${metric.key} text-right ${hiddenOnMobileClass(metric)}`,
            style: { minWidth: colMinWidth }
          },
          metric.renderLabel(query)
        );
      });
      return /* @__PURE__ */ import_react50.default.createElement("div", { className: "pt-3 w-full text-xs font-bold tracking-wide text-gray-500 flex items-center dark:text-gray-400" }, /* @__PURE__ */ import_react50.default.createElement("span", { className: "flex-grow truncate" }, keyLabel), metricLabels);
    }
    function renderReportBody() {
      return /* @__PURE__ */ import_react50.default.createElement(react_flip_move_es_default, { className: "flex-grow" }, state.list.slice(0, MAX_ITEMS).map(renderRow));
    }
    function renderRow(listItem) {
      return /* @__PURE__ */ import_react50.default.createElement("div", { key: listItem.name, style: { minHeight: ROW_HEIGHT } }, /* @__PURE__ */ import_react50.default.createElement("div", { className: "flex w-full", style: { marginTop: ROW_GAP_HEIGHT } }, renderBarFor(listItem), renderMetricValuesFor(listItem)));
    }
    function renderBarFor(listItem) {
      const lightBackground = color2 || "bg-green-50";
      const metricToPlot = metrics.find((metric) => metric.meta.plot).key;
      return /* @__PURE__ */ import_react50.default.createElement("div", { className: "flex-grow w-full overflow-hidden" }, /* @__PURE__ */ import_react50.default.createElement(
        Bar,
        {
          count: listItem[metricToPlot],
          all: state.list,
          bg: `${lightBackground} dark:bg-gray-500 dark:bg-opacity-15`,
          plot: metricToPlot
        },
        /* @__PURE__ */ import_react50.default.createElement("div", { className: "flex justify-start px-2 py-1.5 group text-sm dark:text-gray-300 relative z-9 break-all w-full" }, /* @__PURE__ */ import_react50.default.createElement(
          FilterLink,
          {
            filterInfo: getFilterFor(listItem),
            onClick,
            extraClass: "max-w-max w-full flex items-center md:overflow-hidden"
          },
          maybeRenderIconFor(listItem),
          /* @__PURE__ */ import_react50.default.createElement("span", { className: "w-full md:truncate" }, trimURL(listItem.name, colMinWidth))
        ), /* @__PURE__ */ import_react50.default.createElement(ExternalLink, { item: listItem, externalLinkDest }))
      ));
    }
    function maybeRenderIconFor(listItem) {
      if (renderIcon) {
        return renderIcon(listItem);
      }
    }
    function renderMetricValuesFor(listItem) {
      return getAvailableMetrics().map((metric) => {
        return /* @__PURE__ */ import_react50.default.createElement(
          "div",
          {
            key: `${listItem.name}__${metric.key}`,
            className: `text-right ${hiddenOnMobileClass(metric)}`,
            style: { width: colMinWidth, minWidth: colMinWidth }
          },
          /* @__PURE__ */ import_react50.default.createElement("span", { className: "font-medium text-sm dark:text-gray-200 text-right" }, metric.renderValue(listItem[metric.key]))
        );
      });
    }
    function renderLoading() {
      return /* @__PURE__ */ import_react50.default.createElement("div", { className: "w-full flex flex-col justify-center", style: { minHeight: `${MIN_HEIGHT}px` } }, /* @__PURE__ */ import_react50.default.createElement("div", { className: "mx-auto loading" }, /* @__PURE__ */ import_react50.default.createElement("div", null)));
    }
    function renderNoDataYet() {
      return /* @__PURE__ */ import_react50.default.createElement("div", { className: "w-full h-full flex flex-col justify-center", style: { minHeight: `${MIN_HEIGHT}px` } }, /* @__PURE__ */ import_react50.default.createElement("div", { className: "mx-auto font-medium text-gray-500 dark:text-gray-400" }, "No data yet"));
    }
    function maybeRenderDetailsLink() {
      const moreResultsAvailable = state.list.length >= MAX_ITEMS;
      const hideDetails = maybeHideDetails && !moreResultsAvailable;
      const showDetails = !!detailsLinkProps && !state.loading && !hideDetails;
      return showDetails && /* @__PURE__ */ import_react50.default.createElement(MoreLink, { className: "mt-2", linkProps: detailsLinkProps, list: state.list });
    }
    return /* @__PURE__ */ import_react50.default.createElement(LazyLoader, { onVisible }, /* @__PURE__ */ import_react50.default.createElement("div", { className: "w-full", style: { minHeight: `${MIN_HEIGHT}px` } }, state.loading && renderLoading(), !state.loading && /* @__PURE__ */ import_react50.default.createElement(FadeIn, { show: !state.loading, className: "h-full" }, renderReport())));
  }

  // js/dashboard/stats/reports/metrics.js
  var import_react51 = __toESM(require_react());
  function maybeRequire() {
    if (false) {
      return null;
    } else {
      return { default: null };
    }
  }
  var Money = maybeRequire().default;
  var Metric = class {
    constructor(props) {
      if (!props.key) {
        throw Error("Required field `key` is missing");
      }
      if (typeof props.renderLabel !== "function") {
        throw Error("Required field `renderLabel` should be a function");
      }
      if (typeof props.renderValue !== "function") {
        throw Error("Required field `renderValue` should be a function");
      }
      this.key = props.key;
      this.renderValue = props.renderValue;
      this.renderLabel = props.renderLabel;
      this.meta = props.meta || {};
    }
  };
  var createVisitors = (props) => {
    let renderValue;
    if (typeof props.renderValue === "function") {
      renderValue = props.renderValue;
    } else {
      renderValue = renderNumberWithTooltip;
    }
    let renderLabel;
    if (typeof props.renderLabel === "function") {
      renderLabel = props.renderLabel;
    } else {
      renderLabel = (query) => {
        const defaultLabel = props.defaultLabel || "Visitors";
        const realtimeLabel = props.realtimeLabel || "Current visitors";
        const goalFilterLabel = props.goalFilterLabel || "Conversions";
        if (query.period === "realtime") {
          return realtimeLabel;
        }
        if (query && hasGoalFilter(query)) {
          return goalFilterLabel;
        }
        return defaultLabel;
      };
    }
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "visitors", renderValue, renderLabel }));
  };
  var createConversionRate = (props) => {
    const renderValue = percentageFormatter;
    const renderLabel = (_query) => "CR";
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "conversion_rate", renderLabel, renderValue }));
  };
  var createPercentage = (props) => {
    const renderValue = (value) => value;
    const renderLabel = (_query) => "%";
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "percentage", renderLabel, renderValue }));
  };
  var createEvents = (props) => {
    const renderValue = typeof props.renderValue === "function" ? props.renderValue : renderNumberWithTooltip;
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "events", renderValue }));
  };
  var createTotalRevenue = (props) => {
    const renderValue = (value) => /* @__PURE__ */ import_react51.default.createElement(Money, { formatted: value });
    const renderLabel = (_query) => "Revenue";
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "total_revenue", renderValue, renderLabel }));
  };
  var createAverageRevenue = (props) => {
    const renderValue = (value) => /* @__PURE__ */ import_react51.default.createElement(Money, { formatted: value });
    const renderLabel = (_query) => "Average";
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "average_revenue", renderValue, renderLabel }));
  };
  var createTotalVisitors = (props) => {
    const renderValue = renderNumberWithTooltip;
    const renderLabel = (_query) => "Total Visitors";
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "total_visitors", renderValue, renderLabel }));
  };
  var createVisits = (props) => {
    const renderValue = renderNumberWithTooltip;
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "visits", renderValue }));
  };
  var createVisitDuration = (props) => {
    const renderValue = durationFormatter;
    const renderLabel = (_query) => "Visit Duration";
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "visit_duration", renderValue, renderLabel }));
  };
  var createBounceRate = (props) => {
    const renderValue = (value) => `${value}%`;
    const renderLabel = (_query) => "Bounce Rate";
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "bounce_rate", renderValue, renderLabel }));
  };
  var createPageviews = (props) => {
    const renderValue = renderNumberWithTooltip;
    const renderLabel = (_query) => "Pageviews";
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "pageviews", renderValue, renderLabel }));
  };
  var createTimeOnPage = (props) => {
    const renderValue = durationFormatter;
    const renderLabel = (_query) => "Time on Page";
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "time_on_page", renderValue, renderLabel }));
  };
  var createExitRate = (props) => {
    const renderValue = percentageFormatter;
    const renderLabel = (_query) => "Exit Rate";
    return new Metric(__spreadProps(__spreadValues({}, props), { key: "exit_rate", renderValue, renderLabel }));
  };
  function renderNumberWithTooltip(value) {
    return /* @__PURE__ */ import_react51.default.createElement("span", { tooltip: value }, numberFormatter(value));
  }

  // js/dashboard/stats/sources/source-list.js
  var import_classnames10 = __toESM(require_classnames());

  // js/dashboard/stats/imported-query-unsupported-warning.js
  var import_react52 = __toESM(require_react());

  // node_modules/@heroicons/react/24/outline/esm/ExclamationCircleIcon.js
  var React48 = __toESM(require_react(), 1);
  function ExclamationCircleIcon(_a9, svgRef) {
    var _b2 = _a9, {
      title,
      titleId
    } = _b2, props = __objRest(_b2, [
      "title",
      "titleId"
    ]);
    return /* @__PURE__ */ React48.createElement("svg", Object.assign({
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      strokeWidth: 1.5,
      stroke: "currentColor",
      "aria-hidden": "true",
      ref: svgRef,
      "aria-labelledby": titleId
    }, props), title ? /* @__PURE__ */ React48.createElement("title", {
      id: titleId
    }, title) : null, /* @__PURE__ */ React48.createElement("path", {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      d: "M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z"
    }));
  }
  var ForwardRef9 = React48.forwardRef(ExclamationCircleIcon);
  var ExclamationCircleIcon_default = ForwardRef9;

  // js/dashboard/stats/imported-query-unsupported-warning.js
  function ImportedQueryUnsupportedWarning({ loading, skipImportedReason, altCondition, message }) {
    const { query } = useQueryContext();
    const tooltipMessage = message || "Imported data is excluded due to applied filters";
    const show = query && query.with_imported && skipImportedReason === "unsupported_query" && query.period !== "realtime";
    if (show || altCondition) {
      return /* @__PURE__ */ import_react52.default.createElement(FadeIn, { show: !loading, className: "h-6" }, /* @__PURE__ */ import_react52.default.createElement("span", { tooltip: tooltipMessage }, /* @__PURE__ */ import_react52.default.createElement(ExclamationCircleIcon_default, { className: "w-6 h-6 dark:text-gray-100" })));
    } else {
      return null;
    }
  }

  // js/dashboard/stats/sources/source-list.js
  var UTM_TAGS = {
    utm_medium: { label: "UTM Medium", shortLabel: "UTM Medium", endpoint: "/utm_mediums" },
    utm_source: { label: "UTM Source", shortLabel: "UTM Source", endpoint: "/utm_sources" },
    utm_campaign: { label: "UTM Campaign", shortLabel: "UTM Campai", endpoint: "/utm_campaigns" },
    utm_content: { label: "UTM Content", shortLabel: "UTM Conten", endpoint: "/utm_contents" },
    utm_term: { label: "UTM Term", shortLabel: "UTM Term", endpoint: "/utm_terms" }
  };
  function AllSources({ afterFetchData }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    function fetchData() {
      return get(apiPath(site, "/sources"), query, { limit: 9 });
    }
    function getFilterFor(listItem) {
      return {
        prefix: "source",
        filter: ["is", "source", [listItem["name"]]]
      };
    }
    function renderIcon(listItem) {
      return /* @__PURE__ */ import_react53.default.createElement(
        "img",
        {
          src: `/favicon/sources/${encodeURIComponent(listItem.name)}`,
          className: "w-4 h-4 mr-2"
        }
      );
    }
    function chooseMetrics() {
      return [
        createVisitors({ meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react53.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        keyLabel: "Source",
        metrics: chooseMetrics(),
        detailsLinkProps: { to: sourcesRoute.to, search: (search) => search },
        renderIcon,
        color: "bg-blue-50"
      }
    );
  }
  function UTMSources({ tab, afterFetchData }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const utmTag = UTM_TAGS[tab];
    const route = {
      utm_medium: utmMediumsRoute,
      utm_source: utmSourcesRoute,
      utm_campaign: utmCampaignsRoute,
      utm_content: utmContentsRoute,
      utm_term: utmTermsRoute
    }[tab];
    function fetchData() {
      return get(apiPath(site, utmTag.endpoint), query, { limit: 9 });
    }
    function getFilterFor(listItem) {
      return {
        prefix: tab,
        filter: ["is", tab, [listItem["name"]]]
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react53.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        keyLabel: utmTag.label,
        metrics: chooseMetrics(),
        detailsLinkProps: { to: route == null ? void 0 : route.to, search: (search) => search },
        color: "bg-blue-50"
      }
    );
  }
  function SourceList() {
    const site = useSiteContext();
    const { query } = useQueryContext();
    const tabKey = "sourceTab__" + site.domain;
    const storedTab = getItem(tabKey);
    const [currentTab, setCurrentTab] = (0, import_react53.useState)(storedTab || "all");
    const [loading, setLoading] = (0, import_react53.useState)(true);
    const [skipImportedReason, setSkipImportedReason] = (0, import_react53.useState)(null);
    (0, import_react53.useEffect)(() => setLoading(true), [query, currentTab]);
    function setTab(tab) {
      return () => {
        setItem(tabKey, tab);
        setCurrentTab(tab);
      };
    }
    function renderTabs() {
      const activeClass = "inline-block h-5 text-indigo-700 dark:text-indigo-500 font-bold active-prop-heading truncate text-left";
      const defaultClass = "hover:text-indigo-600 cursor-pointer truncate text-left";
      const dropdownOptions = Object.keys(UTM_TAGS);
      let buttonText = UTM_TAGS[currentTab] ? UTM_TAGS[currentTab].label : "Campaigns";
      return /* @__PURE__ */ import_react53.default.createElement("div", { className: "flex text-xs font-medium text-gray-500 dark:text-gray-400 space-x-2" }, /* @__PURE__ */ import_react53.default.createElement("div", { className: currentTab === "all" ? activeClass : defaultClass, onClick: setTab("all") }, "All"), /* @__PURE__ */ import_react53.default.createElement(Ze, { as: "div", className: "relative inline-block text-left" }, /* @__PURE__ */ import_react53.default.createElement("div", null, /* @__PURE__ */ import_react53.default.createElement(Ze.Button, { className: "inline-flex justify-between focus:outline-none" }, /* @__PURE__ */ import_react53.default.createElement("span", { className: currentTab.startsWith("utm_") ? activeClass : defaultClass }, buttonText), /* @__PURE__ */ import_react53.default.createElement(ChevronDownIcon_default, { className: "-mr-1 ml-1 h-4 w-4", "aria-hidden": "true" }))), /* @__PURE__ */ import_react53.default.createElement(
        Ke,
        {
          as: import_react53.Fragment,
          enter: "transition ease-out duration-100",
          enterFrom: "opacity-0 scale-95",
          enterTo: "opacity-100 scale-100",
          leave: "transition ease-in duration-75",
          leaveFrom: "opacity-100 scale-100",
          leaveTo: "opacity-0 scale-95"
        },
        /* @__PURE__ */ import_react53.default.createElement(Ze.Items, { className: "text-left origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5 focus:outline-none z-10" }, /* @__PURE__ */ import_react53.default.createElement("div", { className: "py-1" }, dropdownOptions.map((option) => {
          return /* @__PURE__ */ import_react53.default.createElement(Ze.Item, { key: option }, ({ active }) => /* @__PURE__ */ import_react53.default.createElement(
            "span",
            {
              onClick: setTab(option),
              className: (0, import_classnames10.default)(
                active ? "bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-200 cursor-pointer" : "text-gray-700 dark:text-gray-200",
                "block px-4 py-2 text-sm",
                currentTab === option ? "font-bold" : ""
              )
            },
            UTM_TAGS[option].label
          ));
        })))
      )));
    }
    function renderContent() {
      if (currentTab === "all") {
        return /* @__PURE__ */ import_react53.default.createElement(AllSources, { afterFetchData });
      } else {
        return /* @__PURE__ */ import_react53.default.createElement(UTMSources, { tab: currentTab, afterFetchData });
      }
    }
    function afterFetchData(apiResponse) {
      setLoading(false);
      setSkipImportedReason(apiResponse.skip_imported_reason);
    }
    return /* @__PURE__ */ import_react53.default.createElement("div", null, /* @__PURE__ */ import_react53.default.createElement("div", { className: "w-full flex justify-between" }, /* @__PURE__ */ import_react53.default.createElement("div", { className: "flex gap-x-1" }, /* @__PURE__ */ import_react53.default.createElement("h3", { className: "font-bold dark:text-gray-100" }, "Top Sources"), /* @__PURE__ */ import_react53.default.createElement(ImportedQueryUnsupportedWarning, { loading, skipImportedReason })), renderTabs()), renderContent());
  }

  // js/dashboard/stats/sources/referrer-list.js
  var import_react55 = __toESM(require_react());
  function Referrers({ source }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const [skipImportedReason, setSkipImportedReason] = (0, import_react55.useState)(null);
    const [loading, setLoading] = (0, import_react55.useState)(true);
    (0, import_react55.useEffect)(() => setLoading(true), [query]);
    function fetchReferrers() {
      return get(apiPath(site, `/referrers/${encodeURIComponent(source)}`), query, { limit: 9 });
    }
    function afterFetchReferrers(apiResponse) {
      setLoading(false);
      setSkipImportedReason(apiResponse.skip_imported_reason);
    }
    function externalLinkDest(referrer) {
      if (referrer.name === "Direct / None") {
        return null;
      }
      return `https://${referrer.name}`;
    }
    function getFilterFor(referrer) {
      if (referrer.name === "Direct / None") {
        return null;
      }
      return {
        prefix: "referrer",
        filter: ["is", "referrer", [referrer.name]]
      };
    }
    function renderIcon(listItem) {
      return /* @__PURE__ */ import_react55.default.createElement(
        "img",
        {
          src: `/favicon/sources/${encodeURIComponent(listItem.name)}`,
          referrerPolicy: "no-referrer",
          className: "inline w-4 h-4 mr-2 -mt-px align-middle"
        }
      );
    }
    function chooseMetrics() {
      return [
        createVisitors({ meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react55.default.createElement("div", { className: "flex flex-col flex-grow" }, /* @__PURE__ */ import_react55.default.createElement("div", { className: "flex gap-x-1" }, /* @__PURE__ */ import_react55.default.createElement("h3", { className: "font-bold dark:text-gray-100" }, "Top Referrers"), /* @__PURE__ */ import_react55.default.createElement(ImportedQueryUnsupportedWarning, { loading, skipImportedReason })), /* @__PURE__ */ import_react55.default.createElement(
      ListReport,
      {
        fetchData: fetchReferrers,
        afterFetchData: afterFetchReferrers,
        getFilterFor,
        keyLabel: "Referrer",
        metrics: chooseMetrics(),
        detailsLinkProps: { to: referrersDrilldownRoute.to, params: { referrer: source }, search: (search) => search },
        externalLinkDest,
        renderIcon,
        color: "bg-blue-50"
      }
    ));
  }

  // js/dashboard/stats/sources/index.js
  function Sources() {
    const { query } = useQueryContext();
    const site = useSiteContext();
    if (isFilteringOnFixedValue(query, "source", "Google")) {
      return /* @__PURE__ */ import_react56.default.createElement(SearchTerms, { query, site });
    } else if (isFilteringOnFixedValue(query, "source")) {
      const [[_operation, _filterKey, clauses]] = getFiltersByKeyPrefix(query, "source");
      return /* @__PURE__ */ import_react56.default.createElement(Referrers, { source: clauses[0] });
    } else {
      return /* @__PURE__ */ import_react56.default.createElement(SourceList, null);
    }
  }

  // js/dashboard/stats/pages/index.js
  var import_react57 = __toESM(require_react());
  function EntryPages({ afterFetchData }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    function fetchData() {
      return get(apiPath(site, "/entry-pages"), query, { limit: 9 });
    }
    function externalLinkDest(page) {
      return externalLinkForPage(site.domain, page.name);
    }
    function getFilterFor(listItem) {
      return {
        prefix: "entry_page",
        filter: ["is", "entry_page", [listItem["name"]]]
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ defaultLabel: "Unique Entrances", meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react57.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        keyLabel: "Entry page",
        metrics: chooseMetrics(),
        detailsLinkProps: { to: entryPagesRoute.to, search: (search) => search },
        externalLinkDest,
        color: "bg-orange-50"
      }
    );
  }
  function ExitPages({ afterFetchData }) {
    const site = useSiteContext();
    const { query } = useQueryContext();
    function fetchData() {
      return get(apiPath(site, "/exit-pages"), query, { limit: 9 });
    }
    function externalLinkDest(page) {
      return externalLinkForPage(site.domain, page.name);
    }
    function getFilterFor(listItem) {
      return {
        prefix: "exit_page",
        filter: ["is", "exit_page", [listItem["name"]]]
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ defaultLabel: "Unique Exits", meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react57.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        keyLabel: "Exit page",
        metrics: chooseMetrics(),
        detailsLinkProps: { to: exitPagesRoute.to, search: (search) => search },
        externalLinkDest,
        color: "bg-orange-50"
      }
    );
  }
  function TopPages({ afterFetchData }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    function fetchData() {
      return get(apiPath(site, "/pages"), query, { limit: 9 });
    }
    function externalLinkDest(page) {
      return externalLinkForPage(site.domain, page.name);
    }
    function getFilterFor(listItem) {
      return {
        prefix: "page",
        filter: ["is", "page", [listItem["name"]]]
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react57.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        keyLabel: "Page",
        metrics: chooseMetrics(),
        detailsLinkProps: { to: topPagesRoute.to, search: (search) => search },
        externalLinkDest,
        color: "bg-orange-50"
      }
    );
  }
  var labelFor = {
    "pages": "Top Pages",
    "entry-pages": "Entry Pages",
    "exit-pages": "Exit Pages"
  };
  function Pages() {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const tabKey = `pageTab__${site.domain}`;
    const storedTab = getItem(tabKey);
    const [mode, setMode] = (0, import_react57.useState)(storedTab || "pages");
    const [loading, setLoading] = (0, import_react57.useState)(true);
    const [skipImportedReason, setSkipImportedReason] = (0, import_react57.useState)(null);
    function switchTab(mode2) {
      setItem(tabKey, mode2);
      setMode(mode2);
    }
    function afterFetchData(apiResponse) {
      setLoading(false);
      setSkipImportedReason(apiResponse.skip_imported_reason);
    }
    (0, import_react57.useEffect)(() => setLoading(true), [query, mode]);
    function renderContent() {
      switch (mode) {
        case "entry-pages":
          return /* @__PURE__ */ import_react57.default.createElement(EntryPages, { afterFetchData });
        case "exit-pages":
          return /* @__PURE__ */ import_react57.default.createElement(ExitPages, { afterFetchData });
        case "pages":
        default:
          return /* @__PURE__ */ import_react57.default.createElement(TopPages, { afterFetchData });
      }
    }
    function renderPill(name, pill) {
      const isActive = mode === pill;
      if (isActive) {
        return /* @__PURE__ */ import_react57.default.createElement(
          "button",
          {
            className: "inline-block h-5 text-indigo-700 dark:text-indigo-500 font-bold active-prop-heading"
          },
          name
        );
      }
      return /* @__PURE__ */ import_react57.default.createElement(
        "button",
        {
          className: "hover:text-indigo-600 cursor-pointer",
          onClick: () => switchTab(pill)
        },
        name
      );
    }
    return /* @__PURE__ */ import_react57.default.createElement("div", null, /* @__PURE__ */ import_react57.default.createElement("div", { className: "w-full flex justify-between" }, /* @__PURE__ */ import_react57.default.createElement("div", { className: "flex gap-x-1" }, /* @__PURE__ */ import_react57.default.createElement("h3", { className: "font-bold dark:text-gray-100" }, labelFor[mode] || "Page Visits"), /* @__PURE__ */ import_react57.default.createElement(ImportedQueryUnsupportedWarning, { loading, skipImportedReason })), /* @__PURE__ */ import_react57.default.createElement("div", { className: "flex font-medium text-xs text-gray-500 dark:text-gray-400 space-x-2" }, renderPill("Top Pages", "pages"), renderPill("Entry Pages", "entry-pages"), renderPill("Exit Pages", "exit-pages"))), renderContent());
  }

  // js/dashboard/stats/locations/index.js
  var import_react59 = __toESM(require_react());

  // js/dashboard/stats/locations/map.js
  var import_react58 = __toESM(require_react());
  var import_datamaps = __toESM(require_datamaps_all());
  var d32 = __toESM(require_d3());
  var Countries = class extends import_react58.default.Component {
    constructor(props) {
      super(props);
      this.resizeMap = this.resizeMap.bind(this);
      this.drawMap = this.drawMap.bind(this);
      this.getDataset = this.getDataset.bind(this);
      this.state = {
        loading: true,
        darkTheme: document.querySelector("html").classList.contains("dark") || false
      };
      this.onVisible = this.onVisible.bind(this);
      this.updateCountries = this.updateCountries.bind(this);
    }
    componentDidUpdate(prevProps) {
      if (this.props.query !== prevProps.query) {
        this.setState({ loading: true, countries: null });
        this.fetchCountries(this.drawMap);
      }
    }
    componentWillUnmount() {
      window.removeEventListener("resize", this.resizeMap);
      document.removeEventListener("tick", this.updateCountries);
    }
    onVisible() {
      this.fetchCountries(this.drawMap);
      window.addEventListener("resize", this.resizeMap);
      if (this.props.query.period === "realtime") {
        document.addEventListener("tick", this.updateCountries);
      }
    }
    getDataset() {
      const dataset = {};
      var onlyValues = this.state.countries.map(function(obj) {
        return obj.visitors;
      });
      var maxValue = Math.max.apply(null, onlyValues);
      const paletteScale = d32.scale.linear().domain([0, maxValue]).range([
        this.state.darkTheme ? "#2e3954" : "#f3ebff",
        this.state.darkTheme ? "#6366f1" : "#a779e9"
      ]);
      this.state.countries.forEach(function(item) {
        dataset[item.alpha_3] = { numberOfThings: item.visitors, fillColor: paletteScale(item.visitors) };
      });
      return dataset;
    }
    updateCountries() {
      this.fetchCountries(() => {
        this.map.updateChoropleth(this.getDataset(), { reset: true });
      });
    }
    fetchCountries(cb) {
      return get(`/api/stats/${encodeURIComponent(this.props.site.domain)}/countries`, this.props.query, { limit: 300 }).then((response) => {
        if (this.props.afterFetchData) {
          this.props.afterFetchData(response);
        }
        this.setState({ loading: false, countries: response.results }, cb);
      });
    }
    resizeMap() {
      this.map && this.map.resize();
    }
    drawMap() {
      const dataset = this.getDataset();
      const label = this.props.query.period === "realtime" ? "Current visitors" : "Visitors";
      const defaultFill = this.state.darkTheme ? "#2d3747" : "#f8fafc";
      const highlightFill = this.state.darkTheme ? "#374151" : "#F5F5F5";
      const borderColor = this.state.darkTheme ? "#1f2937" : "#dae1e7";
      const highlightBorderColor = this.state.darkTheme ? "#4f46e5" : "#a779e9";
      this.map = new import_datamaps.default({
        element: document.getElementById("map-container"),
        responsive: true,
        projection: "mercator",
        fills: { defaultFill },
        data: dataset,
        geographyConfig: {
          borderColor,
          highlightBorderWidth: 2,
          highlightFillColor: (geo) => geo.fillColor || highlightFill,
          highlightBorderColor,
          popupTemplate: (geo, data) => {
            if (!data) {
              return null;
            }
            const pluralizedLabel = data.numberOfThings === 1 ? label.slice(0, -1) : label;
            return [
              '<div class="hoverinfo dark:bg-gray-800 dark:shadow-gray-850 dark:border-gray-850 dark:text-gray-200">',
              "<strong>",
              geo.properties.name,
              " </strong>",
              '<br><strong class="dark:text-indigo-400">',
              numberFormatter(data.numberOfThings),
              "</strong> ",
              pluralizedLabel,
              "</div>"
            ].join("");
          }
        },
        done: (datamap) => {
          datamap.svg.selectAll(".datamaps-subunit").on("click", (geography) => {
            const country = this.state.countries.find((c3) => c3.alpha_3 === geography.id);
            const filters = replaceFilterByPrefix(this.props.query, "country", ["is", "country", [country.code]]);
            const labels = cleanLabels(filters, this.props.query.labels, "country", { [country.code]: country.name });
            if (country) {
              this.props.onClick();
              navigateToQuery(
                this.props.history,
                this.props.query,
                {
                  filters,
                  labels
                }
              );
            }
          });
        }
      });
    }
    geolocationDbNotice() {
      if (this.props.site.isDbip) {
        return /* @__PURE__ */ import_react58.default.createElement("span", { className: "text-xs text-gray-500 absolute bottom-4 right-3" }, "IP Geolocation by ", /* @__PURE__ */ import_react58.default.createElement("a", { target: "_blank", href: "https://db-ip.com", rel: "noreferrer", className: "text-indigo-600" }, "DB-IP"));
      }
      return null;
    }
    renderBody() {
      if (this.state.countries) {
        return /* @__PURE__ */ import_react58.default.createElement(import_react58.default.Fragment, null, /* @__PURE__ */ import_react58.default.createElement("div", { className: "mx-auto mt-4", style: { width: "100%", maxWidth: "475px", height: "335px" }, id: "map-container" }), /* @__PURE__ */ import_react58.default.createElement(MoreLink, { list: this.state.countries, linkProps: { to: countriesRoute.to, search: (search) => search } }), this.geolocationDbNotice());
      }
      return null;
    }
    render() {
      return /* @__PURE__ */ import_react58.default.createElement(LazyLoader, { onVisible: this.onVisible }, this.state.loading && /* @__PURE__ */ import_react58.default.createElement("div", { className: "mx-auto my-32 loading" }, /* @__PURE__ */ import_react58.default.createElement("div", null)), /* @__PURE__ */ import_react58.default.createElement(FadeIn, { show: !this.state.loading }, this.renderBody()));
    }
  };
  function CountriesWithRouter(props) {
    return /* @__PURE__ */ import_react58.default.createElement(Countries, __spreadValues({}, props));
  }

  // js/dashboard/stats/locations/index.js
  function Countries2({ query, site, onClick, afterFetchData }) {
    function fetchData() {
      return get(apiPath(site, "/countries"), query, { limit: 9 });
    }
    function renderIcon(country) {
      return /* @__PURE__ */ import_react59.default.createElement("span", { className: "mr-2" }, country.flag);
    }
    function getFilterFor(listItem) {
      return {
        prefix: "country",
        filter: ["is", "country", [listItem["code"]]],
        labels: { [listItem["code"]]: listItem["name"] }
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react59.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        onClick,
        keyLabel: "Country",
        metrics: chooseMetrics(),
        detailsLinkProps: { to: countriesRoute.to, search: (search) => search },
        renderIcon,
        color: "bg-orange-50"
      }
    );
  }
  function Regions({ query, site, onClick, afterFetchData }) {
    function fetchData() {
      return get(apiPath(site, "/regions"), query, { limit: 9 });
    }
    function renderIcon(region) {
      return /* @__PURE__ */ import_react59.default.createElement("span", { className: "mr-2" }, region.country_flag);
    }
    function getFilterFor(listItem) {
      return {
        prefix: "region",
        filter: ["is", "region", [listItem["code"]]],
        labels: { [listItem["code"]]: listItem["name"] }
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react59.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        onClick,
        keyLabel: "Region",
        metrics: chooseMetrics(),
        detailsLinkProps: { to: regionsRoute.to, search: (search) => search },
        renderIcon,
        color: "bg-orange-50"
      }
    );
  }
  function Cities({ query, site, afterFetchData }) {
    function fetchData() {
      return get(apiPath(site, "/cities"), query, { limit: 9 });
    }
    function renderIcon(city) {
      return /* @__PURE__ */ import_react59.default.createElement("span", { className: "mr-2" }, city.country_flag);
    }
    function getFilterFor(listItem) {
      return {
        prefix: "city",
        filter: ["is", "city", [listItem["code"]]],
        labels: { [listItem["code"]]: listItem["name"] }
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react59.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        keyLabel: "City",
        metrics: chooseMetrics(),
        detailsLinkProps: { to: citiesRoute.to, search: (search) => search },
        renderIcon,
        color: "bg-orange-50"
      }
    );
  }
  var labelFor2 = {
    "countries": "Countries",
    "regions": "Regions",
    "cities": "Cities"
  };
  var Locations = class extends import_react59.default.Component {
    constructor(props) {
      super(props);
      this.onCountryFilter = this.onCountryFilter.bind(this);
      this.onRegionFilter = this.onRegionFilter.bind(this);
      this.afterFetchData = this.afterFetchData.bind(this);
      this.tabKey = `geoTab__${props.site.domain}`;
      const storedTab = getItem(this.tabKey);
      this.state = {
        mode: storedTab || "map",
        loading: true,
        skipImportedReason: null
      };
    }
    componentDidUpdate(prevProps, prevState) {
      const isRemovingFilter = (filterName) => {
        return getFiltersByKeyPrefix(prevProps.query, filterName).length > 0 && getFiltersByKeyPrefix(this.props.query, filterName).length == 0;
      };
      if (this.state.mode === "cities" && isRemovingFilter("region")) {
        this.setMode("regions")();
      }
      if (this.state.mode === "regions" && isRemovingFilter("country")) {
        this.setMode(this.countriesRestoreMode || "countries")();
      }
      if (this.props.query !== prevProps.query || this.state.mode !== prevState.mode) {
        this.setState({ loading: true });
      }
    }
    setMode(mode) {
      return () => {
        setItem(this.tabKey, mode);
        this.setState({ mode });
      };
    }
    onCountryFilter(mode) {
      return () => {
        this.countriesRestoreMode = mode;
        this.setMode("regions")();
      };
    }
    onRegionFilter() {
      this.setMode("cities")();
    }
    afterFetchData(apiResponse) {
      this.setState({ loading: false, skipImportedReason: apiResponse.skip_imported_reason });
    }
    renderContent() {
      switch (this.state.mode) {
        case "cities":
          return /* @__PURE__ */ import_react59.default.createElement(Cities, { site: this.props.site, query: this.props.query, afterFetchData: this.afterFetchData });
        case "regions":
          return /* @__PURE__ */ import_react59.default.createElement(Regions, { onClick: this.onRegionFilter, site: this.props.site, query: this.props.query, afterFetchData: this.afterFetchData });
        case "countries":
          return /* @__PURE__ */ import_react59.default.createElement(Countries2, { onClick: this.onCountryFilter("countries"), site: this.props.site, query: this.props.query, afterFetchData: this.afterFetchData });
        case "map":
        default:
          return /* @__PURE__ */ import_react59.default.createElement(CountriesWithRouter, { onClick: this.onCountryFilter("map"), site: this.props.site, query: this.props.query, afterFetchData: this.afterFetchData });
      }
    }
    renderPill(name, mode) {
      const isActive = this.state.mode === mode;
      if (isActive) {
        return /* @__PURE__ */ import_react59.default.createElement(
          "button",
          {
            className: "inline-block h-5 text-indigo-700 dark:text-indigo-500 font-bold active-prop-heading"
          },
          name
        );
      }
      return /* @__PURE__ */ import_react59.default.createElement(
        "button",
        {
          className: "hover:text-indigo-600 cursor-pointer",
          onClick: this.setMode(mode)
        },
        name
      );
    }
    render() {
      return /* @__PURE__ */ import_react59.default.createElement("div", null, /* @__PURE__ */ import_react59.default.createElement("div", { className: "w-full flex justify-between" }, /* @__PURE__ */ import_react59.default.createElement("div", { className: "flex gap-x-1" }, /* @__PURE__ */ import_react59.default.createElement("h3", { className: "font-bold dark:text-gray-100" }, labelFor2[this.state.mode] || "Locations"), /* @__PURE__ */ import_react59.default.createElement(ImportedQueryUnsupportedWarning, { loading: this.state.loading, skipImportedReason: this.state.skipImportedReason })), /* @__PURE__ */ import_react59.default.createElement("div", { className: "flex text-xs font-medium text-gray-500 dark:text-gray-400 space-x-2" }, this.renderPill("Map", "map"), this.renderPill("Countries", "countries"), this.renderPill("Regions", "regions"), this.renderPill("Cities", "cities"))), this.renderContent());
    }
  };

  // js/dashboard/stats/devices/index.js
  var import_react60 = __toESM(require_react());
  var BROWSER_ICONS = {
    "Chrome": "chrome.svg",
    "curl": "curl.svg",
    "Safari": "safari.png",
    "Firefox": "firefox.svg",
    "Microsoft Edge": "edge.svg",
    "Vivaldi": "vivaldi.svg",
    "Opera": "opera.svg",
    "Samsung Browser": "samsung-internet.svg",
    "Chromium": "chromium.svg",
    "UC Browser": "uc.svg",
    "Yandex Browser": "yandex.png",
    // Only PNG available in browser-logos
    // Logos underneath this line are not available in browser-logos. Grabbed from random places on the internets.
    "DuckDuckGo Privacy Browser": "duckduckgo.svg",
    "MIUI Browser": "miui.webp",
    "Huawei Browser Mobile": "huawei.png",
    "QQ Browser": "qq.png",
    "Ecosia": "ecosia.png",
    "vivo Browser": "vivo.png"
  };
  function browserIconFor(browser) {
    const filename = BROWSER_ICONS[browser] || "fallback.svg";
    return /* @__PURE__ */ import_react60.default.createElement(
      "img",
      {
        src: `/images/icon/browser/${filename}`,
        className: "w-4 h-4 mr-2"
      }
    );
  }
  function Browsers({ afterFetchData }) {
    const site = useSiteContext();
    const { query } = useQueryContext();
    function fetchData() {
      return get(apiPath(site, "/browsers"), query);
    }
    function getFilterFor(listItem) {
      return {
        prefix: "browser",
        filter: ["is", "browser", [listItem["name"]]]
      };
    }
    function renderIcon(listItem) {
      return browserIconFor(listItem.name);
    }
    function chooseMetrics() {
      return [
        createVisitors({ meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate(),
        !hasGoalFilter(query) && createPercentage()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react60.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        keyLabel: "Browser",
        metrics: chooseMetrics(),
        renderIcon
      }
    );
  }
  function BrowserVersions({ afterFetchData }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    function fetchData() {
      return get(apiPath(site, "/browser-versions"), query).then((res) => {
        return __spreadProps(__spreadValues({}, res), {
          results: res.results.map((row) => {
            return __spreadProps(__spreadValues({}, row), { name: `${row.browser} ${row.name}`, version: row.name });
          })
        });
      });
    }
    function renderIcon(listItem) {
      return browserIconFor(listItem.browser);
    }
    function getFilterFor(listItem) {
      if (getSingleFilter(query, "browser") == "(not set)") {
        return null;
      }
      return {
        prefix: "browser_version",
        filter: ["is", "browser_version", [listItem.version]]
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate(),
        !hasGoalFilter(query) && createPercentage()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react60.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        keyLabel: "Browser version",
        metrics: chooseMetrics(),
        renderIcon
      }
    );
  }
  var OS_ICONS = {
    "iOS": "ios.png",
    "Mac": "mac.png",
    "Windows": "windows.png",
    "Windows Phone": "windows.png",
    "Android": "android.png",
    "GNU/Linux": "gnu_linux.png",
    "Ubuntu": "ubuntu.png",
    "Chrome OS": "chrome_os.png",
    "iPadOS": "ipad_os.png",
    "Fire OS": "fire_os.png",
    "HarmonyOS": "harmony_os.png",
    "Tizen": "tizen.png",
    "PlayStation": "playstation.png",
    "KaiOS": "kai_os.png",
    "Fedora": "fedora.png",
    "FreeBSD": "freebsd.png"
  };
  function osIconFor(os) {
    const filename = OS_ICONS[os] || "fallback.svg";
    return /* @__PURE__ */ import_react60.default.createElement(
      "img",
      {
        src: `/images/icon/os/${filename}`,
        className: "w-4 h-4 mr-2"
      }
    );
  }
  function OperatingSystems({ afterFetchData }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    function fetchData() {
      return get(apiPath(site, "/operating-systems"), query);
    }
    function getFilterFor(listItem) {
      return {
        prefix: "os",
        filter: ["is", "os", [listItem["name"]]]
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate(),
        !hasGoalFilter(query) && createPercentage({ meta: { hiddenonMobile: true } })
      ].filter((metric) => !!metric);
    }
    function renderIcon(listItem) {
      return osIconFor(listItem.name);
    }
    return /* @__PURE__ */ import_react60.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        renderIcon,
        keyLabel: "Operating system",
        metrics: chooseMetrics()
      }
    );
  }
  function OperatingSystemVersions({ afterFetchData }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    function fetchData() {
      return get(apiPath(site, "/operating-system-versions"), query).then((res) => {
        return __spreadProps(__spreadValues({}, res), {
          results: res.results.map((row) => {
            return __spreadProps(__spreadValues({}, row), { name: `${row.os} ${row.name}`, version: row.name });
          })
        });
      });
    }
    function renderIcon(listItem) {
      return osIconFor(listItem.os);
    }
    function getFilterFor(listItem) {
      if (getSingleFilter(query, "os") == "(not set)") {
        return null;
      }
      return {
        prefix: "os_version",
        filter: ["is", "os_version", [listItem.version]]
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate(),
        !hasGoalFilter(query) && createPercentage()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react60.default.createElement(
      ListReport,
      {
        fetchData,
        renderIcon,
        afterFetchData,
        getFilterFor,
        keyLabel: "Operating System Version",
        metrics: chooseMetrics()
      }
    );
  }
  function ScreenSizes({ afterFetchData }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    function fetchData() {
      return get(apiPath(site, "/screen-sizes"), query);
    }
    function renderIcon(screenSize) {
      return /* @__PURE__ */ import_react60.default.createElement("span", { className: "mr-1.5" }, iconFor(screenSize.name));
    }
    function getFilterFor(listItem) {
      return {
        prefix: "screen",
        filter: ["is", "screen", [listItem["name"]]]
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ meta: { plot: true } }),
        hasGoalFilter(query) && createConversionRate(),
        !hasGoalFilter(query) && createPercentage()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react60.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        keyLabel: "Screen size",
        metrics: chooseMetrics(),
        renderIcon
      }
    );
  }
  function iconFor(screenSize) {
    if (screenSize === "Mobile") {
      return /* @__PURE__ */ import_react60.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "-mt-px feather" }, /* @__PURE__ */ import_react60.default.createElement("rect", { x: "5", y: "2", width: "14", height: "20", rx: "2", ry: "2" }), /* @__PURE__ */ import_react60.default.createElement("line", { x1: "12", y1: "18", x2: "12", y2: "18" }));
    } else if (screenSize === "Tablet") {
      return /* @__PURE__ */ import_react60.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "-mt-px feather" }, /* @__PURE__ */ import_react60.default.createElement("rect", { x: "4", y: "2", width: "16", height: "20", rx: "2", ry: "2", transform: "rotate(180 12 12)" }), /* @__PURE__ */ import_react60.default.createElement("line", { x1: "12", y1: "18", x2: "12", y2: "18" }));
    } else if (screenSize === "Laptop") {
      return /* @__PURE__ */ import_react60.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "-mt-px feather" }, /* @__PURE__ */ import_react60.default.createElement("rect", { x: "2", y: "3", width: "20", height: "14", rx: "2", ry: "2" }), /* @__PURE__ */ import_react60.default.createElement("line", { x1: "2", y1: "20", x2: "22", y2: "20" }));
    } else if (screenSize === "Desktop") {
      return /* @__PURE__ */ import_react60.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "-mt-px feather" }, /* @__PURE__ */ import_react60.default.createElement("rect", { x: "2", y: "3", width: "20", height: "14", rx: "2", ry: "2" }), /* @__PURE__ */ import_react60.default.createElement("line", { x1: "8", y1: "21", x2: "16", y2: "21" }), /* @__PURE__ */ import_react60.default.createElement("line", { x1: "12", y1: "17", x2: "12", y2: "21" }));
    } else if (screenSize === "(not set)") {
      return null;
    }
  }
  function Devices() {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const tabKey = `deviceTab__${site.domain}`;
    const storedTab = getItem(tabKey);
    const [mode, setMode] = (0, import_react60.useState)(storedTab || "browser");
    const [loading, setLoading] = (0, import_react60.useState)(true);
    const [skipImportedReason, setSkipImportedReason] = (0, import_react60.useState)(null);
    function switchTab(mode2) {
      setItem(tabKey, mode2);
      setMode(mode2);
    }
    function afterFetchData(apiResponse) {
      setLoading(false);
      setSkipImportedReason(apiResponse.skip_imported_reason);
    }
    (0, import_react60.useEffect)(() => setLoading(true), [query, mode]);
    function renderContent() {
      switch (mode) {
        case "browser":
          if (isFilteringOnFixedValue(query, "browser")) {
            return /* @__PURE__ */ import_react60.default.createElement(BrowserVersions, { afterFetchData });
          }
          return /* @__PURE__ */ import_react60.default.createElement(Browsers, { afterFetchData });
        case "os":
          if (isFilteringOnFixedValue(query, "os")) {
            return /* @__PURE__ */ import_react60.default.createElement(OperatingSystemVersions, { afterFetchData });
          }
          return /* @__PURE__ */ import_react60.default.createElement(OperatingSystems, { afterFetchData });
        case "size":
        default:
          return /* @__PURE__ */ import_react60.default.createElement(ScreenSizes, { afterFetchData });
      }
    }
    function renderPill(name, pill) {
      const isActive = mode === pill;
      if (isActive) {
        return /* @__PURE__ */ import_react60.default.createElement(
          "button",
          {
            className: "inline-block h-5 font-bold text-indigo-700 active-prop-heading dark:text-indigo-500"
          },
          name
        );
      }
      return /* @__PURE__ */ import_react60.default.createElement(
        "button",
        {
          className: "cursor-pointer hover:text-indigo-600",
          onClick: () => switchTab(pill)
        },
        name
      );
    }
    return /* @__PURE__ */ import_react60.default.createElement("div", null, /* @__PURE__ */ import_react60.default.createElement("div", { className: "flex justify-between w-full" }, /* @__PURE__ */ import_react60.default.createElement("div", { className: "flex gap-x-1" }, /* @__PURE__ */ import_react60.default.createElement("h3", { className: "font-bold dark:text-gray-100" }, "Devices"), /* @__PURE__ */ import_react60.default.createElement(ImportedQueryUnsupportedWarning, { loading, skipImportedReason })), /* @__PURE__ */ import_react60.default.createElement("div", { className: "flex text-xs font-medium text-gray-500 dark:text-gray-400 space-x-2" }, renderPill("Browser", "browser"), renderPill("OS", "os"), renderPill("Size", "size"))), renderContent());
  }
  function getSingleFilter(query, filterKey) {
    const matches = getFiltersByKeyPrefix(query, filterKey);
    if (matches.length != 1) {
      return null;
    }
    const clauses = matches[0][2];
    return clauses.length == 1 ? clauses[0] : null;
  }

  // js/dashboard/stats/behaviours/index.js
  var import_react68 = __toESM(require_react());
  var import_classnames13 = __toESM(require_classnames());

  // js/dashboard/stats/behaviours/goal-conversions.js
  var import_react62 = __toESM(require_react());

  // js/dashboard/stats/behaviours/conversions.js
  var import_react61 = __toESM(require_react());
  function Conversions({ afterFetchData, onGoalFilterClick }) {
    const site = useSiteContext();
    const { query } = useQueryContext();
    function fetchConversions() {
      return get(apiPath(site, "/conversions"), query, { limit: 9 });
    }
    function getFilterFor(listItem) {
      return {
        prefix: "goal",
        filter: ["is", "goal", [listItem.name]]
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ renderLabel: (_query) => "Uniques", meta: { plot: true } }),
        createEvents({ renderLabel: (_query) => "Total", meta: { hiddenOnMobile: true } }),
        createConversionRate(),
        false,
        false
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react61.default.createElement(
      ListReport,
      {
        fetchData: fetchConversions,
        afterFetchData,
        getFilterFor,
        keyLabel: "Goal",
        onClick: onGoalFilterClick,
        metrics: chooseMetrics(),
        detailsLinkProps: { to: conversionsRoute.to, search: (search) => search },
        maybeHideDetails: true,
        color: "bg-red-50",
        colMinWidth: 90
      }
    );
  }

  // js/dashboard/stats/behaviours/goal-conversions.js
  var SPECIAL_GOALS = {
    "404": { title: "404 Pages", prop: "path" },
    "Outbound Link: Click": { title: "Outbound Links", prop: "url" },
    "Cloaked Link: Click": { title: "Cloaked Links", prop: "url" },
    "File Download": { title: "File Downloads", prop: "url" },
    "WP Search Queries": { title: "WordPress Search Queries", prop: "search_query" }
  };
  function getSpecialGoal(query) {
    const goalFilter = getGoalFilter(query);
    if (!goalFilter) {
      return null;
    }
    const [_operation, _filterKey, clauses] = goalFilter;
    if (clauses.length == 1) {
      return SPECIAL_GOALS[clauses[0]] || null;
    }
    return null;
  }
  function specialTitleWhenGoalFilter(query, defaultTitle) {
    var _a9;
    return ((_a9 = getSpecialGoal(query)) == null ? void 0 : _a9.title) || defaultTitle;
  }
  function SpecialPropBreakdown({ prop, afterFetchData }) {
    const site = useSiteContext();
    const { query } = useQueryContext();
    function fetchData() {
      return get(apiPath(site, `/custom-prop-values/${prop}`), query);
    }
    function externalLinkDest() {
      if (prop === "path") {
        return (listItem) => externalLinkForPage(site.domain, listItem.name);
      } else {
        return (listItem) => listItem.name;
      }
    }
    function getFilterFor(listItem) {
      return {
        prefix: EVENT_PROPS_PREFIX,
        filter: ["is", `${EVENT_PROPS_PREFIX}${prop}`, [listItem["name"]]]
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ renderLabel: (_query) => "Visitors", meta: { plot: true } }),
        createEvents({ renderLabel: (_query) => "Events", meta: { hiddenOnMobile: true } }),
        createConversionRate()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react62.default.createElement(
      ListReport,
      {
        fetchData,
        afterFetchData,
        getFilterFor,
        keyLabel: prop,
        metrics: chooseMetrics(),
        detailsLinkProps: { to: customPropsRoute.to, params: { propKey: prop }, search: (search) => search },
        externalLinkDest: externalLinkDest(),
        maybeHideDetails: true,
        color: "bg-red-50",
        colMinWidth: 90
      }
    );
  }
  function GoalConversions({ afterFetchData, onGoalFilterClick }) {
    const { query } = useQueryContext();
    const specialGoal = getSpecialGoal(query);
    if (specialGoal) {
      return /* @__PURE__ */ import_react62.default.createElement(SpecialPropBreakdown, { prop: specialGoal.prop, afterFetchData });
    } else {
      return /* @__PURE__ */ import_react62.default.createElement(Conversions, { onGoalFilterClick, afterFetchData });
    }
  }

  // js/dashboard/stats/behaviours/props.js
  var import_react65 = __toESM(require_react());

  // js/dashboard/components/combobox.js
  var import_react63 = __toESM(require_react());
  var import_classnames11 = __toESM(require_classnames());
  function Option({ isHighlighted, onClick, onMouseEnter, text, id }) {
    const className = (0, import_classnames11.default)("relative cursor-pointer select-none py-2 px-3", {
      "text-gray-900 dark:text-gray-300": !isHighlighted,
      "bg-indigo-600 text-white": isHighlighted
    });
    return /* @__PURE__ */ import_react63.default.createElement(
      "li",
      {
        className,
        id,
        onClick,
        onMouseEnter
      },
      /* @__PURE__ */ import_react63.default.createElement("span", { className: "block truncate" }, text)
    );
  }
  function scrollTo(wrapper, id) {
    if (wrapper) {
      const el = wrapper.querySelector("#" + id);
      if (el) {
        el.scrollIntoView({ block: "center" });
      }
    }
  }
  function optionId(index2) {
    return `plausible-combobox-option-${index2}`;
  }
  function PlausibleCombobox({
    values,
    fetchOptions,
    singleOption,
    isDisabled,
    autoFocus,
    freeChoice,
    disabledOptions,
    onSelect,
    placeholder,
    forceLoading,
    className,
    boxClass
  }) {
    const isEmpty = values.length === 0;
    const [options, setOptions] = (0, import_react63.useState)([]);
    const [isLoading, setLoading] = (0, import_react63.useState)(false);
    const [isOpen, setOpen] = (0, import_react63.useState)(false);
    const [search, setSearch] = (0, import_react63.useState)("");
    const [highlightedIndex, setHighlightedIndex] = (0, import_react63.useState)(0);
    const searchRef = (0, import_react63.useRef)(null);
    const containerRef = (0, import_react63.useRef)(null);
    const listRef = (0, import_react63.useRef)(null);
    const loading = isLoading || !!forceLoading;
    const visibleOptions = [...options];
    if (freeChoice && search.length > 0 && options.every((option) => option.value !== search)) {
      visibleOptions.push({ value: search, label: search, freeChoice: true });
    }
    const afterFetchOptions = (0, import_react63.useCallback)((loadedOptions) => {
      setLoading(false);
      setHighlightedIndex(0);
      setOptions(loadedOptions);
    }, []);
    const initialFetchOptions = (0, import_react63.useCallback)(() => {
      fetchOptions("").then(afterFetchOptions);
    }, [fetchOptions, afterFetchOptions]);
    const searchOptions = (0, import_react63.useCallback)(() => {
      if (isOpen) {
        setLoading(true);
        fetchOptions(search).then(afterFetchOptions);
      }
    }, [search, isOpen, fetchOptions, afterFetchOptions]);
    const debouncedSearchOptions = useDebounce(searchOptions);
    (0, import_react63.useEffect)(() => {
      if (isOpen) {
        initialFetchOptions();
      }
    }, [isOpen, initialFetchOptions]);
    useMountedEffect(() => {
      debouncedSearchOptions();
    }, [search]);
    function highLight(index2) {
      let newIndex = index2;
      if (index2 < 0) {
        newIndex = visibleOptions.length - 1;
      } else if (index2 >= visibleOptions.length) {
        newIndex = 0;
      }
      setHighlightedIndex(newIndex);
      scrollTo(listRef.current, optionId(newIndex));
    }
    function onKeyDown(e3) {
      var _a9;
      if (e3.key === "Enter") {
        if (!isOpen || loading || visibleOptions.length === 0) return null;
        selectOption(visibleOptions[highlightedIndex]);
        e3.preventDefault();
      }
      if (e3.key === "Escape") {
        if (!isOpen || loading) return null;
        setOpen(false);
        (_a9 = searchRef.current) == null ? void 0 : _a9.focus();
        e3.preventDefault();
      }
      if (e3.key === "ArrowDown") {
        if (isOpen) {
          highLight(highlightedIndex + 1);
        } else {
          setOpen(true);
        }
      }
      if (e3.key === "ArrowUp") {
        if (isOpen) {
          highLight(highlightedIndex - 1);
        } else {
          setOpen(true);
        }
      }
    }
    function isOptionDisabled(option) {
      const optionAlreadySelected = values.some((val) => val.value === option.value);
      const optionDisabled = (disabledOptions || []).some((val) => (val == null ? void 0 : val.value) === option.value);
      return optionAlreadySelected || optionDisabled;
    }
    function onInput(e3) {
      if (!isOpen) {
        setOpen(true);
      }
      setSearch(e3.target.value);
    }
    function toggleOpen() {
      if (!isOpen) {
        setOpen(true);
        searchRef.current.focus();
      } else {
        setSearch("");
        setOpen(false);
      }
    }
    function selectOption(option) {
      if (singleOption) {
        onSelect([option]);
      } else {
        searchRef.current.focus();
        onSelect([...values, option]);
      }
      setOpen(false);
      setSearch("");
    }
    function removeOption(option, e3) {
      e3.stopPropagation();
      const newValues = values.filter((val) => val.value !== option.value);
      onSelect(newValues);
      searchRef.current.focus();
      setOpen(false);
    }
    const handleClick = (0, import_react63.useCallback)((e3) => {
      if (containerRef.current && containerRef.current.contains(e3.target)) {
        return;
      }
      setSearch("");
      setOpen(false);
    }, []);
    (0, import_react63.useEffect)(() => {
      document.addEventListener("mousedown", handleClick, false);
      return () => {
        document.removeEventListener("mousedown", handleClick, false);
      };
    }, [handleClick]);
    (0, import_react63.useEffect)(() => {
      if (singleOption && isEmpty && autoFocus) {
        searchRef.current.focus();
      }
    }, [isEmpty, singleOption, autoFocus]);
    const searchBoxClass = "border-none py-1 px-0 w-full inline-block rounded-md focus:outline-none focus:ring-0 text-sm";
    const containerClass = (0, import_classnames11.default)("relative w-full", {
      [className]: !!className,
      "opacity-30 cursor-default pointer-events-none": isDisabled
    });
    function renderSingleOptionContent() {
      const itemSelected = values.length === 1;
      return /* @__PURE__ */ import_react63.default.createElement("div", { className: "flex items-center truncate" }, itemSelected && renderSingleSelectedItem(), /* @__PURE__ */ import_react63.default.createElement(
        "input",
        {
          className: searchBoxClass,
          ref: searchRef,
          value: search,
          style: { backgroundColor: "inherit" },
          placeholder: itemSelected ? "" : placeholder,
          type: "text",
          onChange: onInput
        }
      ));
    }
    function renderSingleSelectedItem() {
      if (search === "") {
        return /* @__PURE__ */ import_react63.default.createElement("span", { className: "dark:text-gray-300 text-sm w-0" }, values[0].label);
      }
    }
    function renderMultiOptionContent() {
      return /* @__PURE__ */ import_react63.default.createElement(import_react63.default.Fragment, null, values.map((value) => {
        return /* @__PURE__ */ import_react63.default.createElement("div", { key: value.value, className: "bg-indigo-100 dark:bg-indigo-600 flex justify-between w-full rounded-sm px-2 py-0.5 m-0.5 text-sm" }, /* @__PURE__ */ import_react63.default.createElement("span", { className: "break-all" }, value.label), /* @__PURE__ */ import_react63.default.createElement("span", { onClick: (e3) => removeOption(value, e3), className: "cursor-pointer font-bold ml-1" }, "\xD7"));
      }), /* @__PURE__ */ import_react63.default.createElement("input", { className: searchBoxClass, ref: searchRef, value: search, style: { backgroundColor: "inherit" }, placeholder, type: "text", onChange: onInput }));
    }
    function renderDropDownContent() {
      const matchesFound = visibleOptions.length > 0 && visibleOptions.some((option) => !isOptionDisabled(option));
      if (loading) {
        return /* @__PURE__ */ import_react63.default.createElement("div", { className: "relative cursor-default select-none py-2 px-4 text-gray-700 dark:text-gray-300" }, "Loading options...");
      }
      if (matchesFound) {
        return visibleOptions.filter((option) => !isOptionDisabled(option)).map((option, i5) => {
          const text = option.freeChoice ? `Filter by '${option.label}'` : option.label;
          return /* @__PURE__ */ import_react63.default.createElement(
            Option,
            {
              key: option.value,
              id: optionId(i5),
              isHighlighted: highlightedIndex === i5,
              onClick: () => selectOption(option),
              onMouseEnter: () => setHighlightedIndex(i5),
              text
            }
          );
        });
      }
      if (freeChoice) {
        return /* @__PURE__ */ import_react63.default.createElement("div", { className: "relative cursor-default select-none py-2 px-4 text-gray-700 dark:text-gray-300" }, "Start typing to apply filter");
      }
      return /* @__PURE__ */ import_react63.default.createElement("div", { className: "relative cursor-default select-none py-2 px-4 text-gray-700 dark:text-gray-300" }, "No matches found in the current dashboard. Try selecting a different time range or searching for something different");
    }
    const defaultBoxClass = "pl-2 pr-8 py-1 w-full dark:bg-gray-900 dark:text-gray-300 rounded-md shadow-sm border border-gray-300 dark:border-gray-700 focus-within:border-indigo-500 focus-within:ring-1 focus-within:ring-indigo-500";
    const finalBoxClass = (0, import_classnames11.default)(boxClass || defaultBoxClass, {
      "border-indigo-500 ring-1 ring-indigo-500": isOpen
    });
    return /* @__PURE__ */ import_react63.default.createElement("div", { onKeyDown, ref: containerRef, className: containerClass }, /* @__PURE__ */ import_react63.default.createElement("div", { onClick: toggleOpen, className: finalBoxClass }, singleOption && renderSingleOptionContent(), !singleOption && renderMultiOptionContent(), /* @__PURE__ */ import_react63.default.createElement("div", { className: "cursor-pointer absolute inset-y-0 right-0 flex items-center pr-2" }, !loading && /* @__PURE__ */ import_react63.default.createElement(ChevronDownIcon_default, { className: "h-4 w-4 text-gray-500" }), loading && /* @__PURE__ */ import_react63.default.createElement(Spinner, null))), isOpen && /* @__PURE__ */ import_react63.default.createElement(
      Ke,
      {
        as: import_react63.Fragment,
        leave: "transition ease-in duration-100",
        leaveFrom: "opacity-100",
        leaveTo: "opacity-0",
        show: isOpen
      },
      /* @__PURE__ */ import_react63.default.createElement("ul", { ref: listRef, className: "z-50 absolute mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm dark:bg-gray-900" }, renderDropDownContent())
    ));
  }
  function Spinner() {
    return /* @__PURE__ */ import_react63.default.createElement("svg", { className: "animate-spin h-4 w-4 text-indigo-500", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24" }, /* @__PURE__ */ import_react63.default.createElement("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }), /* @__PURE__ */ import_react63.default.createElement("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" }));
  }

  // js/dashboard/stats/behaviours/props.js
  var import_classnames12 = __toESM(require_classnames());
  function Properties({ afterFetchData }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const propKeyStorageName = `prop_key__${site.domain}`;
    const propKeyStorageNameForGoal = () => {
      const [_operation, _filterKey, [goal]] = getGoalFilter(query);
      return `${goal}__prop_key__${site.domain}`;
    };
    const [propKey, setPropKey] = (0, import_react65.useState)(null);
    const [propKeyLoading, setPropKeyLoading] = (0, import_react65.useState)(true);
    function singleGoalFilterApplied() {
      const goalFilter = getGoalFilter(query);
      if (goalFilter) {
        const [operation, _filterKey, clauses] = goalFilter;
        return operation === FILTER_OPERATIONS.is && clauses.length === 1;
      } else {
        return false;
      }
    }
    (0, import_react65.useEffect)(() => {
      setPropKeyLoading(true);
      setPropKey(null);
      fetchPropKeyOptions()("").then((propKeys) => {
        const propKeyValues = propKeys.map((entry) => entry.value);
        if (propKeyValues.length > 0) {
          const storedPropKey = getPropKeyFromStorage();
          if (propKeyValues.includes(storedPropKey)) {
            setPropKey(storedPropKey);
          } else {
            setPropKey(propKeys[0].value);
          }
        }
        setPropKeyLoading(false);
      });
    }, [query]);
    function getPropKeyFromStorage() {
      if (singleGoalFilterApplied()) {
        const storedForGoal = getItem(propKeyStorageNameForGoal());
        if (storedForGoal) {
          return storedForGoal;
        }
      }
      return getItem(propKeyStorageName);
    }
    function fetchProps() {
      return get(apiPath(site, `/custom-prop-values/${encodeURIComponent(propKey)}`), query);
    }
    const fetchPropKeyOptions = (0, import_react65.useCallback)(() => {
      return (input) => {
        return get(apiPath(site, "/suggestions/prop_key"), query, { q: input.trim() });
      };
    }, [query]);
    function onPropKeySelect() {
      return (selectedOptions) => {
        const newPropKey = selectedOptions.length === 0 ? null : selectedOptions[0].value;
        if (newPropKey) {
          const storageName = singleGoalFilterApplied() ? propKeyStorageNameForGoal() : propKeyStorageName;
          setItem(storageName, newPropKey);
        }
        setPropKey(newPropKey);
      };
    }
    function chooseMetrics() {
      return [
        createVisitors({ renderLabel: (_query) => "Visitors", meta: { plot: true } }),
        createEvents({ renderLabel: (_query) => "Events", meta: { hiddenOnMobile: true } }),
        hasGoalFilter(query) && createConversionRate(),
        !hasGoalFilter(query) && createPercentage(),
        false,
        false
      ].filter((metric) => !!metric);
    }
    function renderBreakdown() {
      return /* @__PURE__ */ import_react65.default.createElement(
        ListReport,
        {
          fetchData: fetchProps,
          afterFetchData,
          getFilterFor,
          keyLabel: propKey,
          metrics: chooseMetrics(),
          detailsLinkProps: { to: customPropsRoute.to, params: { propKey }, search: (search) => search },
          maybeHideDetails: true,
          color: "bg-red-50",
          colMinWidth: 90
        }
      );
    }
    const getFilterFor = (listItem) => ({
      prefix: `${EVENT_PROPS_PREFIX}${propKey}`,
      filter: ["is", `${EVENT_PROPS_PREFIX}${propKey}`, [listItem.name]]
    });
    const comboboxDisabled = !propKeyLoading && !propKey;
    const comboboxPlaceholder = comboboxDisabled ? "No custom properties found" : "";
    const comboboxValues = propKey ? [{ value: propKey, label: propKey }] : [];
    const boxClass = (0, import_classnames12.default)("pl-2 pr-8 py-1 bg-transparent dark:text-gray-300 rounded-md shadow-sm border border-gray-300 dark:border-gray-500", {
      "pointer-events-none": comboboxDisabled
    });
    const COMBOBOX_HEIGHT = 40;
    return /* @__PURE__ */ import_react65.default.createElement("div", { className: "w-full mt-4", style: { minHeight: `${COMBOBOX_HEIGHT + MIN_HEIGHT}px` } }, /* @__PURE__ */ import_react65.default.createElement("div", { style: { minHeight: `${COMBOBOX_HEIGHT}px` } }, /* @__PURE__ */ import_react65.default.createElement(PlausibleCombobox, { boxClass, forceLoading: propKeyLoading, fetchOptions: fetchPropKeyOptions(), singleOption: true, values: comboboxValues, onSelect: onPropKeySelect(), placeholder: comboboxPlaceholder })), propKey && renderBreakdown());
  }

  // js/dashboard/components/notice.js
  var import_react66 = __toESM(require_react());
  function FeatureSetupNotice({ feature, title, info, callToAction, onHideAction }) {
    const site = useSiteContext();
    const sectionTitle = sectionTitles[feature];
    const requestHideSection = () => {
      if (window.confirm(`Are you sure you want to hide ${sectionTitle}? You can make it visible again in your site settings later.`)) {
        put(`/api/${encodeURIComponent(site.domain)}/disable-feature`, { feature }).then((response) => {
          if (response.ok) {
            onHideAction();
          }
        });
      }
    };
    function renderCallToAction() {
      return /* @__PURE__ */ import_react66.default.createElement("a", { href: callToAction.link, className: "ml-2 sm:ml-4 button px-2 sm:px-4" }, /* @__PURE__ */ import_react66.default.createElement("p", { className: "flex flex-col justify-center text-xs sm:text-sm" }, callToAction.action), /* @__PURE__ */ import_react66.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor", className: "ml-2 w-5 h-5" }, /* @__PURE__ */ import_react66.default.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75" })));
    }
    function renderHideButton() {
      return /* @__PURE__ */ import_react66.default.createElement(
        "button",
        {
          onClick: requestHideSection,
          className: "inline-block px-2 sm:px-4 py-2 border border-gray-300 dark:border-gray-500 leading-5 rounded-md text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800 transition ease-in-out duration-150"
        },
        "Hide this report"
      );
    }
    return /* @__PURE__ */ import_react66.default.createElement("div", { className: "sm:mx-32 mt-6 mb-3" }, /* @__PURE__ */ import_react66.default.createElement("div", { className: "py-3" }, /* @__PURE__ */ import_react66.default.createElement("div", { className: "text-center mt-2 text-gray-800 dark:text-gray-200" }, title), /* @__PURE__ */ import_react66.default.createElement("div", { className: "text-justify mt-4 font-small text-sm text-gray-500 dark:text-gray-200" }, info), /* @__PURE__ */ import_react66.default.createElement("div", { className: "text-xs sm:text-sm flex my-6 justify-center" }, renderHideButton(), renderCallToAction())));
  }

  // js/dashboard/user-context.js
  var import_react67 = __toESM(require_react());
  var userContextDefaultValue = {
    role: "",
    loggedIn: false
  };
  var UserContext = (0, import_react67.createContext)(userContextDefaultValue);
  var useUserContext = () => {
    return (0, import_react67.useContext)(UserContext);
  };
  function UserContextProvider({ role, loggedIn, children }) {
    return /* @__PURE__ */ import_react67.default.createElement(UserContext.Provider, { value: { role, loggedIn } }, children);
  }

  // js/dashboard/stats/behaviours/index.js
  function maybeRequire2() {
    if (false) {
      return null;
    } else {
      return { default: null };
    }
  }
  var Funnel = maybeRequire2().default;
  var ACTIVE_CLASS = "inline-block h-5 text-indigo-700 dark:text-indigo-500 font-bold active-prop-heading truncate text-left";
  var DEFAULT_CLASS = "hover:text-indigo-600 cursor-pointer truncate text-left";
  var CONVERSIONS = "conversions";
  var PROPS = "props";
  var FUNNELS = "funnels";
  var sectionTitles = {
    [CONVERSIONS]: "Goal Conversions",
    [PROPS]: "Custom Properties",
    [FUNNELS]: "Funnels"
  };
  function Behaviours({ importedDataInView }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const user = useUserContext();
    const adminAccess = ["owner", "admin", "super_admin"].includes(user.role);
    const tabKey = getDomainScopedStorageKey("behavioursTab", site.domain);
    const funnelKey = getDomainScopedStorageKey("behavioursTabFunnel", site.domain);
    const [enabledModes, setEnabledModes] = (0, import_react68.useState)(getEnabledModes());
    const [mode, setMode] = (0, import_react68.useState)(defaultMode());
    const [loading, setLoading] = (0, import_react68.useState)(true);
    const [funnelNames, _setFunnelNames] = (0, import_react68.useState)(site.funnels.map(({ name }) => name));
    const [selectedFunnel, setSelectedFunnel] = (0, import_react68.useState)(defaultSelectedFunnel());
    const [showingPropsForGoalFilter, setShowingPropsForGoalFilter] = (0, import_react68.useState)(false);
    const [skipImportedReason, setSkipImportedReason] = (0, import_react68.useState)(null);
    const onGoalFilterClick = (0, import_react68.useCallback)((e3) => {
      const goalName = e3.target.innerHTML;
      const isSpecialGoal = Object.keys(SPECIAL_GOALS).includes(goalName);
      const isPageviewGoal = goalName.startsWith("Visit ");
      if (!isSpecialGoal && !isPageviewGoal && enabledModes.includes(PROPS) && site.hasProps) {
        setShowingPropsForGoalFilter(true);
        setMode(PROPS);
      }
    }, []);
    (0, import_react68.useEffect)(() => {
      const justRemovedGoalFilter = !hasGoalFilter(query);
      if (mode === PROPS && justRemovedGoalFilter && showingPropsForGoalFilter) {
        setShowingPropsForGoalFilter(false);
        setMode(CONVERSIONS);
      }
    }, [hasGoalFilter(query)]);
    (0, import_react68.useEffect)(() => {
      setMode(defaultMode());
    }, [enabledModes]);
    (0, import_react68.useEffect)(() => setLoading(true), [query, mode]);
    function disableMode(mode2) {
      setEnabledModes(enabledModes.filter((m5) => {
        return m5 !== mode2;
      }));
    }
    function setFunnel(selectedFunnel2) {
      return () => {
        setItem(tabKey, FUNNELS);
        setItem(funnelKey, selectedFunnel2);
        setMode(FUNNELS);
        setSelectedFunnel(selectedFunnel2);
      };
    }
    function defaultSelectedFunnel() {
      const stored = getItem(funnelKey);
      const storedExists = stored && site.funnels.some((f5) => f5.name === stored);
      if (storedExists) {
        return stored;
      } else if (site.funnels.length > 0) {
        const firstAvailable = site.funnels[0].name;
        setItem(funnelKey, firstAvailable);
        return firstAvailable;
      }
    }
    function hasFunnels() {
      return site.funnels.length > 0 && site.funnelsAvailable;
    }
    function tabFunnelPicker() {
      return /* @__PURE__ */ import_react68.default.createElement(Ze, { as: "div", className: "relative inline-block text-left" }, /* @__PURE__ */ import_react68.default.createElement("div", null, /* @__PURE__ */ import_react68.default.createElement(Ze.Button, { className: "inline-flex justify-between focus:outline-none" }, /* @__PURE__ */ import_react68.default.createElement("span", { className: mode == FUNNELS ? ACTIVE_CLASS : DEFAULT_CLASS }, "Funnels"), /* @__PURE__ */ import_react68.default.createElement(ChevronDownIcon_default, { className: "-mr-1 ml-1 h-4 w-4", "aria-hidden": "true" }))), /* @__PURE__ */ import_react68.default.createElement(
        Ke,
        {
          as: import_react68.Fragment,
          enter: "transition ease-out duration-100",
          enterFrom: "opacity-0 scale-95",
          enterTo: "opacity-100 scale-100",
          leave: "transition ease-in duration-75",
          leaveFrom: "opacity-100 scale-100",
          leaveTo: "opacity-0 scale-95"
        },
        /* @__PURE__ */ import_react68.default.createElement(Ze.Items, { className: "text-left origin-top-right absolute right-0 mt-2 w-96 max-h-72 overflow-auto rounded-md shadow-lg bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5 focus:outline-none z-10" }, /* @__PURE__ */ import_react68.default.createElement("div", { className: "py-1" }, funnelNames.map((funnelName) => {
          return /* @__PURE__ */ import_react68.default.createElement(Ze.Item, { key: funnelName }, ({ active }) => /* @__PURE__ */ import_react68.default.createElement(
            "span",
            {
              onClick: setFunnel(funnelName),
              className: (0, import_classnames13.default)(
                active ? "bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-200 cursor-pointer" : "text-gray-700 dark:text-gray-200",
                "block px-4 py-2 text-sm",
                mode === FUNNELS && selectedFunnel === funnelName ? "font-bold text-gray-500" : ""
              )
            },
            funnelName
          ));
        })))
      ));
    }
    function tabSwitcher(toMode, displayName) {
      const className = (0, import_classnames13.default)({ [ACTIVE_CLASS]: mode == toMode, [DEFAULT_CLASS]: mode !== toMode });
      const setTab = () => {
        setItem(tabKey, toMode);
        setMode(toMode);
      };
      return /* @__PURE__ */ import_react68.default.createElement("div", { className, onClick: setTab }, displayName);
    }
    function tabs() {
      return /* @__PURE__ */ import_react68.default.createElement("div", { className: "flex text-xs font-medium text-gray-500 dark:text-gray-400 space-x-2" }, isEnabled(CONVERSIONS) && tabSwitcher(CONVERSIONS, "Goals"), isEnabled(PROPS) && tabSwitcher(PROPS, "Properties"), isEnabled(FUNNELS) && Funnel && (hasFunnels() ? tabFunnelPicker() : tabSwitcher(FUNNELS, "Funnels")));
    }
    function afterFetchData(apiResponse) {
      setLoading(false);
      setSkipImportedReason(apiResponse.skip_imported_reason);
    }
    function renderConversions() {
      if (site.hasGoals) {
        return /* @__PURE__ */ import_react68.default.createElement(GoalConversions, { onGoalFilterClick, afterFetchData });
      } else if (adminAccess) {
        return /* @__PURE__ */ import_react68.default.createElement(
          FeatureSetupNotice,
          {
            feature: CONVERSIONS,
            title: "Measure how often visitors complete specific actions",
            info: "Goals allow you to track registrations, button clicks, form completions, external link clicks, file downloads, 404 error pages and more.",
            callToAction: {
              action: "Set up goals",
              link: `/${encodeURIComponent(site.domain)}/settings/goals`
            },
            onHideAction: onHideAction(CONVERSIONS)
          }
        );
      } else {
        return noDataYet();
      }
    }
    function renderFunnels() {
      if (Funnel === null) {
        return featureUnavailable();
      } else if (Funnel && selectedFunnel && site.funnelsAvailable) {
        return /* @__PURE__ */ import_react68.default.createElement(Funnel, { funnelName: selectedFunnel });
      } else if (Funnel && adminAccess) {
        let callToAction;
        if (site.funnelsAvailable) {
          callToAction = { action: "Set up funnels", link: `/${encodeURIComponent(site.domain)}/settings/funnels` };
        } else {
          callToAction = { action: "Upgrade", link: "/billing/choose-plan" };
        }
        return /* @__PURE__ */ import_react68.default.createElement(
          FeatureSetupNotice,
          {
            feature: FUNNELS,
            title: "Follow the visitor journey from entry to conversion",
            info: "Funnels allow you to analyze the user flow through your website, uncover possible issues, optimize your site and increase the conversion rate.",
            callToAction,
            onHideAction: onHideAction(FUNNELS)
          }
        );
      } else {
        return noDataYet();
      }
    }
    function renderProps() {
      if (site.hasProps && site.propsAvailable) {
        return /* @__PURE__ */ import_react68.default.createElement(Properties, { afterFetchData });
      } else if (adminAccess) {
        let callToAction;
        if (site.propsAvailable) {
          callToAction = { action: "Set up props", link: `/${encodeURIComponent(site.domain)}/settings/properties` };
        } else {
          callToAction = { action: "Upgrade", link: "/billing/choose-plan" };
        }
        return /* @__PURE__ */ import_react68.default.createElement(
          FeatureSetupNotice,
          {
            feature: PROPS,
            title: "Send custom data to create your own metrics",
            info: "You can attach custom properties when sending a pageview or event. This allows you to create custom metrics and analyze stats we don't track automatically.",
            callToAction,
            onHideAction: onHideAction(PROPS)
          }
        );
      } else {
        return noDataYet();
      }
    }
    function noDataYet() {
      return /* @__PURE__ */ import_react68.default.createElement("div", { className: "font-medium text-gray-500 dark:text-gray-400 py-12 text-center" }, "No data yet");
    }
    function featureUnavailable() {
      return /* @__PURE__ */ import_react68.default.createElement("div", { className: "font-medium text-gray-500 dark:text-gray-400 py-12 text-center" }, "This feature is unavailable");
    }
    function onHideAction(mode2) {
      return () => {
        disableMode(mode2);
      };
    }
    function renderContent() {
      switch (mode) {
        case CONVERSIONS:
          return renderConversions();
        case PROPS:
          return renderProps();
        case FUNNELS:
          return renderFunnels();
      }
    }
    function defaultMode() {
      if (enabledModes.length === 0) {
        return null;
      }
      const storedMode = getItem(tabKey);
      if (storedMode && enabledModes.includes(storedMode)) {
        return storedMode;
      }
      if (enabledModes.includes(CONVERSIONS)) {
        return CONVERSIONS;
      }
      if (enabledModes.includes(PROPS)) {
        return PROPS;
      }
      return FUNNELS;
    }
    function getEnabledModes() {
      let enabledModes2 = [];
      for (const feature of Object.keys(sectionTitles)) {
        const isOptedOut = site[feature + "OptedOut"];
        const isAvailable = site[feature + "Available"] !== false;
        const callToActionIsMissing = !isAvailable && user.role !== "owner";
        if (!isOptedOut && !callToActionIsMissing) {
          enabledModes2.push(feature);
        }
      }
      return enabledModes2;
    }
    function isEnabled(mode2) {
      return enabledModes.includes(mode2);
    }
    function isRealtime() {
      return query.period === "realtime";
    }
    function sectionTitle() {
      if (mode === CONVERSIONS) {
        return specialTitleWhenGoalFilter(query, sectionTitles[mode]);
      } else {
        return sectionTitles[mode];
      }
    }
    function renderImportedQueryUnsupportedWarning() {
      if (mode === CONVERSIONS) {
        return /* @__PURE__ */ import_react68.default.createElement(ImportedQueryUnsupportedWarning, { loading, skipImportedReason });
      } else if (mode === PROPS) {
        return /* @__PURE__ */ import_react68.default.createElement(ImportedQueryUnsupportedWarning, { loading, skipImportedReason, message: "Imported data is unavailable in this view" });
      } else {
        return /* @__PURE__ */ import_react68.default.createElement(ImportedQueryUnsupportedWarning, { altCondition: importedDataInView, message: "Imported data is unavailable in this view" });
      }
    }
    if (mode) {
      return /* @__PURE__ */ import_react68.default.createElement("div", { className: "items-start justify-between block w-full mt-6 md:flex" }, /* @__PURE__ */ import_react68.default.createElement("div", { className: "w-full p-4 bg-white rounded shadow-xl dark:bg-gray-825" }, /* @__PURE__ */ import_react68.default.createElement("div", { className: "flex justify-between w-full" }, /* @__PURE__ */ import_react68.default.createElement("div", { className: "flex gap-x-1" }, /* @__PURE__ */ import_react68.default.createElement("h3", { className: "font-bold dark:text-gray-100" }, sectionTitle() + (isRealtime() ? " (last 30min)" : "")), renderImportedQueryUnsupportedWarning()), tabs()), renderContent()));
    } else {
      return null;
    }
  }

  // js/dashboard/pinned-header-hoc.js
  var import_react70 = __toESM(require_react());
  var withPinnedHeader = (WrappedComponent, selector) => {
    return class extends import_react70.default.Component {
      constructor(props) {
        super(props);
        this.state = {
          stuck: false
        };
      }
      componentDidMount() {
        if ("IntersectionObserver" in window) {
          this.attachObserver();
        }
      }
      attachObserver() {
        this.observer = new IntersectionObserver((entries) => {
          if (entries[0].intersectionRatio === 0)
            this.setState({ stuck: true });
          else if (entries[0].intersectionRatio === 1)
            this.setState({ stuck: false });
        }, {
          threshold: [0, 1]
        });
        this.el = document.querySelector(selector);
        this.observer.observe(this.el);
      }
      componentWillUnmount() {
        this.observer && this.observer.unobserve(this.el);
      }
      render() {
        return /* @__PURE__ */ import_react70.default.createElement(WrappedComponent, __spreadValues({ stuck: this.state.stuck }, this.props));
      }
    };
  };

  // js/dashboard/historical.js
  function Historical({ stuck, importedDataInView, updateImportedDataInView }) {
    const site = useSiteContext();
    const user = useUserContext();
    const { query } = useQueryContext();
    const tooltipBoundary = import_react71.default.useRef(null);
    return /* @__PURE__ */ import_react71.default.createElement("div", { className: "mb-12" }, /* @__PURE__ */ import_react71.default.createElement("div", { id: "stats-container-top" }), /* @__PURE__ */ import_react71.default.createElement("div", { className: `relative top-0 sm:py-3 py-2 z-10 ${stuck && !site.embedded ? "sticky fullwidth-shadow bg-gray-50 dark:bg-gray-850" : ""}` }, /* @__PURE__ */ import_react71.default.createElement("div", { className: "items-center w-full flex" }, /* @__PURE__ */ import_react71.default.createElement("div", { className: "flex items-center w-full", ref: tooltipBoundary }, /* @__PURE__ */ import_react71.default.createElement(SiteSwitcher, { site, loggedIn: user.loggedIn, currentUserRole: user.role }), /* @__PURE__ */ import_react71.default.createElement(CurrentVisitors, { tooltipBoundary: tooltipBoundary.current }), /* @__PURE__ */ import_react71.default.createElement(filters_default, { className: "flex" })), /* @__PURE__ */ import_react71.default.createElement(datepicker_default, null), /* @__PURE__ */ import_react71.default.createElement(comparison_input_default, null))), /* @__PURE__ */ import_react71.default.createElement(VisitorGraph, { updateImportedDataInView }), /* @__PURE__ */ import_react71.default.createElement("div", { className: "w-full md:flex" }, /* @__PURE__ */ import_react71.default.createElement("div", { className: statsBoxClass }, /* @__PURE__ */ import_react71.default.createElement(Sources, null)), /* @__PURE__ */ import_react71.default.createElement("div", { className: statsBoxClass }, /* @__PURE__ */ import_react71.default.createElement(Pages, null))), /* @__PURE__ */ import_react71.default.createElement("div", { className: "w-full md:flex" }, /* @__PURE__ */ import_react71.default.createElement("div", { className: statsBoxClass }, /* @__PURE__ */ import_react71.default.createElement(Locations, { site, query })), /* @__PURE__ */ import_react71.default.createElement("div", { className: statsBoxClass }, /* @__PURE__ */ import_react71.default.createElement(Devices, null))), /* @__PURE__ */ import_react71.default.createElement(Behaviours, { importedDataInView }));
  }
  var historical_default = withPinnedHeader(Historical, "#stats-container-top");

  // js/dashboard/realtime.js
  var import_react72 = __toESM(require_react());
  function Realtime({ stuck }) {
    const site = useSiteContext();
    const user = useUserContext();
    const { query } = useQueryContext();
    const navClass = site.embedded ? "relative" : "sticky";
    return /* @__PURE__ */ import_react72.default.createElement("div", { className: "mb-12" }, /* @__PURE__ */ import_react72.default.createElement("div", { id: "stats-container-top" }), /* @__PURE__ */ import_react72.default.createElement("div", { className: `${navClass} top-0 sm:py-3 py-2 z-10 ${stuck && !site.embedded ? "fullwidth-shadow bg-gray-50 dark:bg-gray-850" : ""}` }, /* @__PURE__ */ import_react72.default.createElement("div", { className: "items-center w-full flex" }, /* @__PURE__ */ import_react72.default.createElement("div", { className: "flex items-center w-full" }, /* @__PURE__ */ import_react72.default.createElement(SiteSwitcher, { site, loggedIn: user.loggedIn, currentUserRole: user.role }), /* @__PURE__ */ import_react72.default.createElement(filters_default, { className: "flex" })), /* @__PURE__ */ import_react72.default.createElement(datepicker_default, null))), /* @__PURE__ */ import_react72.default.createElement(VisitorGraph, null), /* @__PURE__ */ import_react72.default.createElement("div", { className: "w-full md:flex" }, /* @__PURE__ */ import_react72.default.createElement("div", { className: statsBoxClass }, /* @__PURE__ */ import_react72.default.createElement(Sources, null)), /* @__PURE__ */ import_react72.default.createElement("div", { className: statsBoxClass }, /* @__PURE__ */ import_react72.default.createElement(Pages, null))), /* @__PURE__ */ import_react72.default.createElement("div", { className: "w-full md:flex" }, /* @__PURE__ */ import_react72.default.createElement("div", { className: statsBoxClass }, /* @__PURE__ */ import_react72.default.createElement(Locations, { site, query })), /* @__PURE__ */ import_react72.default.createElement("div", { className: statsBoxClass }, /* @__PURE__ */ import_react72.default.createElement(Devices, null))), /* @__PURE__ */ import_react72.default.createElement(Behaviours, null));
  }
  var realtime_default = withPinnedHeader(Realtime, "#stats-container-top");

  // js/dashboard/index.js
  var statsBoxClass = "stats-item relative w-full mt-6 p-4 flex flex-col bg-white dark:bg-gray-825 shadow-xl rounded";
  function Dashboard() {
    const isRealTimeDashboard2 = useIsRealtimeDashboard();
    const [importedDataInView, setImportedDataInView] = (0, import_react73.useState)(false);
    if (isRealTimeDashboard2) {
      return /* @__PURE__ */ import_react73.default.createElement(realtime_default, null);
    } else {
      return /* @__PURE__ */ import_react73.default.createElement(
        historical_default,
        {
          importedDataInView,
          updateImportedDataInView: setImportedDataInView
        }
      );
    }
  }
  var dashboard_default = Dashboard;

  // js/dashboard/stats/modals/sources.js
  var import_react77 = __toESM(require_react());

  // js/dashboard/stats/modals/modal.js
  var import_react74 = __toESM(require_react());
  var import_react_dom3 = __toESM(require_react_dom());
  var MD_WIDTH = 768;
  var DEFAULT_WIDTH = 1080;
  var Modal = class extends import_react74.default.Component {
    constructor(props) {
      super(props);
      this.state = {
        viewport: DEFAULT_WIDTH
      };
      this.node = import_react74.default.createRef();
      this.handleClickOutside = this.handleClickOutside.bind(this);
      this.handleKeyup = this.handleKeyup.bind(this);
      this.handleResize = this.handleResize.bind(this);
    }
    componentDidMount() {
      document.body.style.overflow = "hidden";
      document.body.style.height = "100vh";
      document.addEventListener("mousedown", this.handleClickOutside);
      document.addEventListener("keyup", this.handleKeyup);
      window.addEventListener("resize", this.handleResize, false);
      this.handleResize();
    }
    componentWillUnmount() {
      document.body.style.overflow = null;
      document.body.style.height = null;
      document.removeEventListener("mousedown", this.handleClickOutside);
      document.removeEventListener("keyup", this.handleKeyup);
      window.removeEventListener("resize", this.handleResize, false);
    }
    handleClickOutside(e3) {
      if (this.node.current.contains(e3.target)) {
        return;
      }
      this.close();
    }
    handleKeyup(e3) {
      if (!shouldIgnoreKeypress(e3) && e3.code === "Escape") {
        this.close();
      }
    }
    handleResize() {
      this.setState({ viewport: window.innerWidth });
    }
    close() {
      this.props.navigate({
        to: rootRoute.to,
        search: (search) => search
      });
    }
    /**
     * @description
     * Decide whether to set max-width, and if so, to what.
     * If no max-width is available, set width instead to min-content such that we can rely on widths set on th.
     * On >md, we use the same behaviour as before: set width to 800 pixels.
     * Note that When a max-width comes from the parent component, we rely on that *always*.
     */
    getStyle() {
      const { maxWidth } = this.props;
      const { viewport: viewport2 } = this.state;
      const styleObject = {};
      if (maxWidth) {
        styleObject.maxWidth = maxWidth;
      } else {
        styleObject.width = viewport2 <= MD_WIDTH ? "min-content" : "860px";
      }
      return styleObject;
    }
    render() {
      return (0, import_react_dom3.createPortal)(
        /* @__PURE__ */ import_react74.default.createElement("div", { className: "modal is-open", onClick: this.props.onClick }, /* @__PURE__ */ import_react74.default.createElement("div", { className: "modal__overlay" }, /* @__PURE__ */ import_react74.default.createElement("button", { className: "modal__close" }), /* @__PURE__ */ import_react74.default.createElement(
          "div",
          {
            ref: this.node,
            className: "modal__container dark:bg-gray-800",
            style: this.getStyle()
          },
          this.props.children
        ))),
        document.getElementById("modal_root")
      );
    }
  };
  function ModalWithRouting(props) {
    const navigate = useNavigate();
    const location = useLocation();
    return /* @__PURE__ */ import_react74.default.createElement(Modal, __spreadProps(__spreadValues({}, props), { navigate, location }));
  }

  // js/dashboard/stats/modals/breakdown-modal.js
  var import_react76 = __toESM(require_react());

  // js/dashboard/hooks/api-client.js
  var import_react75 = __toESM(require_react());

  // node_modules/@tanstack/query-core/build/modern/subscribable.js
  var Subscribable = class {
    constructor() {
      this.listeners = /* @__PURE__ */ new Set();
      this.subscribe = this.subscribe.bind(this);
    }
    subscribe(listener) {
      this.listeners.add(listener);
      this.onSubscribe();
      return () => {
        this.listeners.delete(listener);
        this.onUnsubscribe();
      };
    }
    hasListeners() {
      return this.listeners.size > 0;
    }
    onSubscribe() {
    }
    onUnsubscribe() {
    }
  };

  // node_modules/@tanstack/query-core/build/modern/utils.js
  var isServer = typeof window === "undefined" || "Deno" in globalThis;
  function noop2() {
    return void 0;
  }
  function functionalUpdate2(updater, input) {
    return typeof updater === "function" ? updater(input) : updater;
  }
  function isValidTimeout(value) {
    return typeof value === "number" && value >= 0 && value !== Infinity;
  }
  function timeUntilStale(updatedAt, staleTime) {
    return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
  }
  function resolveStaleTime(staleTime, query) {
    return typeof staleTime === "function" ? staleTime(query) : staleTime;
  }
  function resolveEnabled(enabled, query) {
    return typeof enabled === "function" ? enabled(query) : enabled;
  }
  function matchQuery(filters, query) {
    const {
      type = "all",
      exact,
      fetchStatus,
      predicate,
      queryKey,
      stale
    } = filters;
    if (queryKey) {
      if (exact) {
        if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
          return false;
        }
      } else if (!partialMatchKey(query.queryKey, queryKey)) {
        return false;
      }
    }
    if (type !== "all") {
      const isActive = query.isActive();
      if (type === "active" && !isActive) {
        return false;
      }
      if (type === "inactive" && isActive) {
        return false;
      }
    }
    if (typeof stale === "boolean" && query.isStale() !== stale) {
      return false;
    }
    if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
      return false;
    }
    if (predicate && !predicate(query)) {
      return false;
    }
    return true;
  }
  function matchMutation(filters, mutation) {
    const { exact, status, predicate, mutationKey } = filters;
    if (mutationKey) {
      if (!mutation.options.mutationKey) {
        return false;
      }
      if (exact) {
        if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
          return false;
        }
      } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
        return false;
      }
    }
    if (status && mutation.state.status !== status) {
      return false;
    }
    if (predicate && !predicate(mutation)) {
      return false;
    }
    return true;
  }
  function hashQueryKeyByOptions(queryKey, options) {
    const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashKey;
    return hashFn(queryKey);
  }
  function hashKey(queryKey) {
    return JSON.stringify(
      queryKey,
      (_2, val) => isPlainObject2(val) ? Object.keys(val).sort().reduce((result, key) => {
        result[key] = val[key];
        return result;
      }, {}) : val
    );
  }
  function partialMatchKey(a3, b2) {
    if (a3 === b2) {
      return true;
    }
    if (typeof a3 !== typeof b2) {
      return false;
    }
    if (a3 && b2 && typeof a3 === "object" && typeof b2 === "object") {
      return !Object.keys(b2).some((key) => !partialMatchKey(a3[key], b2[key]));
    }
    return false;
  }
  function replaceEqualDeep2(a3, b2) {
    if (a3 === b2) {
      return a3;
    }
    const array = isPlainArray2(a3) && isPlainArray2(b2);
    if (array || isPlainObject2(a3) && isPlainObject2(b2)) {
      const aItems = array ? a3 : Object.keys(a3);
      const aSize = aItems.length;
      const bItems = array ? b2 : Object.keys(b2);
      const bSize = bItems.length;
      const copy = array ? [] : {};
      let equalItems = 0;
      for (let i5 = 0; i5 < bSize; i5++) {
        const key = array ? i5 : bItems[i5];
        if ((!array && aItems.includes(key) || array) && a3[key] === void 0 && b2[key] === void 0) {
          copy[key] = void 0;
          equalItems++;
        } else {
          copy[key] = replaceEqualDeep2(a3[key], b2[key]);
          if (copy[key] === a3[key] && a3[key] !== void 0) {
            equalItems++;
          }
        }
      }
      return aSize === bSize && equalItems === aSize ? a3 : copy;
    }
    return b2;
  }
  function shallowEqualObjects(a3, b2) {
    if (!b2 || Object.keys(a3).length !== Object.keys(b2).length) {
      return false;
    }
    for (const key in a3) {
      if (a3[key] !== b2[key]) {
        return false;
      }
    }
    return true;
  }
  function isPlainArray2(value) {
    return Array.isArray(value) && value.length === Object.keys(value).length;
  }
  function isPlainObject2(o10) {
    if (!hasObjectPrototype2(o10)) {
      return false;
    }
    const ctor = o10.constructor;
    if (ctor === void 0) {
      return true;
    }
    const prot = ctor.prototype;
    if (!hasObjectPrototype2(prot)) {
      return false;
    }
    if (!prot.hasOwnProperty("isPrototypeOf")) {
      return false;
    }
    if (Object.getPrototypeOf(o10) !== Object.prototype) {
      return false;
    }
    return true;
  }
  function hasObjectPrototype2(o10) {
    return Object.prototype.toString.call(o10) === "[object Object]";
  }
  function sleep(ms) {
    return new Promise((resolve2) => {
      setTimeout(resolve2, ms);
    });
  }
  function replaceData(prevData, data, options) {
    if (typeof options.structuralSharing === "function") {
      return options.structuralSharing(prevData, data);
    } else if (options.structuralSharing !== false) {
      return replaceEqualDeep2(prevData, data);
    }
    return data;
  }
  function addToEnd(items, item, max2 = 0) {
    const newItems = [...items, item];
    return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
  }
  function addToStart(items, item, max2 = 0) {
    const newItems = [item, ...items];
    return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
  }
  var skipToken = Symbol();
  var ensureQueryFn = (options, fetchOptions) => {
    if (true) {
      if (options.queryFn === skipToken) {
        console.error(
          `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`
        );
      }
    }
    if (!options.queryFn && (fetchOptions == null ? void 0 : fetchOptions.initialPromise)) {
      return () => fetchOptions.initialPromise;
    }
    if (!options.queryFn || options.queryFn === skipToken) {
      return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
    }
    return options.queryFn;
  };

  // node_modules/@tanstack/query-core/build/modern/focusManager.js
  var _focused, _cleanup, _setup, _a;
  var FocusManager = (_a = class extends Subscribable {
    constructor() {
      super();
      __privateAdd(this, _focused);
      __privateAdd(this, _cleanup);
      __privateAdd(this, _setup);
      __privateSet(this, _setup, (onFocus) => {
        if (!isServer && window.addEventListener) {
          const listener = () => onFocus();
          window.addEventListener("visibilitychange", listener, false);
          return () => {
            window.removeEventListener("visibilitychange", listener);
          };
        }
        return;
      });
    }
    onSubscribe() {
      if (!__privateGet(this, _cleanup)) {
        this.setEventListener(__privateGet(this, _setup));
      }
    }
    onUnsubscribe() {
      var _a9;
      if (!this.hasListeners()) {
        (_a9 = __privateGet(this, _cleanup)) == null ? void 0 : _a9.call(this);
        __privateSet(this, _cleanup, void 0);
      }
    }
    setEventListener(setup) {
      var _a9;
      __privateSet(this, _setup, setup);
      (_a9 = __privateGet(this, _cleanup)) == null ? void 0 : _a9.call(this);
      __privateSet(this, _cleanup, setup((focused) => {
        if (typeof focused === "boolean") {
          this.setFocused(focused);
        } else {
          this.onFocus();
        }
      }));
    }
    setFocused(focused) {
      const changed = __privateGet(this, _focused) !== focused;
      if (changed) {
        __privateSet(this, _focused, focused);
        this.onFocus();
      }
    }
    onFocus() {
      const isFocused = this.isFocused();
      this.listeners.forEach((listener) => {
        listener(isFocused);
      });
    }
    isFocused() {
      var _a9;
      if (typeof __privateGet(this, _focused) === "boolean") {
        return __privateGet(this, _focused);
      }
      return ((_a9 = globalThis.document) == null ? void 0 : _a9.visibilityState) !== "hidden";
    }
  }, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
  var focusManager = new FocusManager();

  // node_modules/@tanstack/query-core/build/modern/onlineManager.js
  var _online, _cleanup2, _setup2, _a2;
  var OnlineManager = (_a2 = class extends Subscribable {
    constructor() {
      super();
      __privateAdd(this, _online, true);
      __privateAdd(this, _cleanup2);
      __privateAdd(this, _setup2);
      __privateSet(this, _setup2, (onOnline) => {
        if (!isServer && window.addEventListener) {
          const onlineListener = () => onOnline(true);
          const offlineListener = () => onOnline(false);
          window.addEventListener("online", onlineListener, false);
          window.addEventListener("offline", offlineListener, false);
          return () => {
            window.removeEventListener("online", onlineListener);
            window.removeEventListener("offline", offlineListener);
          };
        }
        return;
      });
    }
    onSubscribe() {
      if (!__privateGet(this, _cleanup2)) {
        this.setEventListener(__privateGet(this, _setup2));
      }
    }
    onUnsubscribe() {
      var _a9;
      if (!this.hasListeners()) {
        (_a9 = __privateGet(this, _cleanup2)) == null ? void 0 : _a9.call(this);
        __privateSet(this, _cleanup2, void 0);
      }
    }
    setEventListener(setup) {
      var _a9;
      __privateSet(this, _setup2, setup);
      (_a9 = __privateGet(this, _cleanup2)) == null ? void 0 : _a9.call(this);
      __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
    }
    setOnline(online) {
      const changed = __privateGet(this, _online) !== online;
      if (changed) {
        __privateSet(this, _online, online);
        this.listeners.forEach((listener) => {
          listener(online);
        });
      }
    }
    isOnline() {
      return __privateGet(this, _online);
    }
  }, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _a2);
  var onlineManager = new OnlineManager();

  // node_modules/@tanstack/query-core/build/modern/retryer.js
  function defaultRetryDelay(failureCount) {
    return Math.min(1e3 * 2 ** failureCount, 3e4);
  }
  function canFetch(networkMode) {
    return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
  }
  var CancelledError = class {
    constructor(options) {
      this.revert = options == null ? void 0 : options.revert;
      this.silent = options == null ? void 0 : options.silent;
    }
  };
  function isCancelledError(value) {
    return value instanceof CancelledError;
  }
  function createRetryer(config) {
    let isRetryCancelled = false;
    let failureCount = 0;
    let isResolved = false;
    let continueFn;
    let promiseResolve;
    let promiseReject;
    const promise = new Promise((outerResolve, outerReject) => {
      promiseResolve = outerResolve;
      promiseReject = outerReject;
    });
    const cancel = (cancelOptions) => {
      var _a9;
      if (!isResolved) {
        reject(new CancelledError(cancelOptions));
        (_a9 = config.abort) == null ? void 0 : _a9.call(config);
      }
    };
    const cancelRetry = () => {
      isRetryCancelled = true;
    };
    const continueRetry = () => {
      isRetryCancelled = false;
    };
    const canContinue = () => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun();
    const canStart = () => canFetch(config.networkMode) && config.canRun();
    const resolve2 = (value) => {
      var _a9;
      if (!isResolved) {
        isResolved = true;
        (_a9 = config.onSuccess) == null ? void 0 : _a9.call(config, value);
        continueFn == null ? void 0 : continueFn();
        promiseResolve(value);
      }
    };
    const reject = (value) => {
      var _a9;
      if (!isResolved) {
        isResolved = true;
        (_a9 = config.onError) == null ? void 0 : _a9.call(config, value);
        continueFn == null ? void 0 : continueFn();
        promiseReject(value);
      }
    };
    const pause = () => {
      return new Promise((continueResolve) => {
        var _a9;
        continueFn = (value) => {
          if (isResolved || canContinue()) {
            continueResolve(value);
          }
        };
        (_a9 = config.onPause) == null ? void 0 : _a9.call(config);
      }).then(() => {
        var _a9;
        continueFn = void 0;
        if (!isResolved) {
          (_a9 = config.onContinue) == null ? void 0 : _a9.call(config);
        }
      });
    };
    const run = () => {
      if (isResolved) {
        return;
      }
      let promiseOrValue;
      const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
      try {
        promiseOrValue = initialPromise != null ? initialPromise : config.fn();
      } catch (error) {
        promiseOrValue = Promise.reject(error);
      }
      Promise.resolve(promiseOrValue).then(resolve2).catch((error) => {
        var _a9, _b2, _c;
        if (isResolved) {
          return;
        }
        const retry = (_a9 = config.retry) != null ? _a9 : isServer ? 0 : 3;
        const retryDelay = (_b2 = config.retryDelay) != null ? _b2 : defaultRetryDelay;
        const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
        const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
        if (isRetryCancelled || !shouldRetry) {
          reject(error);
          return;
        }
        failureCount++;
        (_c = config.onFail) == null ? void 0 : _c.call(config, failureCount, error);
        sleep(delay).then(() => {
          return canContinue() ? void 0 : pause();
        }).then(() => {
          if (isRetryCancelled) {
            reject(error);
          } else {
            run();
          }
        });
      });
    };
    return {
      promise,
      cancel,
      continue: () => {
        continueFn == null ? void 0 : continueFn();
        return promise;
      },
      cancelRetry,
      continueRetry,
      canStart,
      start: () => {
        if (canStart()) {
          run();
        } else {
          pause().then(run);
        }
        return promise;
      }
    };
  }

  // node_modules/@tanstack/query-core/build/modern/notifyManager.js
  function createNotifyManager() {
    let queue = [];
    let transactions = 0;
    let notifyFn = (callback2) => {
      callback2();
    };
    let batchNotifyFn = (callback2) => {
      callback2();
    };
    let scheduleFn = (cb) => setTimeout(cb, 0);
    const setScheduler = (fn2) => {
      scheduleFn = fn2;
    };
    const batch = (callback2) => {
      let result;
      transactions++;
      try {
        result = callback2();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    };
    const schedule = (callback2) => {
      if (transactions) {
        queue.push(callback2);
      } else {
        scheduleFn(() => {
          notifyFn(callback2);
        });
      }
    };
    const batchCalls = (callback2) => {
      return (...args) => {
        schedule(() => {
          callback2(...args);
        });
      };
    };
    const flush = () => {
      const originalQueue = queue;
      queue = [];
      if (originalQueue.length) {
        scheduleFn(() => {
          batchNotifyFn(() => {
            originalQueue.forEach((callback2) => {
              notifyFn(callback2);
            });
          });
        });
      }
    };
    const setNotifyFunction = (fn2) => {
      notifyFn = fn2;
    };
    const setBatchNotifyFunction = (fn2) => {
      batchNotifyFn = fn2;
    };
    return {
      batch,
      batchCalls,
      schedule,
      setNotifyFunction,
      setBatchNotifyFunction,
      setScheduler
    };
  }
  var notifyManager = createNotifyManager();

  // node_modules/@tanstack/query-core/build/modern/removable.js
  var _gcTimeout, _a3;
  var Removable = (_a3 = class {
    constructor() {
      __privateAdd(this, _gcTimeout);
    }
    destroy() {
      this.clearGcTimeout();
    }
    scheduleGc() {
      this.clearGcTimeout();
      if (isValidTimeout(this.gcTime)) {
        __privateSet(this, _gcTimeout, setTimeout(() => {
          this.optionalRemove();
        }, this.gcTime));
      }
    }
    updateGcTime(newGcTime) {
      this.gcTime = Math.max(
        this.gcTime || 0,
        newGcTime != null ? newGcTime : isServer ? Infinity : 5 * 60 * 1e3
      );
    }
    clearGcTimeout() {
      if (__privateGet(this, _gcTimeout)) {
        clearTimeout(__privateGet(this, _gcTimeout));
        __privateSet(this, _gcTimeout, void 0);
      }
    }
  }, _gcTimeout = new WeakMap(), _a3);

  // node_modules/@tanstack/query-core/build/modern/query.js
  var _initialState, _revertState, _cache, _retryer, _defaultOptions, _abortSignalConsumed, _Query_instances, dispatch_fn, _a4;
  var Query = (_a4 = class extends Removable {
    constructor(config) {
      super();
      __privateAdd(this, _Query_instances);
      __privateAdd(this, _initialState);
      __privateAdd(this, _revertState);
      __privateAdd(this, _cache);
      __privateAdd(this, _retryer);
      __privateAdd(this, _defaultOptions);
      __privateAdd(this, _abortSignalConsumed);
      __privateSet(this, _abortSignalConsumed, false);
      __privateSet(this, _defaultOptions, config.defaultOptions);
      this.setOptions(config.options);
      this.observers = [];
      __privateSet(this, _cache, config.cache);
      this.queryKey = config.queryKey;
      this.queryHash = config.queryHash;
      __privateSet(this, _initialState, config.state || getDefaultState(this.options));
      this.state = __privateGet(this, _initialState);
      this.scheduleGc();
    }
    get meta() {
      return this.options.meta;
    }
    get promise() {
      var _a9;
      return (_a9 = __privateGet(this, _retryer)) == null ? void 0 : _a9.promise;
    }
    setOptions(options) {
      this.options = __spreadValues(__spreadValues({}, __privateGet(this, _defaultOptions)), options);
      this.updateGcTime(this.options.gcTime);
    }
    optionalRemove() {
      if (!this.observers.length && this.state.fetchStatus === "idle") {
        __privateGet(this, _cache).remove(this);
      }
    }
    setData(newData, options) {
      const data = replaceData(this.state.data, newData, this.options);
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
        data,
        type: "success",
        dataUpdatedAt: options == null ? void 0 : options.updatedAt,
        manual: options == null ? void 0 : options.manual
      });
      return data;
    }
    setState(state, setStateOptions) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
    }
    cancel(options) {
      var _a9, _b2;
      const promise = (_a9 = __privateGet(this, _retryer)) == null ? void 0 : _a9.promise;
      (_b2 = __privateGet(this, _retryer)) == null ? void 0 : _b2.cancel(options);
      return promise ? promise.then(noop2).catch(noop2) : Promise.resolve();
    }
    destroy() {
      super.destroy();
      this.cancel({ silent: true });
    }
    reset() {
      this.destroy();
      this.setState(__privateGet(this, _initialState));
    }
    isActive() {
      return this.observers.some(
        (observer) => resolveEnabled(observer.options.enabled, this) !== false
      );
    }
    isDisabled() {
      return this.getObserversCount() > 0 && !this.isActive();
    }
    isStale() {
      if (this.state.isInvalidated) {
        return true;
      }
      if (this.getObserversCount() > 0) {
        return this.observers.some(
          (observer) => observer.getCurrentResult().isStale
        );
      }
      return this.state.data === void 0;
    }
    isStaleByTime(staleTime = 0) {
      return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
    }
    onFocus() {
      var _a9;
      const observer = this.observers.find((x3) => x3.shouldFetchOnWindowFocus());
      observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
      (_a9 = __privateGet(this, _retryer)) == null ? void 0 : _a9.continue();
    }
    onOnline() {
      var _a9;
      const observer = this.observers.find((x3) => x3.shouldFetchOnReconnect());
      observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
      (_a9 = __privateGet(this, _retryer)) == null ? void 0 : _a9.continue();
    }
    addObserver(observer) {
      if (!this.observers.includes(observer)) {
        this.observers.push(observer);
        this.clearGcTimeout();
        __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
      }
    }
    removeObserver(observer) {
      if (this.observers.includes(observer)) {
        this.observers = this.observers.filter((x3) => x3 !== observer);
        if (!this.observers.length) {
          if (__privateGet(this, _retryer)) {
            if (__privateGet(this, _abortSignalConsumed)) {
              __privateGet(this, _retryer).cancel({ revert: true });
            } else {
              __privateGet(this, _retryer).cancelRetry();
            }
          }
          this.scheduleGc();
        }
        __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
      }
    }
    getObserversCount() {
      return this.observers.length;
    }
    invalidate() {
      if (!this.state.isInvalidated) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "invalidate" });
      }
    }
    fetch(options, fetchOptions) {
      var _a9, _b2, _c;
      if (this.state.fetchStatus !== "idle") {
        if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
          this.cancel({ silent: true });
        } else if (__privateGet(this, _retryer)) {
          __privateGet(this, _retryer).continueRetry();
          return __privateGet(this, _retryer).promise;
        }
      }
      if (options) {
        this.setOptions(options);
      }
      if (!this.options.queryFn) {
        const observer = this.observers.find((x3) => x3.options.queryFn);
        if (observer) {
          this.setOptions(observer.options);
        }
      }
      if (true) {
        if (!Array.isArray(this.options.queryKey)) {
          console.error(
            `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`
          );
        }
      }
      const abortController2 = new AbortController();
      const addSignalProperty = (object) => {
        Object.defineProperty(object, "signal", {
          enumerable: true,
          get: () => {
            __privateSet(this, _abortSignalConsumed, true);
            return abortController2.signal;
          }
        });
      };
      const fetchFn = () => {
        const queryFn = ensureQueryFn(this.options, fetchOptions);
        const queryFnContext = {
          queryKey: this.queryKey,
          meta: this.meta
        };
        addSignalProperty(queryFnContext);
        __privateSet(this, _abortSignalConsumed, false);
        if (this.options.persister) {
          return this.options.persister(
            queryFn,
            queryFnContext,
            this
          );
        }
        return queryFn(queryFnContext);
      };
      const context = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        state: this.state,
        fetchFn
      };
      addSignalProperty(context);
      (_a9 = this.options.behavior) == null ? void 0 : _a9.onFetch(
        context,
        this
      );
      __privateSet(this, _revertState, this.state);
      if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_b2 = context.fetchOptions) == null ? void 0 : _b2.meta)) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "fetch", meta: (_c = context.fetchOptions) == null ? void 0 : _c.meta });
      }
      const onError = (error) => {
        var _a10, _b3, _c2, _d;
        if (!(isCancelledError(error) && error.silent)) {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
            type: "error",
            error
          });
        }
        if (!isCancelledError(error)) {
          (_b3 = (_a10 = __privateGet(this, _cache).config).onError) == null ? void 0 : _b3.call(
            _a10,
            error,
            this
          );
          (_d = (_c2 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d.call(
            _c2,
            this.state.data,
            error,
            this
          );
        }
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      };
      __privateSet(this, _retryer, createRetryer({
        initialPromise: fetchOptions == null ? void 0 : fetchOptions.initialPromise,
        fn: context.fetchFn,
        abort: abortController2.abort.bind(abortController2),
        onSuccess: (data) => {
          var _a10, _b3, _c2, _d;
          if (data === void 0) {
            if (true) {
              console.error(
                `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
              );
            }
            onError(new Error(`${this.queryHash} data is undefined`));
            return;
          }
          this.setData(data);
          (_b3 = (_a10 = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _b3.call(_a10, data, this);
          (_d = (_c2 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d.call(
            _c2,
            data,
            this.state.error,
            this
          );
          if (!this.isFetchingOptimistic) {
            this.scheduleGc();
          }
          this.isFetchingOptimistic = false;
        },
        onError,
        onFail: (failureCount, error) => {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "failed", failureCount, error });
        },
        onPause: () => {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "pause" });
        },
        onContinue: () => {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "continue" });
        },
        retry: context.options.retry,
        retryDelay: context.options.retryDelay,
        networkMode: context.options.networkMode,
        canRun: () => true
      }));
      return __privateGet(this, _retryer).start();
    }
  }, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _Query_instances = new WeakSet(), dispatch_fn = function(action) {
    const reducer = (state) => {
      var _a9, _b2;
      switch (action.type) {
        case "failed":
          return __spreadProps(__spreadValues({}, state), {
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          });
        case "pause":
          return __spreadProps(__spreadValues({}, state), {
            fetchStatus: "paused"
          });
        case "continue":
          return __spreadProps(__spreadValues({}, state), {
            fetchStatus: "fetching"
          });
        case "fetch":
          return __spreadProps(__spreadValues(__spreadValues({}, state), fetchState(state.data, this.options)), {
            fetchMeta: (_a9 = action.meta) != null ? _a9 : null
          });
        case "success":
          return __spreadValues(__spreadProps(__spreadValues({}, state), {
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: (_b2 = action.dataUpdatedAt) != null ? _b2 : Date.now(),
            error: null,
            isInvalidated: false,
            status: "success"
          }), !action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          });
        case "error":
          const error = action.error;
          if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
            return __spreadProps(__spreadValues({}, __privateGet(this, _revertState)), { fetchStatus: "idle" });
          }
          return __spreadProps(__spreadValues({}, state), {
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error"
          });
        case "invalidate":
          return __spreadProps(__spreadValues({}, state), {
            isInvalidated: true
          });
        case "setState":
          return __spreadValues(__spreadValues({}, state), action.state);
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate();
      });
      __privateGet(this, _cache).notify({ query: this, type: "updated", action });
    });
  }, _a4);
  function fetchState(data, options) {
    return __spreadValues({
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused"
    }, data === void 0 && {
      error: null,
      status: "pending"
    });
  }
  function getDefaultState(options) {
    const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
    const hasData = data !== void 0;
    const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
    return {
      data,
      dataUpdateCount: 0,
      dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchMeta: null,
      isInvalidated: false,
      status: hasData ? "success" : "pending",
      fetchStatus: "idle"
    };
  }

  // node_modules/@tanstack/query-core/build/modern/queryCache.js
  var _queries, _a5;
  var QueryCache = (_a5 = class extends Subscribable {
    constructor(config = {}) {
      super();
      __privateAdd(this, _queries);
      this.config = config;
      __privateSet(this, _queries, /* @__PURE__ */ new Map());
    }
    build(client, options, state) {
      var _a9;
      const queryKey = options.queryKey;
      const queryHash = (_a9 = options.queryHash) != null ? _a9 : hashQueryKeyByOptions(queryKey, options);
      let query = this.get(queryHash);
      if (!query) {
        query = new Query({
          cache: this,
          queryKey,
          queryHash,
          options: client.defaultQueryOptions(options),
          state,
          defaultOptions: client.getQueryDefaults(queryKey)
        });
        this.add(query);
      }
      return query;
    }
    add(query) {
      if (!__privateGet(this, _queries).has(query.queryHash)) {
        __privateGet(this, _queries).set(query.queryHash, query);
        this.notify({
          type: "added",
          query
        });
      }
    }
    remove(query) {
      const queryInMap = __privateGet(this, _queries).get(query.queryHash);
      if (queryInMap) {
        query.destroy();
        if (queryInMap === query) {
          __privateGet(this, _queries).delete(query.queryHash);
        }
        this.notify({ type: "removed", query });
      }
    }
    clear() {
      notifyManager.batch(() => {
        this.getAll().forEach((query) => {
          this.remove(query);
        });
      });
    }
    get(queryHash) {
      return __privateGet(this, _queries).get(queryHash);
    }
    getAll() {
      return [...__privateGet(this, _queries).values()];
    }
    find(filters) {
      const defaultedFilters = __spreadValues({ exact: true }, filters);
      return this.getAll().find(
        (query) => matchQuery(defaultedFilters, query)
      );
    }
    findAll(filters = {}) {
      const queries = this.getAll();
      return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach((listener) => {
          listener(event);
        });
      });
    }
    onFocus() {
      notifyManager.batch(() => {
        this.getAll().forEach((query) => {
          query.onFocus();
        });
      });
    }
    onOnline() {
      notifyManager.batch(() => {
        this.getAll().forEach((query) => {
          query.onOnline();
        });
      });
    }
  }, _queries = new WeakMap(), _a5);

  // node_modules/@tanstack/query-core/build/modern/mutation.js
  var _observers, _mutationCache, _retryer2, _Mutation_instances, dispatch_fn2, _a6;
  var Mutation = (_a6 = class extends Removable {
    constructor(config) {
      super();
      __privateAdd(this, _Mutation_instances);
      __privateAdd(this, _observers);
      __privateAdd(this, _mutationCache);
      __privateAdd(this, _retryer2);
      this.mutationId = config.mutationId;
      __privateSet(this, _mutationCache, config.mutationCache);
      __privateSet(this, _observers, []);
      this.state = config.state || getDefaultState2();
      this.setOptions(config.options);
      this.scheduleGc();
    }
    setOptions(options) {
      this.options = options;
      this.updateGcTime(this.options.gcTime);
    }
    get meta() {
      return this.options.meta;
    }
    addObserver(observer) {
      if (!__privateGet(this, _observers).includes(observer)) {
        __privateGet(this, _observers).push(observer);
        this.clearGcTimeout();
        __privateGet(this, _mutationCache).notify({
          type: "observerAdded",
          mutation: this,
          observer
        });
      }
    }
    removeObserver(observer) {
      __privateSet(this, _observers, __privateGet(this, _observers).filter((x3) => x3 !== observer));
      this.scheduleGc();
      __privateGet(this, _mutationCache).notify({
        type: "observerRemoved",
        mutation: this,
        observer
      });
    }
    optionalRemove() {
      if (!__privateGet(this, _observers).length) {
        if (this.state.status === "pending") {
          this.scheduleGc();
        } else {
          __privateGet(this, _mutationCache).remove(this);
        }
      }
    }
    continue() {
      var _a9, _b2;
      return (_b2 = (_a9 = __privateGet(this, _retryer2)) == null ? void 0 : _a9.continue()) != null ? _b2 : (
        // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
        this.execute(this.state.variables)
      );
    }
    async execute(variables) {
      var _a9, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
      __privateSet(this, _retryer2, createRetryer({
        fn: () => {
          if (!this.options.mutationFn) {
            return Promise.reject(new Error("No mutationFn found"));
          }
          return this.options.mutationFn(variables);
        },
        onFail: (failureCount, error) => {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "failed", failureCount, error });
        },
        onPause: () => {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pause" });
        },
        onContinue: () => {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "continue" });
        },
        retry: (_a9 = this.options.retry) != null ? _a9 : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode,
        canRun: () => __privateGet(this, _mutationCache).canRun(this)
      }));
      const restored = this.state.status === "pending";
      const isPaused = !__privateGet(this, _retryer2).canStart();
      try {
        if (!restored) {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
          await ((_c = (_b2 = __privateGet(this, _mutationCache).config).onMutate) == null ? void 0 : _c.call(
            _b2,
            variables,
            this
          ));
          const context = await ((_e = (_d = this.options).onMutate) == null ? void 0 : _e.call(_d, variables));
          if (context !== this.state.context) {
            __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
              type: "pending",
              context,
              variables,
              isPaused
            });
          }
        }
        const data = await __privateGet(this, _retryer2).start();
        await ((_g = (_f = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _g.call(
          _f,
          data,
          variables,
          this.state.context,
          this
        ));
        await ((_i = (_h = this.options).onSuccess) == null ? void 0 : _i.call(_h, data, variables, this.state.context));
        await ((_k = (_j = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _k.call(
          _j,
          data,
          null,
          this.state.variables,
          this.state.context,
          this
        ));
        await ((_m = (_l = this.options).onSettled) == null ? void 0 : _m.call(_l, data, null, variables, this.state.context));
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "success", data });
        return data;
      } catch (error) {
        try {
          await ((_o = (_n = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _o.call(
            _n,
            error,
            variables,
            this.state.context,
            this
          ));
          await ((_q = (_p = this.options).onError) == null ? void 0 : _q.call(
            _p,
            error,
            variables,
            this.state.context
          ));
          await ((_s = (_r = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _s.call(
            _r,
            void 0,
            error,
            this.state.variables,
            this.state.context,
            this
          ));
          await ((_u = (_t = this.options).onSettled) == null ? void 0 : _u.call(
            _t,
            void 0,
            error,
            variables,
            this.state.context
          ));
          throw error;
        } finally {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "error", error });
        }
      } finally {
        __privateGet(this, _mutationCache).runNext(this);
      }
    }
  }, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _Mutation_instances = new WeakSet(), dispatch_fn2 = function(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return __spreadProps(__spreadValues({}, state), {
            failureCount: action.failureCount,
            failureReason: action.error
          });
        case "pause":
          return __spreadProps(__spreadValues({}, state), {
            isPaused: true
          });
        case "continue":
          return __spreadProps(__spreadValues({}, state), {
            isPaused: false
          });
        case "pending":
          return __spreadProps(__spreadValues({}, state), {
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: action.isPaused,
            status: "pending",
            variables: action.variables,
            submittedAt: Date.now()
          });
        case "success":
          return __spreadProps(__spreadValues({}, state), {
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          });
        case "error":
          return __spreadProps(__spreadValues({}, state), {
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          });
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      __privateGet(this, _observers).forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      __privateGet(this, _mutationCache).notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }, _a6);
  function getDefaultState2() {
    return {
      context: void 0,
      data: void 0,
      error: null,
      failureCount: 0,
      failureReason: null,
      isPaused: false,
      status: "idle",
      variables: void 0,
      submittedAt: 0
    };
  }

  // node_modules/@tanstack/query-core/build/modern/mutationCache.js
  var _mutations, _mutationId, _a7;
  var MutationCache = (_a7 = class extends Subscribable {
    constructor(config = {}) {
      super();
      __privateAdd(this, _mutations);
      __privateAdd(this, _mutationId);
      this.config = config;
      __privateSet(this, _mutations, /* @__PURE__ */ new Map());
      __privateSet(this, _mutationId, Date.now());
    }
    build(client, options, state) {
      const mutation = new Mutation({
        mutationCache: this,
        mutationId: ++__privateWrapper(this, _mutationId)._,
        options: client.defaultMutationOptions(options),
        state
      });
      this.add(mutation);
      return mutation;
    }
    add(mutation) {
      var _a9;
      const scope = scopeFor(mutation);
      const mutations = (_a9 = __privateGet(this, _mutations).get(scope)) != null ? _a9 : [];
      mutations.push(mutation);
      __privateGet(this, _mutations).set(scope, mutations);
      this.notify({ type: "added", mutation });
    }
    remove(mutation) {
      var _a9;
      const scope = scopeFor(mutation);
      if (__privateGet(this, _mutations).has(scope)) {
        const mutations = (_a9 = __privateGet(this, _mutations).get(scope)) == null ? void 0 : _a9.filter((x3) => x3 !== mutation);
        if (mutations) {
          if (mutations.length === 0) {
            __privateGet(this, _mutations).delete(scope);
          } else {
            __privateGet(this, _mutations).set(scope, mutations);
          }
        }
      }
      this.notify({ type: "removed", mutation });
    }
    canRun(mutation) {
      var _a9;
      const firstPendingMutation = (_a9 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a9.find((m5) => m5.state.status === "pending");
      return !firstPendingMutation || firstPendingMutation === mutation;
    }
    runNext(mutation) {
      var _a9, _b2;
      const foundMutation = (_a9 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a9.find((m5) => m5 !== mutation && m5.state.isPaused);
      return (_b2 = foundMutation == null ? void 0 : foundMutation.continue()) != null ? _b2 : Promise.resolve();
    }
    clear() {
      notifyManager.batch(() => {
        this.getAll().forEach((mutation) => {
          this.remove(mutation);
        });
      });
    }
    getAll() {
      return [...__privateGet(this, _mutations).values()].flat();
    }
    find(filters) {
      const defaultedFilters = __spreadValues({ exact: true }, filters);
      return this.getAll().find(
        (mutation) => matchMutation(defaultedFilters, mutation)
      );
    }
    findAll(filters = {}) {
      return this.getAll().filter((mutation) => matchMutation(filters, mutation));
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach((listener) => {
          listener(event);
        });
      });
    }
    resumePausedMutations() {
      const pausedMutations = this.getAll().filter((x3) => x3.state.isPaused);
      return notifyManager.batch(
        () => Promise.all(
          pausedMutations.map((mutation) => mutation.continue().catch(noop2))
        )
      );
    }
  }, _mutations = new WeakMap(), _mutationId = new WeakMap(), _a7);
  function scopeFor(mutation) {
    var _a9, _b2;
    return (_b2 = (_a9 = mutation.options.scope) == null ? void 0 : _a9.id) != null ? _b2 : String(mutation.mutationId);
  }

  // node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js
  function infiniteQueryBehavior(pages) {
    return {
      onFetch: (context, query) => {
        const fetchFn = async () => {
          var _a9, _b2, _c, _d, _e, _f;
          const options = context.options;
          const direction = (_c = (_b2 = (_a9 = context.fetchOptions) == null ? void 0 : _a9.meta) == null ? void 0 : _b2.fetchMore) == null ? void 0 : _c.direction;
          const oldPages = ((_d = context.state.data) == null ? void 0 : _d.pages) || [];
          const oldPageParams = ((_e = context.state.data) == null ? void 0 : _e.pageParams) || [];
          const empty = { pages: [], pageParams: [] };
          let cancelled = false;
          const addSignalProperty = (object) => {
            Object.defineProperty(object, "signal", {
              enumerable: true,
              get: () => {
                if (context.signal.aborted) {
                  cancelled = true;
                } else {
                  context.signal.addEventListener("abort", () => {
                    cancelled = true;
                  });
                }
                return context.signal;
              }
            });
          };
          const queryFn = ensureQueryFn(context.options, context.fetchOptions);
          const fetchPage = async (data, param, previous) => {
            if (cancelled) {
              return Promise.reject();
            }
            if (param == null && data.pages.length) {
              return Promise.resolve(data);
            }
            const queryFnContext = {
              queryKey: context.queryKey,
              pageParam: param,
              direction: previous ? "backward" : "forward",
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext);
            const page = await queryFn(
              queryFnContext
            );
            const { maxPages } = context.options;
            const addTo = previous ? addToStart : addToEnd;
            return {
              pages: addTo(data.pages, page, maxPages),
              pageParams: addTo(data.pageParams, param, maxPages)
            };
          };
          let result;
          if (direction && oldPages.length) {
            const previous = direction === "backward";
            const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
            const oldData = {
              pages: oldPages,
              pageParams: oldPageParams
            };
            const param = pageParamFn(options, oldData);
            result = await fetchPage(oldData, param, previous);
          } else {
            result = await fetchPage(
              empty,
              (_f = oldPageParams[0]) != null ? _f : options.initialPageParam
            );
            const remainingPages = pages != null ? pages : oldPages.length;
            for (let i5 = 1; i5 < remainingPages; i5++) {
              const param = getNextPageParam(options, result);
              result = await fetchPage(result, param);
            }
          }
          return result;
        };
        if (context.options.persister) {
          context.fetchFn = () => {
            var _a9, _b2;
            return (_b2 = (_a9 = context.options).persister) == null ? void 0 : _b2.call(
              _a9,
              fetchFn,
              {
                queryKey: context.queryKey,
                meta: context.options.meta,
                signal: context.signal
              },
              query
            );
          };
        } else {
          context.fetchFn = fetchFn;
        }
      }
    };
  }
  function getNextPageParam(options, { pages, pageParams }) {
    const lastIndex = pages.length - 1;
    return options.getNextPageParam(
      pages[lastIndex],
      pages,
      pageParams[lastIndex],
      pageParams
    );
  }
  function getPreviousPageParam(options, { pages, pageParams }) {
    var _a9;
    return (_a9 = options.getPreviousPageParam) == null ? void 0 : _a9.call(
      options,
      pages[0],
      pages,
      pageParams[0],
      pageParams
    );
  }
  function hasNextPage(options, data) {
    if (!data)
      return false;
    return getNextPageParam(options, data) != null;
  }
  function hasPreviousPage(options, data) {
    if (!data || !options.getPreviousPageParam)
      return false;
    return getPreviousPageParam(options, data) != null;
  }

  // node_modules/@tanstack/query-core/build/modern/queryClient.js
  var _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _a8;
  var QueryClient = (_a8 = class {
    constructor(config = {}) {
      __privateAdd(this, _queryCache);
      __privateAdd(this, _mutationCache2);
      __privateAdd(this, _defaultOptions2);
      __privateAdd(this, _queryDefaults);
      __privateAdd(this, _mutationDefaults);
      __privateAdd(this, _mountCount);
      __privateAdd(this, _unsubscribeFocus);
      __privateAdd(this, _unsubscribeOnline);
      __privateSet(this, _queryCache, config.queryCache || new QueryCache());
      __privateSet(this, _mutationCache2, config.mutationCache || new MutationCache());
      __privateSet(this, _defaultOptions2, config.defaultOptions || {});
      __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
      __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
      __privateSet(this, _mountCount, 0);
    }
    mount() {
      __privateWrapper(this, _mountCount)._++;
      if (__privateGet(this, _mountCount) !== 1)
        return;
      __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
        if (focused) {
          await this.resumePausedMutations();
          __privateGet(this, _queryCache).onFocus();
        }
      }));
      __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
        if (online) {
          await this.resumePausedMutations();
          __privateGet(this, _queryCache).onOnline();
        }
      }));
    }
    unmount() {
      var _a9, _b2;
      __privateWrapper(this, _mountCount)._--;
      if (__privateGet(this, _mountCount) !== 0)
        return;
      (_a9 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a9.call(this);
      __privateSet(this, _unsubscribeFocus, void 0);
      (_b2 = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b2.call(this);
      __privateSet(this, _unsubscribeOnline, void 0);
    }
    isFetching(filters) {
      return __privateGet(this, _queryCache).findAll(__spreadProps(__spreadValues({}, filters), { fetchStatus: "fetching" })).length;
    }
    isMutating(filters) {
      return __privateGet(this, _mutationCache2).findAll(__spreadProps(__spreadValues({}, filters), { status: "pending" })).length;
    }
    getQueryData(queryKey) {
      var _a9;
      const options = this.defaultQueryOptions({ queryKey });
      return (_a9 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a9.state.data;
    }
    ensureQueryData(options) {
      const cachedData = this.getQueryData(options.queryKey);
      if (cachedData === void 0)
        return this.fetchQuery(options);
      else {
        const defaultedOptions = this.defaultQueryOptions(options);
        const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
        if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
          void this.prefetchQuery(defaultedOptions);
        }
        return Promise.resolve(cachedData);
      }
    }
    getQueriesData(filters) {
      return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
        const data = state.data;
        return [queryKey, data];
      });
    }
    setQueryData(queryKey, updater, options) {
      const defaultedOptions = this.defaultQueryOptions({ queryKey });
      const query = __privateGet(this, _queryCache).get(
        defaultedOptions.queryHash
      );
      const prevData = query == null ? void 0 : query.state.data;
      const data = functionalUpdate2(updater, prevData);
      if (data === void 0) {
        return void 0;
      }
      return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data, __spreadProps(__spreadValues({}, options), { manual: true }));
    }
    setQueriesData(filters, updater, options) {
      return notifyManager.batch(
        () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
          queryKey,
          this.setQueryData(queryKey, updater, options)
        ])
      );
    }
    getQueryState(queryKey) {
      var _a9;
      const options = this.defaultQueryOptions({ queryKey });
      return (_a9 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a9.state;
    }
    removeQueries(filters) {
      const queryCache = __privateGet(this, _queryCache);
      notifyManager.batch(() => {
        queryCache.findAll(filters).forEach((query) => {
          queryCache.remove(query);
        });
      });
    }
    resetQueries(filters, options) {
      const queryCache = __privateGet(this, _queryCache);
      const refetchFilters = __spreadValues({
        type: "active"
      }, filters);
      return notifyManager.batch(() => {
        queryCache.findAll(filters).forEach((query) => {
          query.reset();
        });
        return this.refetchQueries(refetchFilters, options);
      });
    }
    cancelQueries(filters = {}, cancelOptions = {}) {
      const defaultedCancelOptions = __spreadValues({ revert: true }, cancelOptions);
      const promises = notifyManager.batch(
        () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
      );
      return Promise.all(promises).then(noop2).catch(noop2);
    }
    invalidateQueries(filters = {}, options = {}) {
      return notifyManager.batch(() => {
        var _a9, _b2;
        __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
          query.invalidate();
        });
        if (filters.refetchType === "none") {
          return Promise.resolve();
        }
        const refetchFilters = __spreadProps(__spreadValues({}, filters), {
          type: (_b2 = (_a9 = filters.refetchType) != null ? _a9 : filters.type) != null ? _b2 : "active"
        });
        return this.refetchQueries(refetchFilters, options);
      });
    }
    refetchQueries(filters = {}, options) {
      var _a9;
      const fetchOptions = __spreadProps(__spreadValues({}, options), {
        cancelRefetch: (_a9 = options == null ? void 0 : options.cancelRefetch) != null ? _a9 : true
      });
      const promises = notifyManager.batch(
        () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
          let promise = query.fetch(void 0, fetchOptions);
          if (!fetchOptions.throwOnError) {
            promise = promise.catch(noop2);
          }
          return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
        })
      );
      return Promise.all(promises).then(noop2);
    }
    fetchQuery(options) {
      const defaultedOptions = this.defaultQueryOptions(options);
      if (defaultedOptions.retry === void 0) {
        defaultedOptions.retry = false;
      }
      const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
      return query.isStaleByTime(
        resolveStaleTime(defaultedOptions.staleTime, query)
      ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
    }
    prefetchQuery(options) {
      return this.fetchQuery(options).then(noop2).catch(noop2);
    }
    fetchInfiniteQuery(options) {
      options.behavior = infiniteQueryBehavior(options.pages);
      return this.fetchQuery(options);
    }
    prefetchInfiniteQuery(options) {
      return this.fetchInfiniteQuery(options).then(noop2).catch(noop2);
    }
    resumePausedMutations() {
      if (onlineManager.isOnline()) {
        return __privateGet(this, _mutationCache2).resumePausedMutations();
      }
      return Promise.resolve();
    }
    getQueryCache() {
      return __privateGet(this, _queryCache);
    }
    getMutationCache() {
      return __privateGet(this, _mutationCache2);
    }
    getDefaultOptions() {
      return __privateGet(this, _defaultOptions2);
    }
    setDefaultOptions(options) {
      __privateSet(this, _defaultOptions2, options);
    }
    setQueryDefaults(queryKey, options) {
      __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
        queryKey,
        defaultOptions: options
      });
    }
    getQueryDefaults(queryKey) {
      const defaults2 = [...__privateGet(this, _queryDefaults).values()];
      let result = {};
      defaults2.forEach((queryDefault) => {
        if (partialMatchKey(queryKey, queryDefault.queryKey)) {
          result = __spreadValues(__spreadValues({}, result), queryDefault.defaultOptions);
        }
      });
      return result;
    }
    setMutationDefaults(mutationKey, options) {
      __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
        mutationKey,
        defaultOptions: options
      });
    }
    getMutationDefaults(mutationKey) {
      const defaults2 = [...__privateGet(this, _mutationDefaults).values()];
      let result = {};
      defaults2.forEach((queryDefault) => {
        if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
          result = __spreadValues(__spreadValues({}, result), queryDefault.defaultOptions);
        }
      });
      return result;
    }
    defaultQueryOptions(options) {
      if (options._defaulted) {
        return options;
      }
      const defaultedOptions = __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, __privateGet(this, _defaultOptions2).queries), this.getQueryDefaults(options.queryKey)), options), {
        _defaulted: true
      });
      if (!defaultedOptions.queryHash) {
        defaultedOptions.queryHash = hashQueryKeyByOptions(
          defaultedOptions.queryKey,
          defaultedOptions
        );
      }
      if (defaultedOptions.refetchOnReconnect === void 0) {
        defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
      }
      if (defaultedOptions.throwOnError === void 0) {
        defaultedOptions.throwOnError = !!defaultedOptions.suspense;
      }
      if (!defaultedOptions.networkMode && defaultedOptions.persister) {
        defaultedOptions.networkMode = "offlineFirst";
      }
      if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === skipToken) {
        defaultedOptions.enabled = false;
      }
      return defaultedOptions;
    }
    defaultMutationOptions(options) {
      if (options == null ? void 0 : options._defaulted) {
        return options;
      }
      return __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, __privateGet(this, _defaultOptions2).mutations), (options == null ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey)), options), {
        _defaulted: true
      });
    }
    clear() {
      __privateGet(this, _queryCache).clear();
      __privateGet(this, _mutationCache2).clear();
    }
  }, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _a8);

  // node_modules/@tanstack/query-core/build/modern/queryObserver.js
  var _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn, _b;
  var QueryObserver = (_b = class extends Subscribable {
    constructor(client, options) {
      super();
      __privateAdd(this, _QueryObserver_instances);
      __privateAdd(this, _client);
      __privateAdd(this, _currentQuery);
      __privateAdd(this, _currentQueryInitialState);
      __privateAdd(this, _currentResult);
      __privateAdd(this, _currentResultState);
      __privateAdd(this, _currentResultOptions);
      __privateAdd(this, _selectError);
      __privateAdd(this, _selectFn);
      __privateAdd(this, _selectResult);
      // This property keeps track of the last query with defined data.
      // It will be used to pass the previous data and query to the placeholder function between renders.
      __privateAdd(this, _lastQueryWithDefinedData);
      __privateAdd(this, _staleTimeoutId);
      __privateAdd(this, _refetchIntervalId);
      __privateAdd(this, _currentRefetchInterval);
      __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
      this.options = options;
      __privateSet(this, _client, client);
      __privateSet(this, _selectError, null);
      this.bindMethods();
      this.setOptions(options);
    }
    bindMethods() {
      this.refetch = this.refetch.bind(this);
    }
    onSubscribe() {
      if (this.listeners.size === 1) {
        __privateGet(this, _currentQuery).addObserver(this);
        if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {
          __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
        } else {
          this.updateResult();
        }
        __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
      }
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        this.destroy();
      }
    }
    shouldFetchOnReconnect() {
      return shouldFetchOn(
        __privateGet(this, _currentQuery),
        this.options,
        this.options.refetchOnReconnect
      );
    }
    shouldFetchOnWindowFocus() {
      return shouldFetchOn(
        __privateGet(this, _currentQuery),
        this.options,
        this.options.refetchOnWindowFocus
      );
    }
    destroy() {
      this.listeners = /* @__PURE__ */ new Set();
      __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
      __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
      __privateGet(this, _currentQuery).removeObserver(this);
    }
    setOptions(options, notifyOptions) {
      const prevOptions = this.options;
      const prevQuery = __privateGet(this, _currentQuery);
      this.options = __privateGet(this, _client).defaultQueryOptions(options);
      if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== "boolean") {
        throw new Error(
          "Expected enabled to be a boolean or a callback that returns a boolean"
        );
      }
      __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
      __privateGet(this, _currentQuery).setOptions(this.options);
      if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
        __privateGet(this, _client).getQueryCache().notify({
          type: "observerOptionsUpdated",
          query: __privateGet(this, _currentQuery),
          observer: this
        });
      }
      const mounted = this.hasListeners();
      if (mounted && shouldFetchOptionally(
        __privateGet(this, _currentQuery),
        prevQuery,
        this.options,
        prevOptions
      )) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      }
      this.updateResult(notifyOptions);
      if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {
        __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
      }
      const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);
      if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {
        __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);
      }
    }
    getOptimisticResult(options) {
      const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), options);
      const result = this.createResult(query, options);
      if (shouldAssignObserverCurrentProperties(this, result)) {
        __privateSet(this, _currentResult, result);
        __privateSet(this, _currentResultOptions, this.options);
        __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
      }
      return result;
    }
    getCurrentResult() {
      return __privateGet(this, _currentResult);
    }
    trackResult(result, onPropTracked) {
      const trackedResult = {};
      Object.keys(result).forEach((key) => {
        Object.defineProperty(trackedResult, key, {
          configurable: false,
          enumerable: true,
          get: () => {
            this.trackProp(key);
            onPropTracked == null ? void 0 : onPropTracked(key);
            return result[key];
          }
        });
      });
      return trackedResult;
    }
    trackProp(key) {
      __privateGet(this, _trackedProps).add(key);
    }
    getCurrentQuery() {
      return __privateGet(this, _currentQuery);
    }
    refetch(_a9 = {}) {
      var options = __objRest(_a9, []);
      return this.fetch(__spreadValues({}, options));
    }
    fetchOptimistic(options) {
      const defaultedOptions = __privateGet(this, _client).defaultQueryOptions(options);
      const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), defaultedOptions);
      query.isFetchingOptimistic = true;
      return query.fetch().then(() => this.createResult(query, defaultedOptions));
    }
    fetch(fetchOptions) {
      var _a9;
      return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, __spreadProps(__spreadValues({}, fetchOptions), {
        cancelRefetch: (_a9 = fetchOptions.cancelRefetch) != null ? _a9 : true
      })).then(() => {
        this.updateResult();
        return __privateGet(this, _currentResult);
      });
    }
    createResult(query, options) {
      var _a9;
      const prevQuery = __privateGet(this, _currentQuery);
      const prevOptions = this.options;
      const prevResult = __privateGet(this, _currentResult);
      const prevResultState = __privateGet(this, _currentResultState);
      const prevResultOptions = __privateGet(this, _currentResultOptions);
      const queryChange = query !== prevQuery;
      const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);
      const { state } = query;
      let newState = __spreadValues({}, state);
      let isPlaceholderData = false;
      let data;
      if (options._optimisticResults) {
        const mounted = this.hasListeners();
        const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
        const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
        if (fetchOnMount || fetchOptionally) {
          newState = __spreadValues(__spreadValues({}, newState), fetchState(state.data, query.options));
        }
        if (options._optimisticResults === "isRestoring") {
          newState.fetchStatus = "idle";
        }
      }
      let { error, errorUpdatedAt, status } = newState;
      if (options.select && newState.data !== void 0) {
        if (prevResult && newState.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === __privateGet(this, _selectFn)) {
          data = __privateGet(this, _selectResult);
        } else {
          try {
            __privateSet(this, _selectFn, options.select);
            data = options.select(newState.data);
            data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
            __privateSet(this, _selectResult, data);
            __privateSet(this, _selectError, null);
          } catch (selectError) {
            __privateSet(this, _selectError, selectError);
          }
        }
      } else {
        data = newState.data;
      }
      if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
        let placeholderData;
        if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
          placeholderData = prevResult.data;
        } else {
          placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
            (_a9 = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a9.state.data,
            __privateGet(this, _lastQueryWithDefinedData)
          ) : options.placeholderData;
          if (options.select && placeholderData !== void 0) {
            try {
              placeholderData = options.select(placeholderData);
              __privateSet(this, _selectError, null);
            } catch (selectError) {
              __privateSet(this, _selectError, selectError);
            }
          }
        }
        if (placeholderData !== void 0) {
          status = "success";
          data = replaceData(
            prevResult == null ? void 0 : prevResult.data,
            placeholderData,
            options
          );
          isPlaceholderData = true;
        }
      }
      if (__privateGet(this, _selectError)) {
        error = __privateGet(this, _selectError);
        data = __privateGet(this, _selectResult);
        errorUpdatedAt = Date.now();
        status = "error";
      }
      const isFetching = newState.fetchStatus === "fetching";
      const isPending = status === "pending";
      const isError = status === "error";
      const isLoading = isPending && isFetching;
      const hasData = data !== void 0;
      const result = {
        status,
        fetchStatus: newState.fetchStatus,
        isPending,
        isSuccess: status === "success",
        isError,
        isInitialLoading: isLoading,
        isLoading,
        data,
        dataUpdatedAt: newState.dataUpdatedAt,
        error,
        errorUpdatedAt,
        failureCount: newState.fetchFailureCount,
        failureReason: newState.fetchFailureReason,
        errorUpdateCount: newState.errorUpdateCount,
        isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
        isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
        isFetching,
        isRefetching: isFetching && !isPending,
        isLoadingError: isError && !hasData,
        isPaused: newState.fetchStatus === "paused",
        isPlaceholderData,
        isRefetchError: isError && hasData,
        isStale: isStale(query, options),
        refetch: this.refetch
      };
      return result;
    }
    updateResult(notifyOptions) {
      const prevResult = __privateGet(this, _currentResult);
      const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);
      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
      __privateSet(this, _currentResultOptions, this.options);
      if (__privateGet(this, _currentResultState).data !== void 0) {
        __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));
      }
      if (shallowEqualObjects(nextResult, prevResult)) {
        return;
      }
      __privateSet(this, _currentResult, nextResult);
      const defaultNotifyOptions = {};
      const shouldNotifyListeners = () => {
        if (!prevResult) {
          return true;
        }
        const { notifyOnChangeProps } = this.options;
        const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
        if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {
          return true;
        }
        const includedProps = new Set(
          notifyOnChangePropsValue != null ? notifyOnChangePropsValue : __privateGet(this, _trackedProps)
        );
        if (this.options.throwOnError) {
          includedProps.add("error");
        }
        return Object.keys(__privateGet(this, _currentResult)).some((key) => {
          const typedKey = key;
          const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];
          return changed && includedProps.has(typedKey);
        });
      };
      if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
        defaultNotifyOptions.listeners = true;
      }
      __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, __spreadValues(__spreadValues({}, defaultNotifyOptions), notifyOptions));
    }
    onQueryUpdate() {
      this.updateResult();
      if (this.hasListeners()) {
        __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
      }
    }
  }, _client = new WeakMap(), _currentQuery = new WeakMap(), _currentQueryInitialState = new WeakMap(), _currentResult = new WeakMap(), _currentResultState = new WeakMap(), _currentResultOptions = new WeakMap(), _selectError = new WeakMap(), _selectFn = new WeakMap(), _selectResult = new WeakMap(), _lastQueryWithDefinedData = new WeakMap(), _staleTimeoutId = new WeakMap(), _refetchIntervalId = new WeakMap(), _currentRefetchInterval = new WeakMap(), _trackedProps = new WeakMap(), _QueryObserver_instances = new WeakSet(), executeFetch_fn = function(fetchOptions) {
    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
    let promise = __privateGet(this, _currentQuery).fetch(
      this.options,
      fetchOptions
    );
    if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
      promise = promise.catch(noop2);
    }
    return promise;
  }, updateStaleTimeout_fn = function() {
    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
    const staleTime = resolveStaleTime(
      this.options.staleTime,
      __privateGet(this, _currentQuery)
    );
    if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {
      return;
    }
    const time = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);
    const timeout = time + 1;
    __privateSet(this, _staleTimeoutId, setTimeout(() => {
      if (!__privateGet(this, _currentResult).isStale) {
        this.updateResult();
      }
    }, timeout));
  }, computeRefetchInterval_fn = function() {
    var _a9;
    return (_a9 = typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) != null ? _a9 : false;
  }, updateRefetchInterval_fn = function(nextInterval) {
    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
    __privateSet(this, _currentRefetchInterval, nextInterval);
    if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {
      return;
    }
    __privateSet(this, _refetchIntervalId, setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      }
    }, __privateGet(this, _currentRefetchInterval)));
  }, updateTimers_fn = function() {
    __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
    __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));
  }, clearStaleTimeout_fn = function() {
    if (__privateGet(this, _staleTimeoutId)) {
      clearTimeout(__privateGet(this, _staleTimeoutId));
      __privateSet(this, _staleTimeoutId, void 0);
    }
  }, clearRefetchInterval_fn = function() {
    if (__privateGet(this, _refetchIntervalId)) {
      clearInterval(__privateGet(this, _refetchIntervalId));
      __privateSet(this, _refetchIntervalId, void 0);
    }
  }, updateQuery_fn = function() {
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), this.options);
    if (query === __privateGet(this, _currentQuery)) {
      return;
    }
    const prevQuery = __privateGet(this, _currentQuery);
    __privateSet(this, _currentQuery, query);
    __privateSet(this, _currentQueryInitialState, query.state);
    if (this.hasListeners()) {
      prevQuery == null ? void 0 : prevQuery.removeObserver(this);
      query.addObserver(this);
    }
  }, notify_fn = function(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(__privateGet(this, _currentResult));
        });
      }
      __privateGet(this, _client).getQueryCache().notify({
        query: __privateGet(this, _currentQuery),
        type: "observerResultsUpdated"
      });
    });
  }, _b);
  function shouldLoadOnMount(query, options) {
    return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
  }
  function shouldFetchOnMount(query, options) {
    return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
  }
  function shouldFetchOn(query, options, field) {
    if (resolveEnabled(options.enabled, query) !== false) {
      const value = typeof field === "function" ? field(query) : field;
      return value === "always" || value !== false && isStale(query, options);
    }
    return false;
  }
  function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
    return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
  }
  function isStale(query, options) {
    return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
  }
  function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
    if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
      return true;
    }
    return false;
  }

  // node_modules/@tanstack/query-core/build/modern/infiniteQueryObserver.js
  var InfiniteQueryObserver = class extends QueryObserver {
    constructor(client, options) {
      super(client, options);
    }
    bindMethods() {
      super.bindMethods();
      this.fetchNextPage = this.fetchNextPage.bind(this);
      this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
    }
    setOptions(options, notifyOptions) {
      super.setOptions(
        __spreadProps(__spreadValues({}, options), {
          behavior: infiniteQueryBehavior()
        }),
        notifyOptions
      );
    }
    getOptimisticResult(options) {
      options.behavior = infiniteQueryBehavior();
      return super.getOptimisticResult(options);
    }
    fetchNextPage(options) {
      return this.fetch(__spreadProps(__spreadValues({}, options), {
        meta: {
          fetchMore: { direction: "forward" }
        }
      }));
    }
    fetchPreviousPage(options) {
      return this.fetch(__spreadProps(__spreadValues({}, options), {
        meta: {
          fetchMore: { direction: "backward" }
        }
      }));
    }
    createResult(query, options) {
      var _a9, _b2;
      const { state } = query;
      const parentResult = super.createResult(query, options);
      const { isFetching, isRefetching, isError, isRefetchError } = parentResult;
      const fetchDirection = (_b2 = (_a9 = state.fetchMeta) == null ? void 0 : _a9.fetchMore) == null ? void 0 : _b2.direction;
      const isFetchNextPageError = isError && fetchDirection === "forward";
      const isFetchingNextPage = isFetching && fetchDirection === "forward";
      const isFetchPreviousPageError = isError && fetchDirection === "backward";
      const isFetchingPreviousPage = isFetching && fetchDirection === "backward";
      const result = __spreadProps(__spreadValues({}, parentResult), {
        fetchNextPage: this.fetchNextPage,
        fetchPreviousPage: this.fetchPreviousPage,
        hasNextPage: hasNextPage(options, state.data),
        hasPreviousPage: hasPreviousPage(options, state.data),
        isFetchNextPageError,
        isFetchingNextPage,
        isFetchPreviousPageError,
        isFetchingPreviousPage,
        isRefetchError: isRefetchError && !isFetchNextPageError && !isFetchPreviousPageError,
        isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
      });
      return result;
    }
  };

  // node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js
  var React69 = __toESM(require_react(), 1);
  var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
  var QueryClientContext = React69.createContext(
    void 0
  );
  var useQueryClient = (queryClient2) => {
    const client = React69.useContext(QueryClientContext);
    if (queryClient2) {
      return queryClient2;
    }
    if (!client) {
      throw new Error("No QueryClient set, use QueryClientProvider to set one");
    }
    return client;
  };
  var QueryClientProvider = ({
    client,
    children
  }) => {
    React69.useEffect(() => {
      client.mount();
      return () => {
        client.unmount();
      };
    }, [client]);
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(QueryClientContext.Provider, { value: client, children });
  };

  // node_modules/@tanstack/react-query/build/modern/isRestoring.js
  var React70 = __toESM(require_react(), 1);
  var IsRestoringContext = React70.createContext(false);
  var useIsRestoring = () => React70.useContext(IsRestoringContext);
  var IsRestoringProvider = IsRestoringContext.Provider;

  // node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js
  var React71 = __toESM(require_react(), 1);
  var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
  function createValue() {
    let isReset = false;
    return {
      clearReset: () => {
        isReset = false;
      },
      reset: () => {
        isReset = true;
      },
      isReset: () => {
        return isReset;
      }
    };
  }
  var QueryErrorResetBoundaryContext = React71.createContext(createValue());
  var useQueryErrorResetBoundary = () => React71.useContext(QueryErrorResetBoundaryContext);

  // node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js
  var React72 = __toESM(require_react(), 1);

  // node_modules/@tanstack/react-query/build/modern/utils.js
  function shouldThrowError(throwError, params) {
    if (typeof throwError === "function") {
      return throwError(...params);
    }
    return !!throwError;
  }

  // node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js
  var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
    if (options.suspense || options.throwOnError) {
      if (!errorResetBoundary.isReset()) {
        options.retryOnMount = false;
      }
    }
  };
  var useClearResetErrorBoundary = (errorResetBoundary) => {
    React72.useEffect(() => {
      errorResetBoundary.clearReset();
    }, [errorResetBoundary]);
  };
  var getHasError = ({
    result,
    errorResetBoundary,
    throwOnError,
    query
  }) => {
    return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && shouldThrowError(throwOnError, [result.error, query]);
  };

  // node_modules/@tanstack/react-query/build/modern/suspense.js
  var ensureStaleTime = (defaultedOptions) => {
    if (defaultedOptions.suspense) {
      if (typeof defaultedOptions.staleTime !== "number") {
        defaultedOptions.staleTime = 1e3;
      }
    }
  };
  var shouldSuspend = (defaultedOptions, result) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && result.isPending;
  var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
    errorResetBoundary.clearReset();
  });

  // node_modules/@tanstack/react-query/build/modern/useBaseQuery.js
  var React73 = __toESM(require_react(), 1);
  function useBaseQuery(options, Observer, queryClient2) {
    var _a9, _b2, _c, _d;
    if (true) {
      if (typeof options !== "object" || Array.isArray(options)) {
        throw new Error(
          'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
        );
      }
    }
    const client = useQueryClient(queryClient2);
    const isRestoring = useIsRestoring();
    const errorResetBoundary = useQueryErrorResetBoundary();
    const defaultedOptions = client.defaultQueryOptions(options);
    (_b2 = (_a9 = client.getDefaultOptions().queries) == null ? void 0 : _a9._experimental_beforeQuery) == null ? void 0 : _b2.call(
      _a9,
      defaultedOptions
    );
    defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
    ensureStaleTime(defaultedOptions);
    ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
    useClearResetErrorBoundary(errorResetBoundary);
    const [observer] = React73.useState(
      () => new Observer(
        client,
        defaultedOptions
      )
    );
    const result = observer.getOptimisticResult(defaultedOptions);
    React73.useSyncExternalStore(
      React73.useCallback(
        (onStoreChange) => {
          const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));
          observer.updateResult();
          return unsubscribe;
        },
        [observer, isRestoring]
      ),
      () => observer.getCurrentResult(),
      () => observer.getCurrentResult()
    );
    React73.useEffect(() => {
      observer.setOptions(defaultedOptions, { listeners: false });
    }, [defaultedOptions, observer]);
    if (shouldSuspend(defaultedOptions, result)) {
      throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
    }
    if (getHasError({
      result,
      errorResetBoundary,
      throwOnError: defaultedOptions.throwOnError,
      query: client.getQueryCache().get(defaultedOptions.queryHash)
    })) {
      throw result.error;
    }
    ;
    (_d = (_c = client.getDefaultOptions().queries) == null ? void 0 : _c._experimental_afterQuery) == null ? void 0 : _d.call(
      _c,
      defaultedOptions,
      result
    );
    return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
  }

  // node_modules/@tanstack/react-query/build/modern/useInfiniteQuery.js
  function useInfiniteQuery(options, queryClient2) {
    return useBaseQuery(
      options,
      InfiniteQueryObserver,
      queryClient2
    );
  }

  // js/dashboard/hooks/api-client.js
  var LIMIT = 100;
  function useAPIClient(props) {
    const { key, getRequestParams, afterFetchData, afterFetchNextPage } = props;
    const [endpoint] = key;
    const queryClient2 = useQueryClient();
    const queryFn = async ({ pageParam, queryKey }) => {
      const [query, params] = getRequestParams(queryKey);
      params.limit = LIMIT;
      params.page = pageParam;
      const response = await get(endpoint, query, params);
      if (pageParam === 1 && typeof afterFetchData === "function") {
        afterFetchData(response);
      }
      if (pageParam > 1 && typeof afterFetchNextPage === "function") {
        afterFetchNextPage(response);
      }
      return response.results;
    };
    (0, import_react75.useEffect)(() => {
      const key2 = [endpoint];
      return () => {
        queryClient2.setQueriesData(key2, (data) => {
          var _a9;
          if ((_a9 = data == null ? void 0 : data.pages) == null ? void 0 : _a9.length) {
            return {
              pages: data.pages.slice(0, 1),
              pageParams: data.pageParams.slice(0, 1)
            };
          }
        });
      };
    }, [queryClient2, endpoint]);
    const getNextPageParam2 = (lastPageResults, _2, lastPageIndex) => {
      return lastPageResults.length === LIMIT ? lastPageIndex + 1 : null;
    };
    const defaultInitialPageParam = 1;
    const initialPageParam = props.initialPageParam === void 0 ? defaultInitialPageParam : props.initialPageParam;
    return useInfiniteQuery({
      queryKey: key,
      queryFn,
      getNextPageParam: getNextPageParam2,
      initialPageParam
    });
  }

  // js/dashboard/stats/modals/breakdown-modal.js
  var MIN_HEIGHT_PX = 500;
  function BreakdownModal({
    reportInfo,
    metrics,
    renderIcon,
    getExternalLinkURL,
    searchEnabled = true,
    afterFetchData,
    afterFetchNextPage,
    addSearchFilter,
    getFilterInfo
  }) {
    const searchBoxRef = (0, import_react76.useRef)(null);
    const { query } = useQueryContext();
    const [search, setSearch] = (0, import_react76.useState)("");
    const {
      data,
      hasNextPage: hasNextPage2,
      fetchNextPage,
      isFetchingNextPage,
      isFetching,
      isPending
    } = useAPIClient({
      key: [reportInfo.endpoint, { query, search }],
      getRequestParams: (key) => {
        const [_endpoint, { query: query2, search: search2 }] = key;
        let queryWithSearchFilter = __spreadValues({}, query2);
        if (searchEnabled && search2 !== "") {
          queryWithSearchFilter = addSearchFilter(query2, search2);
        }
        return [queryWithSearchFilter, { detailed: true }];
      },
      afterFetchData,
      afterFetchNextPage
    });
    (0, import_react76.useEffect)(() => {
      if (!searchEnabled) {
        return;
      }
      const searchBox = searchBoxRef.current;
      const handleKeyUp = (event) => {
        if (event.key === "Escape") {
          event.target.blur();
          event.stopPropagation();
        }
      };
      searchBox.addEventListener("keyup", handleKeyUp);
      return () => {
        searchBox.removeEventListener("keyup", handleKeyUp);
      };
    }, [searchEnabled]);
    function maybeRenderIcon(item) {
      if (typeof renderIcon === "function") {
        return renderIcon(item);
      }
    }
    function maybeRenderExternalLink(item) {
      if (typeof getExternalLinkURL === "function") {
        const linkUrl = getExternalLinkURL(item);
        if (!linkUrl) {
          return null;
        }
        return /* @__PURE__ */ import_react76.default.createElement("a", { target: "_blank", href: linkUrl, rel: "noreferrer", className: "hidden group-hover:block" }, /* @__PURE__ */ import_react76.default.createElement("svg", { className: "inline h-4 w-4 ml-1 -mt-1 text-gray-600 dark:text-gray-400", fill: "currentColor", viewBox: "0 0 20 20" }, /* @__PURE__ */ import_react76.default.createElement("path", { d: "M11 3a1 1 0 100 2h2.586l-6.293 6.293a1 1 0 101.414 1.414L15 6.414V9a1 1 0 102 0V4a1 1 0 00-1-1h-5z" }), /* @__PURE__ */ import_react76.default.createElement("path", { d: "M5 5a2 2 0 00-2 2v8a2 2 0 002 2h8a2 2 0 002-2v-3a1 1 0 10-2 0v3H5V7h3a1 1 0 000-2H5z" })));
      }
    }
    function renderRow(item) {
      return /* @__PURE__ */ import_react76.default.createElement("tr", { className: "text-sm dark:text-gray-200", key: item.name }, /* @__PURE__ */ import_react76.default.createElement("td", { className: "p-2 truncate flex items-center group" }, maybeRenderIcon(item), /* @__PURE__ */ import_react76.default.createElement(
        FilterLink,
        {
          to: rootRoute.to,
          filterInfo: getFilterInfo(item)
        },
        trimURL(item.name, 40)
      ), maybeRenderExternalLink(item)), metrics.map((metric) => {
        return /* @__PURE__ */ import_react76.default.createElement("td", { key: metric.key, className: "p-2 w-32 font-medium", align: "right" }, metric.renderValue(item[metric.key]));
      }));
    }
    function renderInitialLoadingSpinner() {
      return /* @__PURE__ */ import_react76.default.createElement("div", { className: "w-full h-full flex flex-col justify-center", style: { minHeight: `${MIN_HEIGHT_PX}px` } }, /* @__PURE__ */ import_react76.default.createElement("div", { className: "mx-auto loading" }, /* @__PURE__ */ import_react76.default.createElement("div", null)));
    }
    function renderSmallLoadingSpinner() {
      return /* @__PURE__ */ import_react76.default.createElement("div", { className: "loading sm" }, /* @__PURE__ */ import_react76.default.createElement("div", null));
    }
    function renderLoadMoreButton() {
      if (isPending) return null;
      if (!isFetching && !hasNextPage2) return null;
      return /* @__PURE__ */ import_react76.default.createElement("div", { className: "flex flex-col w-full my-4 items-center justify-center h-10" }, !isFetching && /* @__PURE__ */ import_react76.default.createElement("button", { onClick: fetchNextPage, type: "button", className: "button" }, "Load more"), isFetchingNextPage && renderSmallLoadingSpinner());
    }
    function handleInputChange(e3) {
      setSearch(e3.target.value);
    }
    const debouncedHandleInputChange = useDebounce(handleInputChange);
    function renderSearchInput() {
      return /* @__PURE__ */ import_react76.default.createElement(
        "input",
        {
          ref: searchBoxRef,
          type: "text",
          placeholder: "Search",
          className: "shadow-sm dark:bg-gray-900 dark:text-gray-100 focus:ring-indigo-500 focus:border-indigo-500 block sm:text-sm border-gray-300 dark:border-gray-500 rounded-md dark:bg-gray-800 w-48",
          onChange: debouncedHandleInputChange
        }
      );
    }
    function renderModalBody() {
      var _a9;
      if ((_a9 = data == null ? void 0 : data.pages) == null ? void 0 : _a9.length) {
        return /* @__PURE__ */ import_react76.default.createElement("main", { className: "modal__content" }, /* @__PURE__ */ import_react76.default.createElement("table", { className: "w-max overflow-x-auto md:w-full table-striped table-fixed" }, /* @__PURE__ */ import_react76.default.createElement("thead", null, /* @__PURE__ */ import_react76.default.createElement("tr", null, /* @__PURE__ */ import_react76.default.createElement(
          "th",
          {
            className: "p-2 w-48 md:w-56 lg:w-1/3 text-xs tracking-wide font-bold text-gray-500 dark:text-gray-400",
            align: "left"
          },
          reportInfo.dimensionLabel
        ), metrics.map((metric) => {
          return /* @__PURE__ */ import_react76.default.createElement("th", { key: metric.key, className: "p-2 w-32 text-xs tracking-wide font-bold text-gray-500 dark:text-gray-400", align: "right" }, metric.renderLabel(query));
        }))), /* @__PURE__ */ import_react76.default.createElement("tbody", null, data.pages.map((p3) => p3.map(renderRow)))));
      }
    }
    return /* @__PURE__ */ import_react76.default.createElement("div", { className: "w-full h-full" }, /* @__PURE__ */ import_react76.default.createElement("div", { className: "flex justify-between items-center" }, /* @__PURE__ */ import_react76.default.createElement("div", { className: "flex items-center gap-x-2" }, /* @__PURE__ */ import_react76.default.createElement("h1", { className: "text-xl font-bold dark:text-gray-100" }, reportInfo.title), !isPending && isFetching && renderSmallLoadingSpinner()), searchEnabled && renderSearchInput()), /* @__PURE__ */ import_react76.default.createElement("div", { className: "my-4 border-b border-gray-300" }), /* @__PURE__ */ import_react76.default.createElement("div", { style: { minHeight: `${MIN_HEIGHT_PX}px` } }, isPending && renderInitialLoadingSpinner(), !isPending && renderModalBody(), renderLoadMoreButton()));
  }

  // js/dashboard/stats/modals/sources.js
  var VIEWS = {
    sources: {
      info: { title: "Top Sources", dimension: "source", endpoint: "/sources", dimensionLabel: "Source" },
      renderIcon: (listItem) => {
        return /* @__PURE__ */ import_react77.default.createElement(
          "img",
          {
            src: `/favicon/sources/${encodeURIComponent(listItem.name)}`,
            className: "h-4 w-4 mr-2 align-middle inline"
          }
        );
      }
    },
    utm_mediums: {
      info: { title: "Top UTM Mediums", dimension: "utm_medium", endpoint: "/utm_mediums", dimensionLabel: "UTM Medium" }
    },
    utm_sources: {
      info: { title: "Top UTM Sources", dimension: "utm_source", endpoint: "/utm_sources", dimensionLabel: "UTM Source" }
    },
    utm_campaigns: {
      info: { title: "Top UTM Campaigns", dimension: "utm_campaign", endpoint: "/utm_campaigns", dimensionLabel: "UTM Campaign" }
    },
    utm_contents: {
      info: { title: "Top UTM Contents", dimension: "utm_content", endpoint: "/utm_contents", dimensionLabel: "UTM Content" }
    },
    utm_terms: {
      info: { title: "Top UTM Terms", dimension: "utm_term", endpoint: "/utm_terms", dimensionLabel: "UTM Term" }
    }
  };
  function SourcesModal({ currentView }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    let reportInfo = VIEWS[currentView].info;
    reportInfo = __spreadProps(__spreadValues({}, reportInfo), { endpoint: apiPath(site, reportInfo.endpoint) });
    const getFilterInfo = (0, import_react77.useCallback)((listItem) => {
      return {
        prefix: reportInfo.dimension,
        filter: ["is", reportInfo.dimension, [listItem.name]]
      };
    }, [reportInfo.dimension]);
    const addSearchFilter = (0, import_react77.useCallback)((query2, searchString) => {
      return addFilter(query2, ["contains", reportInfo.dimension, [searchString]]);
    }, [reportInfo.dimension]);
    function chooseMetrics() {
      if (hasGoalFilter(query)) {
        return [
          createTotalVisitors(),
          createVisitors({ renderLabel: (_query) => "Conversions" }),
          createConversionRate()
        ];
      }
      if (isRealTimeDashboard(query)) {
        return [
          createVisitors({ renderLabel: (_query) => "Current visitors" })
        ];
      }
      return [
        createVisitors({ renderLabel: (_query) => "Visitors" }),
        createBounceRate(),
        createVisitDuration()
      ];
    }
    return /* @__PURE__ */ import_react77.default.createElement(ModalWithRouting, null, /* @__PURE__ */ import_react77.default.createElement(
      BreakdownModal,
      {
        reportInfo,
        metrics: chooseMetrics(),
        getFilterInfo,
        addSearchFilter,
        renderIcon: VIEWS[currentView].renderIcon
      }
    ));
  }
  var sources_default = SourcesModal;

  // js/dashboard/stats/modals/referrer-drilldown.js
  var import_react78 = __toESM(require_react());
  function ReferrerDrilldownModal() {
    const { referrer } = referrersDrilldownRoute.useParams();
    const { query } = useQueryContext();
    const site = useSiteContext();
    const reportInfo = {
      title: "Referrer Drilldown",
      dimension: "referrer",
      endpoint: apiPath(site, `/referrers/${referrer}`),
      dimensionLabel: "Referrer"
    };
    const getFilterInfo = (0, import_react78.useCallback)((listItem) => {
      return {
        prefix: reportInfo.dimension,
        filter: ["is", reportInfo.dimension, [listItem.name]]
      };
    }, [reportInfo.dimension]);
    const addSearchFilter = (0, import_react78.useCallback)((query2, searchString) => {
      return addFilter(query2, ["contains", reportInfo.dimension, [searchString]]);
    }, [reportInfo.dimension]);
    function chooseMetrics() {
      if (hasGoalFilter(query)) {
        return [
          createTotalVisitors(),
          createVisitors({ renderLabel: (_query) => "Conversions" }),
          createConversionRate()
        ];
      }
      if (isRealTimeDashboard(query)) {
        return [
          createVisitors({ renderLabel: (_query) => "Current visitors" })
        ];
      }
      return [
        createVisitors({ renderLabel: (_query) => "Visitors" }),
        createBounceRate(),
        createVisitDuration()
      ];
    }
    const renderIcon = (0, import_react78.useCallback)((listItem) => {
      return /* @__PURE__ */ import_react78.default.createElement(
        "img",
        {
          src: `/favicon/sources/${encodeURIComponent(listItem.name)}`,
          className: "h-4 w-4 mr-2 align-middle inline"
        }
      );
    }, []);
    const getExternalLinkURL = (0, import_react78.useCallback)((listItem) => {
      if (listItem.name !== "Direct / None") {
        return "//" + listItem.name;
      }
    }, []);
    return /* @__PURE__ */ import_react78.default.createElement(ModalWithRouting, null, /* @__PURE__ */ import_react78.default.createElement(
      BreakdownModal,
      {
        reportInfo,
        metrics: chooseMetrics(),
        getFilterInfo,
        addSearchFilter,
        renderIcon,
        getExternalLinkURL
      }
    ));
  }
  var referrer_drilldown_default = ReferrerDrilldownModal;

  // js/dashboard/stats/modals/google-keywords.js
  var import_react79 = __toESM(require_react());
  var import_classnames14 = __toESM(require_classnames());
  function GoogleKeywordsModal() {
    const searchBoxRef = (0, import_react79.useRef)(null);
    const { query } = useQueryContext();
    const site = useSiteContext();
    const endpoint = `/api/stats/${encodeURIComponent(site.domain)}/referrers/Google`;
    const [search, setSearch] = (0, import_react79.useState)("");
    const metrics = [
      createVisitors({ renderLabel: (_query) => "Visitors" }),
      new Metric({ key: "impressions", renderLabel: (_query) => "Impressions", renderValue: renderNumberWithTooltip }),
      new Metric({ key: "ctr", renderLabel: (_query) => "CTR", renderValue: percentageFormatter }),
      new Metric({ key: "position", renderLabel: (_query) => "Position", renderValue: numberFormatter })
    ];
    const {
      data,
      hasNextPage: hasNextPage2,
      fetchNextPage,
      isFetchingNextPage,
      isFetching,
      isPending,
      error,
      status
    } = useAPIClient({
      key: [endpoint, { query, search }],
      getRequestParams: (key) => {
        const [_endpoint, { query: query2, search: search2 }] = key;
        const params = { detailed: true };
        return [query2, search2 === "" ? params : __spreadProps(__spreadValues({}, params), { search: search2 })];
      },
      initialPageParam: 0
    });
    (0, import_react79.useEffect)(() => {
      const searchBox = searchBoxRef.current;
      const handleKeyUp = (event) => {
        if (event.key === "Escape") {
          event.target.blur();
          event.stopPropagation();
        }
      };
      searchBox.addEventListener("keyup", handleKeyUp);
      return () => {
        searchBox.removeEventListener("keyup", handleKeyUp);
      };
    }, []);
    function renderRow(item) {
      return /* @__PURE__ */ import_react79.default.createElement("tr", { className: "text-sm dark:text-gray-200", key: item.name }, /* @__PURE__ */ import_react79.default.createElement("td", { className: "p-2" }, item.name), metrics.map((metric) => {
        return /* @__PURE__ */ import_react79.default.createElement("td", { key: metric.key, className: "p-2 w-32 font-medium", align: "right" }, metric.renderValue(item[metric.key]));
      }));
    }
    function renderInitialLoadingSpinner() {
      return /* @__PURE__ */ import_react79.default.createElement("div", { className: "w-full h-full flex flex-col justify-center", style: { minHeight: `${MIN_HEIGHT_PX}px` } }, /* @__PURE__ */ import_react79.default.createElement("div", { className: "mx-auto loading" }, /* @__PURE__ */ import_react79.default.createElement("div", null)));
    }
    function renderSmallLoadingSpinner() {
      return /* @__PURE__ */ import_react79.default.createElement("div", { className: "loading sm" }, /* @__PURE__ */ import_react79.default.createElement("div", null));
    }
    function renderLoadMoreButton() {
      if (isPending) return null;
      if (!isFetching && !hasNextPage2) return null;
      return /* @__PURE__ */ import_react79.default.createElement("div", { className: "flex flex-col w-full my-4 items-center justify-center h-10" }, !isFetching && /* @__PURE__ */ import_react79.default.createElement("button", { onClick: fetchNextPage, type: "button", className: "button" }, "Load more"), isFetchingNextPage && renderSmallLoadingSpinner());
    }
    function handleInputChange(e3) {
      setSearch(e3.target.value);
    }
    const debouncedHandleInputChange = useDebounce(handleInputChange);
    function renderSearchInput() {
      const searchBoxClass = (0, import_classnames14.default)("shadow-sm dark:bg-gray-900 dark:text-gray-100 focus:ring-indigo-500 focus:border-indigo-500 block sm:text-sm border-gray-300 dark:border-gray-500 rounded-md dark:bg-gray-800 w-48", {
        "pointer-events-none": status === "error"
      });
      return /* @__PURE__ */ import_react79.default.createElement(
        "input",
        {
          ref: searchBoxRef,
          type: "text",
          placeholder: "Search",
          className: searchBoxClass,
          onChange: debouncedHandleInputChange
        }
      );
    }
    function renderModalBody() {
      var _a9;
      if ((_a9 = data == null ? void 0 : data.pages) == null ? void 0 : _a9.length) {
        return /* @__PURE__ */ import_react79.default.createElement("main", { className: "modal__content" }, /* @__PURE__ */ import_react79.default.createElement("table", { className: "w-max overflow-x-auto md:w-full table-striped table-fixed" }, /* @__PURE__ */ import_react79.default.createElement("thead", null, /* @__PURE__ */ import_react79.default.createElement("tr", null, /* @__PURE__ */ import_react79.default.createElement(
          "th",
          {
            className: "p-2 w-48 md:w-56 lg:w-1/3 text-xs tracking-wide font-bold text-gray-500 dark:text-gray-400",
            align: "left"
          },
          "Search term"
        ), metrics.map((metric) => {
          return /* @__PURE__ */ import_react79.default.createElement("th", { key: metric.key, className: "p-2 w-32 text-xs tracking-wide font-bold text-gray-500 dark:text-gray-400", align: "right" }, metric.renderLabel(query));
        }))), /* @__PURE__ */ import_react79.default.createElement("tbody", null, data.pages.map((p3) => p3.map(renderRow)))));
      }
    }
    function renderError() {
      return /* @__PURE__ */ import_react79.default.createElement(
        "div",
        {
          className: "grid grid-rows-2 text-gray-700 dark:text-gray-300",
          style: { height: `${MIN_HEIGHT_PX}px` }
        },
        /* @__PURE__ */ import_react79.default.createElement("div", { className: "text-center self-end" }, /* @__PURE__ */ import_react79.default.createElement(RocketIcon, null)),
        /* @__PURE__ */ import_react79.default.createElement("div", { className: "text-lg text-center" }, error.message)
      );
    }
    return /* @__PURE__ */ import_react79.default.createElement(ModalWithRouting, null, /* @__PURE__ */ import_react79.default.createElement("div", { className: "w-full h-full" }, /* @__PURE__ */ import_react79.default.createElement("div", { className: "flex justify-between items-center" }, /* @__PURE__ */ import_react79.default.createElement("div", { className: "flex items-center gap-x-2" }, /* @__PURE__ */ import_react79.default.createElement("h1", { className: "text-xl font-bold dark:text-gray-100" }, "Google Search Terms"), !isPending && isFetching && renderSmallLoadingSpinner()), renderSearchInput()), /* @__PURE__ */ import_react79.default.createElement("div", { className: "my-4 border-b border-gray-300" }), /* @__PURE__ */ import_react79.default.createElement("div", { style: { minHeight: `${MIN_HEIGHT_PX}px` } }, status === "error" && renderError(), isPending && renderInitialLoadingSpinner(), !isPending && renderModalBody(), renderLoadMoreButton())));
  }
  var google_keywords_default = GoogleKeywordsModal;

  // js/dashboard/stats/modals/pages.js
  var import_react80 = __toESM(require_react());
  function PagesModal() {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const reportInfo = {
      title: "Top Pages",
      dimension: "page",
      endpoint: apiPath(site, "/pages"),
      dimensionLabel: "Page url"
    };
    const getFilterInfo = (0, import_react80.useCallback)((listItem) => {
      return {
        prefix: reportInfo.dimension,
        filter: ["is", reportInfo.dimension, [listItem.name]]
      };
    }, [reportInfo.dimension]);
    const addSearchFilter = (0, import_react80.useCallback)((query2, searchString) => {
      return addFilter(query2, ["contains", reportInfo.dimension, [searchString]]);
    }, [reportInfo.dimension]);
    function chooseMetrics() {
      if (hasGoalFilter(query)) {
        return [
          createTotalVisitors(),
          createVisitors({ renderLabel: (_query) => "Conversions" }),
          createConversionRate()
        ];
      }
      if (isRealTimeDashboard(query)) {
        return [
          createVisitors({ renderLabel: (_query) => "Current visitors" })
        ];
      }
      return [
        createVisitors({ renderLabel: (_query) => "Visitors" }),
        createPageviews(),
        createBounceRate(),
        createTimeOnPage()
      ];
    }
    return /* @__PURE__ */ import_react80.default.createElement(ModalWithRouting, null, /* @__PURE__ */ import_react80.default.createElement(
      BreakdownModal,
      {
        reportInfo,
        metrics: chooseMetrics(),
        getFilterInfo,
        addSearchFilter
      }
    ));
  }
  var pages_default = PagesModal;

  // js/dashboard/stats/modals/entry-pages.js
  var import_react81 = __toESM(require_react());
  function EntryPagesModal() {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const reportInfo = {
      title: "Entry Pages",
      dimension: "entry_page",
      endpoint: apiPath(site, "/entry-pages"),
      dimensionLabel: "Entry page"
    };
    const getFilterInfo = (0, import_react81.useCallback)((listItem) => {
      return {
        prefix: reportInfo.dimension,
        filter: ["is", reportInfo.dimension, [listItem.name]]
      };
    }, [reportInfo.dimension]);
    const addSearchFilter = (0, import_react81.useCallback)((query2, searchString) => {
      return addFilter(query2, ["contains", reportInfo.dimension, [searchString]]);
    }, [reportInfo.dimension]);
    function chooseMetrics() {
      if (hasGoalFilter(query)) {
        return [
          createTotalVisitors(),
          createVisitors({ renderLabel: (_query) => "Conversions" }),
          createConversionRate()
        ];
      }
      if (isRealTimeDashboard(query)) {
        return [
          createVisitors({ renderLabel: (_query) => "Current visitors" })
        ];
      }
      return [
        createVisitors({ renderLabel: (_query) => "Visitors" }),
        createVisits({ renderLabel: (_query) => "Total Entrances" }),
        createVisitDuration()
      ];
    }
    return /* @__PURE__ */ import_react81.default.createElement(ModalWithRouting, null, /* @__PURE__ */ import_react81.default.createElement(
      BreakdownModal,
      {
        reportInfo,
        metrics: chooseMetrics(),
        getFilterInfo,
        addSearchFilter
      }
    ));
  }
  var entry_pages_default = EntryPagesModal;

  // js/dashboard/stats/modals/exit-pages.js
  var import_react82 = __toESM(require_react());
  function ExitPagesModal() {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const reportInfo = {
      title: "Exit Pages",
      dimension: "exit_page",
      endpoint: apiPath(site, "/exit-pages"),
      dimensionLabel: "Page url"
    };
    const getFilterInfo = (0, import_react82.useCallback)((listItem) => {
      return {
        prefix: reportInfo.dimension,
        filter: ["is", reportInfo.dimension, [listItem.name]]
      };
    }, [reportInfo.dimension]);
    const addSearchFilter = (0, import_react82.useCallback)((query2, searchString) => {
      return addFilter(query2, ["contains", reportInfo.dimension, [searchString]]);
    }, [reportInfo.dimension]);
    function chooseMetrics() {
      if (hasGoalFilter(query)) {
        return [
          createTotalVisitors(),
          createVisitors({ renderLabel: (_query) => "Conversions" }),
          createConversionRate()
        ];
      }
      if (query.period === "realtime") {
        return [
          createVisitors({ renderLabel: (_query) => "Current visitors" })
        ];
      }
      return [
        createVisitors({ renderLabel: (_query) => "Visitors" }),
        createVisits({ renderLabel: (_query) => "Total Exits" }),
        createExitRate()
      ];
    }
    return /* @__PURE__ */ import_react82.default.createElement(ModalWithRouting, null, /* @__PURE__ */ import_react82.default.createElement(
      BreakdownModal,
      {
        reportInfo,
        metrics: chooseMetrics(),
        getFilterInfo,
        addSearchFilter
      }
    ));
  }
  var exit_pages_default = ExitPagesModal;

  // js/dashboard/stats/modals/locations-modal.js
  var import_react83 = __toESM(require_react());
  var VIEWS2 = {
    countries: { title: "Top Countries", dimension: "country", endpoint: "/countries", dimensionLabel: "Country" },
    regions: { title: "Top Regions", dimension: "region", endpoint: "/regions", dimensionLabel: "Region" },
    cities: { title: "Top Cities", dimension: "city", endpoint: "/cities", dimensionLabel: "City" }
  };
  function LocationsModal({ currentView }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    let reportInfo = VIEWS2[currentView];
    reportInfo = __spreadProps(__spreadValues({}, reportInfo), { endpoint: apiPath(site, reportInfo.endpoint) });
    const getFilterInfo = (0, import_react83.useCallback)((listItem) => {
      return {
        prefix: reportInfo.dimension,
        filter: ["is", reportInfo.dimension, [listItem.code]],
        labels: { [listItem.code]: listItem.name }
      };
    }, [reportInfo.dimension]);
    function chooseMetrics() {
      if (hasGoalFilter(query)) {
        return [
          createTotalVisitors(),
          createVisitors({ renderLabel: (_query) => "Conversions" }),
          createConversionRate()
        ];
      }
      if (query.period === "realtime") {
        return [
          createVisitors({ renderLabel: (_query) => "Current visitors" })
        ];
      }
      return [
        createVisitors({ renderLabel: (_query) => "Visitors" }),
        currentView === "countries" && createPercentage()
      ].filter((metric) => !!metric);
    }
    const renderIcon = (0, import_react83.useCallback)((listItem) => {
      return /* @__PURE__ */ import_react83.default.createElement("span", { className: "mr-1" }, listItem.country_flag || listItem.flag);
    }, []);
    return /* @__PURE__ */ import_react83.default.createElement(ModalWithRouting, null, /* @__PURE__ */ import_react83.default.createElement(
      BreakdownModal,
      {
        reportInfo,
        metrics: chooseMetrics(),
        getFilterInfo,
        renderIcon,
        searchEnabled: false
      }
    ));
  }
  var locations_modal_default = LocationsModal;

  // js/dashboard/stats/modals/props.js
  var import_react84 = __toESM(require_react());
  function PropsModal() {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const { propKey } = customPropsRoute.useParams();
    const showRevenueMetrics = false;
    const reportInfo = {
      title: specialTitleWhenGoalFilter(query, "Custom Property Breakdown"),
      dimension: propKey,
      endpoint: apiPath(site, `/custom-prop-values/${propKey}`),
      dimensionLabel: propKey
    };
    const getFilterInfo = (0, import_react84.useCallback)((listItem) => {
      return {
        prefix: `${EVENT_PROPS_PREFIX}${propKey}`,
        filter: ["is", `${EVENT_PROPS_PREFIX}${propKey}`, [listItem.name]]
      };
    }, [propKey]);
    const addSearchFilter = (0, import_react84.useCallback)((query2, searchString) => {
      return addFilter(query2, ["contains", `${EVENT_PROPS_PREFIX}${propKey}`, [searchString]]);
    }, [propKey]);
    function chooseMetrics() {
      return [
        createVisitors({ renderLabel: (_query) => "Visitors" }),
        createEvents({ renderLabel: (_query) => "Events" }),
        hasGoalFilter(query) && createConversionRate(),
        !hasGoalFilter(query) && createPercentage(),
        showRevenueMetrics && createAverageRevenue(),
        showRevenueMetrics && createTotalRevenue()
      ].filter((metric) => !!metric);
    }
    return /* @__PURE__ */ import_react84.default.createElement(ModalWithRouting, null, /* @__PURE__ */ import_react84.default.createElement(
      BreakdownModal,
      {
        reportInfo,
        metrics: chooseMetrics(),
        getFilterInfo,
        addSearchFilter
      }
    ));
  }
  var props_default = PropsModal;

  // js/dashboard/stats/modals/conversions.js
  var import_react85 = __toESM(require_react());
  function ConversionsModal() {
    const [showRevenue, setShowRevenue] = (0, import_react85.useState)(false);
    const site = useSiteContext();
    const reportInfo = {
      title: "Goal Conversions",
      dimension: "goal",
      endpoint: apiPath(site, "/conversions"),
      dimensionLabel: "Goal"
    };
    const getFilterInfo = (0, import_react85.useCallback)((listItem) => {
      return {
        prefix: reportInfo.dimension,
        filter: ["is", reportInfo.dimension, [listItem.name]]
      };
    }, [reportInfo.dimension]);
    function chooseMetrics() {
      return [
        createVisitors({ renderLabel: (_query) => "Uniques" }),
        createEvents({ renderLabel: (_query) => "Total" }),
        createConversionRate(),
        showRevenue && createAverageRevenue(),
        showRevenue && createTotalRevenue()
      ].filter((metric) => !!metric);
    }
    const afterFetchData = (0, import_react85.useCallback)((res) => {
      setShowRevenue(revenueInResponse(res));
    }, []);
    const afterFetchNextPage = (0, import_react85.useCallback)((res) => {
      if (!showRevenue && revenueInResponse(res)) {
        setShowRevenue(true);
      }
    }, [showRevenue]);
    function revenueInResponse(apiResponse) {
      return apiResponse.results.some((item) => item.total_revenue);
    }
    return /* @__PURE__ */ import_react85.default.createElement(ModalWithRouting, null, /* @__PURE__ */ import_react85.default.createElement(
      BreakdownModal,
      {
        reportInfo,
        metrics: chooseMetrics(),
        afterFetchData: false ? afterFetchData : void 0,
        afterFetchNextPage: false ? afterFetchNextPage : void 0,
        getFilterInfo,
        searchEnabled: false
      }
    ));
  }
  var conversions_default = ConversionsModal;

  // js/dashboard/stats/modals/filter-modal.js
  var import_react91 = __toESM(require_react());

  // js/dashboard/stats/modals/filter-modal-group.js
  var import_react90 = __toESM(require_react());

  // js/dashboard/stats/modals/filter-modal-row.js
  var import_react88 = __toESM(require_react());

  // js/dashboard/components/filter-operator-selector.js
  var import_react86 = __toESM(require_react());
  var import_classnames15 = __toESM(require_classnames());
  function FilterOperatorSelector(props) {
    const filterName = props.forFilter;
    function renderTypeItem(operation, shouldDisplay) {
      return shouldDisplay && /* @__PURE__ */ import_react86.default.createElement(Ze.Item, null, ({ active }) => /* @__PURE__ */ import_react86.default.createElement(
        "span",
        {
          onClick: () => props.onSelect(operation),
          className: (0, import_classnames15.default)(
            "cursor-pointer block px-4 py-2 text-sm",
            {
              "bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100": active,
              "text-gray-700 dark:text-gray-200": !active
            }
          )
        },
        FILTER_OPERATIONS_DISPLAY_NAMES[operation]
      ));
    }
    const containerClass = (0, import_classnames15.default)("w-full", {
      "opacity-20 cursor-default pointer-events-none": props.isDisabled
    });
    return /* @__PURE__ */ import_react86.default.createElement("div", { className: containerClass }, /* @__PURE__ */ import_react86.default.createElement(Ze, { as: "div", className: "relative inline-block text-left w-full" }, ({ open }) => /* @__PURE__ */ import_react86.default.createElement(import_react86.default.Fragment, null, /* @__PURE__ */ import_react86.default.createElement("div", { className: "w-full" }, /* @__PURE__ */ import_react86.default.createElement(Ze.Button, { className: "inline-flex justify-between items-center w-full rounded-md border border-gray-300 dark:border-gray-500 shadow-sm px-4 py-2 bg-white dark:bg-gray-800 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-50 dark:hover:bg-gray-850 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-100 dark:focus:ring-offset-gray-900 focus:ring-indigo-500 text-left" }, FILTER_OPERATIONS_DISPLAY_NAMES[props.selectedType], /* @__PURE__ */ import_react86.default.createElement(ChevronDownIcon_default, { className: "-mr-2 ml-2 h-4 w-4 text-gray-500 dark:text-gray-400", "aria-hidden": "true" }))), /* @__PURE__ */ import_react86.default.createElement(
      Ke,
      {
        show: open,
        as: import_react86.Fragment,
        enter: "transition ease-out duration-100",
        enterFrom: "opacity-0 scale-95",
        enterTo: "opacity-100 scale-100",
        leave: "transition ease-in duration-75",
        leaveFrom: "opacity-100 scale-100",
        leaveTo: "opacity-0 scale-95"
      },
      /* @__PURE__ */ import_react86.default.createElement(
        Ze.Items,
        {
          static: true,
          className: "z-10 origin-top-left absolute left-0 mt-2 rounded-md shadow-lg bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5 focus:outline-none"
        },
        /* @__PURE__ */ import_react86.default.createElement("div", { className: "py-1" }, renderTypeItem(FILTER_OPERATIONS.is, true), renderTypeItem(FILTER_OPERATIONS.isNot, supportsIsNot(filterName)), renderTypeItem(FILTER_OPERATIONS.contains, isFreeChoiceFilter(filterName)), renderTypeItem(FILTER_OPERATIONS.does_not_contain, isFreeChoiceFilter(filterName)))
      )
    ))));
  }

  // js/dashboard/stats/modals/filter-modal-row.js
  function FilterModalRow({
    filter,
    labels,
    onUpdate
  }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const [operation, filterKey, clauses] = filter;
    const selectedClauses = (0, import_react88.useMemo)(
      () => clauses.map((value) => ({ value, label: getLabel(labels, filterKey, value) })),
      [filter, labels]
    );
    function onComboboxSelect(selection) {
      const newClauses = selection.map(({ value }) => value);
      const newLabels = Object.fromEntries(selection.map(({ label, value }) => [value, label]));
      onUpdate(
        [operation, filterKey, newClauses],
        newLabels
      );
    }
    function fetchOptions(input) {
      if ([FILTER_OPERATIONS.contains, FILTER_OPERATIONS.does_not_contain].includes(operation)) {
        return Promise.resolve([]);
      }
      return fetchSuggestions(apiPath(site, `/suggestions/${filterKey}`), query, input, [
        FILTER_OPERATIONS.isNot,
        filterKey,
        clauses
      ]);
    }
    return /* @__PURE__ */ import_react88.default.createElement("div", { className: "grid grid-cols-11 mt-1" }, /* @__PURE__ */ import_react88.default.createElement("div", { className: "col-span-3" }, /* @__PURE__ */ import_react88.default.createElement(
      FilterOperatorSelector,
      {
        forFilter: filterKey,
        onSelect: (newOperation) => onUpdate([newOperation, filterKey, clauses], labels),
        selectedType: operation
      }
    )), /* @__PURE__ */ import_react88.default.createElement("div", { className: "col-span-8 ml-2" }, /* @__PURE__ */ import_react88.default.createElement(
      PlausibleCombobox,
      {
        fetchOptions,
        freeChoice: isFreeChoiceFilter(filterKey),
        values: selectedClauses,
        onSelect: onComboboxSelect,
        placeholder: `Select ${withIndefiniteArticle(formattedFilters[filterKey])}`
      }
    )));
  }
  function withIndefiniteArticle(word) {
    if (word.startsWith("UTM")) {
      return `a ${word}`;
    }
    if (["a", "e", "i", "o", "u"].some((vowel) => word.toLowerCase().startsWith(vowel))) {
      return `an ${word}`;
    }
    return `a ${word}`;
  }

  // js/dashboard/stats/modals/filter-modal-props-row.js
  var import_react89 = __toESM(require_react());
  function FilterModalPropsRow({
    filter,
    showDelete,
    disabledOptions,
    onUpdate,
    onDelete
  }) {
    const { query } = useQueryContext();
    const site = useSiteContext();
    const [operation, filterKey, clauses] = filter;
    const propKey = (0, import_react89.useMemo)(
      () => getPropertyKeyFromFilterKey(filterKey),
      [filterKey]
    );
    const selectedClauses = (0, import_react89.useMemo)(
      () => clauses.map((value) => ({ value, label: value })),
      [clauses]
    );
    function fetchPropKeyOptions(input) {
      return fetchSuggestions(apiPath(site, `/suggestions/prop_key`), query, input);
    }
    function fetchPropValueOptions(input) {
      if ([FILTER_OPERATIONS.contains, FILTER_OPERATIONS.does_not_contain].includes(operation)) {
        return Promise.resolve([]);
      }
      return fetchSuggestions(apiPath(site, `/suggestions/prop_value`), query, input, [
        FILTER_OPERATIONS.isNot,
        filterKey,
        ["(none)"]
      ]);
    }
    function onPropKeySelect(selection) {
      const { value } = selection[0];
      onUpdate([operation, `${EVENT_PROPS_PREFIX}${value}`, clauses]);
    }
    function onPropValueSelect(selection) {
      const newClauses = selection.map(({ value }) => value);
      onUpdate([operation, filterKey, newClauses]);
    }
    return /* @__PURE__ */ import_react89.default.createElement("div", { className: "grid grid-cols-12 mt-6" }, /* @__PURE__ */ import_react89.default.createElement("div", { className: "col-span-4" }, /* @__PURE__ */ import_react89.default.createElement(
      PlausibleCombobox,
      {
        className: "mr-2",
        fetchOptions: fetchPropKeyOptions,
        singleOption: true,
        autoFocus: true,
        values: propKey ? [{ value: propKey, label: propKey }] : [],
        onSelect: onPropKeySelect,
        placeholder: "Property",
        disabledOptions
      }
    )), /* @__PURE__ */ import_react89.default.createElement("div", { className: "col-span-3 mx-2" }, /* @__PURE__ */ import_react89.default.createElement(
      FilterOperatorSelector,
      {
        isDisabled: !filterKey,
        forFilter: "prop_value",
        onSelect: (newOperation) => onUpdate([newOperation, filterKey, clauses]),
        selectedType: operation
      }
    )), /* @__PURE__ */ import_react89.default.createElement("div", { className: "col-span-4" }, /* @__PURE__ */ import_react89.default.createElement(
      PlausibleCombobox,
      {
        isDisabled: !filterKey,
        fetchOptions: fetchPropValueOptions,
        values: selectedClauses,
        onSelect: onPropValueSelect,
        placeholder: "Value",
        freeChoice: operation == FILTER_OPERATIONS.contains
      }
    )), showDelete && /* @__PURE__ */ import_react89.default.createElement("div", { className: "col-span-1 flex flex-col justify-center" }, /* @__PURE__ */ import_react89.default.createElement("a", { className: "ml-2 text-red-600 h-5 w-5 cursor-pointer", onClick: onDelete }, /* @__PURE__ */ import_react89.default.createElement(TrashIcon_default, null))));
  }

  // js/dashboard/stats/modals/filter-modal-group.js
  function FilterModalGroup({
    filterGroup,
    filterState,
    labels,
    onUpdateRowValue,
    onAddRow,
    onDeleteRow
  }) {
    const rows = (0, import_react90.useMemo)(
      () => Object.entries(filterState).filter(([_2, filter]) => getFilterGroup(filter) == filterGroup).map(([id, filter]) => ({ id, filter })),
      [filterGroup, filterState]
    );
    const disabledOptions = (0, import_react90.useMemo)(
      () => filterGroup == "props" ? rows.map(({ filter }) => ({ value: getPropertyKeyFromFilterKey(filter[1]) })) : null,
      [filterGroup, rows]
    );
    const showAddRow = filterGroup == "props";
    const showTitle = filterGroup != "props";
    return /* @__PURE__ */ import_react90.default.createElement(import_react90.default.Fragment, null, /* @__PURE__ */ import_react90.default.createElement("div", { className: "mt-6" }, showTitle && /* @__PURE__ */ import_react90.default.createElement("div", { className: "text-sm font-medium text-gray-700 dark:text-gray-300" }, formattedFilters[filterGroup]), rows.map(
      ({ id, filter }) => filterGroup === "props" ? /* @__PURE__ */ import_react90.default.createElement(
        FilterModalPropsRow,
        {
          key: id,
          filter,
          showDelete: rows.length > 1,
          disabledOptions,
          onUpdate: (newFilter) => onUpdateRowValue(id, newFilter),
          onDelete: () => onDeleteRow(id)
        }
      ) : /* @__PURE__ */ import_react90.default.createElement(
        FilterModalRow,
        {
          key: id,
          filter,
          labels,
          onUpdate: (newFilter, labelUpdate) => onUpdateRowValue(id, newFilter, labelUpdate)
        }
      )
    )), showAddRow && /* @__PURE__ */ import_react90.default.createElement("div", { className: "mt-2" }, /* @__PURE__ */ import_react90.default.createElement("a", { className: "underline text-indigo-500 text-sm cursor-pointer", onClick: () => onAddRow(filterGroup) }, "+ Add another")));
  }

  // js/dashboard/stats/modals/filter-modal.js
  function partitionFilters(modalType, filters) {
    const otherFilters = [];
    const filterState = {};
    let hasRelevantFilters = false;
    filters.forEach((filter, index2) => {
      const filterGroup = getFilterGroup(filter);
      if (FILTER_GROUP_TO_MODAL_TYPE[filterGroup] === modalType) {
        const key = filterState[filterGroup] ? `${filterGroup}:${index2}` : filterGroup;
        filterState[key] = filter;
        hasRelevantFilters = true;
      } else {
        otherFilters.push(filter);
      }
    });
    FILTER_MODAL_TO_FILTER_GROUP[modalType].forEach((filterGroup) => {
      if (!filterState[filterGroup]) {
        filterState[filterGroup] = emptyFilter(filterGroup);
      }
    });
    return { filterState, otherFilters, hasRelevantFilters };
  }
  function emptyFilter(key) {
    const filterKey = key === "props" ? EVENT_PROPS_PREFIX : key;
    return [FILTER_OPERATIONS.is, filterKey, []];
  }
  var FilterModal = class extends import_react91.default.Component {
    constructor(props) {
      super(props);
      const modalType = this.props.modalType;
      const query = this.props.query;
      const { filterState, otherFilters, hasRelevantFilters } = partitionFilters(modalType, query.filters);
      this.handleKeydown = this.handleKeydown.bind(this);
      this.state = { query, filterState, labelState: query.labels, otherFilters, hasRelevantFilters };
    }
    componentDidMount() {
      document.addEventListener("keydown", this.handleKeydown);
    }
    componentWillUnmount() {
      document.removeEventListener("keydown", this.handleKeydown);
    }
    handleKeydown(e3) {
      if (shouldIgnoreKeypress(e3)) return;
      if (e3.target.tagName === "BODY" && e3.key === "Enter") {
        this.handleSubmit();
      }
    }
    handleSubmit() {
      const filters = Object.values(this.state.filterState).filter(([_op, _key, clauses]) => clauses.length > 0).concat(this.state.otherFilters);
      this.selectFiltersAndCloseModal(filters);
    }
    isDisabled() {
      return Object.values(this.state.filterState).every(([_operation, _key, clauses]) => clauses.length === 0);
    }
    selectFiltersAndCloseModal(filters) {
      this.props.navigate({
        to: rootRoute.to,
        search: {
          filters,
          labels: cleanLabels(filters, this.state.labelState)
        },
        replace: true
      });
    }
    onUpdateRowValue(id, newFilter, newLabels) {
      this.setState((prevState) => {
        const [_operation, filterKey, _clauses] = newFilter;
        return {
          filterState: __spreadProps(__spreadValues({}, prevState.filterState), {
            [id]: newFilter
          }),
          labelState: cleanLabels(
            Object.values(this.state.filterState).concat(this.state.query.filters),
            prevState.labelState,
            filterKey,
            newLabels
          )
        };
      });
    }
    onAddRow(filterGroup) {
      this.setState((prevState) => {
        const filter = emptyFilter(filterGroup);
        const id = `${filterGroup}${Object.keys(this.state.filterState).length}`;
        return {
          filterState: __spreadProps(__spreadValues({}, prevState.filterState), {
            [id]: filter
          })
        };
      });
    }
    onDeleteRow(id) {
      this.setState((prevState) => {
        const filterState = __spreadValues({}, prevState.filterState);
        delete filterState[id];
        return { filterState };
      });
    }
    render() {
      return /* @__PURE__ */ import_react91.default.createElement(ModalWithRouting, { maxWidth: "460px" }, /* @__PURE__ */ import_react91.default.createElement("h1", { className: "text-xl font-bold dark:text-gray-100" }, "Filter by ", formatFilterGroup(this.props.modalType)), /* @__PURE__ */ import_react91.default.createElement("div", { className: "mt-4 border-b border-gray-300" }), /* @__PURE__ */ import_react91.default.createElement("main", { className: "modal__content" }, /* @__PURE__ */ import_react91.default.createElement("form", { className: "flex flex-col", onSubmit: this.handleSubmit.bind(this) }, FILTER_MODAL_TO_FILTER_GROUP[this.props.modalType].map((filterGroup) => /* @__PURE__ */ import_react91.default.createElement(
        FilterModalGroup,
        {
          key: filterGroup,
          filterGroup,
          filterState: this.state.filterState,
          labels: this.state.labelState,
          onUpdateRowValue: this.onUpdateRowValue.bind(this),
          onAddRow: this.onAddRow.bind(this),
          onDeleteRow: this.onDeleteRow.bind(this)
        }
      )), /* @__PURE__ */ import_react91.default.createElement("div", { className: "mt-6 flex items-center justify-start" }, /* @__PURE__ */ import_react91.default.createElement(
        "button",
        {
          type: "submit",
          className: "button",
          disabled: this.isDisabled()
        },
        "Apply Filter"
      ), this.state.hasRelevantFilters && /* @__PURE__ */ import_react91.default.createElement(
        "button",
        {
          type: "button",
          className: "ml-2 button px-4 flex bg-red-500 dark:bg-red-500 hover:bg-red-600 dark:hover:bg-red-700 items-center",
          onClick: () => {
            this.selectFiltersAndCloseModal(this.state.otherFilters);
          }
        },
        /* @__PURE__ */ import_react91.default.createElement("svg", { className: "w-4 h-4 mr-2", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ import_react91.default.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" })),
        "Remove filter",
        FILTER_MODAL_TO_FILTER_GROUP[this.props.modalType].length > 1 ? "s" : ""
      )))));
    }
  };
  function FilterModalWithRouter(props) {
    const navigate = useNavigate();
    const { field } = filterRoute.useParams();
    const { query } = useQueryContext();
    return /* @__PURE__ */ import_react91.default.createElement(
      FilterModal,
      __spreadProps(__spreadValues({}, props), {
        modalType: field || "page",
        query,
        navigate
      })
    );
  }

  // js/dashboard/router.js
  var queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false
      }
    }
  });
  function DashboardRoute() {
    return /* @__PURE__ */ import_react92.default.createElement(QueryClientProvider, { client: queryClient }, /* @__PURE__ */ import_react92.default.createElement(QueryContextProvider, null, /* @__PURE__ */ import_react92.default.createElement(dashboard_default, null), /* @__PURE__ */ import_react92.default.createElement(Outlet, null)));
  }
  var rootRoute = createRootRoute({
    component: DashboardRoute,
    // renders null in the <Outlet /> for unhandleable routes like /${site.domain}/does/not/exist
    notFoundComponent: () => null
  });
  var sourcesRoute = createRoute({
    path: "sources",
    component: () => /* @__PURE__ */ import_react92.default.createElement(sources_default, { currentView: "sources" }),
    getParentRoute: () => rootRoute
  });
  var utmMediumsRoute = createRoute({
    path: "utm_mediums",
    component: () => /* @__PURE__ */ import_react92.default.createElement(sources_default, { currentView: "utm_mediums" }),
    getParentRoute: () => rootRoute
  });
  var utmSourcesRoute = createRoute({
    path: "utm_sources",
    component: () => /* @__PURE__ */ import_react92.default.createElement(sources_default, { currentView: "utm_sources" }),
    getParentRoute: () => rootRoute
  });
  var utmCampaignsRoute = createRoute({
    path: "utm_campaigns",
    component: () => /* @__PURE__ */ import_react92.default.createElement(sources_default, { currentView: "utm_campaigns" }),
    getParentRoute: () => rootRoute
  });
  var utmContentsRoute = createRoute({
    path: "utm_contents",
    component: () => /* @__PURE__ */ import_react92.default.createElement(sources_default, { currentView: "utm_contents" }),
    getParentRoute: () => rootRoute
  });
  var utmTermsRoute = createRoute({
    path: "utm_terms",
    component: () => /* @__PURE__ */ import_react92.default.createElement(sources_default, { currentView: "utm_terms" }),
    getParentRoute: () => rootRoute
  });
  var referrersGoogleRoute = createRoute({
    path: "referrers/Google",
    component: google_keywords_default,
    getParentRoute: () => rootRoute
  });
  var topPagesRoute = createRoute({
    path: "pages",
    component: pages_default,
    getParentRoute: () => rootRoute
  });
  var entryPagesRoute = createRoute({
    path: "entry-pages",
    component: entry_pages_default,
    getParentRoute: () => rootRoute
  });
  var exitPagesRoute = createRoute({
    path: "exit-pages",
    component: exit_pages_default,
    getParentRoute: () => rootRoute
  });
  var countriesRoute = createRoute({
    path: "countries",
    component: () => /* @__PURE__ */ import_react92.default.createElement(locations_modal_default, { currentView: "countries" }),
    getParentRoute: () => rootRoute
  });
  var regionsRoute = createRoute({
    path: "regions",
    component: () => /* @__PURE__ */ import_react92.default.createElement(locations_modal_default, { currentView: "regions" }),
    getParentRoute: () => rootRoute
  });
  var citiesRoute = createRoute({
    path: "cities",
    component: () => /* @__PURE__ */ import_react92.default.createElement(locations_modal_default, { currentView: "cities" }),
    getParentRoute: () => rootRoute
  });
  var conversionsRoute = createRoute({
    path: "conversions",
    component: conversions_default,
    getParentRoute: () => rootRoute
  });
  var referrersDrilldownRoute = createRoute({
    path: "referrers/$referrer",
    component: referrer_drilldown_default,
    getParentRoute: () => rootRoute
  });
  var customPropsRoute = createRoute({
    path: "custom-prop-values/$propKey",
    component: props_default,
    getParentRoute: () => rootRoute
  });
  var filterRoute = createRoute({
    path: "filter/$field",
    component: FilterModalWithRouter,
    getParentRoute: () => rootRoute
  });
  var routeTree = rootRoute.addChildren([
    sourcesRoute,
    utmMediumsRoute,
    utmSourcesRoute,
    utmCampaignsRoute,
    utmContentsRoute,
    utmTermsRoute,
    referrersGoogleRoute,
    referrersDrilldownRoute,
    topPagesRoute,
    entryPagesRoute,
    exitPagesRoute,
    countriesRoute,
    regionsRoute,
    citiesRoute,
    conversionsRoute,
    customPropsRoute,
    filterRoute
  ]);
  function createAppRouter(site) {
    const basepath = site.shared ? `/share/${encodeURIComponent(site.domain)}` : encodeURIComponent(site.domain);
    return createRouter({
      routeTree,
      stringifySearch,
      parseSearch,
      basepath
    });
  }

  // js/dashboard/error-boundary.js
  var import_react93 = __toESM(require_react());
  var ErrorBoundary = class extends import_react93.default.Component {
    constructor(props) {
      super(props);
      this.state = { error: null };
    }
    static getDerivedStateFromError(error) {
      return { error };
    }
    render() {
      if (this.state.error) {
        return /* @__PURE__ */ import_react93.default.createElement("div", { className: "text-center text-gray-900 dark:text-gray-100 mt-36" }, /* @__PURE__ */ import_react93.default.createElement(RocketIcon, null), /* @__PURE__ */ import_react93.default.createElement("div", { className: "text-lg font-bold" }, "Oops! Something went wrong"), /* @__PURE__ */ import_react93.default.createElement("div", { className: "text-lg" }, this.state.error.name + ": " + this.state.error.message));
      }
      return this.props.children;
    }
  };

  // js/dashboard/util/realtime-update-timer.js
  var THIRTY_SECONDS = 3e4;
  var tickEvent = new Event("tick");
  function start2() {
    setInterval(() => {
      document.dispatchEvent(tickEvent);
    }, THIRTY_SECONDS);
  }

  // js/dashboard.js
  start2();
  var container = document.getElementById("stats-react-container");
  if (container) {
    const site = parseSiteFromDataset(container.dataset);
    const sharedLinkAuth = container.dataset.sharedLinkAuth;
    if (sharedLinkAuth) {
      setSharedLinkAuth(sharedLinkAuth);
    }
    try {
      filtersBackwardsCompatibilityRedirect(window.location);
    } catch (e3) {
      console.error("Error redirecting in a backwards compatible way", e3);
    }
    const router = createAppRouter(site);
    const app = /* @__PURE__ */ import_react94.default.createElement(ErrorBoundary, null, /* @__PURE__ */ import_react94.default.createElement(site_context_default, { site }, /* @__PURE__ */ import_react94.default.createElement(UserContextProvider, { role: container.dataset.currentUserRole, loggedIn: container.dataset.loggedIn === "true" }, /* @__PURE__ */ import_react94.default.createElement(RouterProvider, { router }))));
    const root = (0, import_client.createRoot)(container);
    root.render(app);
  }
})();
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

flatpickr/dist/flatpickr.js:
  (* flatpickr v4.6.13, @license MIT *)
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)

@jsonurl/jsonurl/dist/jsonurl.min.js:
  (*!
   * jsonurl.js v1.1.7
   * (c) 2022 David MacCormack
   * Released under the MIT License.
   *)

classnames/index.js:
  (*!
    Copyright (c) 2018 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  *)

chart.js/dist/chunks/helpers.segment.mjs:
  (*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.mjs:
  (*!
   * @kurkle/color v0.2.1
   * https://github.com/kurkle/color#readme
   * (c) 2022 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chart.mjs:
  (*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)
*/
